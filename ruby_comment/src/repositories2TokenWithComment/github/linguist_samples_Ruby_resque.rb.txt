def UNK on_lparen server on_rparen on_ignored_nl UNK server on_nl UNK on_const on_nl if server on_op UNK on_tstring_content UNK on_nl redis # Accepts: # 1. A 'hostname:port' String # 2. A 'hostname:port:db' String (to select the Redis db) # 3. A 'hostname:port/namespace' String (to set the Redis namespace) # 4. A Redis URL String 'redis://host:port' # 5. An instance of `Redis`, `Redis::Client`, `Redis::DistRedis`, # or `Redis::Namespace`.
def UNK on_nl on_ivar on_op on_const on_period new on_nl end on_nl UNK on_symbeg UNK on_nl on_ignored_nl def redis on_nl UNK # Encapsulation of encode/decode. Overwrite this to use it across Resque. # This defaults to MultiJson for backwards compatibilty.
def redis on_nl UNK on_ivar if on_ivar on_nl UNK on_period redis on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_op # Returns the current Redis connection. If none has been created, will # create a new one.
if redis on_period UNK on_lparen on_symbeg server on_rparen on_nl redis on_period server on_nl UNK redis on_period UNK on_lparen on_symbeg UNK # support 1.x versions of redis-rb
redis on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_rbrace on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # distributed
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op on_lparen on_ivar on_op block on_rparen on_op on_ivar on_nl end on_nl on_ignored_nl # The `before_first_fork` hook will be run in the **parent** process # only once, before forking to run the first job. Be careful- any # changes you make will be permanent for the lifespan of the # worker. # # Call with a block to set the hook. # Call with no arguments to return the hook.
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op on_lparen on_ivar on_op block on_rparen on_op # Set a proc that will be called in the parent process before the # worker forks for the first time.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op on_lparen on_ivar on_op block on_rparen on_op on_ivar on_nl end on_nl on_ignored_nl # The `before_fork` hook will be run in the **parent** process # before every job, so be careful- any changes you make will be # permanent for the lifespan of the worker. # # Call with a block to set the hook. # Call with no arguments to return the hook.
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op on_lparen on_ivar on_op block on_rparen on_op # Set the before_fork proc.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op on_lparen on_ivar on_op block on_rparen on_op on_ivar on_nl end on_nl on_ignored_nl # The `after_fork` hook will be run in the child process and is passed # the current job. Any changes you make, therefore, will only live as # long as the job currently being processed. # # Call with a block to set the hook. # Call with no arguments to return the hook.
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_nl on_tstring_beg on_tstring_content UNK UNK UNK on_tstring_end on_nl end on_nl on_ignored_nl UNK on_symbeg # Set the after_fork proc.
UNK on_symbeg UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def UNK on_lparen queue on_comma UNK on_rparen on_ignored_nl queue on_lparen queue on_rparen # If 'inline' is true Resque will call #perform method inline # without queuing it into Redis and without any Resque callbacks. # The 'inline' is false Resque jobs will be put in queue regularly.
on_ignored_nl def UNK on_lparen queue on_comma UNK on_rparen on_ignored_nl queue on_lparen queue on_rparen on_op UNK on_nl end on_nl on_ignored_nl def # # queue manipulation #
def UNK on_lparen queue on_comma UNK on_rparen on_ignored_nl queue on_lparen queue on_rparen on_op UNK on_nl end on_nl on_ignored_nl def UNK # Pushes a job onto a queue. Queue name should be a string and the # item should be any JSON-able Ruby object. # # Resque works generally expect the `item` to be a hash with the following # keys: # # class - The String name of the job to run. # args - An Array of arguments to pass the job. Usually passed # via `class.to_class.perform(*args)`. # # Example # # Resque.push('archive', :class => 'Archive', :args => [ 35, 'tar' ]) # # Returns nothing
def UNK on_lparen queue on_rparen on_ignored_nl UNK on_ignored_nl queue on_lparen queue on_rparen on_period UNK on_lparen UNK on_rparen on_nl UNK on_const # Pops a job off a queue. Queue name should be a string. # # Returns a Ruby object.
def size on_lparen queue on_rparen on_ignored_nl queue on_lparen queue on_rparen on_period size on_nl end on_nl on_ignored_nl def UNK on_lparen queue # Returns an integer representing the size of a queue. # Queue name should be a string.
def UNK on_lparen queue on_comma start on_op on_int on_comma UNK on_op on_int on_rparen on_ignored_nl queue on_lparen queue on_rparen on_period UNK # Returns an array of items currently queued. Queue name should be # a string. # # start and count should be integer and can be used for pagination. # start is the item to begin, count is how many items to return. # # To get the 3rd page of a 30 item, paginatied list one would use: # Resque.peek('my_list', 59, 30)
def UNK on_lparen UNK on_comma start on_op on_int on_comma UNK on_op on_int on_rparen on_ignored_nl if UNK on_op on_int on_nl UNK # Does the dirty work of fetching a range of items from a Redis list # and converting them into Ruby objects.
def UNK on_nl on_const on_lparen redis on_period UNK on_lparen on_symbeg UNK on_rparen on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Returns an array of all known Resque queues as strings.
def UNK on_lparen queue on_rparen on_ignored_nl queue on_lparen queue on_rparen on_period UNK on_nl on_ivar on_period UNK on_lparen queue on_period UNK # Given a queue name, completely deletes the queue.
def queue on_lparen UNK on_rparen on_ignored_nl on_ivar on_lbracket UNK on_period UNK on_rbracket on_nl end on_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK # Return the Resque::Queue object for a given name
on_ignored_nl def UNK on_lparen klass on_comma on_op args on_rparen on_ignored_nl UNK on_lparen UNK on_lparen klass on_rparen on_comma klass on_comma on_op # # job shortcuts #
def UNK on_lparen klass on_comma on_op args on_rparen on_ignored_nl UNK on_lparen UNK on_lparen klass on_rparen on_comma klass on_comma on_op args # This method can be used to conveniently add a job to a queue. # It assumes the class you're passing it is a real Ruby class (not # a string or reference) which either: # # a) has a @queue ivar set # b) responds to `queue` # # If either of those conditions are met, it will use the value obtained # from performing one of the above operations to determine the queue. # # If no queue can be inferred this method will raise a `Resque::NoQueueError` # # Returns true if the job was queued, nil if the job was rejected by a # before_enqueue hook. # # This method is considered part of the `stable` API.
def UNK on_lparen queue on_comma klass on_comma on_op args on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period # Just like `enqueue` but allows you to specify the queue you want to # use. Runs hooks. # # `queue` should be the String name of the queue you're targeting. # # Returns true if the job was queued, nil if the job was rejected by a # before_enqueue hook. # # This method is considered part of the `stable` API.
UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period UNK do on_op hook on_op on_ignored_nl klass on_period UNK on_lparen hook # Perform before_enqueue hooks. Don't perform enqueue if any hook returns false
def UNK on_lparen klass on_comma on_op args on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period UNK do # This method can be used to conveniently remove a job from a queue. # It assumes the class you're passing it is a real Ruby class (not # a string or reference) which either: # # a) has a @queue ivar set # b) responds to `queue` # # If either of those conditions are met, it will use the value obtained # from performing one of the above operations to determine the queue. # # If no queue can be inferred this method will raise a `Resque::NoQueueError` # # If no args are given, this method will dequeue *all* jobs matching # the provided class. See `Resque::Job.destroy` for more # information. # # Returns the number of jobs destroyed. # # Example: # # # Removes all jobs of class `UpdateNetworkGraph` # Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph) # # # Removes all jobs of class `UpdateNetworkGraph` with matching args. # Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph, 'repo:135325') # # This method is considered part of the `stable` API.
UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period UNK do on_op hook on_op on_ignored_nl klass on_period UNK on_lparen hook # Perform before_dequeue hooks. Don't perform dequeue if any hook returns false
def UNK on_lparen klass on_rparen on_ignored_nl klass on_period UNK on_lparen on_symbeg on_ivar on_rparen on_op on_ignored_nl on_lparen klass on_period UNK on_lparen # Given a class, try to extrapolate an appropriate queue based on a # class instance variable or `queue` method.
def UNK on_lparen queue on_rparen on_ignored_nl on_const on_period UNK on_lparen queue on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen klass # This method will return a `Resque::Job` object or a non-true value # depending on whether a job can be obtained. You should pass it the # precise name of a queue: case matters. # # This method is considered part of the `stable` API.
def UNK on_lparen klass on_comma queue on_op UNK on_rparen on_ignored_nl queue on_op UNK on_lparen klass on_rparen on_nl on_ignored_nl if on_op # Validates if the given klass could be a valid Resque job # # If no queue can be inferred this method will raise a `Resque::NoQueueError` # # If given klass is nil this method will raise a `Resque::NoClassError`
on_ignored_nl def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_const on_period UNK on_nl end on_nl # # worker shortcuts #
def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl # A shortcut to Worker.all
def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_op # A shortcut to Worker.working
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen on_nl UNK on_period UNK # A shortcut to unregister_worker # useful for command line tool
on_ignored_nl def UNK on_nl UNK on_lbrace on_ignored_nl on_symbeg UNK on_op UNK on_period UNK on_lparen on_int on_rparen on_lbrace on_op UNK on_comma # # stats #
def UNK on_nl UNK on_lbrace on_ignored_nl on_symbeg UNK on_op UNK on_period UNK on_lparen on_int on_rparen on_lbrace on_op UNK on_comma UNK # Returns a hash, similar to redis-rb's #info, of interesting stats.
def UNK on_nl redis on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK do on_op UNK on_op on_ignored_nl UNK on_period # Returns an array of all known Resque keys in Redis. Redis' KEYS operation # is O(N) for the keyspace, so be careful - this can be slow for big databases.
