on_ignored_nl def UNK on_nl store_names on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_comma on_const on_nl store_names on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_comma # def test_child_suggest # store_names ["Shark"], Cat # store_names ["Sharp"], Dog # assert_equal ["shark"], Cat.search("shar", fields: [:name], suggest: true).suggestions # end
assert_equal on_int on_comma on_const on_period search on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_label on_lbracket on_const on_comma on_const on_rbracket on_rparen on_period size # note: the models option is less efficient than Animal.search("bear", type: [Cat, Dog]) # since it requires two database calls instead of one to Animal
UNK on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_int on_op on_int on_nl assert_equal UNK on_comma on_const on_period # hits and pagination will be off with this approach (for now) # ideal case is add where conditions (index a, type a OR index b) # however, we don't know the exact index name and aliases don't work for filters # see https://github.com/elastic/elasticsearch/issues/23306 # show warning for now # alternative is disallow inherited models with models option
on_ignored_nl def UNK on_nl store_names on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl store_names on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_comma on_const on_nl # TODO move somewhere better
