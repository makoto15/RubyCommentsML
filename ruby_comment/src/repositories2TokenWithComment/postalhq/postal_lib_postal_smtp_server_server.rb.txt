UNK on_op true on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content # Instruct the nio loop to unlisten and wake it
on_ivar on_op on_const on_op on_const on_period new on_nl on_ivar on_period UNK on_lparen on_ivar on_comma on_symbeg UNK on_rparen on_nl buffers on_op # Set up an instance of nio4r to monitor for connections and data
on_ivar on_period UNK on_lparen on_ivar on_comma on_symbeg UNK on_rparen on_nl buffers on_op on_const on_period new UNK on_op UNK on_comma UNK # Register the SMTP listener
buffers on_op on_const on_period new UNK on_op UNK on_comma UNK on_op UNK on_lbracket UNK on_rbracket on_op on_const on_period new on_period # Create a hash to contain a buffer for each client.
on_ivar on_period UNK do on_op monitor on_op on_ignored_nl io on_op monitor on_period io on_nl if io on_period UNK on_lparen on_const # Wait for an event to occur
io on_op monitor on_period io on_nl if io on_period UNK on_lparen on_const on_rparen on_nl begin on_ignored_nl new_io on_op io on_period # Get the IO from the nio monitor
if io on_period UNK on_lparen on_const on_rparen on_nl begin on_ignored_nl new_io on_op io on_period UNK on_nl if on_const on_period config # Is this event an incoming connection?
new_io on_op io on_period UNK on_nl if on_const on_period config on_period smtp_server on_period UNK on_nl client on_op on_const on_period new # Accept the connection
client on_op on_const on_period new on_lparen nil on_rparen on_nl if on_const on_period config on_period smtp_server on_period UNK on_nl logger on_period # If we are using the haproxy proxy protocol, we will be sent the # client's IP later. Delay the welcome process.
client on_op on_const on_period new on_lparen new_io on_period UNK on_period UNK on_rparen on_nl if on_const on_period config on_period smtp_server on_period # We're not using the proxy protocol so we already know the client's IP
client on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg new_io on_period UNK on_period UNK on_embexpr_end on_tstring_content on_tstring_end on_nl new_io on_period UNK on_lparen on_tstring_beg # We know who the client is, welcome them.
monitor on_op on_ivar on_period UNK on_lparen new_io on_comma on_symbeg UNK on_rparen on_nl monitor on_period UNK on_op client on_nl rescue on_op # Register the client and its socket with nio4r
if defined? on_lparen on_const on_rparen on_nl on_const on_period UNK on_lparen e on_comma on_symbeg UNK on_op UNK on_symbeg UNK on_op on_lparen # If something goes wrong, log as appropriate and disconnect the client
begin on_ignored_nl client on_op monitor on_period UNK on_nl eof on_op false on_nl begin on_ignored_nl UNK io on_nl UNK on_const on_op # This event is not an incoming connection so it must be data from a client
client on_op monitor on_period UNK on_nl eof on_op false on_nl begin on_ignored_nl UNK io on_nl UNK on_const on_op on_const on_op # Get the client from the nio monitor
eof on_op false on_nl begin on_ignored_nl UNK io on_nl UNK on_const on_op on_const on_op on_const on_nl buffers on_lbracket io on_rbracket # For now we assume the connection isn't closed
UNK io on_nl UNK on_const on_op on_const on_op on_const on_nl buffers on_lbracket io on_rbracket on_op io on_period UNK on_lparen on_int # Read 10kiB of data at a time from the socket. # There is an extra step for SSL sockets
eof on_op true on_nl end on_nl UNK buffers on_lbracket io on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if # Client went away
UNK buffers on_lbracket io on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if buffers on_lbracket io on_rbracket on_period UNK # We line buffer, so look to see if we have received a newline # and keep doing so until all buffered lines have been processed.
if buffers on_lbracket io on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl line on_comma buffers on_lbracket io on_rbracket on_op # Extract the line
result on_op client on_period UNK on_lparen line on_rparen on_nl UNK result on_period UNK on_nl result on_op on_lbracket result on_rbracket UNK # Send the received line to the client object for processing
UNK result on_period UNK on_nl result on_op on_lbracket result on_rbracket UNK result on_period UNK on_lparen on_const on_rparen on_nl result on_period # If the client object returned some data, write it back to the client
eof on_op true on_nl end on_nl end on_nl end on_nl end on_nl if on_op eof on_op client on_period UNK on_nl # Client disconnected before we could write response
if on_op eof on_op client on_period UNK on_nl client on_period UNK on_op false on_nl on_ivar on_period UNK on_lparen io on_rparen # If the client requested we start TLS, do it now
client on_period UNK on_op false on_nl on_ivar on_period UNK on_lparen io on_rparen on_nl buffers on_period UNK on_lparen io on_rparen on_nl # Clear the request
on_ivar on_period UNK on_lparen io on_rparen on_nl buffers on_period UNK on_lparen io on_rparen on_nl UNK on_op io on_nl io on_op # Deregister the unencrypted IO
UNK on_op io on_nl io on_op on_const on_op on_const on_op on_const on_period new on_lparen io on_comma ssl_context on_rparen on_nl monitor # Prepare TLS on the socket
monitor on_op on_ivar on_period UNK on_lparen io on_comma on_symbeg UNK on_rparen on_nl monitor on_period UNK on_op client on_nl io on_period # Register the new TLS socket with nio
io on_period UNK on_op true on_nl begin on_ignored_nl io on_period UNK on_nl rescue on_const on_op on_const on_op on_const on_op e # Close the underlying IO when the TLS socket is closed
io on_period UNK on_nl rescue on_const on_op on_const on_op on_const on_op e on_nl client on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg e # Start TLS negotiation
if client on_period UNK on_op eof on_nl client on_period UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_period UNK on_lparen io on_rparen # Has the clint requested we close the connection?
on_ivar on_period UNK on_lparen io on_rparen on_nl buffers on_period UNK on_lparen io on_rparen on_nl io on_period UNK on_nl if on_ivar # Deregister the socket and close it
if on_ivar on_period UNK on_nl on_const on_period UNK on_lparen on_int on_rparen on_nl end on_nl end on_nl rescue on_op e on_nl # If we have no more clients or listeners left, exit the process
UNK on_op client on_op client on_period id on_op on_tstring_beg on_tstring_content on_tstring_end on_nl if defined? on_lparen on_const on_rparen on_nl on_const on_period # Something went wrong, log as appropriate
on_ivar on_period UNK on_lparen io on_rparen rescue nil on_nl buffers on_period UNK on_lparen io on_rparen on_nl io on_period UNK rescue # Close all IO and forget this client
if UNK on_nl on_ivar on_period UNK on_lparen on_ivar on_rparen on_nl on_ivar on_period UNK on_nl if on_ivar on_period UNK on_nl on_const # If unlisten has been called, stop listening
if on_ivar on_period UNK on_nl on_const on_period UNK on_lparen on_int on_rparen on_nl end on_nl UNK on_op false on_nl end on_nl # If there's nothing left to do, shut down the process
UNK on_op false on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end # Clear the request
if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_const on_period UNK on_lparen on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_comma on_tstring_beg # Write PID to file if path specified
if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_nl UNK on_nl else on_ignored_nl UNK on_nl end on_nl UNK on_nl # If we have been spawned to replace an existing processm shut down the # parent after listening.
