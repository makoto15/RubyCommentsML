on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
class on_const on_nl def self on_period UNK on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma on_op # Step Definitions that match a plain text Step with a multiline argument table # will receive it as an instance of Table. A Table object holds the data of a # table parsed from a feature file and lets you access and manipulate the data # in different ways. # # For example: # # Given I have: # | a | b | # | c | d | # # And a matching StepDefinition: # # Given /I have:/ do |table| # data = table.raw # end # # This will store <tt>[['a', 'b'], ['c', 'd']]</tt> in the <tt>data</tt> variable. #
on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen #:nodoc:
def initialize on_lparen data on_comma UNK on_op on_const on_period dup on_comma UNK on_op on_lbrace on_rbrace on_comma UNK on_op UNK on_rparen # @param data [Core::Test::DataTable] the data for the table # @param conversion_procs [Hash] see map_columns! # @param header_mappings [Hash] see map_headers! # @param header_conversion_proc [Proc] see map_headers!
ast_table on_period transpose on_nl on_ivar on_op UNK on_lparen ast_table on_rparen on_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_nl on_ivar # Verify that it's square
def dup on_nl self on_period class on_period new on_lparen on_const on_op on_const on_op on_const on_period new on_lparen raw on_rparen on_comma # Creates a copy of this table, inheriting any column and header mappings # registered with #map_column! and #map_headers!. #
def transpose on_nl self on_period class on_period new on_lparen on_const on_op on_const on_op on_const on_period new on_lparen raw on_period transpose # Returns a new, transposed table. Example: # # | a | 7 | 4 | # | b | 9 | 2 | # # Gets converted into the following: # # | a | b | # | 7 | 9 | # | 4 | 2 | #
def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_ignored_nl UNK on_period map do # Converts this table into an Array of Hash where the keys of each # Hash are the headers in the table. For example, a Table built from # the following plain text: # # | a | b | sum | # | 2 | 3 | 5 | # | 7 | 9 | 16 | # # Gets converted into the following: # # [{'a' => '2', 'b' => '3', 'sum' => '5'}, {'a' => '7', 'b' => '9', 'sum' => '16'}] # # Use #map_column! to specify how values in a column are converted. #
def UNK on_nl on_ivar on_op on_ignored_nl UNK on_period map do on_op UNK on_op on_ignored_nl on_const on_lbracket UNK on_period map on_lbrace # Converts this table into an Array of Hashes where the keys are symbols. # For example, a Table built from the following plain text: # # | foo | Bar | Foo Bar | # | 2 | 3 | 5 | # | 7 | 9 | 16 | # # Gets converted into the following: # # [{:foo => '2', :bar => '3', :foo_bar => '5'}, {:foo => '7', :bar => '9', :foo_bar => '16'}] #
def UNK on_nl UNK on_ivar if on_ivar on_nl UNK on_lparen on_int on_rparen on_nl on_ivar on_op transpose on_period UNK on_lbracket on_int # Converts this table into a Hash where the first column is # used as keys and the second column is used as values # # | a | 2 | # | b | 3 | # # Gets converted into the following: # # {'a' => '2', 'b' => '3'} # # The table must be exactly two columns wide #
def raw on_nl cell_matrix on_period map do on_op row on_op on_ignored_nl row on_period map on_lparen on_op on_symbeg value on_rparen on_nl # Gets the raw data of this table. For example, a Table built from # the following plain text: # # | a | b | # | c | d | # # gets converted into the following: # # [['a', 'b'], ['c', 'd']] #
on_ivar on_op cell_matrix on_lbracket on_int on_rbracket on_period map on_lparen on_op on_symbeg value on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl #:nodoc:
cells_rows on_period each on_lparen on_op UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_tstring_beg #:nodoc:
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_embexpr_end # Matches +pattern+ against the header row of the table. # This is used especially for argument transforms. # # Example: # | column_1_name | column_2_name | # | x | y | # # table.match(/table:column_1_name,column_2_name/) #=> non-nil # # Note: must use 'table:' prefix on match
def UNK on_lparen UNK on_op on_lbrace on_rbrace on_comma on_op UNK on_rparen on_ignored_nl UNK on_nl on_ivar on_op UNK on_nl on_ivar on_op # Redefines the table headers. This makes it possible to use # prettier and more flexible header names in the features. The # keys of +mappings+ are Strings or regular expressions # (anything that responds to #=== will work) that may match # column headings in the table. The values of +mappings+ are # desired names for the columns. # # Example: # # | Phone Number | Address | # | 123456 | xyz | # | 345678 | abc | # # A StepDefinition receiving this table can then map the columns # with both Regexp and String: # # table.map_headers!(/phone( number)?/i => :phone, 'Address' => :address) # table.hashes # # => [{:phone => '123456', :address => 'xyz'}, {:phone => '345678', :address => 'abc'}] # # You may also pass in a block if you wish to convert all of the headers: # # table.map_headers! { |header| header.downcase } # table.hashes.keys # # => ['phone number', 'address'] # # When a block is passed in along with a hash then the mappings in the hash take precendence: # # table.map_headers!('Address' => 'ADDRESS') { |header| header.downcase } # table.hashes.keys # # => ['phone number', 'ADDRESS'] #
UNK on_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_op on_lbrace on_rbrace # TODO: Remove this method for 2.0
def UNK on_lparen UNK on_op on_lbrace on_rbrace on_comma on_op UNK on_rparen on_ignored_nl self on_period class on_period new on_lparen on_const on_op # Returns a new Table where the headers are redefined. See #map_headers!
def UNK on_lparen column_name on_comma UNK on_op UNK on_comma on_op conversion_proc on_rparen on_ignored_nl on_ivar on_lbracket column_name on_period to_s on_rbracket on_op # Change how #hashes converts column values. The +column_name+ argument identifies the column # and +conversion_proc+ performs the conversion for each cell in that column. If +strict+ is # true, an error will be raised if the column named +column_name+ is not found. If +strict+ # is false, no error will be raised. Example: # # Given /^an expense report for (.*) with the following posts:$/ do |table| # posts_table.map_column!('amount') { |a| a.to_i } # posts_table.hashes.each do |post| # # post['amount'] is a Fixnum, rather than a String # end # end #
on_ivar on_lbracket column_name on_period to_s on_rbracket on_op on_lbrace on_label UNK on_comma on_label conversion_proc on_rbrace on_nl self on_nl end on_nl on_ignored_nl # TODO: Remove this method for 2.0
def UNK on_lparen column_name on_comma UNK on_op UNK on_comma on_op conversion_proc on_rparen on_ignored_nl UNK on_op on_ivar on_period dup on_nl UNK # Returns a new Table with an additional column mapping. See #map_column!
def UNK on_lparen other_table on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl other_table on_op UNK on_lparen other_table on_rparen on_nl other_table on_period # Compares +other_table+ to self. If +other_table+ contains columns # and/or rows that are not in self, new columns/rows are added at the # relevant positions, marking the cells in those rows/columns as # <tt>surplus</tt>. Likewise, if +other_table+ lacks columns and/or # rows that are present in self, these are marked as <tt>missing</tt>. # # <tt>surplus</tt> and <tt>missing</tt> cells are recognised by formatters # and displayed so that it's easy to read the differences. # # Cells that are different, but <em>look</em> identical (for example the # boolean true and the string "true") are converted to their Object#inspect # representation and preceded with (i) - to make it easier to identify # where the difference actually is. # # Since all tables that are passed to StepDefinitions always have String # objects in their cells, you may want to use #map_column! before calling # #diff!. You can use #map_column! on either of the tables. # # A Different error is raised if there are missing rows or columns, or # surplus rows. An error is <em>not</em> raised for surplus columns. An # error is <em>not</em> raised for misplaced (out of sequence) columns. # Whether to raise or not raise can be changed by setting values in # +options+ to true or false: # # * <tt>missing_row</tt> : Raise on missing rows (defaults to true) # * <tt>surplus_row</tt> : Raise on surplus rows (defaults to true) # * <tt>missing_col</tt> : Raise on missing columns (defaults to true) # * <tt>surplus_col</tt> : Raise on surplus columns (defaults to false) # * <tt>misplaced_col</tt> : Raise on misplaced columns (defaults to false) # # The +other_table+ argument can be another Table, an Array of Array or # an Array of Hash (similar to the structure returned by #hashes). # # Calling this method is particularly useful in <tt>Then</tt> steps that take # a Table argument, if you want to compare that table to some actual values. #
hash on_op on_const on_period new do on_op UNK on_comma UNK on_op on_ignored_nl UNK on_lbracket UNK on_period to_s on_rbracket if UNK #:nodoc:
cells_rows on_period UNK on_lparen cells on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen column_name on_rparen raise on_tstring_beg on_tstring_content on_embexpr_beg column_name #:nodoc:
raise on_tstring_beg on_tstring_content on_embexpr_beg column_name on_embexpr_end on_tstring_content on_tstring_end UNK raw on_lbracket on_int on_rbracket on_period UNK on_lparen column_name on_rparen on_nl end #:nodoc:
raise on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end UNK raw on_lbracket on_int on_rbracket on_period UNK on_op UNK on_nl end on_nl #:nodoc:
def UNK on_lparen UNK on_rparen raw on_period UNK on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_lparen # TODO: remove the below function if it's not actually being used. # Nothing else in this repo calls it.
raw on_period UNK on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_lparen UNK on_rparen on_rbrace on_nl end #:nodoc:
on_ivar on_op cell_matrix on_period map do on_op UNK on_op on_const on_period new on_lparen self on_comma UNK on_rparen on_nl end on_nl #:nodoc:
on_const on_period new on_lparen self on_comma UNK on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK raw on_period UNK on_nl # rubocop:disable Naming/MemoizedInstanceVariableName
raw on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen col on_rparen cells_rows on_lbracket on_int on_rbracket on_lbracket col on_rbracket on_nl #:nodoc:
cells_rows on_lbracket on_int on_rbracket on_lbracket col on_rbracket on_nl end on_nl on_ignored_nl attr_reader on_symbeg cell_matrix on_nl on_ignored_nl def UNK on_lparen col #:nodoc:
UNK on_lbracket col on_rbracket on_period UNK on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def to_s on_lparen options on_op on_lbrace #:nodoc:
indentation on_op options on_period UNK on_lparen on_symbeg UNK on_rparen on_op options on_lbracket on_symbeg UNK on_rbracket on_op on_int on_nl prefixes on_op #:nodoc:
UNK on_const on_op on_const on_op on_const on_op on_const on_nl attr_reader on_symbeg data_table on_comma on_symbeg indentation on_comma on_symbeg prefixes on_nl UNK #:nodoc:
on_ivar on_op cell_matrix on_period transpose on_period map do on_op UNK on_op on_ignored_nl on_const on_period new on_lparen self on_comma UNK on_rparen #:nodoc:
ast_table on_period raw on_period map do on_op UNK on_op on_ignored_nl line on_op UNK on_ignored_nl UNK on_period line on_nl UNK on_const #:nodoc:
on_ivar on_period each do on_op column_name on_comma conversion_proc on_op on_ignored_nl UNK on_lparen column_name on_rparen if conversion_proc on_lbracket on_symbeg UNK on_rbracket #:nodoc:
UNK on_op cell_matrix on_lbracket on_int on_rbracket on_nl on_ignored_nl if on_ivar on_nl UNK on_op UNK on_period map on_lparen on_op on_symbeg value #:nodoc:
on_ivar on_op on_ivar on_op on_ivar on_op on_ivar on_op on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen #:nodoc:
UNK UNK if on_const on_op UNK on_period class on_nl on_const on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def #:nodoc:
class on_const UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # Represents a row of cells or columns of cells
UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def initialize #:nodoc:
def UNK on_lbracket on_symbeg row on_comma line on_comma on_op on_ivar on_period map on_lparen on_op on_symbeg UNK on_rparen on_rbracket on_nl end # For testing only
on_lbracket on_symbeg row on_comma line on_comma on_op on_ivar on_period map on_lparen on_op on_symbeg UNK on_rparen on_rbracket on_nl end on_nl on_ignored_nl #:nodoc:
on_ivar on_op on_ivar on_period UNK on_lparen self on_rparen on_nl end on_nl on_ignored_nl def value on_lparen UNK on_rparen self on_lbracket UNK #:nodoc:
self on_lbracket UNK on_rbracket on_period value on_nl end on_nl on_ignored_nl def on_op on_lparen UNK on_rparen on_ignored_nl on_ivar on_lbracket UNK on_rbracket #:nodoc:
attr_reader on_symbeg line on_comma on_symbeg table on_nl UNK on_symbeg UNK on_comma on_symbeg value on_nl on_ignored_nl def initialize on_lparen value on_comma #:nodoc:
def UNK on_lbracket on_symbeg cell on_comma on_ivar on_rbracket on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const def UNK # For testing only
on_lbracket on_symbeg cell on_comma on_ivar on_rbracket on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const def UNK on_nl on_symbeg #:nodoc:
def UNK on_nl on_symbeg UNK on_nl end on_nl on_ignored_nl def on_op on_lparen UNK on_rparen on_ignored_nl UNK on_nl end on_nl on_ignored_nl #:nodoc:
