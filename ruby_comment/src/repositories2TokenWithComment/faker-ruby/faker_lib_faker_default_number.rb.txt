on_ignored_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_op UNK on_nl def number on_lparen legacy_digits on_op on_const on_comma # frozen_string_literal: true
def number on_lparen legacy_digits on_op on_const on_comma on_label on_int on_rparen on_ignored_nl warn_for_deprecated_arguments do on_op keywords on_op on_ignored_nl keywords on_op on_symbeg ## # Produce a random number. # # @param digits [Integer] Number of digits that the generated number should have. # @return [Integer] # # @example # Faker::Number.number(digits: 10) #=> 1968353479 # # @faker.version 1.0.0
on_lparen UNK UNK UNK on_op UNK on_lparen digits on_op on_int on_rparen on_rparen on_period UNK on_period UNK on_nl end on_nl on_ignored_nl # Ensure the first digit is not zero
def UNK on_lparen legacy_digits on_op on_const on_comma on_label on_int on_rparen on_ignored_nl warn_for_deprecated_arguments do on_op keywords on_op on_ignored_nl keywords on_op on_symbeg ## # Produce a random number with a leading zero. # # @param digits [Integer] Number of digits that the generated number should have. # @return [String] # # @example # Faker::Number.leading_zero_number(digits: 10) #=> "0669336915" # # @faker.version 1.0.0
def UNK on_lparen legacy_digits on_op on_const on_comma on_label on_int on_rparen on_ignored_nl warn_for_deprecated_arguments do on_op keywords on_op on_ignored_nl keywords on_op on_symbeg ## # Produce a number with a number of digits, preserves leading zeroes. # # @param digits [Integer] Number of digits that the generated number should have. # @return [String] # # @example # Faker::Number.decimal_part(digits: 2) #=> "09" # # @faker.version 1.0.0
def UNK on_lparen UNK on_op on_const on_comma UNK on_op on_const on_comma on_label on_int on_comma on_label on_int on_rparen on_ignored_nl warn_for_deprecated_arguments do ## # Produces a float. # # @param l_digits [Integer] Number of digits that the generated decimal should have to the left of the decimal point. # @param r_digits [Integer] Number of digits that the generated decimal should have to the right of the decimal point. # @return [Float] # # @example # Faker::Number.decimal(l_digits: 2) #=> 11.88 # Faker::Number.decimal(l_digits: 3, r_digits: 3) #=> 181.843 # # @faker.version 1.0.0
UNK on_lparen UNK on_op on_int on_rparen on_period UNK on_op UNK on_period UNK on_nl end on_nl UNK UNK UNK UNK UNK # Ensure the last digit is not zero # so it does not get truncated on converting to float
def UNK on_nl rand on_lparen on_int on_op on_int on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl rand on_lparen on_int on_rparen ## # Produces a non-zero single-digit integer. # # @return [Integer] # # @example # Faker::Number.non_zero_digit #=> 8 # # @faker.version 1.0.0
def UNK on_nl rand on_lparen on_int on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen legacy_digits on_op on_const on_comma on_label on_int ## # Produces a single-digit integer. # # @return [Integer] # # @example # Faker::Number.digit #=> 1 # # @faker.version 1.0.0
def UNK on_lparen legacy_digits on_op on_const on_comma on_label on_int on_rparen on_ignored_nl warn_for_deprecated_arguments do on_op keywords on_op on_ignored_nl keywords on_op on_symbeg ## # Produces a number in hexadecimal format. # # @param digits [Integer] Number of digits in the he # @return [String] # # @example # Faker::Number.hexadecimal(digits: 3) #=> "e74" # # @faker.version 1.0.0
def UNK on_lparen UNK on_op on_const on_comma UNK on_op on_const on_comma on_label on_int on_comma on_label on_int on_rparen on_ignored_nl warn_for_deprecated_arguments do ## # Produces a float given a mean and standard deviation. # # @param mean [Integer] # @param standard_deviation [Integer, Float] # @return [Float] # # @example # Faker::Number.normal(mean: 50, standard_deviation: 3.5) #=> 47.14669604069156 # # @faker.version 1.0.0
def UNK on_lparen legacy_from on_op on_const on_comma legacy_to on_op on_const on_comma on_label on_float on_comma on_label on_float on_rparen on_ignored_nl warn_for_deprecated_arguments do ## # Produces a number between two provided values. Boundaries are inclusive. # # @param from [Integer] The lowest number to include. # @param to [Integer] The highest number to include. # @return [Integer] # # @example # Faker::Number.between(from: 1, to: 10) #=> 7 # # @faker.version 1.0.0
def UNK on_lparen UNK on_op on_const on_comma on_label on_float on_op on_float on_rparen on_ignored_nl warn_for_deprecated_arguments do on_op keywords on_op on_ignored_nl keywords ## # Produces a number within two provided values. Boundaries are inclusive or exclusive depending on the range passed. # # @param range [Range] The range from which to generate a number. # @return [Integer] # # @example # Faker::Number.within(range: 1..10) #=> 7 # # @faker.version 1.0.0
def UNK on_lparen legacy_from on_op on_const on_comma legacy_to on_op on_const on_comma on_label on_float on_comma on_label on_float on_rparen on_ignored_nl warn_for_deprecated_arguments do ## # Produces a positive float. # # @param from [Integer] The lower boundary. # @param to [Integer] The higher boundary. # @return [Float] # # @example # Faker::Number.positive #=> 235.59238499107653 # # @faker.version 1.0.0
def UNK on_lparen legacy_from on_op on_const on_comma legacy_to on_op on_const on_comma on_label on_op on_float on_comma on_label on_op on_float on_rparen on_ignored_nl ## # Produces a negative float. # # @param from [Integer] The lower boundary. # @param to [Integer] The higher boundary. # @return [Float] # # @example # Faker::Number.negative #=> -4480.042585669558 # # @faker.version 1.0.0
