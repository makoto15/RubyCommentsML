on_ignored_nl UNK on_op UNK on_nl on_ignored_nl UNK on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
on_ignored_nl on_const on_period UNK on_lparen on_const on_period UNK on_lparen on_const on_period UNK on_lparen UNK on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma # Fixes a bug in i18n 0.6.11
def UNK on_lparen UNK on_comma UNK UNK on_rparen on_ignored_nl UNK UNK on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace rand ## by default numerify results do not start with a zero
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK if UNK on_period UNK on_lparen on_symbeg UNK on_rparen UNK # Given a regular expression, attempt to generate a string # that would match it. This is a rather simple implementation, # so don't be shocked if it blows up on you in a spectacular fashion. # # It does not handle ., *, unbounded ranges such as {1,}, # extensions such as (?=), character classes, some abbreviations # for character classes, and nested parentheses. # # I told you it was simple. :) It's also probably dog-slow, # so you shouldn't use it. # # It will take a regex like this: # # /^[A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}$/ # # and generate a string like this: # # "U3V 3TP" #
UNK on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end on_rparen # Handle either a Regexp or a String that looks like a Regexp
on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content # Ditch the anchors
on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace on_op _match on_op on_const on_period last_match on_lparen on_int on_rparen on_op sample on_lparen # All {2} become {2,2} and ? become {0,1}
on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace on_op _match on_op on_const on_period last_match on_lparen on_int on_rparen on_op sample on_lparen # [12]{1,2} becomes [12] or [12][12]
on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace on_op _match on_op on_const on_period last_match on_lparen on_int on_rparen on_op sample on_lparen # (12|34){1,2} becomes (12|34) or (12|34)(12|34)
on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace on_op match on_op sample on_lparen match on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end # A{1,2} becomes A or AA or \d{3} becomes \d\d\d
on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace on_op match on_op match on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace # (this|that) becomes 'this' or 'that'
on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_lbrace on_op _match on_op sample on_lparen on_const on_period last_match on_lparen on_int on_rparen on_period # All A-Z inside of [] become C (or X, or whatever)
on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace on_op _match on_op sample on_lparen on_const on_rparen on_rbrace on_ignored_nl on_period gsub on_lparen # All [ABC] become B (or A or C)
def UNK on_lparen key on_rparen on_ignored_nl fetched on_op sample on_lparen translate on_lparen on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_end on_rparen on_rparen # Helper for the common approach of grabbing a translation # with an array of values and selecting one of them.
UNK on_lparen fetched on_rparen on_nl else on_ignored_nl fetched on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen key on_rparen on_ignored_nl # A regex
def UNK on_lparen key on_rparen on_ignored_nl fetched on_op translate on_lparen on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_end on_rparen on_nl fetched on_op # Helper for the common approach of grabbing a translation # with an array of values and returning all of them.
UNK on_lparen fetched on_rparen on_nl else on_ignored_nl fetched on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen key on_rparen on_ignored_nl # A regex
def UNK on_lparen key on_rparen on_ignored_nl fetched on_op UNK on_lparen key on_rparen on_nl UNK on_op fetched on_period UNK on_lparen on_regexp_beg # Load formatted strings from the locale, "parsing" them # into method calls that can be used to generate a # formatted translation: e.g., "#{first_name} #{last_name}".
UNK on_op UNK on_op on_const on_period UNK on_lparen UNK on_period UNK on_rparen on_op UNK on_nl on_ignored_nl UNK on_op UNK on_nl # If the token had a class Prefix (e.g., Name.first_name) # grab the constant, otherwise use self
UNK on_op UNK on_nl on_ignored_nl UNK on_op if UNK on_period UNK on_lparen UNK on_rparen on_nl UNK on_period UNK on_lparen UNK # If an optional leading parentheses is not present, prefix.should == "", otherwise prefix.should == "(" # In either case the information will be retained for reconstruction of the string.
UNK on_op if UNK on_period UNK on_lparen UNK on_rparen on_nl UNK on_period UNK on_lparen UNK on_rparen on_nl else on_ignored_nl UNK # If the class has the method, call it, otherwise fetch the transation # (e.g., faker.phone_number.area_code)
UNK on_op UNK on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end # Do just enough snake casing to convert PhoneNumber to phone_number
UNK on_op UNK on_period UNK on_nl end on_nl UNK on_period UNK on_op UNK on_period UNK on_op UNK on_lparen fetched on_rparen # And tack on spaces, commas, etc. left over in the string
UNK on_period UNK on_op UNK on_period UNK on_op UNK on_lparen fetched on_rparen on_nl end on_nl on_ignored_nl def translate on_lparen on_op # If the fetched key couldn't be parsed, then fallback to numerify
def translate on_lparen on_op UNK on_comma on_op opts on_rparen on_ignored_nl opts on_lbracket on_symbeg locale on_rbracket on_op on_const on_op on_const on_period # Call I18n.translate with our configured locale if no # locale is specified
UNK UNK on_ignored_nl on_const on_period translate on_lparen on_op UNK on_comma on_op opts on_rparen on_nl end on_nl end on_nl on_ignored_nl def # Super-simple fallback -- fallback to en if the # translation was missing. If the translation isn't # in en either, then it will raise again.
def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_nl on_const on_op on_const on_period # Executes block with given locale set.
def UNK on_lparen UNK on_comma on_op UNK on_comma on_op UNK on_rparen on_ignored_nl UNK UNK on_ivar on_nl on_ignored_nl if on_lparen UNK # You can add whatever you want to the locale file, and it will get caught here. # E.g., in your locale file, create a # name: # girls_name: ["Alice", "Cheryl", "Tatiana"] # Then you can call Faker::Name.girls_name and it will act like #first_name
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_comma UNK on_op UNK on_comma UNK if UNK on_op UNK on_nl # Generates a random value between the interval
def UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK on_nl UNK on_const UNK sample on_lparen UNK on_rparen on_nl UNK on_const UNK # If an array or range is passed, a random value will be selected. # All other values are simply returned.
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl on_ivar on_op on_const on_period new on_lparen UNK on_comma UNK on_rparen on_nl end # Return unique values from the generator every time. # # @param max_retries [Integer] The max number of retries that should be done before giving up. # @return [self]
def UNK on_lparen UNK on_comma UNK on_int on_rparen on_ignored_nl UNK on_op UNK on_lparen UNK on_lbracket UNK on_rbracket on_rparen on_period UNK # Workaround for emulating `warn '...', uplevel: 1` in Ruby 2.4 or lower.
if on_regexp_beg on_tstring_content on_regexp_end on_op UNK on_nl file on_op on_const on_period last_match on_lparen on_int on_rparen on_nl UNK on_op on_const on_period # rubocop:disable Style/GuardClause
end on_nl end on_nl end on_nl end on_nl on_ignored_nl on_const on_period UNK on_lparen on_const on_period UNK on_lparen on_const on_period UNK # rubocop:enable Style/GuardClause
on_const on_period UNK on_lparen on_const on_period UNK on_lparen on_const on_period UNK on_lparen UNK on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # require faker objects
