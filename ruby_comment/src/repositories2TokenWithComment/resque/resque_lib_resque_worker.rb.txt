UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl UNK # A Resque Worker processes jobs. On platforms that support fork(2), # the worker will fork off a child to process each job. This ensures # a clean slate when beginning the next job and cuts down on gradual # memory growth as well as low level failures. # # It also ensures workers are always listening to signals from you, # their master, and can react accordingly.
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # Given a Ruby object, returns a string suitable for storage in a # queue.
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl # Given a string, returns a Ruby object.
attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl UNK # decide whether to use new_kill_child logic
attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl UNK on_symbeg UNK on_nl UNK on_symbeg # should term kill workers gracefully (vs. immediately) # Makes SIGTERM work like SIGQUIT
attr_accessor on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl UNK on_symbeg UNK on_nl UNK on_symbeg to_s on_nl UNK on_symbeg pid # When set to true, forked workers will exit with `exit`, calling any `at_exit` code handlers that have been # registered in the application. Otherwise, forked workers exit with `exit!`
def self on_period UNK on_nl data_store on_period UNK on_period map on_lbrace on_op id on_op UNK on_lparen id on_comma on_symbeg UNK # Returns an array of all worker objects.
def self on_period UNK on_nl UNK on_op UNK on_nl return on_lbracket on_rbracket unless UNK on_period UNK on_nl on_ignored_nl UNK on_op # Returns an array of all worker objects currently processing # jobs.
def self on_period UNK on_lparen worker_id on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op UNK on_lbracket on_symbeg UNK on_rbracket # Returns a single worker object. Accepts a string id.
def self on_period UNK on_lparen worker_id on_rparen on_ignored_nl UNK on_lparen worker_id on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK # Alias of `find`
def self on_period UNK on_lparen worker_id on_rparen on_ignored_nl data_store on_period UNK on_lparen worker_id on_rparen on_nl end on_nl on_ignored_nl def UNK # Given a string worker id, return a boolean indicating whether the # worker exists
def UNK on_lparen on_op queues on_rparen on_ignored_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op false on_nl on_ignored_nl # Workers should be initialized with an array of string queue # names. The order is important: a Worker will check the first # queue given for a job. If none is found, it will check the # second queue name given. If a job is found, it will be # processed. Upon completion, the Worker will again check the # first queue given, and so forth. In this way the queue list # passed to a Worker on startup defines the priorities of queues. # # If passed a single "*", this Worker will operate on all queues # in alphabetical order. Queues can be dynamically added or # removed without needing to restart workers using this method. # # Workers should have `#prepare` called after they are initialized # if you are running work on the worker.
def UNK on_nl if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_const on_period UNK on_lparen true on_rparen on_nl end on_nl # Daemonizes the worker if ENV['BACKGROUND'] is set and writes # the process id to ENV['PIDFILE'] if set. Should only be called # once per worker.
def UNK on_nl if on_ivar on_period UNK on_op on_ivar on_period empty? on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end # A worker must be given a queue, otherwise it won't know what to # do with itself. # # You probably never need to call this.
def queues on_nl if on_ivar on_nl UNK on_op on_const on_period queues on_nl on_ivar on_period map on_lbrace on_op queue on_op UNK # Returns a list of queues to use when searching for a job. # A splat ("*") means you want every queue (in alpha order) - this # can be useful for dynamically adding new queues.
def UNK on_lparen interval on_op UNK on_comma on_op block on_rparen on_ignored_nl interval on_op on_const on_lparen interval on_rparen on_nl UNK on_nl # This is the main workhorse method. Called on a Worker instance, # it begins the worker life cycle. # # The following events occur during a worker's life cycle: # # 1. Startup: Signals are registered, dead workers are pruned, # and this worker is registered. # 2. Work loop: Jobs are pulled from a queue and processed. # 3. Teardown: This worker is unregistered. # # Can be passed a float representing the polling frequency. # The default is 5 seconds, but for a semi-active site you may # want to use a smaller value. # # Also accepts a block which will be passed the job as soon as it # has completed processing. Useful for testing.
def UNK on_lparen job on_op nil on_comma on_op block on_rparen on_ignored_nl return unless job on_op UNK on_nl on_ignored_nl job on_period # DEPRECATED. Processes a single job. If none is given, it will # try to produce one. Usually run in the child.
def UNK on_lparen job on_comma exception on_rparen on_ignored_nl log_with_severity on_symbeg error on_comma on_tstring_beg on_embexpr_beg job on_period inspect on_embexpr_end on_tstring_content on_embexpr_beg # Reports the exception and marks the job as failed
def perform on_lparen job on_rparen on_ignored_nl begin on_ignored_nl if UNK on_nl UNK on_nl run_hook on_symbeg UNK on_comma job on_nl end # Processes a given job in the child.
def UNK on_nl queues on_period each do on_op queue on_op on_ignored_nl log_with_severity on_symbeg debug on_comma on_tstring_beg on_tstring_content on_embexpr_beg queue on_embexpr_end # Attempts to grab a job off one of the provided queues. Returns # nil if no job can be found.
def UNK on_nl UNK on_op on_int on_nl begin on_ignored_nl data_store on_period UNK on_nl rescue on_const on_op on_const on_nl if on_lparen # Reconnect to Redis to avoid sharing a connection with the parent, # retry up to 3 times with increasing delay before giving up.
def UNK on_nl on_gvar on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_nl UNK on_nl UNK on_nl UNK on_nl run_hook on_symbeg # Runs all the methods needed when a worker begins its lifecycle.
on_gvar on_period UNK on_op true on_nl end on_nl on_ignored_nl def UNK on_nl if on_const on_period UNK on_lparen on_symbeg UNK on_rparen # Fix buffering so we can `rake resque:work > resque.log` and # get output from the child in there.
def UNK on_nl if on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_nl on_const on_period UNK on_op true on_nl end on_nl # Enables GC Optimizations if you're running REE. # http://www.rubyenterpriseedition.com/faq.html#adapt_apps_for_cow
def UNK on_nl trap on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace UNK on_op UNK on_op UNK on_rbrace on_nl trap on_lparen on_tstring_beg # Registers the various signal handlers a worker responds to. # # TERM: Shutdown immediately, stop processing jobs. # INT: Shutdown immediately, stop processing jobs. # QUIT: Shutdown after the current job has finished processing. # USR1: Kill the forked child immediately, continue processing jobs. # USR2: Don't process any new jobs # CONT: Start processing jobs again after a USR2
end on_nl on_ignored_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl trap on_lparen on_tstring_beg on_tstring_content # Ignore subsequent term signals
def UNK on_nl log_with_severity on_symbeg info on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_op true on_nl end on_nl on_ignored_nl def UNK # Schedule this worker for shutdown. Will finish processing the # current job.
def UNK on_nl UNK on_nl if UNK on_nl if UNK on_nl UNK on_nl else on_ignored_nl trap on_lparen on_tstring_beg on_tstring_content on_tstring_end # Kill the child and shutdown immediately. # If not forking, abort this process.
trap on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_ignored_nl end on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Raise TermException in the same process
end on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl else on_ignored_nl UNK on_nl end on_nl # ignore subsequent terms
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl if on_ivar on_nl log_with_severity on_symbeg debug on_comma on_tstring_beg on_tstring_content # Should this worker shutdown as soon as current job is finished?
def UNK on_nl if on_ivar on_nl log_with_severity on_symbeg debug on_comma on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_end on_nl if UNK on_tstring_content # Kills the forked child immediately, without remorse. The job it # is processing will not be completed.
def self on_period UNK on_nl UNK on_op on_const on_period UNK on_nl UNK on_op on_const on_period UNK on_nl UNK on_op data_store # Returns a list of workers that have sent a heartbeat in the past, but which # already expired (does NOT include workers that have never sent a heartbeat at all).
def UNK on_nl if on_ivar on_nl unless UNK on_nl if pre_shutdown_timeout on_op pre_shutdown_timeout on_op UNK on_nl log_with_severity on_symbeg debug on_comma # Kills the forked child immediately with minimal remorse. The job it # is processing will not be completed. Send the child a TERM signal, # wait <term_timeout> seconds, and then a KILL signal if it has not quit # If pre_shutdown_timeout has been set to a positive number, it will allow # the child that many seconds before sending the aforementioned TERM and KILL.
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl log_with_severity on_symbeg info on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl run_hook # are we paused?
def UNK on_nl log_with_severity on_symbeg info on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl run_hook on_symbeg UNK on_comma self on_nl on_ivar on_op true # Stop processing jobs after the current one has completed (if we're # currently running one).
def UNK on_nl log_with_severity on_symbeg info on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_op false on_nl run_hook on_symbeg UNK on_comma self # Start processing jobs again after a pause
def UNK on_nl return unless data_store on_period UNK on_lparen self on_comma on_const on_period UNK on_rparen on_nl on_ignored_nl UNK on_op on_const # Looks for any workers which should be running on this server # and, if they're not, removes them from Redis. # # This is a form of garbage collection. If a server is killed by a # hard shutdown, power failure, or something else beyond our # control, the Resque workers will not die gracefully and therefore # will leave stale state information in Redis. # # By checking the current Redis state against the actual # environment, we can determine if Redis is old and clean it up a bit.
if UNK on_period UNK on_lparen worker on_rparen on_nl log_with_severity on_symbeg info on_comma on_tstring_beg on_tstring_content on_embexpr_beg worker on_embexpr_end on_tstring_end on_nl on_ignored_nl # If the worker hasn't sent a heartbeat, remove it from the registry. # # If the worker hasn't ever sent a heartbeat, we won't remove it since # the first heartbeat is sent before the worker is registred it means # that this is a worker that doesn't support heartbeats, e.g., another # client library or an older version of Resque. We won't touch these.
UNK on_nl end on_nl on_ignored_nl UNK unless UNK on_op UNK on_nl UNK if UNK on_period UNK on_lparen pid on_rparen on_nl # If the worker we are trying to prune does not belong to the queues # we are listening to, we should not touch it. # Attempt to prune a worker from different queues may easily result in # an unknown class exception, since that worker could easily be even # written in different language.
def UNK on_nl data_store on_period UNK on_lparen self on_rparen on_nl end on_nl on_ignored_nl def run_hook on_lparen name on_comma on_op UNK # Registers ourself as a worker. Useful when entering the worker # lifecycle on startup.
def run_hook on_lparen name on_comma on_op UNK on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen name on_rparen on_nl return if # Runs a named hook, passing along any arguments.
def unregister_worker on_lparen exception on_op nil on_rparen on_ignored_nl if on_lparen UNK on_op UNK on_rparen on_op on_op UNK on_period empty? on_nl # Unregisters ourself as a worker. Useful when shutting down.
if on_lparen UNK on_op UNK on_rparen on_op on_op UNK on_period empty? on_nl job on_op on_const on_period new on_lparen UNK on_lbracket # If we're still processing a job, make sure it gets logged as a # failure.
job on_period worker on_op self on_nl begin on_ignored_nl job on_period UNK on_lparen exception on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content # Ensure the proper worker is attached to this job, even if # it's not the precise instance that died.
def UNK on_lparen job on_rparen on_ignored_nl UNK on_op UNK on_symbeg queue on_op job on_period queue on_comma on_ignored_nl on_symbeg UNK on_op # Given a job, tells Redis we're working on it. Useful for seeing # what workers are doing and when.
def UNK on_nl data_store on_period UNK on_lparen self on_rparen do on_ignored_nl UNK on_nl end on_nl end on_nl on_ignored_nl def UNK # Called when we are done working - clears our `working_on` state # and tells Redis we processed a job.
def UNK on_nl on_const on_lbracket on_tstring_beg on_tstring_content on_embexpr_beg self on_embexpr_end on_tstring_end on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_const # How many jobs has this worker processed? Returns an int.
def UNK on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_embexpr_beg self on_embexpr_end on_tstring_end on_nl end on_nl # Tell Redis we've processed a job.
def UNK on_nl on_const on_lbracket on_tstring_beg on_tstring_content on_embexpr_beg self on_embexpr_end on_tstring_end on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_const # How many failed jobs has this worker seen? Returns an int.
def UNK on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_embexpr_beg self on_embexpr_end on_tstring_end on_nl end on_nl # Tells Redis we've failed a job.
def UNK on_nl data_store on_period UNK on_lparen self on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl data_store on_period UNK on_lparen # What time did this worker start? Returns an instance of `Time`
def UNK on_nl data_store on_period UNK on_lparen self on_rparen on_nl end on_nl on_ignored_nl def job on_lparen UNK on_op true on_rparen # Tell Redis we've started
def job on_lparen UNK on_op true on_rparen on_ignored_nl on_ivar on_op nil if UNK on_nl on_ivar on_op UNK on_lparen data_store on_period # Returns a hash explaining the Job we're currently processing, if any.
def UNK on_nl UNK on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_symbeg UNK on_nl end # Boolean - true if working, false if not
def UNK on_nl UNK on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK on_nl return on_ivar if UNK on_lparen on_ivar # Boolean - true if idle, false if not
def UNK on_nl data_store on_period UNK on_lparen self on_rparen on_op on_symbeg UNK on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def # Returns a symbol representing the current worker state, # which can be either :working or :idle
def on_op on_lparen UNK on_rparen on_ignored_nl to_s on_op UNK on_period to_s on_nl end on_nl on_ignored_nl def inspect on_nl on_tstring_beg on_tstring_content # Is this worker the same as another worker?
def to_s on_nl on_ivar on_op on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg pid on_embexpr_end on_tstring_content on_embexpr_beg on_ivar on_period join on_lparen on_tstring_beg # The string representation is the same as the id for this worker # instance. Can be used with `Worker.find`.
def UNK on_nl on_ivar on_op on_const on_period UNK on_nl end on_nl on_ignored_nl def pid on_nl on_ivar on_op on_const on_period pid # chomp'd hostname of this worker's machine
def pid on_nl on_ivar on_op on_const on_period pid on_nl end on_nl on_ignored_nl def UNK on_nl if on_const on_op UNK on_tstring_content # Returns Integer PID of running worker
def UNK on_nl if on_const on_op UNK on_tstring_content UNK on_nl UNK on_nl UNK on_const on_op UNK on_tstring_content UNK on_nl UNK # Returns an Array of string pids of all the other workers on this # machine. Useful when pruning dead workers on startup.
def UNK on_nl UNK on_op UNK on_tstring_content on_tstring_end on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_const on_period UNK on_rparen on_nl # Returns an Array of string pids of all the other workers on this # machine. Useful when pruning dead workers on startup.
def UNK on_nl UNK on_tstring_content on_tstring_end on_period split on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period map do on_op line on_op on_ignored_nl # Find Resque worker pids on Linux and OS X. #
def UNK on_nl UNK on_tstring_content on_tstring_end on_period split on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period map do on_op line on_op on_ignored_nl # Find Resque worker pids on Solaris. # # Returns an Array of string pids of all the other workers on this # machine. Useful when pruning dead workers on startup.
def UNK on_lparen UNK on_rparen on_ignored_nl on_gvar on_op on_tstring_beg on_embexpr_beg on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_embexpr_end on_tstring_content on_embexpr_beg on_const # Given a string, sets the procline ($0) and logs. # Procline is always in the format of: # RESQUE_PROCLINE_PREFIXresque-VERSION: STRING
UNK on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_embexpr_beg on_const on_period UNK on_period UNK on_embexpr_end on_tstring_end on_nl on_ignored_nl begin on_ignored_nl on_const # Reseeding
