def UNK on_lparen object on_rparen on_ignored_nl if on_const on_period respond_to? on_lparen on_symbeg UNK on_rparen on_op on_const on_period respond_to? on_lparen on_symbeg # Given a Ruby object, returns a string suitable for storage in a # queue.
def decode on_lparen object on_rparen on_ignored_nl return UNK object on_nl on_ignored_nl UNK on_ignored_nl if on_const on_period respond_to? on_lparen on_symbeg UNK # Given a string, returns a Ruby object.
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_lparen on_op on_symbeg UNK # Given a word with dashes, returns a camel cased version of it. # # classify('job-name') # => 'JobName'
def UNK on_lparen camel_cased_word on_rparen on_ignored_nl camel_cased_word on_op camel_cased_word on_period UNK on_nl on_ignored_nl if camel_cased_word on_period UNK on_lparen on_tstring_beg on_tstring_content # Tries to find a constant with the name specified in the argument string: # # constantize("Module") # => Module # constantize("Test::Unit") # => Test::Unit # # The name is assumed to be the one of a top-level constant, no matter # whether it starts with "::" or not. No lexical context is taken into # account: # # C = 'outside' # module M # C = 'inside' # C # => 'inside' # constantize("C") # => 'outside', same as ::C # end # # NameError is raised when the constant is unknown.
def UNK on_lparen server on_rparen on_ignored_nl UNK server on_nl UNK on_const on_nl if server on_op UNK on_tstring_content UNK on_nl redis # Accepts: # 1. A 'hostname:port' String # 2. A 'hostname:port:db' String (to select the Redis db) # 3. A 'hostname:port/namespace' String (to set the Redis namespace) # 4. A Redis URL String 'redis://host:port' # 5. An instance of `Redis`, `Redis::Client`, `Redis::DistRedis`, # or `Redis::Namespace`. # 6. An Hash of a redis connection {:host => 'localhost', :port => 6379, :db => 0}
def redis on_nl return on_ivar if on_ivar on_nl UNK on_period redis on_op on_const on_period respond_to? on_lparen on_symbeg UNK on_rparen on_op # Returns the current Redis connection. If none has been created, will # create a new one.
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_op on_const on_period data_store on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl # Set the data store for the processed and failed statistics. # # By default it uses the same as `Resque.redis`, but different stores can be used. # # A custom store needs to obey the following API to work correctly # # class NullDataStore # # Returns the current value for the given stat. # def stat(stat) # end # # # Increments the stat by the given value. # def increment_stat(stat, by) # end # # # Decrements the stat by the given value. # def decrement_stat(stat, by) # end # # # Clear the values for the given stat. # def clear_stat(stat) # end # end
def UNK on_nl on_const on_op on_const on_period data_store on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl on_const on_op on_int # Returns the data store for the statistics module.
UNK on_symbeg UNK on_nl on_ignored_nl on_const on_op on_int on_nl on_const on_op on_const on_op on_int on_nl on_ignored_nl UNK on_symbeg UNK on_nl # Set or retrieve the current logger object
UNK on_symbeg UNK on_nl def UNK on_nl if UNK on_ivar on_nl on_ivar on_nl else on_ignored_nl on_const on_nl end on_nl end # Defines how often a Resque worker updates the heartbeat key. Must be less # than the prune interval.
UNK on_symbeg UNK on_nl def UNK on_nl if UNK on_ivar on_nl on_ivar on_nl else on_ignored_nl on_const on_nl end on_nl end # Defines how often Resque checks for dead workers.
UNK on_symbeg UNK on_nl def UNK on_nl if UNK on_ivar on_nl on_ivar on_nl else on_ignored_nl on_ivar on_op UNK on_nl end # By default, jobs are pushed to the back of the queue and popped from # the front, resulting in "first in, first out" (FIFO) execution order. # Set to true to push jobs to the front of the queue instead, resulting # in "last in, first out" (LIFO) execution order.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_op hooks on_lparen on_symbeg # The `before_first_fork` hook will be run in the **parent** process # only once, before forking to run the first job. Be careful- any # changes you make will be permanent for the lifespan of the # worker. # # Call with a block to register a hook. # Call with no arguments to return all registered hooks.
def UNK on_lparen block on_rparen on_ignored_nl register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Register a before_first_fork proc.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_op hooks on_lparen on_symbeg # The `before_fork` hook will be run in the **parent** process # before every job, so be careful- any changes you make will be # permanent for the lifespan of the worker. # # Call with a block to register a hook. # Call with no arguments to return all registered hooks.
def UNK on_lparen block on_rparen on_ignored_nl register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Register a before_fork proc.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_op hooks on_lparen on_symbeg # The `after_fork` hook will be run in the child process and is passed # the current job. Any changes you make, therefore, will only live as # long as the job currently being processed. # # Call with a block to register a hook. # Call with no arguments to return all registered hooks.
def UNK on_lparen block on_rparen on_ignored_nl register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Register an after_fork proc.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_op hooks on_lparen on_symbeg # The `before_pause` hook will be run in the parent process before the # worker has paused processing (via #pause_processing or SIGUSR2).
def UNK on_lparen block on_rparen on_ignored_nl register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Register a before_pause proc.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_op hooks on_lparen on_symbeg # The `after_pause` hook will be run in the parent process after the # worker has paused (via SIGCONT).
def UNK on_lparen block on_rparen on_ignored_nl register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Register an after_pause proc.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_op hooks on_lparen on_symbeg # The `queue_empty` hook will be run in the **parent** process when # the worker finds no more jobs in the queue and becomes idle. # # Call with a block to register a hook. # Call with no arguments to return all registered hooks.
def UNK on_lparen block on_rparen on_ignored_nl register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Register a queue_empty proc.
def UNK on_lparen on_op block on_rparen on_ignored_nl block on_op register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_op hooks on_lparen on_symbeg # The `worker_exit` hook will be run in the **parent** process # after the worker has existed (via SIGQUIT, SIGTERM, SIGINT, etc.). # # Call with a block to register a hook. # Call with no arguments to return all registered hooks.
def UNK on_lparen block on_rparen on_ignored_nl register_hook on_lparen on_symbeg UNK on_comma block on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # Register a worker_exit proc.
UNK on_symbeg UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def UNK on_lparen queue on_comma UNK on_rparen on_ignored_nl data_store on_period UNK on_lparen # If 'inline' is true Resque will call #perform method inline # without queuing it into Redis and without any Resque callbacks. # The 'inline' is false Resque jobs will be put in queue regularly.
on_ignored_nl def UNK on_lparen queue on_comma UNK on_rparen on_ignored_nl data_store on_period UNK on_lparen queue on_comma UNK on_lparen UNK on_rparen on_rparen # # queue manipulation #
def UNK on_lparen queue on_comma UNK on_rparen on_ignored_nl data_store on_period UNK on_lparen queue on_comma UNK on_lparen UNK on_rparen on_rparen on_nl # Pushes a job onto a queue. Queue name should be a string and the # item should be any JSON-able Ruby object. # # Resque works generally expect the `item` to be a hash with the following # keys: # # class - The String name of the job to run. # args - An Array of arguments to pass the job. Usually passed # via `class.to_class.perform(*args)`. # # Example # # Resque.push('archive', :class => 'Archive', :args => [ 35, 'tar' ]) # # Returns nothing
def UNK on_lparen queue on_rparen on_ignored_nl decode on_lparen data_store on_period UNK on_lparen queue on_rparen on_rparen on_nl end on_nl on_ignored_nl def # Pops a job off a queue. Queue name should be a string. # # Returns a Ruby object.
def UNK on_lparen queue on_rparen on_ignored_nl data_store on_period UNK on_lparen queue on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen queue # Returns an integer representing the size of a queue. # Queue name should be a string.
def UNK on_lparen queue on_comma UNK on_op on_int on_comma count on_op on_int on_rparen on_ignored_nl results on_op data_store on_period UNK on_lparen # Returns an array of items currently queued. Queue name should be # a string. # # start and count should be integer and can be used for pagination. # start is the item to begin, count is how many items to return. # # To get the 3rd page of a 30 item, paginatied list one would use: # Resque.peek('my_list', 59, 30)
def UNK on_lparen UNK on_comma UNK on_op on_int on_comma count on_op on_int on_rparen on_ignored_nl results on_op data_store on_period UNK on_lparen # Does the dirty work of fetching a range of items from a Redis list # and converting them into Ruby objects.
def UNK on_nl data_store on_period queue_names on_nl end on_nl on_ignored_nl def UNK on_lparen queue on_rparen on_ignored_nl data_store on_period UNK on_lparen # Returns an array of all known Resque queues as strings.
def UNK on_lparen queue on_rparen on_ignored_nl data_store on_period UNK on_lparen queue on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen queue # Given a queue name, completely deletes the queue.
def UNK on_lparen queue on_rparen on_ignored_nl data_store on_period UNK on_lparen queue on_rparen on_nl end on_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK # Used internally to keep track of which queues we've created. # Don't call this directly.
on_ignored_nl def UNK on_lparen klass on_comma on_op args on_rparen on_ignored_nl UNK on_lparen UNK on_lparen klass on_rparen on_comma klass on_comma on_op # # job shortcuts #
def UNK on_lparen klass on_comma on_op args on_rparen on_ignored_nl UNK on_lparen UNK on_lparen klass on_rparen on_comma klass on_comma on_op args # This method can be used to conveniently add a job to a queue. # It assumes the class you're passing it is a real Ruby class (not # a string or reference) which either: # # a) has a @queue ivar set # b) responds to `queue` # # If either of those conditions are met, it will use the value obtained # from performing one of the above operations to determine the queue. # # If no queue can be inferred this method will raise a `Resque::NoQueueError` # # Returns true if the job was queued, nil if the job was rejected by a # before_enqueue hook. # # This method is considered part of the `stable` API.
def UNK on_lparen queue on_comma klass on_comma on_op args on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period # Just like `enqueue` but allows you to specify the queue you want to # use. Runs hooks. # # `queue` should be the String name of the queue you're targeting. # # Returns true if the job was queued, nil if the job was rejected by a # before_enqueue hook. # # This method is considered part of the `stable` API.
UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period UNK do on_op hook on_op on_ignored_nl klass on_period UNK on_lparen hook # Perform before_enqueue hooks. Don't perform enqueue if any hook returns false
def UNK on_lparen klass on_comma on_op args on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period UNK do # This method can be used to conveniently remove a job from a queue. # It assumes the class you're passing it is a real Ruby class (not # a string or reference) which either: # # a) has a @queue ivar set # b) responds to `queue` # # If either of those conditions are met, it will use the value obtained # from performing one of the above operations to determine the queue. # # If no queue can be inferred this method will raise a `Resque::NoQueueError` # # If no args are given, this method will dequeue *all* jobs matching # the provided class. See `Resque::Job.destroy` for more # information. # # Returns the number of jobs destroyed. # # Example: # # # Removes all jobs of class `UpdateNetworkGraph` # Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph) # # # Removes all jobs of class `UpdateNetworkGraph` with matching args. # Resque.dequeue(GitHub::Jobs::UpdateNetworkGraph, 'repo:135325') # # This method is considered part of the `stable` API.
UNK on_op on_const on_period UNK on_lparen klass on_rparen on_period UNK do on_op hook on_op on_ignored_nl klass on_period UNK on_lparen hook # Perform before_dequeue hooks. Don't perform dequeue if any hook returns false
def UNK on_lparen klass on_rparen on_ignored_nl on_lparen klass on_period UNK on_lparen on_symbeg on_ivar on_rparen on_op klass on_period UNK on_lparen on_symbeg # Given a class, try to extrapolate an appropriate queue based on a # class instance variable or `queue` method.
def UNK on_lparen queue on_rparen on_ignored_nl on_const on_period UNK on_lparen queue on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen klass # This method will return a `Resque::Job` object or a non-true value # depending on whether a job can be obtained. You should pass it the # precise name of a queue: case matters. # # This method is considered part of the `stable` API.
def UNK on_lparen klass on_comma queue on_op UNK on_rparen on_ignored_nl queue on_op UNK on_lparen klass on_rparen on_nl on_ignored_nl if on_op # Validates if the given klass could be a valid Resque job # # If no queue can be inferred this method will raise a `Resque::NoQueueError` # # If given klass is nil this method will raise a `Resque::NoClassError`
on_ignored_nl def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_const on_period UNK on_nl end on_nl # # worker shortcuts #
def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl # A shortcut to Worker.all
def UNK on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_op # A shortcut to Worker.working
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen on_nl UNK on_period UNK # A shortcut to unregister_worker # useful for command line tool
on_ignored_nl def UNK on_nl return on_lbrace on_ignored_nl on_symbeg UNK on_op UNK on_period UNK on_lparen on_int on_rparen on_lbrace on_op UNK on_comma # # stats #
def UNK on_nl return on_lbrace on_ignored_nl on_symbeg UNK on_op UNK on_period UNK on_lparen on_int on_rparen on_lbrace on_op UNK on_comma on_lparen # Returns a hash, similar to redis-rb's #info, of interesting stats.
def UNK on_nl data_store on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl queue_names on_op UNK on_nl on_ignored_nl UNK on_op # Returns an array of all known Resque keys in Redis. Redis' KEYS operation # is O(N) for the keyspace, so be careful - this can be slow for big databases.
def UNK on_nl queue_names on_op UNK on_nl on_ignored_nl UNK on_op redis on_period UNK do on_ignored_nl queue_names on_period UNK do on_op # Returns a hash, mapping queue names to queue sizes
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl queue_names on_op UNK on_nl on_ignored_nl UNK on_op redis on_period UNK do on_ignored_nl # Returns a hash, mapping queue names to (up to `sample_size`) samples of jobs in that queue
def register_hook on_lparen name on_comma block on_rparen on_ignored_nl return UNK on_lparen name on_rparen if block on_period UNK on_nl on_ignored_nl block # Register a new proc as a hook. If the block is nil this is the # equivalent of removing all hooks of the given name. # # `name` is the hook that the block should be registered with.
def UNK on_lparen name on_rparen on_ignored_nl on_ivar on_lbracket name on_rbracket on_op on_lbracket on_rbracket on_nl end on_nl on_ignored_nl def hooks on_lparen # Clear all hooks given a hook name.
def hooks on_lparen name on_rparen on_ignored_nl on_ivar on_lbracket name on_rbracket on_nl end on_nl end on_nl on_ignored_nl on_const on_period UNK on_op # Retrieve all hooks of a given name.
on_const on_period UNK on_op on_const on_period new on_lparen on_const on_rparen on_nl on_const on_period UNK on_period UNK on_op on_const on_op on_const # Log to STDOUT by default
