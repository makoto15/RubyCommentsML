on_ignored_nl on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content # coding: utf-8
on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # rubocop:disable Metrics/ClassLength
def UNK on_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_ignored_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # `DANGER_GITHUB_API_HOST` is the old name kept for legacy reasons and # backwards compatibility. `DANGER_GITHUB_API_BASE_URL` is the new # correctly named variable.
UNK on_op self on_period pr_json on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_op self on_period # we can use a github specific feature here:
UNK on_period UNK UNK on_comma UNK on_nl self on_period UNK on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_embexpr_end on_tstring_content # Next, we want to ensure that we have a version of the current branch at a known location
UNK on_period UNK UNK on_comma UNK on_nl self on_period UNK on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_embexpr_end on_tstring_content # OK, so we want to ensure that we have a known head branch, this will always represent # the head of the PR ( e.g. the most recent commit that will be merged. )
def UNK on_lparen on_label on_lbracket on_rbracket on_comma on_label on_lbracket on_rbracket on_comma on_label on_lbracket on_rbracket on_comma on_label on_lbracket on_rbracket on_comma on_label # Sending data to GitHub
UNK on_lparen on_label danger_id on_rparen on_nl end on_nl on_ignored_nl if UNK on_period UNK on_nl body on_op UNK on_lparen on_lbrace on_ignored_nl # Just remove the comment, if there's nothing to say or --remove-previous-comments CLI was set.
if UNK on_period UNK on_nl body on_op UNK on_lparen on_lbrace on_ignored_nl on_label on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_label danger_id on_comma # If there are still violations to show
UNK on_lparen on_ignored_nl on_label warnings on_comma on_ignored_nl on_label errors on_comma on_ignored_nl on_label UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_comma on_ignored_nl # Now, set the pull request status. # Note: this can terminate the entire process.
if errors on_period UNK on_op on_int on_nl UNK on_op pr_json on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket # This usually means the user has no commit access to this repo # That's always the case for open source projects where you can only # use a read-only GitHub account
UNK on_op pr_json on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl if # We need to fail the actual build here
def UNK on_lparen on_label nil on_comma on_label on_tstring_beg on_tstring_content on_tstring_end on_rparen on_ignored_nl UNK on_period UNK do on_op comment on_op on_ignored_nl # Get rid of the previously posted comment, to only have the latest one
UNK on_lbrace on_rbrace if on_lparen warnings on_op errors on_op messages on_op markdowns on_rparen on_period select on_lparen on_op on_symbeg inline? on_rparen # Avoid doing any fetchs if there's no inline comments
danger_comments on_period UNK do on_op comment on_op on_ignored_nl violation on_op UNK on_lparen comment on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_rparen on_period # submit removes from the array all comments that are still in force # so we strike out all remaining ones
UNK on_op UNK on_period select do on_op UNK on_op on_ignored_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op comment on_lbracket on_tstring_beg # We remove non-sticky violations that have no replies # Since there's no direct concept of a reply in GH, we simply consider # the existence of non-danger comments in that line as replies
next UNK on_lparen kind on_rparen if position on_period nil? on_nl on_ignored_nl if UNK on_nl body on_op UNK on_lparen m on_comma # Keep the change if it's line is not in the diff and not in dismiss mode
if UNK on_nl body on_op UNK on_lparen m on_comma on_label danger_id on_comma on_label on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl else on_ignored_nl # Once we know we're gonna submit it, we format it
m on_op UNK on_lparen m on_comma true on_rparen on_nl body on_op UNK on_lparen UNK on_comma m on_comma on_label danger_id on_comma # Hide the inline link behind a span
previous_violations on_period UNK on_lbrace on_op UNK on_op UNK on_lparen UNK on_comma m on_rparen on_rbrace on_nl end on_nl on_ignored_nl UNK on_op # A comment might be in previous_violations because only now it's part of the unified diff # We remove from the array since it won't have a place in the table anymore
violation on_op UNK on_lparen UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_rparen on_period UNK on_nl if violation on_nl UNK on_lparen violation # Parse it to avoid problems with strikethrough
message on_op on_lbracket UNK on_comma on_tstring_beg on_tstring_content on_embexpr_beg body on_embexpr_end on_tstring_end on_comma on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end on_comma on_tstring_beg # Show more detail for UnprocessableEntity error
next false on_nl end on_nl else on_ignored_nl danger_comments on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK UNK on_rbrace on_nl # Not reject because this comment has not completed
danger_comments on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK UNK on_rbrace on_nl on_ignored_nl comment on_op UNK on_period UNK on_nl # Remove the surviving comment so we don't strike it out
comment on_op UNK on_period UNK on_nl client on_period UNK on_lparen ci_source on_period repo_slug on_comma comment on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket # Update the comment to remove the strikethrough if present
next true on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen diff_lines on_comma message on_comma kind on_rparen on_ignored_nl UNK on_op # Remove this element from the array
if UNK on_period nil? on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_op message on_period file on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK # Files containing spaces sometimes have a trailing tab
if line on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl position on_op on_int on_nl next on_nl end on_nl UNK if # If the line has `No newline` annotation, position need increment
UNK if line on_period match UNK on_nl on_ignored_nl match on_op line on_period match UNK on_nl on_ignored_nl if on_op file_line on_period # If we found the start of another file diff, we went too far
if on_op file_line on_period nil? on_op on_op line on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if file_line on_op message # file_line is set once we find the hunk the line is in # we need to count how many lines in new file we have # so we do it one by one ignoring the deleted lines
position on_op on_int on_nl on_ignored_nl next unless match on_nl on_ignored_nl range_start on_op match on_lbracket on_symbeg UNK on_rbracket on_period to_i on_nl # We need to count how many diff lines are between us and # the line we're looking for
UNK if message on_period line on_period to_i on_op range_start on_nl next unless message on_period line on_period to_i on_op range_start on_op # We are past the line position, just abort
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_regexp_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg ci_source on_period repo_slug on_embexpr_end on_tstring_content # See the tests for examples of data coming in looks like
def UNK on_nl UNK on_op self on_period UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period match on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen # @return [String] The organisation name, is nil if it can't be detected
def UNK on_lparen on_label nil on_comma on_label nil on_comma on_label nil on_comma on_label nil on_rparen on_ignored_nl UNK on_op self on_period # @return [String] A URL to the specific file, ready to be downloaded
UNK on_op client on_period UNK on_lparen on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end on_comma on_label UNK on_comma on_label # Retrieve the download URL (default branch on nil param)
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_op on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg UNK # Fallback to github.com
on_lbrace on_ignored_nl on_label warnings on_period select on_lparen on_op on_symbeg inline? on_rparen on_period UNK on_lparen on_op UNK on_rparen on_comma on_ignored_nl on_label # Sort to group inline comments by file
