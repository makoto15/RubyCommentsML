UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl # coding: utf-8
UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_ivar on_op on_const on_period client on_lparen on_label UNK on_comma on_label UNK on_rparen on_nl UNK # The require happens inline so that it won't cause exceptions when just using the `danger` gem.
on_ivar on_op begin on_ignored_nl if UNK on_nl on_ivar on_op UNK on_ignored_nl on_period UNK on_ignored_nl on_period UNK on_lbrace on_op discussion on_op # @raw_comments contains what we got back from the server. # @comments contains Comment objects (that have less information)
UNK on_op self on_period mr_json on_period UNK on_nl UNK on_op self on_period mr_json on_period diff_refs on_period UNK on_nl UNK on_op # we can use a GitLab specific feature here:
UNK on_period UNK UNK on_comma UNK on_nl self on_period UNK on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_embexpr_end on_tstring_content # Next, we want to ensure that we have a version of the current branch at a known location
UNK on_period UNK UNK on_comma UNK on_nl self on_period UNK on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_embexpr_end on_tstring_content # OK, so we want to ensure that we have a known head branch, this will always represent # the head of the PR ( e.g. the most recent commit that will be merged. )
if on_const on_period UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK on_op on_const on_nl false on_nl else on_ignored_nl UNK on_op # If we can't check GitLab's version, we assume we don't support inline comments
UNK on_lparen on_label danger_id on_rparen on_nl end on_nl on_ignored_nl if UNK on_period UNK on_nl body on_op UNK on_lparen on_lbrace on_ignored_nl # Just remove the comment, if there's nothing to say or --remove-previous-comments CLI was set.
if UNK on_period UNK on_nl body on_op UNK on_lparen on_lbrace on_ignored_nl on_label on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_label danger_id on_comma # If there are still violations to show
UNK on_lparen on_label danger_id on_rparen on_nl else on_ignored_nl body on_op UNK on_lparen on_label warnings on_comma on_ignored_nl on_label errors on_comma on_ignored_nl # Just remove the comment, if there's nothing to say or --remove-previous-comments CLI was set.
def UNK on_nl nil end on_nl on_ignored_nl def UNK on_lparen on_label nil on_comma on_label nil on_comma on_label nil on_comma on_label # @return [String] The organisation name, is nil if it can't be detected
end on_nl on_ignored_nl def UNK on_lparen on_label nil on_comma on_label nil on_comma on_label nil on_comma on_label nil on_rparen on_ignored_nl UNK # TODO: Implement this
def UNK on_lparen on_label nil on_comma on_label nil on_comma on_label nil on_comma on_label nil on_rparen on_ignored_nl UNK on_op on_tstring_beg on_tstring_content # @return [String] A URL to the specific file, ready to be downloaded
UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_tstring_beg on_embexpr_beg # According to GitLab Repositories API docs path and id(slug) should be encoded.
on_lbrace on_ignored_nl on_label warnings on_period select on_lparen on_op on_symbeg inline? on_rparen on_period UNK on_lparen on_op UNK on_rparen on_comma on_ignored_nl on_label # Sort to group inline comments by file
danger_comments on_period UNK do on_op comment on_op on_ignored_nl UNK on_op UNK on_lparen comment on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_rparen on_period # submit removes from the array all comments that are still in force # so we strike out all remaining ones
UNK on_op UNK on_period select do on_op UNK on_op on_ignored_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op comment on_lbracket on_tstring_beg # We remove non-sticky violations that have no replies # Since there's no direct concept of a reply in GH, we simply consider # the existence of non-danger comments in that line as replies
next if on_op UNK on_period UNK on_lparen m on_period file on_rparen on_nl on_ignored_nl if UNK on_nl body on_op UNK on_lparen # Keep the change it's in a file changed in this diff
if UNK on_nl body on_op UNK on_lparen m on_comma on_label danger_id on_comma on_label on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl else on_ignored_nl # Once we know we're gonna submit it, we format it
m on_op UNK on_lparen m on_comma UNK on_rparen on_nl body on_op UNK on_lparen UNK on_comma m on_comma on_label danger_id on_comma # Hide the inline link behind a span
previous_violations on_period UNK on_lbrace on_op UNK on_op UNK on_lparen UNK on_comma m on_rparen on_rbrace on_nl end on_nl on_ignored_nl UNK on_op # A comment might be in previous_violations because only now it's part of the unified diff # We remove from the array since it won't have a place in the table anymore
danger_comments on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK UNK on_rbrace on_nl on_ignored_nl comment on_op UNK on_period UNK on_nl # Remove the surviving comment so we don't strike it out
comment on_op UNK on_period UNK on_nl begin on_ignored_nl client on_period UNK on_lparen ci_source on_period repo_slug on_comma ci_source on_period pull_request_id on_comma # Update the comment to remove the strikethrough if present
next UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma message on_rparen on_ignored_nl UNK on_op UNK on_tstring_content # Remove this element from the array
UNK nil if change on_period nil? on_op change on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period empty? on_op change on_lbracket on_tstring_beg on_tstring_content # If there is no changes or rename only or deleted, return nil.
UNK UNK if change on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ignored_nl UNK on_op on_int on_nl current_new_line on_op on_int on_nl on_ignored_nl # If the file is new one, old line number must be nil.
UNK if message on_period line on_period to_i on_op match on_lbracket on_symbeg new on_rbracket on_period to_i on_nl on_ignored_nl UNK on_op match # If the message line is at before next diffs, break from loop.
UNK on_op match on_lbracket on_symbeg UNK on_rbracket on_period to_i on_op on_int on_nl current_new_line on_op match on_lbracket on_symbeg new on_rbracket on_period # The match [:old] line does not appear yet at the header position, so reduce line number.
UNK UNK if current_new_line on_op message on_period line on_period to_i on_nl UNK on_op line on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # If the message line starts with '+', old line number must be nil.
UNK if current_new_line on_op message on_period line on_period to_i on_nl end on_nl end on_nl on_ignored_nl on_lbrace on_ignored_nl on_label change on_lbracket # If the message line doesn't start with '+', old line number must be specified.
