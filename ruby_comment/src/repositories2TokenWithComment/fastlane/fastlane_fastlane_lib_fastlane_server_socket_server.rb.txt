def UNK on_nl UNK on_nl on_ignored_nl UNK on_ivar on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_nl # this is the public API, don't call anything else
UNK on_op on_const on_lbracket on_symbeg ready on_rbracket on_nl on_ignored_nl UNK on_op nil on_nl UNK on_ignored_nl UNK on_op on_ivar on_period UNK # no idea how many commands are coming, so we loop until an error or the done command is sent
UNK on_const on_op on_const on_op e on_nl on_const on_period verbose on_lparen e on_rparen on_nl UNK on_op on_const on_lbracket on_symbeg error # 1024 * 1024
UNK on_op UNK on_lparen on_label UNK on_rparen on_nl end on_nl on_ignored_nl UNK UNK on_nl UNK on_const on_lbracket on_symbeg ready on_rbracket # Ok, all is good, let's see what command we have
UNK on_nl UNK on_const on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_nl UNK on_const on_lbracket on_symbeg error on_rbracket on_nl UNK on_lparen # command executed successfully, let's setup for the next command
UNK on_nl UNK on_const on_lbracket on_symbeg error on_rbracket on_nl UNK on_lparen on_label UNK on_comma on_label on_symbeg error on_rparen on_nl UNK # we shutdown in response to a command, nothing left to do but exit
UNK on_lparen on_label UNK on_comma on_label on_symbeg error on_rparen on_nl UNK on_nl end on_nl end on_nl end on_nl on_ignored_nl def # we got an error somewhere, let's shutdown and exit
UNK on_tstring_beg on_tstring_content on_embexpr_beg command on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_lparen command on_rparen on_ignored_nl exit_reason on_op # catch all
def UNK on_lparen command on_rparen on_ignored_nl exit_reason on_op nil on_nl if command on_period UNK on_nl on_const on_period verbose on_lparen on_tstring_beg # we got a server control command from the client to do something like shutdown
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_lparen UNK on_rparen on_nl on_ignored_nl exit_reason on_op on_symbeg UNK on_nl UNK command on_period # send an ack to the client to let it know we're shutting down
exit_reason on_op on_symbeg UNK on_nl end on_nl on_ignored_nl if command on_period UNK on_nl on_const on_period UNK on_lparen command on_period UNK # client is already in the process of shutting down, no need to ack
if command on_period UNK on_nl on_const on_period UNK on_lparen command on_period UNK on_rparen on_nl end on_nl on_ignored_nl UNK on_lparen on_label # if the command came in with a user-facing message, display it
UNK on_lparen on_label UNK on_comma on_label exit_reason on_rparen on_nl return on_const on_lbracket on_symbeg UNK on_rbracket on_nl end on_nl on_ignored_nl def # currently all control commands should trigger a disconnect and shutdown
def UNK on_lparen command on_rparen on_ignored_nl UNK on_op UNK on_lparen on_label command on_rparen on_nl return UNK on_lparen UNK on_rparen on_nl # execute and send back response to client
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period verbose on_lparen on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end on_rparen on_nl UNK on_ignored_nl # send json back to client
UNK on_const on_op on_const on_op e on_nl on_const on_period verbose on_lparen e on_rparen on_nl return on_const on_lbracket on_symbeg error on_rbracket # Send some json to the client
on_const on_period verbose on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl on_const on_period UNK on_lbracket on_symbeg ready # Socket to listen on port 2000
on_const on_period UNK on_lbracket on_symbeg ready on_rbracket on_op UNK on_nl on_ivar on_op nil on_nl UNK on_ignored_nl on_const on_period UNK on_lparen # set thread local to ready so we can check it
end on_nl UNK on_const on_op on_const on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl # Wait for a client to connect
UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_label UNK on_comma on_label on_symbeg error on_rparen on_ignored_nl on_const on_period UNK on_lbracket # this loops forever
on_ivar on_period UNK on_nl on_ivar on_op nil on_nl on_ignored_nl on_ivar on_period UNK on_nl on_ivar on_op nil on_nl end on_nl on_ignored_nl # clean up
def UNK on_lparen on_label nil on_rparen on_ignored_nl on_const on_period verbose on_lparen on_tstring_beg on_tstring_content on_embexpr_beg command on_period UNK on_embexpr_end on_tstring_end on_rparen # record fastlane action command and then execute it
def UNK on_lparen on_label nil on_rparen on_ignored_nl UNK on_op on_ivar on_period UNK on_lparen on_label command on_comma on_label nil on_rparen on_nl # execute fastlane action command
UNK on_op UNK on_period UNK on_nl UNK on_op UNK on_period UNK on_nl closure_arg on_op UNK on_period UNK on_nl on_ignored_nl UNK ## probably need to just return Strings, or ready_for_next with object isn't String
on_rparen on_nl end on_nl on_ignored_nl on_const on_period UNK on_lbracket on_symbeg UNK on_rbracket on_op nil on_nl on_ignored_nl UNK on_op UNK on_ignored_nl # always assume string for closure error_callback
