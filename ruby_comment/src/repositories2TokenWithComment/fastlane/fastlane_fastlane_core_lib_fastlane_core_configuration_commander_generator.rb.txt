UNK UNK on_lparen UNK on_comma UNK UNK on_rparen on_ignored_nl UNK on_nl on_ignored_nl UNK on_op UNK UNK on_nl UNK on_period UNK # Calls the appropriate methods for commander to show the available parameters
UNK on_nl on_ignored_nl UNK on_op UNK UNK on_nl UNK on_period UNK UNK on_op option on_op on_ignored_nl UNK if option on_period # First, enable `always_trace`, to show the stack trace
UNK UNK option on_period UNK on_nl on_ignored_nl short_switch on_op option on_period UNK on_nl key on_op option on_period key on_nl UNK # "private" options
if type on_op on_const on_nl type on_op option on_period UNK on_op on_const on_op UNK on_nl end on_nl on_ignored_nl if type # We added type: Hash to code generation, but Ruby's OptionParser doesn't like that # so we need to switch that to something that is supported, luckily, we have an `is_string` # property and if that is false, we'll default to nil
if type on_op on_const on_op on_const on_nl type on_op UNK on_nl end on_nl on_ignored_nl UNK on_op on_lparen type on_op on_tstring_beg # Boolean is a fastlane thing, it's either TrueClass, or FalseClass, but we won't know # that until runtime, so nil is the best we get
UNK on_op on_lparen type on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_period UNK on_nl UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg option # This is an important bit of trickery to solve the boolean option situation. # # Typically, boolean command line flags do not accept trailing values. If the flag # is present, the value is true, if it is missing, the value is false. fastlane # supports this style of flag. For example, you can specify a flag like `--clean`, # and the :clean option will be true. # # However, fastlane also supports another boolean flag style that accepts trailing # values much like options for Strings and other value types. That looks like # `--include_bitcode false` The problem is that this does not work out of the box # for Commander and OptionsParser. So, we need to get tricky. # # The value_appendix below acts as a placeholder in the switch definition that # states that we expect to have a trailing value for our options. When an option # declares a data type, we use the name of that data type in all caps like: # "--devices ARRAY". When the data type is nil, this implies that we're going # to be doing some special handling on that value. One special thing we do # automatically in Configuration is to coerce special Strings into boolean values. # # If the data type is nil, the trick we do is to specify a value placeholder, but # we wrap it in [] brackets to mark it as optional. That means that the trailing # value may or may not be present for this flag. If the flag is present, but the # value is not, we get a value of `true`. Perfect for the boolean flag base-case! # If the value is there, we'll actually get it back as a String, which we can # later coerce into a boolean. # # In this way we support handling boolean flags with or without trailing values.
UNK on_op UNK short_switch on_comma UNK on_comma on_lparen type on_op on_const on_rparen on_comma UNK UNK on_period UNK on_nl on_ignored_nl if # We compact this array here to remove the short_switch variable if it is nil. # Passing a nil value to global_option has been shown to create problems with # option parsing! # # See: https://github.com/fastlane/fastlane_core/pull/89 # # If we don't have a data type for this option, we tell it to act like a String. # This allows us to get a reasonable value for boolean options that can be # automatically coerced or otherwise handled by the ConfigItem for others.
UNK on_lparen on_op UNK on_rparen on_nl end on_nl end on_nl end on_nl on_ignored_nl UNK UNK on_lparen UNK on_comma short_switch on_comma # This is the call to Commander to set up the option we've been building.
