require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl # HTTP Client
class on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_embexpr_beg on_const on_op on_const on_embexpr_end on_tstring_end on_nl # rubocop:disable Metrics/ClassLength
attr_accessor on_symbeg user on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg logger on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl # The user that is currently logged in
attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg logger on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl # The email of the user that is currently logged in
attr_accessor on_symbeg logger on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl on_const on_op on_const on_op on_const # The logger in which all requests are logged # /tmp/spaceship[time]_[pid].log by default
on_const on_op on_const on_op on_const on_nl on_const on_op on_const on_op on_const on_nl on_const on_op on_const on_op on_const on_nl on_const on_op # legacy support
on_ignored_nl def teams on_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK do on_op team on_op on_ignored_nl on_lbracket on_ignored_nl team ##################################################### # @!group Teams + User #####################################################
def teams on_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK do on_op team on_op on_ignored_nl on_lbracket on_ignored_nl team on_lbracket # @return (Array) A list of all available teams
def UNK on_nl return on_ivar if on_ivar on_nl UNK on_op request on_lparen on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Fetch the general information of the user, is used by various methods across spaceship # Sample return value # => {"associatedAccounts"=> # [{"contentProvider"=>{"contentProviderId"=>11142800, "name"=>"Felix Krause", "contentProviderTypes"=>["Purple Software"]}, "roles"=>["Developer"], "lastLogin"=>1468784113000}], # "sessionToken"=>{"dsId"=>"8501011116", "contentProviderId"=>18111111, "expirationDate"=>nil, "ipAddress"=>nil}, # "permittedActivities"=> # {"EDIT"=> # ["UserManagementSelf", # "GameCenterTestData", # "AppAddonCreation"], # "REPORT"=> # ["UserManagementSelf", # "AppAddonCreation"], # "VIEW"=> # ["TestFlightAppExternalTesterManagement", # ... # "HelpGeneral", # "HelpApplicationLoader"]}, # "preferredCurrencyCode"=>"EUR", # "preferredCountryCode"=>nil, # "countryOfOrigin"=>"AT", # "isLocaleNameReversed"=>false, # "feldsparToken"=>nil, # "feldsparChannelName"=>nil, # "hasPendingFeldsparBindingRequest"=>false, # "isLegalUser"=>false, # "userId"=>"1771111155", # "firstname"=>"Detlef", # "lastname"=>"Mueller", # "isEmailInvalid"=>false, # "hasContractInfo"=>false, # "canEditITCUsersAndRoles"=>false, # "canViewITCUsersAndRoles"=>true, # "canEditIAPUsersAndRoles"=>false, # "transporterEnabled"=>false, # "contentProviderFeatures"=>["APP_SILOING", "PROMO_CODE_REDESIGN", ...], # "contentProviderType"=>"Purple Software", # "displayName"=>"Detlef", # "contentProviderId"=>"18742800", # "userFeatures"=>[], # "visibility"=>true, # "DYCVisibility"=>false, # "contentProvider"=>"Felix Krause", # "userName"=>"detlef@krausefx.com"}
def team_id on_nl return on_ivar if on_ivar on_nl on_ignored_nl if teams on_period UNK on_op on_int on_nl puts on_lparen on_tstring_beg on_tstring_content # @return (String) The currently selected Team ID
def UNK on_lparen team_id on_rparen on_ignored_nl UNK on_op teams on_period UNK do on_op team on_op on_ignored_nl on_lbrace on_ignored_nl on_label on_lparen # Set a new team ID which will be used from now on
UNK on_op teams on_period UNK do on_op team on_op on_ignored_nl on_lbrace on_ignored_nl on_label on_lparen team on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket # First, we verify the team actually exists, because otherwise iTC would return the # following confusing error message # # invalid content provider id #
on_rbrace on_period UNK on_nl req on_period headers on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl # https://github.com/fastlane/fastlane/issues/6711
def UNK on_nl teams on_period UNK do on_op UNK on_op on_ignored_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op team_id on_nl # @return (Hash) Fetches all information of the currently used team
def UNK on_nl on_lparen UNK on_op on_lbrace on_rbrace on_rparen on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl end on_nl on_ignored_nl on_ignored_nl def # @return (String) Fetches name from currently used team
on_ignored_nl def self on_period UNK on_lparen UNK on_rparen on_ignored_nl self on_period new on_lparen on_label UNK on_period UNK on_lparen on_symbeg on_ivar ##################################################### # @!group Client Init #####################################################
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl self on_period new on_lparen on_label UNK on_period UNK on_lparen on_symbeg on_ivar on_rparen # Instantiates a client but with a cookie derived from another client. # # HACK: since the `@cookie` is not exposed, we use this hacky way of sharing the instance.
c on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl c on_period UNK on_lbracket on_symbeg UNK on_rbracket on_op on_const on_op on_const on_op # for debugging only # This enables tracking of networking requests using Charles Web Proxy
on_ignored_nl def logger on_nl unless on_ivar on_nl if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ivar on_op on_const on_period new ##################################################### # @!group Request Logger #####################################################
def logger on_nl unless on_ivar on_nl if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ivar on_op on_const on_period new on_lparen # The logger in which all requests are logged # /tmp/spaceship[time]_[pid]_["threadid"].log by default
path on_op on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_period UNK on_embexpr_end on_tstring_content on_embexpr_beg on_const on_period UNK on_embexpr_end on_tstring_content on_embexpr_beg on_const # Log to file by default
on_ignored_nl def UNK on_nl on_ivar on_period UNK on_lparen on_op on_symbeg to_s on_rparen on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl ##################################################### # @!group Session Cookie #####################################################
def UNK on_nl on_ivar on_period UNK on_lparen on_op on_symbeg to_s on_rparen on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end ## # Return the session cookie. # # @return (String) the cookie-string in the RFC6265 format: https://tools.ietf.org/html/rfc6265#section-4.2.1
on_ivar on_period UNK on_lparen path on_comma on_symbeg UNK on_comma on_label true on_rparen on_nl return on_const on_period UNK on_lparen path on_rparen # really important to specify the session to true # otherwise myacinfo and more won't be stored
def UNK on_nl path on_op on_const on_period expand_path on_lparen on_const on_period join on_lparen on_const on_period UNK on_comma on_tstring_beg on_tstring_content on_tstring_end # This is a duplicate method of fastlane_core/fastlane_core.rb#fastlane_user_dir
def UNK on_nl if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl path on_op on_const on_period expand_path on_lparen on_const on_period join # Returns preferred path for storing cookie # for two step verification.
on_ignored_nl def UNK on_nl on_ivar on_op on_int on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_int on_nl UNK on_op ##################################################### # @!group Automatic Paging #####################################################
def UNK on_nl on_ivar on_op on_int on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_int on_nl UNK on_op on_lbracket # The page size we want to request, defaults to 500
def UNK on_nl UNK on_op on_int on_nl UNK on_op on_lbracket on_rbracket on_nl UNK do on_ignored_nl UNK on_op on_int on_nl UNK # Handles the paging for you... for free # Just pass a block and use the parameter as page number
end on_nl on_ignored_nl return UNK on_nl end on_nl on_ignored_nl on_ignored_nl def self on_period UNK on_lparen user on_op nil on_comma password # no more results
on_ignored_nl def self on_period UNK on_lparen user on_op nil on_comma password on_op nil on_rparen on_ignored_nl UNK on_op self on_period new ##################################################### # @!group Login and Team Selection #####################################################
def self on_period UNK on_lparen user on_op nil on_comma password on_op nil on_rparen on_ignored_nl UNK on_op self on_period new on_nl # Authenticates with Apple's web services. This method has to be called once # to generate a valid session. The session will automatically be used from then # on. # # This method will automatically use the username from the Appfile (if available) # and fetch the password from the Keychain (if available) # # @param user (String) (optional): The username (usually the email address) # @param password (String) (optional): The password # # @raise InvalidUserCredentialsError: raised if authentication failed # # @return (Spaceship::Client) The client the login method was called for
def UNK on_lparen user on_op nil on_comma password on_op nil on_rparen on_ignored_nl if user on_period to_s on_period UNK on_op password # Authenticates with Apple's web services. This method has to be called once # to generate a valid session. The session will automatically be used from then # on. # # This method will automatically use the username from the Appfile (if available) # and fetch the password from the Keychain (if available) # # @param user (String) (optional): The username (usually the email address) # @param password (String) (optional): The password # # @raise InvalidUserCredentialsError: raised if authentication failed # # @return (Spaceship::Client) The client the login method was called for
rescue on_const on_op ex on_nl raise ex unless UNK on_nl on_ignored_nl if UNK on_period UNK on_nl UNK on_lparen user on_rparen # calls `send_login_request` in sub class (which then will redirect back here to `send_shared_login_request`, below)
def UNK on_lparen user on_comma password on_rparen on_ignored_nl if UNK on_nl begin on_ignored_nl return true if UNK on_nl rescue on_nl # This method is used for both the Apple Dev Portal and App Store Connect # This will also handle 2 step verification and 2 factor authentication # # It is called in `send_login_request` of sub classes (which the method `login`, above, transferred over to via `do_login`)
if UNK on_nl begin on_ignored_nl return true if UNK on_nl rescue on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end # Check if we have a cached/valid session # # Background: # December 4th 2017 Apple introduced a rate limit - which is of course fine by itself - # but unfortunately also rate limits successful logins. If you call multiple tools in a # lane (e.g. call match 5 times), this would lock you out of the account for a while. # By loading existing sessions and checking if they're valid, we're sending less login requests. # More context on why this change was necessary https://github.com/fastlane/fastlane/pull/11108 # # If there was a successful manual login before, we have a session on disk
begin on_ignored_nl return true if UNK on_nl rescue on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl # Check if the session is still valid here
return true if UNK on_nl rescue on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl if UNK # We use the olympus session to determine if the old session is still valid # As this will raise an exception if the old session has expired # If the old session is still valid, we don't have to do anything else in this method # that's why we return true
puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl if UNK on_nl begin on_ignored_nl return true if UNK # If the `fetch_olympus_session` method raises an exception # we'll land here, and therefore continue doing a full login process # This happens if the session we loaded from the cache isn't valid any more # which is common, as the session automatically invalidates after x hours (we don't know x) # In this case we don't actually care about the exact exception, and why it was failing # because either way, we'll have to do a fresh login, where we do the actual error handling
if UNK on_nl begin on_ignored_nl return true if UNK on_nl rescue on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end # # The user can pass the session via environment variable (Mainly used in CI environments)
begin on_ignored_nl return true if UNK on_nl rescue on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl # see above
return true if UNK on_nl rescue on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl on_ignored_nl UNK # see above
end on_nl end on_nl on_ignored_nl UNK on_op on_lbrace on_ignored_nl on_label user on_comma on_ignored_nl on_label password on_comma on_ignored_nl on_label true on_nl # see above
on_ignored_nl UNK on_op on_lbrace on_ignored_nl on_label user on_comma on_ignored_nl on_label password on_comma on_ignored_nl on_label true on_nl on_rbrace on_nl on_ignored_nl begin # # After this point, we sure have no valid session any more and have to create a new one #
important_cookie on_op on_ivar on_period UNK on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_period include? on_lparen on_tstring_beg # The below workaround is only needed for 2 step verified machines # Due to escaping of cookie values we have a little workaround here # By default the cookie jar would generate the following header # DES5c148...=HSARM.......xaA/O69Ws/CHfQ==SRVT # However we need the following # DES5c148...="HSARM.......xaA/O69Ws/CHfQ==SRVT" # There is no way to get the cookie jar value with " around the value # so we manually modify the cookie (only this one) to be properly escaped # Afterwards we pass this value manually as a header # It's not enough to just modify @cookie, it needs to be done after self.cookie # as a string operation
UNK on_op on_tstring_beg on_embexpr_beg important_cookie on_period UNK on_embexpr_end on_tstring_content on_embexpr_beg important_cookie on_period UNK on_embexpr_end on_tstring_end on_nl UNK on_op on_tstring_beg on_embexpr_beg # returns a string of all cookies
on_ignored_nl UNK response on_period UNK on_nl UNK on_int on_nl raise on_const on_period new on_comma on_tstring_beg on_tstring_content on_embexpr_beg user on_embexpr_end on_tstring_content # Now we know if the login is successful or if we need to do 2 factor
UNK on_lparen response on_rparen on_nl UNK on_nl return true on_nl else on_ignored_nl if on_lparen response on_period body on_op on_tstring_beg on_tstring_end # 2 step/factor is enabled for this account, first handle that
UNK on_nl return true on_nl else on_ignored_nl if on_lparen response on_period body on_op on_tstring_beg on_tstring_end on_rparen on_period include? on_lparen on_tstring_beg # and then get the olympus session
raise on_const on_period new on_comma on_tstring_beg on_tstring_content on_embexpr_beg user on_embexpr_end on_tstring_content on_tstring_end on_nl elsif response on_period UNK on_op on_int on_op # User Credentials are wrong
raise on_const on_period new on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl elsif on_lparen response on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_end # Need to acknowledge Apple ID and Privacy statement - https://github.com/fastlane/fastlane/issues/12577 # Looking for status of 412 might be enough but might be safer to keep looking only at what is being reported
def UNK on_nl response on_op request on_lparen on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl body on_op response on_period body # Get the `itctx` from the new (22nd May 2017) API endpoint "olympus" # Update (29th March 2019) olympus migrates to new appstoreconnect API
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl return on_const on_period UNK on_lparen UNK on_rparen if on_const on_period UNK on_lparen UNK on_rparen # Check if we have a local cache of the key
response on_op request on_lparen on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ivar on_op response on_period body on_lbracket on_tstring_beg on_tstring_content # Fixes issue https://github.com/fastlane/fastlane/issues/13281 # Even though we are using https://appstoreconnect.apple.com, the service key needs to still use a # hostname through itunesconnect.apple.com
on_const on_period UNK on_lparen UNK on_comma on_ivar on_rparen on_nl on_ignored_nl return on_ivar on_nl rescue on_op ex on_nl puts on_lparen ex # Cache the key locally
on_ignored_nl def UNK on_nl begin on_ignored_nl if on_const on_period UNK on_lparen UNK on_rparen on_nl puts on_lparen on_tstring_beg on_tstring_content on_embexpr_beg UNK ##################################################### # @!group Session #####################################################
def self on_period UNK on_nl on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl end # Fetch the session cookie from the environment # (if exists)
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl on_ignored_nl UNK on_op request on_lparen on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Get contract messages from App Store Connect's "olympus" endpoint
on_ignored_nl def UNK on_lparen tries on_op on_int on_comma on_op UNK on_rparen on_ignored_nl return UNK on_nl rescue on_const on_op on_const on_comma ##################################################### # @!group Helpers #####################################################
rescue on_const on_op on_const on_comma on_const on_op ex on_nl tries on_op on_int on_nl unless tries on_period UNK on_nl msg on_op # re-raise the exception
on_const on_op ex on_nl tries on_op on_int on_nl unless tries on_period UNK on_nl msg on_op on_tstring_beg on_tstring_content on_embexpr_beg ex on_period # <h2>Internal Server Error</h2> with content type json
rescue on_const on_op ex on_nl if on_ivar on_op on_op on_lparen tries on_op on_int on_rparen on_period UNK on_nl msg on_op on_tstring_beg # re-raise the exception
end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_lbrace on_rbrace on_nl end on_nl on_ignored_nl def request on_lparen method on_comma url_or_path # re-raise the exception
def UNK on_nl on_ivar on_op on_lbrace on_rbrace on_nl end on_nl on_ignored_nl def request on_lparen method on_comma url_or_path on_op nil on_comma # memorize the last csrf tokens from responses
UNK on_lparen method on_comma url_or_path on_comma params on_comma headers on_comma on_op block on_rparen on_nl on_ignored_nl if method on_op on_symbeg UNK # Before encoding the parameters, log them
if method on_op on_symbeg UNK on_op params on_op on_op UNK on_nl params on_comma headers on_op UNK on_lparen params on_comma headers # form-encode the params only if there are params, and the block is not supplied. # this is so that certain requests can be made using the block for more control
on_ignored_nl response on_period body on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_const on_period UNK on_lparen response on_period body on_lbracket on_tstring_beg on_tstring_content # If we have an `expected_key`, select that from response.body Hash # Else, don't.
response on_period body on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_const on_period UNK on_lparen response on_period body on_lbracket on_tstring_beg on_tstring_content on_tstring_end # the returned error message and info, is html encoded -> &quot;issued&quot; -> make this readable -> "issued"
if content on_period UNK on_nl UNK on_lparen response on_period body on_rparen if response on_period body on_nl raise on_const on_comma response # if content (filled with whole body or just expected_key) is missing
elsif content on_period kind_of? on_lparen on_const on_rparen on_op on_lparen content on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_end on_rparen on_period # else if it is a hash and `resultString` includes `NotAllowed`
UNK on_lparen on_label content on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_rparen on_nl else on_ignored_nl UNK on_lparen response on_rparen on_nl content on_nl # example content when doing a Developer Portal action with not enough permission # => {"responseId"=>"e5013d83-c5cb-4ba0-bb62-734a8d56007f", # "resultCode"=>1200, # "resultString"=>"webservice.certificate.downloadNotAllowed", # "userString"=>"You are not permitted to download this certificate.", # "creationTimestamp"=>"2017-01-26T22:44:13Z", # "protocolVersion"=>"QH65B2", # "userLocale"=>"en_US", # "requestUrl"=>"https://developer.apple.com/services-account/QH65B2/account/ios/certificate/downloadCertificateContent.action", # "httpCode"=>200}
if body on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op body on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period # Check if the failure is due to missing permissions (App Store Connect)
UNK on_lparen on_label on_int on_rparen on_nl elsif body on_period to_s on_period include? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl raise on_const # Passing a specific `caller_location` here to make sure we return the correct method # With the default location the error would say that `parse_response` is the caller
def UNK on_lparen on_label nil on_comma on_label on_int on_rparen on_ignored_nl UNK on_op UNK on_lparen UNK on_comma on_int on_rparen on_period UNK # This also gets called from subclasses
UNK on_op UNK on_lparen UNK on_comma on_int on_rparen on_period UNK on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # get the method name of the request that failed # `block in` is used very often for requests when surrounded for paging or retrying blocks # The ! is part of some methods when they modify or delete a resource, so we don't want to show it # Using `sub` instead of `delete` as we don't want to allow multiple matches
team_id on_op on_ivar on_op on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_end on_nl on_ignored_nl UNK on_op on_tstring_beg on_tstring_content # calling the computed property self.team_id can get us into an exception handling loop
on_ivar on_op true on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen response on_rparen on_ignored_nl if response on_op response on_period # different in subclasses
def UNK on_lparen response on_rparen on_ignored_nl if response on_op response on_period headers on_nl UNK on_op response on_period headers on_period UNK # Is called from `parse_response` to store the latest csrf_token (if available)
body on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end if body on_period kind_of? on_lparen on_const on_rparen on_op body on_period # replace password in body if present
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl params_to_log on_op on_const on_lparen params on_rparen on_period UNK params_to_log on_period # no json, no password to replace
params_to_log on_period UNK on_lparen on_symbeg UNK on_rparen params_to_log on_period UNK on_lparen on_symbeg UNK on_rparen params_to_log on_op params_to_log on_period UNK do # to also work with nil
params_to_log on_period UNK on_lparen on_symbeg UNK on_rparen params_to_log on_op params_to_log on_period UNK do on_op UNK on_comma UNK on_op on_ignored_nl on_tstring_beg # Dev Portal
params_to_log on_op params_to_log on_period UNK do on_op UNK on_comma UNK on_op on_ignored_nl on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg UNK # iTC
def url on_lparen url on_rparen on_ignored_nl on_ivar on_op url on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_const on_period # rubocop: disable Style/TrivialAccessors # the block calls `url` (not `url=`) so need to define `url` method
end on_nl UNK on_period headers on_op on_lbrace on_rbrace on_nl UNK on_lparen UNK on_rparen on_nl UNK on_period UNK on_lparen on_tstring_beg on_tstring_content # rubocop: enable Style/TrivialAccessors
def UNK on_lparen method on_comma url_or_path on_comma params on_comma headers on_comma on_op block on_rparen on_ignored_nl UNK do on_ignored_nl response on_op # Actually sends the request to the remote server # Automatically retries the request up to 3 times if something goes wrong
end on_nl on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # rubocop:enable Metrics/ClassLength
