args on_period UNK UNK on_op current on_comma UNK on_op on_ignored_nl UNK UNK current on_op on_tstring_beg on_tstring_content on_tstring_end on_op current on_op # args example: ["-a", "com.krausefx.app", "--team_id", "5AA97AAHK2"]
return args on_lbracket UNK on_op UNK on_rbracket if args on_period UNK on_op UNK on_nl end on_nl nil on_nl end on_nl # argument names are followed by argument values in the args array; # use [index + 1] to find the package name (range check the array # to avoid array bounds errors)
UNK on_op on_lbracket on_const on_op on_const on_period UNK on_lparen UNK UNK app_identifier on_rparen on_rbracket on_nl UNK on_op on_const on_op on_const # we only care about the app_identifier item in the configuration file, so # build an options array & Configuration with just that one key and it will # be fetched if it is present in the config file
UNK on_period UNK on_lparen UNK on_comma UNK UNK UNK on_comma UNK on_rparen on_nl return UNK on_period UNK on_lparen UNK app_identifier # pass the empty proc to disable options validation, otherwise this will fail # when the other (non-app_identifier) keys are encountered in the config file; # 3rd parameter "true" disables the printout of the contents of the # configuration file, which is noisy and confusing in this case
nil on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_lparen UNK # any option/file error here should just be treated as identifier not found
on_ignored_nl on_ignored_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl # Deliverfile.swift, Snapfile.swift, Appfile.swift all look like: # var appIdentifier: String? { return nil } # var appIdentifier: String { return "" }
on_ignored_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl # Matchfile.swift is the odd one out # var appIdentifier: [String] { return [] } #
return nil on_nl end on_nl on_ignored_nl def UNK on_lparen UNK nil on_rparen on_ignored_nl UNK on_period UNK on_nl UNK on_op on_const # any option/file error here should just be treated as identifier not found
on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK UNK # if we're swifty, let's look there # this isn't the same list as above
def UNK on_lparen args on_rparen on_ignored_nl app_identifier on_op nil on_nl app_identifier on_op UNK on_lparen args on_rparen on_nl app_identifier on_op UNK # make a best-guess for the app_identifier for this project, using most-reliable signals # first and then using less accurate ones afterwards; because this method only returns # a GUESS for the app_identifier, it is only useful for metrics or other places where # absolute accuracy is not required
