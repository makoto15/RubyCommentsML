UNK on_const on_op on_const on_nl attr_accessor on_symbeg git_url on_nl attr_accessor on_symbeg UNK on_nl attr_accessor on_symbeg UNK on_nl attr_accessor on_symbeg branch # Store the code signing identities in a git repo
attr_accessor on_symbeg git_url on_nl attr_accessor on_symbeg UNK on_nl attr_accessor on_symbeg UNK on_nl attr_accessor on_symbeg branch on_nl attr_accessor on_symbeg UNK on_nl # User provided values
return if UNK on_nl on_ignored_nl self on_period working_directory on_op on_const on_period UNK on_nl on_ignored_nl command on_op on_tstring_beg on_tstring_content on_embexpr_beg self # Check if we already have a functional working_directory
self on_period working_directory on_op on_const on_period UNK on_nl on_ignored_nl command on_op on_tstring_beg on_tstring_content on_embexpr_beg self on_period git_url on_period shellescape on_embexpr_end # No existing working directory, creating a new one now
command on_op on_tstring_beg on_tstring_content on_embexpr_beg self on_period git_basic_authorization on_embexpr_end on_tstring_content on_tstring_end unless self on_period git_basic_authorization on_period UNK on_nl command on_op # HTTP headers are supposed to be be case insensitive but # Bitbucket requires `Authorization: Basic` and `Authorization Bearer` to work # https://github.com/fastlane/fastlane/pull/15928
on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_ignored_nl on_const on_op on_const on_period UNK on_lparen # GIT_TERMINAL_PROMPT will fail the `git clone` command if user credentials are missing
UNK on_lparen on_label on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_comma on_label UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen on_label # No specific list given, e.g. this happens on `fastlane match nuke` # We just want to run `git add -A` to commit everything
def UNK on_nl on_lbracket on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl self on_period type on_comma on_ignored_nl # Generate the commit message based on the user's parameters
def UNK on_nl return unless self on_period working_directory on_nl on_ignored_nl commands on_op on_lbracket on_rbracket on_nl if UNK on_lparen self on_period # Create and checkout an specific branch in the git repo
commands on_op on_tstring_beg on_tstring_content on_embexpr_beg self on_period branch on_period shellescape on_embexpr_end on_tstring_end on_nl UNK on_ignored_nl commands on_op on_tstring_beg on_tstring_content on_embexpr_beg # Checkout the branch if it already exists
commands on_op on_tstring_beg on_tstring_content on_embexpr_beg self on_period branch on_period shellescape on_embexpr_end on_tstring_end on_nl commands on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end # If a new branch is being created, we create it as an 'orphan' to not inherit changes from the master branch.
commands on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg self on_period branch on_embexpr_end # We also need to reset the working directory to not transfer any uncommitted changes to the new branch.
def UNK on_lparen branch on_rparen on_ignored_nl return unless self on_period working_directory on_nl on_ignored_nl UNK on_op on_const on_period UNK on_lparen self # Checks if a specific branch exists in the git repo
commands on_op on_lbracket on_rbracket on_nl commands on_op on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end unless UNK on_period UNK on_nl commands # Add git config if needed
