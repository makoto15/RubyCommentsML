def UNK on_lparen params on_rparen on_ignored_nl self on_period files_to_commit on_op on_lbracket on_rbracket on_nl on_ignored_nl on_const on_period UNK on_lparen params on_lbracket # rubocop:disable Metrics/PerceivedComplexity
self on_period storage on_op on_const on_period UNK on_lparen params on_lbracket on_symbeg UNK on_rbracket on_comma UNK on_ignored_nl on_label params on_lbracket on_symbeg # Choose the right storage and encryption implementations
on_label params on_lbracket on_symbeg UNK on_rbracket on_comma on_ignored_nl on_label params on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_rparen on_nl storage on_period # only pass username if not readonly
UNK on_op on_const on_period UNK on_lparen params on_lbracket on_symbeg UNK on_rbracket on_comma UNK on_ignored_nl on_label params on_lbracket on_symbeg UNK on_rbracket # Init the encryption only after the `storage.download` was called to have the right working directory
app_identifiers on_period UNK on_nl on_ignored_nl if spaceship on_nl app_identifiers on_period UNK UNK on_op app_identifier on_op on_ignored_nl spaceship on_period UNK on_lparen # sometimes we get an array with arrays, this is a bug. To unblock people using match, I suggest we flatten! # then in the future address the root cause of https://github.com/fastlane/fastlane/issues/11324
if spaceship on_nl app_identifiers on_period UNK UNK on_op app_identifier on_op on_ignored_nl spaceship on_period UNK on_lparen on_label params on_lbracket on_symbeg UNK # Verify the App ID (as we don't want 'match' to fail at a later point)
UNK on_op UNK on_lparen on_label params on_comma on_label storage on_period UNK on_rparen on_nl on_ignored_nl UNK on_op params on_lbracket on_symbeg UNK # Certificate
UNK on_op params on_lbracket on_symbeg UNK on_rbracket on_op on_lbracket on_rbracket on_nl UNK on_op UNK on_period UNK UNK on_op UNK on_op # Mac Installer Distribution Certificate
UNK params on_lbracket on_symbeg UNK on_rbracket on_nl app_identifiers on_period UNK UNK on_op app_identifier on_op on_ignored_nl UNK UNK on_ignored_nl UNK if # Provisioning Profiles
app_identifiers on_period UNK UNK on_op app_identifier on_op on_ignored_nl on_const on_period UNK on_lparen on_label app_identifier on_comma on_label params on_lbracket on_symbeg UNK # Print a summary table for each app_identifier
on_ignored_nl def prefixed_working_directory on_nl return self on_period storage on_period prefixed_working_directory on_nl end on_nl on_ignored_nl def UNK on_lparen params on_rparen on_ignored_nl # rubocop:enable Metrics/PerceivedComplexity
def prefixed_working_directory on_nl return self on_period storage on_period prefixed_working_directory on_nl end on_nl on_ignored_nl def UNK on_lparen params on_rparen on_ignored_nl if # Used when creating a new certificate or profile
def UNK on_lparen params on_rparen on_ignored_nl if params on_lbracket on_symbeg UNK on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl params on_period UNK # Be smart about optional values here # Depending on the storage mode, different values are required
if on_const on_period UNK on_lparen cert_path on_rparen on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_lparen cert_path # Check validity of certificate
keychain_name on_op params on_lbracket on_symbeg keychain_name on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_op nil on_op params on_lbracket on_symbeg keychain_name on_rbracket on_nl # Only looking for cert in "custom" (non login.keychain) keychain # Doing this for backwards compatibility
on_const on_period UNK on_lparen UNK on_period UNK on_comma params on_lbracket on_symbeg keychain_name on_rbracket on_comma on_label params on_lbracket on_symbeg UNK on_rbracket # Import the private key # there seems to be no good way to check if it's already installed - so just install it # Key will only be added to the partition list if it isn't already installed
UNK on_op on_const on_period UNK on_lparen cert_path on_rparen on_nl on_const on_period UNK on_lparen on_label UNK on_rparen on_nl end on_nl on_ignored_nl # Get and print info of certificate
end on_nl on_ignored_nl def UNK on_lparen on_label nil on_comma on_label nil on_comma on_label nil on_comma on_label nil on_rparen on_ignored_nl prov_type # Certificate ID
def UNK on_lparen on_label nil on_comma on_label nil on_comma on_label nil on_comma on_label nil on_rparen on_ignored_nl prov_type on_op on_const on_period # @return [String] The UUID of the provisioning profile so we can verify it with the Apple Developer Portal
UNK on_op on_const on_period UNK on_lparen prefixed_working_directory on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma prov_type on_period to_s on_rparen on_nl on_ignored_nl UNK on_op # this is important, as it shouldn't be a wildcard
profile on_op UNK on_period UNK on_nl force on_op params on_lbracket on_symbeg force on_rbracket on_nl on_ignored_nl if params on_lbracket on_symbeg UNK # Install the provisioning profiles
on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # App Store provisioning profiles don't contain device identifiers and # thus shouldn't be renewed if the device count has changed.
UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_period UNK UNK on_op UNK on_op UNK on_period UNK on_lparen on_tstring_beg on_tstring_content # folder for `prov_type` does not exist on first match use for that type
on_const on_period UNK on_lparen profile on_rparen on_nl return nil on_nl end on_nl on_ignored_nl on_const on_period UNK on_lparen on_const on_period UNK # This profile is invalid, let's remove the local file and generate a new one
return nil on_nl end on_nl on_ignored_nl on_const on_period UNK on_lparen on_const on_period UNK on_lparen on_label app_identifier on_comma on_ignored_nl on_label prov_type # This method will be called again, no need to modify `files_to_commit`
on_const on_period UNK on_lparen on_const on_period UNK on_lparen on_label app_identifier on_comma on_ignored_nl on_label prov_type on_comma on_ignored_nl on_label params on_lbracket on_symbeg # TeamIdentifier is returned as an array, but we're not sure why there could be more than one
