def self on_period UNK on_lparen lane on_comma parameters on_op nil on_comma UNK on_op nil on_comma on_label false on_comma on_label nil # @param lane_name The name of the lane to execute # @param parameters [Hash] The parameters passed from the command line to the lane # @param env Dot Env Information
on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op lane on_nl on_const on_period UNK on_lbracket on_const on_op on_const on_op on_const on_rbracket on_op # Sets environment variable and lane context for lane name
on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_const on_op on_const on_op on_const on_period UNK on_lparen # xcodeproj has a bug in certain versions that causes it to change directories # and not return to the original working directory # https://github.com/CocoaPods/Xcodeproj/issues/426 # Setting this environment variable causes xcodeproj to work around the problem
self on_period UNK on_lparen lane on_comma parameters on_comma UNK on_rparen on_nl on_ignored_nl socket_thread on_period UNK on_nl UNK on_const on_op UNK # wait on socket_thread to be in ready state, then start the runner thread
e on_op UNK on_nl end on_nl e on_op socket_thread on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl UNK e on_period nil? on_nl # rubocop:disable Lint/RescueException
e on_op socket_thread on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl UNK e on_period nil? on_nl UNK on_nl on_ignored_nl on_const on_period UNK # If we have a thread exception, drop that in the exception # won't ever have a situation where e is non-nil, and socket_thread[:exception] is also non-nil
on_const on_period UNK on_lparen e on_period UNK on_rparen if e on_period UNK on_lparen on_const on_rparen end on_nl on_ignored_nl UNK on_op # We also catch Exception, since the implemented action might send a SystemExit signal # (or similar). We still want to catch that, since we want properly finish running fastlane # Tested with `xcake`, which throws a `Xcake::Informative` object
end on_nl on_ignored_nl UNK on_op false on_nl on_ignored_nl UNK on_op on_symbeg UNK if socket_thread on_period nil? on_nl on_ignored_nl UNK on_op # we don't want to print things like 'system exit'
UNK on_op on_symbeg UNK if socket_thread on_period nil? on_nl on_ignored_nl UNK on_op socket_thread on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl if # if socket_thread is nil, we were probably debugging, or something else weird happened
UNK on_op socket_thread on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl if UNK on_op on_symbeg UNK on_op e on_period nil? on_nl UNK # normal exit means we have a reason
def self on_period UNK on_lparen on_label nil on_comma on_label nil on_rparen on_ignored_nl new_user_tool_file_paths on_op UNK on_period UNK do on_op UNK # Find all the config files we care about (Deliverfile, Gymfile, etc), and build tuples of what file we'll look for # in the Xcode project, and what file paths we'll need to swap (since we have to inject the user's configs) # # Return a mapping of what file paths we're looking => new file pathes we'll need to inject
new_user_tool_file_paths on_op new_user_tool_file_paths on_period UNK do on_op UNK on_comma preinstalled_config_relative_path on_comma user_config_relative_path on_op on_ignored_nl if UNK on_nl on_lbracket preinstalled_config_relative_path on_comma # Now strip out the fastlane-relative path and leave us with xcodeproj relative paths
def self on_period UNK on_nl UNK on_op on_const on_op on_const on_period UNK on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op # open and return the swift project
def self on_period UNK on_lparen on_label nil on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_period UNK do on_op UNK on_op # return the FastlaneRunner build target
runner_target on_op UNK on_period UNK on_nl return runner_target on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen on_label nil on_rparen # get runner target
self on_period UNK on_lparen on_label UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl end on_nl on_ignored_nl def self # Go through and link up whatever we generated during `fastlane init swift` so the user can edit them easily
UNK on_op on_const on_period UNK do on_op UNK on_op on_ignored_nl on_lbracket on_ignored_nl on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_embexpr_beg # All the tools that could have <tool name>file.swift their paths, and where we expect to find the user's tool files.
new_user_tool_file_paths on_op UNK on_lparen on_label UNK on_comma on_label true on_rparen on_nl on_ignored_nl UNK on_op UNK on_lparen on_label UNK on_comma on_label # Tool files the user now provides
UNK on_op UNK on_lparen on_label UNK on_comma on_label false on_rparen on_nl on_ignored_nl UNK on_op self on_period UNK on_nl runner_target on_op # Tool files we provide AND the user doesn't provide
UNK on_op UNK on_lparen on_ignored_nl on_label runner_target on_comma on_ignored_nl on_label UNK on_comma on_ignored_nl on_label new_user_tool_file_paths on_nl on_rparen on_nl on_ignored_nl UNK # Swap in all new user supplied configs into the project
UNK on_op UNK on_lparen on_ignored_nl on_label runner_target on_comma on_ignored_nl on_label UNK on_comma on_ignored_nl on_label UNK on_nl on_rparen on_op UNK on_nl # Swap out any configs the user has removed, inserting fastlane defaults
UNK on_op self on_period UNK on_nl on_ignored_nl if on_const on_op on_const on_period UNK on_nl UNK on_op on_const on_period UNK on_lparen # if self.link_user_configs_to_project returns true, that means we need to rebuild the runner
on_const on_period verbose on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op true on_nl end on_nl UNK on_ignored_nl on_const on_period verbose # It's older than the Fastfile, so build it again
on_const on_period verbose on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op true on_nl end on_nl on_ignored_nl if UNK on_nl self # Runner isn't built yet, so build it
def self on_period UNK on_nl UNK on_op false on_nl UNK on_op on_const on_period UNK on_nl on_ignored_nl UNK on_op UNK on_period # do we have the latest FastlaneSwiftRunner code from the current version of fastlane?
