on_ignored_nl def gemfile_path on_nl on_const on_op on_const on_period UNK on_period UNK on_nl UNK on_const on_op on_const on_nl UNK on_nl end ##################################################### # @!group Reading the files and their paths #####################################################
on_const on_op on_const on_period UNK on_period UNK on_nl UNK on_const on_op on_const on_nl UNK on_nl end on_nl on_ignored_nl def pluginfile_path # This is pretty important, since we don't know what kind of # Gemfile the user has (e.g. Gemfile, gems.rb, or custom env variable)
on_ignored_nl def self on_period plugin_prefix on_nl on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen plugin_name on_rparen on_ignored_nl plugin_name ##################################################### # @!group Helpers #####################################################
def UNK on_nl return on_lbracket on_rbracket unless gemfile_path on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen gemfile_path on_comma UNK # Returns an array of gems that are added to the Gemfile or Pluginfile
def UNK on_nl UNK on_period UNK do on_op current on_op on_ignored_nl current on_period UNK on_lparen self on_period class on_period plugin_prefix # Returns an array of fastlane plugins that are added to the Gemfile or Pluginfile # The returned array contains the string with their prefixes (e.g. fastlane-plugin-xcversion)
def UNK on_lparen plugin_name on_rparen on_ignored_nl on_const on_period user_error! on_lparen on_tstring_beg on_tstring_content on_embexpr_beg self on_period class on_period plugin_prefix on_embexpr_end on_tstring_content # Check if a plugin is added as dependency to either the # Gemfile or the Pluginfile
on_ignored_nl def UNK on_lparen plugin_name on_rparen on_ignored_nl on_const on_period user_error! on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless pluginfile_path on_nl plugin_name on_op ##################################################### # @!group Modifying dependencies #####################################################
on_const on_period user_error! on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl unless UNK on_lparen plugin_name on_rparen on_nl content on_op # e.g. "fastlane-plugin-ya_tu-sabes" (which is invalid)
UNK on_nl on_ignored_nl true on_nl end on_nl on_ignored_nl def UNK on_lparen plugin_name on_rparen on_ignored_nl return on_tstring_beg on_tstring_end unless self on_period # We do this *after* creating the Plugin file # Since `bundle exec` would be broken if something fails on the way
def UNK on_lparen plugin_name on_rparen on_ignored_nl return on_tstring_beg on_tstring_end unless self on_period class on_period UNK on_lparen plugin_name on_rparen on_period UNK # Get a suffix (e.g. `path` or `git` for the gem dependency)
def UNK on_lparen path_to_gemfile on_rparen on_ignored_nl content on_op UNK on_op on_lparen on_const on_op on_const on_rparen on_nl on_ignored_nl content on_op on_tstring_beg # Modify the user's Gemfile to load the plugins
content on_op on_tstring_beg on_tstring_content on_tstring_end unless UNK on_period include? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl content on_op on_tstring_beg on_tstring_content on_embexpr_beg # We have to make sure fastlane is also added to the Gemfile, since we now use # bundler to run fastlane
on_ignored_nl def self on_period UNK on_lparen gem_name on_rparen on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK ##################################################### # @!group Accessing RubyGems #####################################################
on_ignored_nl def UNK on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_nl UNK do on_ignored_nl cmd on_op on_tstring_beg on_tstring_content ##################################################### # @!group Installing and updating dependencies #####################################################
def UNK on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_nl UNK do on_ignored_nl cmd on_op on_tstring_beg on_tstring_content on_tstring_end # Warning: This will exec out # This is necessary since the user might be prompted for their password
puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_nl UNK do on_ignored_nl cmd on_op on_tstring_beg on_tstring_content on_tstring_end on_nl cmd on_op # Using puts instead of `UI` to have the same style as the `echo`
def UNK on_nl puts on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_nl UNK on_op UNK on_nl if UNK on_period UNK # Warning: This will exec out # This is necessary since the user might be prompted for their password
on_ignored_nl on_const on_period UNK do on_ignored_nl UNK if UNK on_nl end on_nl end on_nl on_ignored_nl on_ignored_nl def UNK on_nl on_const # There is an interesting problem with using exec to call back into Bundler # The `bundle ________` command that we exec, inherits all of the Bundler # state we'd already built up during this run. That was causing the command # to fail, telling us to install the Gem we'd just introduced, even though # that is exactly what we are trying to do! # # Bundler.with_clean_env solves this problem by resetting Bundler state before the # exec'd call gets merged into this process.
on_ignored_nl def UNK on_nl on_const on_period important on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl path_to_gemfile on_op gemfile_path on_op on_const on_nl ##################################################### # @!group Initial setup #####################################################
on_const on_period user_error! on_lparen on_tstring_beg on_tstring_content on_embexpr_beg path_to_gemfile on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl UNK on_lparen path_to_gemfile on_rparen # we use `puts` instead of `UI` to make it easier to copy and paste
def self on_period UNK on_nl if on_const on_op on_const on_period path on_nl UNK on_op on_const on_period UNK on_lparen on_const on_op # The code required to load the Plugins file
def UNK on_nl gemfile_path on_op UNK on_period include? on_lparen on_const on_op on_const on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # Makes sure, the user's Gemfile actually loads the Plugins file
on_ignored_nl def UNK on_lparen on_label true on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK on_op ##################################################### # @!group Requiring the plugins #####################################################
def UNK on_lparen on_label true on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK on_op UNK # Iterate over all available plugins # which follow the naming convention # fastlane-plugin-[plugin_name] # This will make sure to load the action # and all its helpers
self on_period UNK on_period UNK on_lparen on_const on_op on_const on_period UNK on_rparen on_nl on_ignored_nl on_const on_period UNK on_lparen on_label gem_name # BEFORE requiring the gem, we get a list of loaded actions # This way we can check inside `store_plugin_reference` if # any actions were overwritten
on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg gem_name on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end on_rparen on_nl on_ignored_nl self on_period UNK # some errors, like ScriptError are not caught unless explicitly
self on_period UNK on_lbracket gem_name on_rbracket on_op UNK on_ignored_nl on_label on_const on_op on_const on_period UNK on_lparen gem_name on_rparen on_comma on_ignored_nl # We'll still add it to the table, to make the error # much more visible and obvious
UNK on_lparen self on_period UNK on_rparen unless UNK on_nl end on_nl on_ignored_nl def UNK on_lparen references on_rparen on_ignored_nl UNK on_op # We want to avoid printing output other than the version number if we are running `fastlane -v`
def UNK on_lparen references on_rparen on_ignored_nl UNK on_op UNK on_nl on_ignored_nl UNK on_op references on_period UNK do on_op current on_op # Prints a table all the plugins that were loaded
UNK on_op true on_nl on_lbracket current on_lbracket on_int on_rbracket on_period UNK on_comma current on_lbracket on_int on_rbracket on_lbracket UNK UNK on_rbracket # Something is wrong with this plugin, no available actions
on_ignored_nl def UNK on_nl UNK on_op UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl ##################################################### # @!group Reference between plugins to actions #####################################################
def UNK on_nl UNK on_op UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl end # Connection between plugins and their actions # Example value of plugin_references # => {"fastlane-plugin-ruby" => { # version_number: "0.1.0", # actions: [:rspec, :rubocop] # }}
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl end on_nl on_ignored_nl def UNK on_lparen gem_name on_rparen on_ignored_nl UNK on_op gem_name # Contains an array of symbols for the action classes
UNK on_op on_const on_op on_const on_period UNK on_lparen gem_name on_rparen on_nl references on_op on_const on_period UNK on_lparen UNK on_rparen on_period # We store a collection of the imported plugins # This way we can tell which action came from what plugin # (a plugin may contain any number of actions)
on_ignored_nl on_const on_period UNK on_lparen path on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen on_period UNK on_lparen # we only want to match actions
end on_nl references on_period UNK on_nl on_ignored_nl references on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op on_lparen UNK on_period # the _action is optional
references on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op on_lparen UNK on_period UNK on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end # Check if this overwrites a built-in action and # show a warning if that's the case
UNK on_op on_lparen UNK on_period UNK on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_nl on_ignored_nl if self on_period # current_ref is a symbol, e.g. :emoji_fetcher
