package_name on_op UNK on_nl args on_period UNK UNK on_op UNK on_comma UNK on_op on_ignored_nl UNK UNK UNK on_lparen gem_name on_comma # args example: ["-a", "com.krausefx.app"]
package_name on_op args UNK UNK on_op UNK UNK UNK args on_period UNK on_op UNK on_nl UNK on_nl end on_nl package_name # argument names are followed by argument values in the args array; # use [index + 1] to find the package name (range check the array # to avoid array bounds errors)
UNK on_op UNK on_const on_op on_const on_period UNK on_lparen UNK UNK on_rparen UNK on_nl UNK on_op on_const on_op on_const on_period # we only care about the package name item in the configuration file, so # build an options array & Configuration with just that one key and it will # be fetched if it is present in the config file
UNK on_period UNK on_lparen UNK on_comma UNK UNK UNK on_comma UNK on_rparen on_nl UNK UNK on_period UNK on_lparen UNK on_comma # pass the empty proc to disable options validation, otherwise this will fail # when the other (non-package name) keys are encountered in the config file; # 3rd parameter "true" disables the printout of the contents of the # configuration file, which is noisy and confusing in this case
UNK on_nl end on_nl on_ignored_nl def UNK on_nl package_name on_op UNK on_nl package_name on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma # any option/file error here should just be treated as identifier not found
def UNK on_lparen gem_name on_comma args on_rparen on_ignored_nl package_name on_op UNK on_nl package_name on_op UNK on_lparen gem_name on_comma args on_rparen # make a best-guess for the package_name for this project, using most-reliable signals # first and then using less accurate ones afterwards; because this method only returns # a GUESS for the package_name, it is only useful for metrics or other places where # absolute accuracy is not required
