UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl class # frozen_string_literal: true
on_const on_op on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end # When action is create or update, we still should use new and edit
UNK on_nl on_ivar on_op UNK on_lparen on_ivar on_rparen on_nl on_ivar on_op options on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_op on_const #:nodoc:
def input on_lparen attribute_name on_comma options on_op on_lbrace on_rbrace on_comma on_op block on_rparen on_ignored_nl options on_op on_ivar on_period UNK on_period # Basic input helper, combines all components in the stack to generate # input html based on options the user define and some guesses through # database column information. By default a call to input will generate # label + input + hint (when defined) + errors (when exists), and all can # be configured inside a wrapper html. # # If a block is given, the contents of the block will replace the input # field that would otherwise be generated automatically. The content will # be given a label and wrapper div to make it consistent with the other # elements in the form. # # == Examples # # # Imagine @user has error "can't be blank" on name # simple_form_for @user do |f| # f.input :name, hint: 'My hint' # end # # This is the output html (only the input portion, not the form): # # <label class="string required" for="user_name"> # <abbr title="required">*</abbr> Super User Name! # </label> # <input class="string required" id="user_name" maxlength="100" # name="user[name]" type="text" value="Carlos" /> # <span class="hint">My hint</span> # <span class="error">can't be blank</span> # # Each database type will render a default input, based on some mappings and # heuristic to determine which is the best option. # # You have some options for the input to enable/disable some functions: # # as: allows you to define the input type you want, for instance you # can use it to generate a text field for a date column. # # required: defines whether this attribute is required or not. True # by default. # # The fact SimpleForm is built in components allow the interface to be unified. # So, for instance, if you need to disable :hint for a given input, you can pass # hint: false. The same works for :error, :label and :wrapper. # # Besides the html for any component can be changed. So, if you want to change # the label html you just need to give a hash to :label_html. To configure the # input html, supply :input_html instead and so on. # # == Options # # Some inputs, as datetime, time and select allow you to give extra options, like # prompt and/or include blank. Such options are given in plainly: # # f.input :created_at, include_blank: true # # == Collection # # When playing with collections (:radio_buttons, :check_boxes and :select # inputs), you have three extra options: # # collection: use to determine the collection to generate the radio or select # # label_method: the method to apply on the array collection to get the label # # value_method: the method to apply on the array collection to get the value # # == Priority # # Some inputs, as :time_zone and :country accepts a :priority option. If none is # given SimpleForm.time_zone_priority and SimpleForm.country_priority are used respectively. #
def UNK on_lparen attribute_name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl components on_op on_lparen wrapper on_period components on_period UNK on_lparen # Creates a input tag for the given attribute. All the given options # are sent as :input_html. # # == Examples # # simple_form_for @user do |f| # f.input_field :name # end # # This is the output html (only the input portion, not the form): # # <input class="string required" id="user_name" maxlength="100" # name="user[name]" type="text" value="Carlos" /> # # It also support validation classes once it is configured. # # # config/initializers/simple_form.rb # SimpleForm.setup do |config| # config.input_field_valid_class = 'is-valid' # config.input_field_error_class = 'is-invalid' # end # # simple_form_for @user do |f| # f.input_field :name # end # # When the validation happens, the input will be rendered with # the class configured according to the validation: # # - when the input is valid: # # <input class="is-valid string required" id="user_name" value="Carlos" /> # # - when the input is invalid: # # <input class="is-invalid string required" id="user_name" value="" /> #
def association on_lparen association on_comma options on_op on_lbrace on_rbrace on_comma on_op block on_rparen on_ignored_nl options on_op options on_period dup on_nl # Helper for dealing with association selects/radios, generating the # collection automatically. It's just a wrapper to input, so all options # supported in input are also supported by association. Some extra options # can also be given: # # == Examples # # simple_form_for @user do |f| # f.association :company # Company.all # end # # f.association :company, collection: Company.all(order: 'name') # # Same as using :order option, but overriding collection # # == Block # # When a block is given, association simple behaves as a proxy to # simple_fields_for: # # f.association :company do |c| # c.input :name # c.input :type # end # # From the options above, only :collection can also be supplied. # # Please note that the association helper is currently only tested with Active Record. Depending on the ORM you are using your mileage may vary. #
UNK on_symbeg UNK on_comma on_symbeg UNK on_nl def UNK on_lparen type on_comma on_op args on_comma on_op block on_rparen on_ignored_nl options # Creates a button: # # form_for @user do |f| # f.button :submit # end # # It just acts as a proxy to method name given. We also alias original Rails # button implementation (3.2 forward (to delegate to the original when # calling `f.button :button`. #
def UNK on_lparen attribute_name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl options on_op options on_period dup on_nl on_ignored_nl options on_lbracket # Creates an error tag based on the given attribute, only when the attribute # contains errors. All the given options are sent as :error_html. # # == Examples # # f.error :name # f.error :name, id: "cool_error" #
def UNK on_lparen attribute_name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl options on_op options on_period dup on_nl on_ignored_nl options on_lbracket # Return the error but also considering its name. This is used # when errors for a hidden field need to be shown. # # == Examples # # f.full_error :token #=> <span class="error">Token is invalid</span> #
def UNK on_lparen attribute_name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl options on_op options on_period dup on_nl on_ignored_nl options on_lbracket # Creates a hint tag for the given attribute. Accepts a symbol indicating # an attribute for I18n lookup or a string. All the given options are sent # as :hint_html. # # == Examples # # f.hint :name # Do I18n lookup # f.hint :name, id: "cool_hint" # f.hint "Don't forget to accept this" #
def UNK on_lparen attribute_name on_comma on_op args on_rparen on_ignored_nl return UNK if args on_period UNK on_period UNK on_lparen on_const on_rparen # Creates a default label tag for the given attribute. You can give a label # through the :label option or using i18n. All the given options are sent # as :label_html. # # == Examples # # f.label :name # Do I18n lookup # f.label :name, "Name" # Same behavior as Rails, do not add required tag # f.label :name, label: "Name" # Same as above, but adds required tag # # f.label :name, required: false # f.label :name, id: "cool_label" #
def UNK on_lparen options on_op on_lbrace on_rbrace on_rparen on_ignored_nl on_const on_op on_const on_period new on_lparen self on_comma options on_rparen on_period # Creates an error notification message that only appears when the form object # has some error. You can give a specific message with the :message option, # otherwise it will look for a message using I18n. All other options given are # passed straight as html options to the html tag. # # == Examples # # f.error_notification # f.error_notification message: 'Something went wrong' # f.error_notification id: 'user_error_message', class: 'form_error' #
def UNK on_lparen UNK on_comma collection on_comma UNK on_comma UNK on_comma options on_op on_lbrace on_rbrace on_comma html_options on_op on_lbrace on_rbrace # Create a collection of radio inputs for the attribute. Basically this # helper will create a radio input associated with a label for each # text/value option in the collection, using value_method and text_method # to convert these text/value. You can give a symbol or a proc to both # value_method and text_method, that will be evaluated for each item in # the collection. # # == Examples # # form_for @user do |f| # f.collection_radio_buttons :options, [[true, 'Yes'] ,[false, 'No']], :first, :last # end # # <input id="user_options_true" name="user[options]" type="radio" value="true" /> # <label class="collection_radio_buttons" for="user_options_true">Yes</label> # <input id="user_options_false" name="user[options]" type="radio" value="false" /> # <label class="collection_radio_buttons" for="user_options_false">No</label> # # It is also possible to give a block that should generate the radio + # label. To wrap the radio with the label, for instance: # # form_for @user do |f| # f.collection_radio_buttons( # :options, [[true, 'Yes'] ,[false, 'No']], :first, :last # ) do |b| # b.label { b.radio_button + b.text } # end # end # # == Options # # Collection radio accepts some extra options: # # * checked => the value that should be checked initially. # # * disabled => the value or values that should be disabled. Accepts a single # item or an array of items. # # * collection_wrapper_tag => the tag to wrap the entire collection. # # * collection_wrapper_class => the CSS class to use for collection_wrapper_tag # # * item_wrapper_tag => the tag to wrap each item in the collection. # # * item_wrapper_class => the CSS class to use for item_wrapper_tag # # * a block => to generate the label + radio or any other component.
def UNK on_lparen UNK on_comma collection on_comma UNK on_comma UNK on_comma options on_op on_lbrace on_rbrace on_comma html_options on_op on_lbrace on_rbrace # Creates a collection of check boxes for each item in the collection, # associated with a clickable label. Use value_method and text_method to # convert items in the collection for use as text/value in check boxes. # You can give a symbol or a proc to both value_method and text_method, # that will be evaluated for each item in the collection. # # == Examples # # form_for @user do |f| # f.collection_check_boxes :options, [[true, 'Yes'] ,[false, 'No']], :first, :last # end # # <input name="user[options][]" type="hidden" value="" /> # <input id="user_options_true" name="user[options][]" type="checkbox" value="true" /> # <label class="collection_check_boxes" for="user_options_true">Yes</label> # <input name="user[options][]" type="hidden" value="" /> # <input id="user_options_false" name="user[options][]" type="checkbox" value="false" /> # <label class="collection_check_boxes" for="user_options_false">No</label> # # It is also possible to give a block that should generate the check box + # label. To wrap the check box with the label, for instance: # # form_for @user do |f| # f.collection_check_boxes( # :options, [[true, 'Yes'] ,[false, 'No']], :first, :last # ) do |b| # b.label { b.check_box + b.text } # end # end # # == Options # # Collection check box accepts some extra options: # # * checked => the value or values that should be checked initially. Accepts # a single item or an array of items. It overrides existing associations. # # * disabled => the value or values that should be disabled. Accepts a single # item or an array of items. # # * collection_wrapper_tag => the tag to wrap the entire collection. # # * collection_wrapper_class => the CSS class to use for collection_wrapper_tag. This option # is ignored if the :collection_wrapper_tag option is blank. # # * item_wrapper_tag => the tag to wrap each item in the collection. # # * item_wrapper_class => the CSS class to use for item_wrapper_tag # # * a block => to generate the label + check box or any other component.
def UNK on_ivar on_op UNK on_ignored_nl UNK on_op options on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_op UNK on_period to_s on_period # Extract the model names from the object_name mess, ignoring numeric and # explicit child indexes. # # Example: # # route[blocks_attributes][0][blocks_learning_object_attributes][1][foo_attributes] # ["route", "blocks", "blocks_learning_object", "foo"] #
on_ivar on_op UNK on_ignored_nl UNK on_op options on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_op UNK on_period to_s on_period UNK on_lparen #:nodoc:
def UNK on_ivar on_op UNK on_ignored_nl action on_op UNK on_period UNK on_op UNK on_period UNK on_period UNK on_nl return UNK # The action to be used in lookup.
on_ivar on_op UNK on_ignored_nl action on_op UNK on_period UNK on_op UNK on_period UNK on_period UNK on_nl return UNK action on_nl #:nodoc:
if options on_lbracket on_symbeg UNK on_rbracket on_op UNK on_op object on_period respond_to? on_lparen association on_rparen on_nl UNK on_op object on_period # Force the association to be preloaded for performance.
def UNK on_lparen attribute_name on_comma options on_op on_lbrace on_rbrace on_comma on_op block on_rparen on_ignored_nl column on_op UNK on_lparen attribute_name on_rparen # Find an input based on the attribute name.
def UNK on_lparen attribute_name on_comma column on_comma options on_rparen on_ignored_nl return options on_lbracket on_symbeg as on_rbracket on_period UNK if options # Attempt to guess the better input type given the defined options. By # default always fallback to the user :as option, or to a :select when a # collection is given.
def UNK on_lparen attribute_name on_rparen on_ignored_nl on_ivar on_period respond_to? on_lparen on_tstring_beg on_embexpr_beg attribute_name on_embexpr_end on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl on_ivar # Internal: Try to discover whether an attribute corresponds to a file or not. # # Most upload Gems add some kind of attributes to the ActiveRecord's model they are included in. # This method tries to guess if an attribute belongs to some of these Gems by checking the presence # of their methods using `#respond_to?`. # # Note: This does not support multiple file upload inputs, as this is very application-specific. # # The order here was chosen based on the popularity of Gems: # # - `#{attribute_name}_attachment` - ActiveStorage >= `5.2` and Refile >= `0.2.0` <= `0.4.0` # - `remote_#{attribute_name}_url` - Refile >= `0.3.0` and CarrierWave >= `0.2.2` # - `#{attribute_name}_attacher` - Refile >= `0.4.0` and Shrine >= `0.9.0` # - `#{attribute_name}_file_name` - Paperclip ~> `2.0` (added for backwards compatibility) # # Returns a Boolean.
def UNK on_lparen input_type on_rparen on_ignored_nl UNK on_lbracket input_type on_rbracket on_op on_ignored_nl if mapping on_op self on_period class on_period UNK # Attempts to find a mapping. It follows the following rules: # # 1) It tries to find a registered mapping, if succeeds: # a) Try to find an alternative with the same name in the Object scope # b) Or use the found mapping # 2) If not, fallbacks to #{input_type}Input # 3) If not, fallbacks to SimpleForm::Inputs::#{input_type}Input
def UNK on_lparen input_type on_rparen on_ignored_nl if options on_lbracket on_symbeg UNK on_rbracket on_op options on_lbracket on_symbeg UNK on_rbracket on_lbracket input_type # Attempts to find a wrapper mapping. It follows the following rules: # # 1) It tries to find a wrapper for the current form # 2) If not, it tries to find a config
def UNK on_nl if on_const on_period UNK on_nl self on_period class on_period UNK on_nl else on_ignored_nl on_ivar on_op on_lbrace on_rbrace # If cache_discovery is enabled, use the class level cache that persists # between requests, otherwise use the instance one.
