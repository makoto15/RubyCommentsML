on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl module on_const on_nl module on_const on_nl def UNK # frozen_string_literal: true
UNK on_const on_op on_const on_nl end on_nl on_ignored_nl UNK on_const on_nl def UNK on_lparen on_op UNK on_rparen on_ignored_nl on_ivar on_op #:nodoc: # Ensure Devise modules are included only after loading routes, because we # need devise_for mappings already declared to create filters and helpers.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl UNK UNK on_const on_period UNK on_nl options on_op UNK # Includes devise_for method for routes. This method is responsible to # generate all needed routes for devise, based on what modules you have # defined in your model. # # ==== Examples # # Let's say you have an User model configured to use authenticatable, # confirmable and recoverable modules. After creating this inside your routes: # # devise_for :users # # This method is going to look inside your User model and create the # needed routes: # # # Session routes for Authenticatable (default) # new_user_session GET /users/sign_in {controller:"devise/sessions", action:"new"} # user_session POST /users/sign_in {controller:"devise/sessions", action:"create"} # destroy_user_session DELETE /users/sign_out {controller:"devise/sessions", action:"destroy"} # # # Password routes for Recoverable, if User model has :recoverable configured # new_user_password GET /users/password/new(.:format) {controller:"devise/passwords", action:"new"} # edit_user_password GET /users/password/edit(.:format) {controller:"devise/passwords", action:"edit"} # user_password PUT /users/password(.:format) {controller:"devise/passwords", action:"update"} # POST /users/password(.:format) {controller:"devise/passwords", action:"create"} # # # Confirmation routes for Confirmable, if User model has :confirmable configured # new_user_confirmation GET /users/confirmation/new(.:format) {controller:"devise/confirmations", action:"new"} # user_confirmation GET /users/confirmation(.:format) {controller:"devise/confirmations", action:"show"} # POST /users/confirmation(.:format) {controller:"devise/confirmations", action:"create"} # # ==== Routes integration # # +devise_for+ is meant to play nicely with other routes methods. For example, # by calling +devise_for+ inside a namespace, it automatically nests your devise # controllers: # # namespace :publisher do # devise_for :account # end # # The snippet above will use publisher/sessions controller instead of devise/sessions # controller. You can revert this change or configure it directly by passing the :module # option described below to +devise_for+. # # Also note that when you use a namespace it will affect all the helpers and methods # for controllers and views. For example, using the above setup you'll end with # following methods: current_publisher_account, authenticate_publisher_account!, # publisher_account_signed_in, etc. # # The only aspect not affect by the router configuration is the model name. The # model name can be explicitly set via the :class_name option. # # ==== Options # # You can configure your routes with some options: # # * class_name: set up a different class to be looked up by devise, if it cannot be # properly found by the route name. # # devise_for :users, class_name: 'Account' # # * path: allows you to set up path name that will be used, as rails routes does. # The following route configuration would set up your route as /accounts instead of /users: # # devise_for :users, path: 'accounts' # # * singular: set up the singular name for the given resource. This is used as the helper methods # names in controller ("authenticate_#{singular}!", "#{singular}_signed_in?", "current_#{singular}" # and "#{singular}_session"), as the scope name in routes and as the scope given to warden. # # devise_for :admins, singular: :manager # # devise_scope :manager do # ... # end # # class ManagerController < ApplicationController # before_action authenticate_manager! # # def show # @manager = current_manager # ... # end # end # # * path_names: configure different path names to overwrite defaults :sign_in, :sign_out, :sign_up, # :password, :confirmation, :unlock. # # devise_for :users, path_names: { # sign_in: 'login', sign_out: 'logout', # password: 'secret', confirmation: 'verification', # registration: 'register', edit: 'edit/profile' # } # # * controllers: the controller which should be used. All routes by default points to Devise controllers. # However, if you want them to point to custom controller, you should do: # # devise_for :users, controllers: { sessions: "users/sessions" } # # * failure_app: a rack app which is invoked whenever there is a failure. Strings representing a given # are also allowed as parameter. # # * sign_out_via: the HTTP method(s) accepted for the :sign_out action (default: :delete), # if you wish to restrict this to accept only :post or :delete requests you should do: # # devise_for :users, sign_out_via: [:get, :post] # # You need to make sure that your sign_out controls trigger a request with a matching HTTP method. # # * module: the namespace to find controllers (default: "devise", thus # accessing devise/sessions, devise/registrations, and so on). If you want # to namespace all at once, use module: # # devise_for :users, module: "users" # # * skip: tell which controller you want to skip routes from being created. # It accepts :all as an option, meaning it will not generate any route at all: # # devise_for :users, skip: :sessions # # * only: the opposite of :skip, tell which controllers only to generate routes to: # # devise_for :users, only: :sessions # # * skip_helpers: skip generating Devise url helpers like new_session_path(@user). # This is useful to avoid conflicts with previous routes and is false by default. # It accepts true as option, meaning it will skip all the helpers for the controllers # given in :skip but it also accepts specific helpers to be skipped: # # devise_for :users, skip: [:registrations, :confirmations], skip_helpers: true # devise_for :users, skip_helpers: [:registrations, :confirmations] # # * format: include "(.:format)" in the generated routes? true by default, set to false to disable: # # devise_for :users, format: false # # * constraints: works the same as Rails' constraints # # * defaults: works the same as Rails' defaults # # * router_name: allows application level router name to be overwritten for the current scope # # ==== Scoping # # Following Rails 3 routes DSL, you can nest devise_for calls inside a scope: # # scope "/my" do # devise_for :users # end # # However, since Devise uses the request path to retrieve the current user, # this has one caveat: If you are using a dynamic segment, like so ... # # scope ":locale" do # devise_for :users # end # # you are required to configure default_url_options in your # ApplicationController class, so Devise can pick it: # # class ApplicationController < ActionController::Base # def self.default_url_options # { locale: I18n.locale } # end # end # # ==== Adding custom actions to override controllers # # You can pass a block to devise_for that will add any routes defined in the block to Devise's # list of known actions. This is important if you add a custom action to a controller that # overrides an out of the box Devise controller. # For example: # # class RegistrationsController < Devise::RegistrationsController # def update # # do something different here # end # # def deactivate # # not a standard action # # deactivate code here # end # end # # In order to get Devise to recognize the deactivate action, your devise_scope entry should look like this: # # devise_scope :owner do # post "deactivate", to: "registrations#deactivate", as: "deactivate_registration" # end #
def UNK on_lparen scope on_op nil on_comma block on_op nil on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma scope on_comma block # Allow you to add authentication request from the router. # Takes an optional scope and block to provide constraints # on the model instance itself. # # authenticate do # resources :post # end # # authenticate(:admin) do # resources :users # end # # authenticate :user, lambda {|u| u.role == "admin"} do # root to: "admin/dashboard#show", as: :user_root # end #
def UNK on_lparen scope on_op nil on_comma block on_op nil on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma scope on_comma block # Allow you to route based on whether a scope is authenticated. You # can optionally specify which scope and a block. The block accepts # a model and allows extra constraints to be done on the instance. # # authenticated :admin do # root to: 'admin/dashboard#show', as: :admin_root # end # # authenticated do # root to: 'dashboard#show', as: :authenticated_root # end # # authenticated :user, lambda {|u| u.role == "admin"} do # root to: "admin/dashboard#show", as: :user_root # end # # root to: 'landing#show' #
def UNK on_lparen scope on_op nil on_rparen on_ignored_nl constraint on_op UNK do on_op request on_op on_ignored_nl UNK request on_period UNK # Allow you to route based on whether a scope is *not* authenticated. # You can optionally specify which scope. # # unauthenticated do # as :user do # root to: 'devise/registrations#new' # end # end # # root to: 'dashboard#show' #
def UNK on_lparen scope on_rparen on_ignored_nl constraint on_op UNK do on_op request on_op on_ignored_nl request on_period UNK on_lbracket on_tstring_beg on_tstring_content # Sets the devise scope to be used in the controller. If you have custom routes, # you are required to call this method (also aliased as :as) in order to specify # to which controller it is targeted. # # as :user do # get "sign_in", to: "devise/sessions#new" # end # # Notice you cannot have two scopes mapping to the same URL. And remember, if # you try to access a devise controller without specifying a scope, it will # raise ActionNotFound error. # # Also be aware of that 'devise_scope' and 'as' use the singular form of the # noun where other devise route commands expect the plural form. This would be a # good and working example. # # devise_scope :user do # get "/some/route" => "some_devise_controller" # end # devise_for :users # # Notice and be aware of the differences above between :user and :users
resource on_symbeg UNK on_comma on_label on_lbracket on_rbracket on_comma on_label controllers on_lbracket on_symbeg UNK on_rbracket on_comma on_label on_tstring_beg on_tstring_end do on_ignored_nl #:nodoc:
resource on_symbeg UNK on_comma on_label on_lbracket on_symbeg new on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_comma on_ignored_nl #:nodoc:
resource on_symbeg UNK on_comma on_label on_lbracket on_symbeg new on_comma on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_comma on_ignored_nl on_label mapping on_period #:nodoc:
if mapping on_period UNK on_period UNK on_lparen on_symbeg UNK on_rparen on_nl resource on_symbeg UNK on_comma on_label on_lbracket on_symbeg new on_comma #:nodoc:
path_names on_op on_lbrace on_ignored_nl on_label mapping on_period path_names on_lbracket on_symbeg UNK on_rbracket on_comma on_ignored_nl on_label mapping on_period path_names on_lbracket on_symbeg #:nodoc:
if mapping on_period UNK on_op UNK on_tstring_content UNK on_nl raise UNK on_nl on_tstring_content on_embexpr_beg mapping on_period UNK on_period UNK on_embexpr_end #:nodoc:
UNK on_op on_ivar on_period UNK on_nl on_ignored_nl UNK on_op on_lbrace on_label UNK on_comma on_label UNK on_comma on_label nil on_rbrace on_nl #:nodoc:
if on_op on_const on_period UNK on_period path_prefix on_op on_op on_const on_period UNK on_period path_prefix on_op path_prefix on_nl raise on_tstring_beg on_tstring_content #:nodoc:
raise UNK on_nl on_tstring_content on_embexpr_beg on_const on_period UNK on_lparen UNK on_rparen on_embexpr_end on_tstring_content UNK end on_nl on_ignored_nl def UNK on_lparen #:nodoc:
raise on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end on_tstring_beg on_tstring_content on_tstring_end on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl end on_nl #:nodoc:
