on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
UNK on_const on_op on_const on_op on_const on_op on_const on_nl UNK UNK on_nl UNK on_op UNK on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg # These tests are to prove that a warden strategy can successfully # return a custom response, including a specific status code and # custom http response headers. This does work in production, # however, at the time of writing this, the Devise test helpers do # not recognise the custom response and proceed to calling the # Failure App. This makes it impossible to write tests for a # strategy that return a custom response with Devise.
UNK UNK on_period UNK on_lparen on_const on_op on_const on_rparen on_nl on_ignored_nl UNK UNK on_nl end on_nl on_ignored_nl UNK on_tstring_beg on_tstring_content # check the returned rack array # assert ret.is_a?(Array) # assert_equal 400, ret.first
UNK UNK on_nl end on_nl on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end UNK on_ignored_nl UNK on_op UNK UNK UNK on_nl on_ignored_nl UNK # check the saved response as well. This is purely so that the response is available to the testing framework # for verification. In production, the above array would be delivered directly to Rack.
UNK UNK on_period UNK on_lparen on_const on_op on_const on_rparen on_nl on_ignored_nl UNK UNK on_period UNK UNK on_tstring_beg on_tstring_content on_tstring_end UNK # check the returned rack array # assert ret.is_a?(Array) # assert_equal ret.third['X-FOO'], 'BAR'
UNK UNK on_period UNK UNK on_tstring_beg on_tstring_content on_tstring_end UNK UNK on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl EMP EMP # check the saved response headers as well.
