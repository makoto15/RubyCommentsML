on_ignored_nl module on_const on_nl module on_const on_nl def UNK on_lparen UNK on_op UNK UNK on_rparen on_ignored_nl UNK on_op UNK UNK # frozen_string_literal: true
module on_const on_nl def UNK on_lparen UNK on_op UNK UNK on_rparen on_ignored_nl UNK on_op UNK UNK on_symbeg UNK UNK on_op # Active Record specific page scope methods implementations
def UNK on_lparen UNK on_op UNK UNK on_rparen on_ignored_nl UNK on_op UNK UNK on_symbeg UNK UNK on_op on_int on_op UNK # Used for page_entry_info
on_ivar on_op UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_op on_symbeg UNK UNK UNK on_op UNK #:nodoc:
UNK on_ivar if UNK on_lparen on_ivar on_rparen on_op on_ivar on_nl on_ignored_nl if UNK on_nl UNK on_ivar on_op on_int if on_lparen #:nodoc:
if UNK on_nl UNK on_ivar on_op on_int if on_lparen UNK on_op on_int on_rparen on_op on_ivar on_period UNK on_nl UNK on_ivar # There are some cases that total count can be deduced from loaded records
UNK on_ivar on_op on_int if on_lparen UNK on_op on_int on_rparen on_op on_ivar on_period UNK on_nl UNK on_ivar on_op on_lparen UNK # Total count has to be 0 if loaded records are 0
UNK on_ivar on_op on_lparen UNK on_op on_int on_rparen on_op limit_value on_op on_ivar on_period UNK if on_ivar on_period UNK on_op on_lparen # Total count is calculable at the last page
c on_op UNK on_lparen on_symbeg UNK UNK on_symbeg limit UNK on_symbeg UNK on_rparen on_nl c on_op c on_period UNK on_lparen # #count overrides the #select which could include generated columns referenced in #order, so skip #order here, where it's irrelevant to the result anyway
c on_op c on_period UNK on_lparen on_symbeg UNK on_rparen UNK UNK on_nl on_ignored_nl c on_op c on_period limit on_lparen UNK # Remove includes only if they are irrelevant
c on_op c on_period UNK on_lparen UNK on_rparen on_nl on_ivar on_op if c on_period UNK on_lparen on_const on_rparen on_op c # .group returns an OrderedHash that responds to #count
def UNK on_nl UNK on_op on_const on_op on_const on_nl end on_nl end on_nl on_ignored_nl module on_const on_nl module on_const on_nl # Turn this Relation to a "without count mode" Relation. # Note that the "without count mode" is supposed to be performant but has a feature limitation. # Pro: paginates without casting an extra SELECT COUNT query # Con: unable to know the total number of records/pages
module on_const on_nl module on_const on_nl UNK on_op on_const on_op on_const UNK on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen UNK # A module that makes AR::Relation paginatable without having to cast another SELECT COUNT query
UNK on_op on_const on_op on_const UNK on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar UNK on_symbeg limit # refine PaginatableWithoutCount do # NOTE: this doesn't work in Ruby < 2.4
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar UNK on_symbeg limit UNK on_op UNK on_nl on_ignored_nl if on_ivar on_nl UNK on_ivar # Update multiple instance variables that holds `limit` to a given value
UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl module on_const on_nl module on_const on_nl def UNK on_nl if UNK on_op # NOTE: ending all modules and reopening again because using has to be called from the toplevel in Ruby 2.0
def UNK on_nl if UNK on_op limit_value on_period UNK on_nl UNK on_nl UNK on_ignored_nl UNK limit_value on_op on_int on_nl UNK # Overwrite AR::Relation#load to actually load one more record to judge if the page has next page # then store the result in @_has_next ivar
def UNK on_nl on_op UNK on_op on_op on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK UNK on_nl on_ivar # The page wouldn't be the last page if there's "limit + 1" record
def UNK on_nl UNK UNK UNK on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK UNK # Empty relation needs no pagination
def UNK on_nl UNK UNK UNK UNK UNK UNK UNK on_nl end on_nl end on_nl end on_nl EMP EMP EMP # Force to raise an exception if #total_count is called explicitly.
