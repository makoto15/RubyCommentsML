UNK on_const on_nl def UNK on_lparen action on_comma subject on_comma on_op UNK on_rparen on_ignored_nl UNK on_op UNK on_lparen action on_comma # This module is designed to be included into an Ability class. This will # provide the "can" methods for defining and checking abilities. # # class Ability # include CanCan::Ability # # def initialize(user) # if user.admin? # can :manage, :all # else # can :read, :all # end # end # end #
def UNK on_lparen action on_comma subject on_comma on_op UNK on_rparen on_ignored_nl UNK on_op UNK on_lparen action on_comma subject on_rparen on_period # Check if the user has permission to perform a given action on an object. # # can? :destroy, @project # # You can also pass the class instead of an instance (if you don't have one handy). # # can? :create, Project # # Nested resources can be passed through a hash, this way conditions which are # dependent upon the association will work when using a class. # # can? :create, @category => Project # # Any additional arguments will be passed into the "can" block definition. This # can be used to pass more information about the user's request for example. # # can? :create, Project, request.remote_ip # # can :create, Project do |project, remote_ip| # # ... # end # # Not only can you use the can? method in the controller and view (see ControllerAdditions), # but you can also call it directly on an ability instance. # # ability.can? :destroy, @project # # This makes testing a user's abilities very easy. # # def test "user can only destroy projects which he owns" # user = User.new # ability = Ability.new(user) # assert ability.can?(:destroy, Project.new(:user => user)) # assert ability.cannot?(:destroy, Project.new) # end # # Also see the RSpec Matchers to aid in testing.
def UNK on_lparen on_op args on_rparen on_ignored_nl on_op UNK on_lparen on_op args on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Convenience method which works the same as "can?" but returns the opposite value. # # cannot? :destroy, @project #
def UNK on_lparen action on_op nil on_comma subject on_op nil on_comma UNK on_op nil on_comma on_op UNK on_rparen on_ignored_nl rules # Defines which abilities are allowed using two arguments. The first one is the action # you're setting the permission for, the second one is the class of object you're setting it on. # # can :update, Article # # You can pass an array for either of these parameters to match any one. # Here the user has the ability to update or destroy both articles and comments. # # can [:update, :destroy], [Article, Comment] # # You can pass :all to match any object and :manage to match any action. Here are some examples. # # can :manage, :all # can :update, :all # can :manage, Project # # You can pass a hash of conditions as the third argument. Here the user can only see active projects which he owns. # # can :read, Project, :active => true, :user_id => user.id # # See ActiveRecordAdditions#accessible_by for how to use this in database queries. These conditions # are also used for initial attributes when building a record in ControllerAdditions#load_resource. # # If the conditions hash does not give you enough control over defining abilities, you can use a block # along with any Ruby code you want. # # can :update, Project do |project| # project.groups.include?(user.group) # end # # If the block returns true then the user has that :update ability for that project, otherwise he # will be denied access. The downside to using a block is that it cannot be used to generate # conditions for database queries. # # You can pass custom objects into this "can" method, this is usually done with a symbol # and is useful if a class isn't available to define permissions on. # # can :read, :stats # can? :read, :stats # => true # # IMPORTANT: Neither a hash of conditions or a block will be used when checking permission on a class. # # can :update, Project, :priority => 3 # can? :update, Project # => true # # If you pass no arguments to +can+, the action, class, and object will be passed to the block and the # block will always be executed. This allows you to override the full behavior if the permissions are # defined in an external source such as the database. # # can do |action, object_class, object| # # check the database and return true/false # end #
def UNK on_lparen action on_op nil on_comma subject on_op nil on_comma UNK on_op nil on_comma on_op UNK on_rparen on_ignored_nl rules # Defines an ability which cannot be done. Accepts the same arguments as "can". # # can :read, :all # cannot :read, Comment # # A block can be passed just like "can", however if the logic is complex it is recommended # to use the "can" method. # # cannot :read, Product do |product| # product.invisible? # end #
def UNK on_lparen on_op args on_rparen on_ignored_nl target on_op args on_period UNK on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_lparen target # Alias one or more actions into another one. # # alias_action :update, :destroy, :to => :modify # can :modify, Comment # # Then :modify permission will apply to both :update and :destroy requests. # # can? :update, Comment # => true # can? :destroy, Comment # => true # # This only works in one direction. Passing the aliased action into the "can?" call # will not work because aliases are meant to generate more generic actions. # # alias_action :update, :destroy, :to => :modify # can :update, Comment # can? :modify, Comment # => false # # Unless that exact alias is used. # # can :modify, Comment # can? :modify, Comment # => true # # The following aliases are added by default for conveniently mapping common controller actions. # # alias_action :index, :show, :to => :read # alias_action :new, :to => :create # alias_action :edit, :to => :update # # This way one can use params[:action] in the controller to determine the permission.
def UNK on_lparen target on_rparen on_ignored_nl UNK on_const on_comma UNK on_tstring_content on_embexpr_beg target on_embexpr_end on_tstring_content UNK if aliased_actions on_period UNK # User shouldn't specify targets with names of real actions or it will cause Seg fault
def aliased_actions on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op UNK UNK on_nl end on_nl # Returns a hash of aliased actions. The key is the target and the value is an array of actions aliasing the key.
def UNK on_nl UNK on_op UNK UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma action on_rparen on_ignored_nl UNK # Removes previously aliased actions including the defaults.
def UNK on_lparen action on_comma subject on_comma on_op args on_rparen on_ignored_nl message on_op nil on_nl if args on_period UNK on_period # See ControllerAdditions#authorize! for documentation.
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK do on_op action on_op on_ignored_nl aliased_actions on_lbracket action on_rbracket on_op on_lbracket # Accepts an array of actions and returns an array of actions which match. # This should be called before "matches?" and other checking methods since they # rely on the actions to be expanded.
def UNK on_lparen action on_rparen on_ignored_nl UNK on_op on_lbracket action on_rbracket on_nl aliased_actions on_period UNK do on_op UNK on_comma UNK # Given an action, it will try to find all of the actions which are aliased to it. # This does the opposite kind of lookup as expand_actions.
def relevant_rules on_lparen action on_comma subject on_rparen on_ignored_nl rules on_period UNK on_period UNK do on_op rule on_op on_ignored_nl rule on_period # Returns an array of Rule instances which match the action and subject # This does not take into consideration any hash conditions or block statements
