UNK on_const on_nl on_ignored_nl on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg UNK on_nl UNK on_symbeg UNK on_nl on_ignored_nl # Supporting logic for the parser. # This supporting logic has slightly different responsibilities compared to the original Puppet::Parser::Parser. # It is only concerned with parsing. #
on_ignored_nl on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg UNK on_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK t # Note that the name of the contained class and the file name (currently parser_support.rb) # needs to be different as the class is generated by Racc, and this file (parser_support.rb) is included as a mix in #
on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg UNK on_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK t on_nl # Simplify access to the Model factory # Note that the parser/parser support does not have direct knowledge about the Model. # All model construction/manipulation is made by the Factory. #
def UNK t on_nl UNK t if t on_period UNK on_nl if t on_period is_a? on_lparen on_const on_rparen on_op t # Returns the token text of the given lexer token, or nil, if token is nil
t on_lbracket on_symbeg value on_rbracket on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_lbracket UNK on_comma # else it is a lexer token
def UNK on_lparen UNK on_rparen on_ignored_nl on_lbracket UNK on_comma UNK on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK # Produces the fully qualified name, with the full (current) namespace for a given name. # # This is needed because class bodies are lazily evaluated and an inner class' container(s) may not # have been evaluated before some external reference is made to the inner class; its must therefore know its complete name # before evaluation-time. #
def error on_lparen semantic on_comma UNK on_rparen on_ignored_nl except on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen on_nl if # Raises a Parse error with location information. Information about file is always obtained from the # lexer. Line and position is produced if the given semantic is a Positioned object and have been given an offset. #
def UNK on_lparen file on_rparen on_ignored_nl UNK on_const on_op on_const on_period UNK on_lparen file on_rparen on_nl UNK file on_op UNK # Parses a file expected to contain pp DSL logic.
def UNK on_lparen token on_comma value on_comma UNK on_rparen on_ignored_nl if token on_op UNK UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl # This is a callback from the generated parser (when an error occurs while parsing) #
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl else on_ignored_nl UNK on_op on_tstring_beg on_tstring_content UNK value on_lbracket on_symbeg value on_rbracket UNK on_tstring_content # denotes end of file
file on_op nil on_nl line on_op nil on_nl pos on_op nil on_nl if token on_op UNK on_nl file on_op value # Note, old parser had processing of "expected token here" - do not try to reinstate: # The 'expected' is only of value at end of input, otherwise any parse error involving a # start of a pair will be reported as expecting the close of the pair - e.g. "$x.each |$x {|", would # report that "seeing the '{', the '}' is expected. That would be wrong. # Real "expected" tokens are very difficult to compute (would require parsing of racc output data). Output of the stack # could help, but can require extensive backtracking and produce many options. # # The lexer should handle the "expected instead of end of file for strings, and interpolation", other expectancies # must be handled by the grammar. The lexer may have enqueued tokens far ahead - the lexer's opinion about this # is not trustworthy. #
UNK on_comma UNK on_op locator on_period UNK on_lparen value on_period UNK on_comma value on_period UNK on_rparen on_nl line on_op locator # The error occurs when doing sub-parsing and the token must be transformed # Transpose the local offset, length to global "coordinates"
file on_op UNK on_period file on_nl end on_nl file on_op nil UNK file on_period is_a? on_lparen on_const on_rparen on_op on_op # At end of input, use what the lexer thinks is the source file
def UNK on_lparen UNK on_comma UNK on_op nil on_rparen on_ignored_nl on_ivar on_period UNK on_lparen UNK on_comma UNK on_rparen on_nl UNK # Parses a String of pp DSL code. #
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_period UNK on_lparen on_ivar on_period locator on_comma # Mark the factory wrapped model object with location information # @return [Factory] the given factory # @api private #
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_period UNK on_lparen UNK on_comma UNK on_rparen # Mark the factory wrapped heredoc model object with location information # @return [Factory] the given factory # @api private #
UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_ignored_nl on_const on_period UNK on_lparen # The actual handling of mappings happens in PopsBridge
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen on_nl UNK on_const on_op on_const on_op # Transforms an array of expressions containing literal name expressions to calls if followed by an # expression, or expression list #
UNK on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen on_nl UNK on_const on_op on_const on_op e on_nl if e on_period UNK # Factory transform raises an error if a non qualified name is followed by an argument list # since there is no way that that can be transformed back to sanity. This occurs in situations like this: # # $a = 10, notice hello # # where the "10, notice" forms an argument list. The parser builds an Array with the expressions and includes # the comma tokens to enable the error to be reported against the first comma. #
if e on_period UNK on_period is_a? on_lparen on_const on_rparen on_op e on_period UNK on_period UNK on_op on_const on_op on_const on_nl # e.args[1] is the first comma token in the list # e.name_expr is the function name expression
def UNK on_lparen UNK on_comma UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_comma UNK on_comma # Transforms a LEFT followed by the result of attribute_operations, this may be a call or an invalid sequence
def UNK on_lparen UNK on_rparen on_ignored_nl locator on_op on_ivar on_period locator on_nl on_const on_period on_const on_lparen UNK on_comma UNK on_comma # Creates a program with the given body. #
def UNK on_lparen on_rparen on_ignored_nl locator on_op on_ivar on_period locator on_nl UNK on_op on_const on_period UNK on_lparen nil on_rparen on_nl # Creates an empty program with a single No-op at the input's EOF offset with 0 length. #
UNK on_comma token on_op on_ivar on_period UNK on_lparen on_lbracket on_symbeg on_const on_comma on_tstring_beg on_tstring_end on_comma UNK on_rbracket on_comma locator on_period # Create a synthetic NOOP token at EOF offset with 0 size. The lexer does not produce an EOF token that is # visible to the grammar rules. Creating this token is mainly to reuse the positioning logic as it # expects a token decorated with location information.
UNK on_op on_const on_period on_const on_lparen UNK on_comma on_lbracket on_rbracket on_comma locator on_rparen on_nl UNK on_nl end on_nl on_ignored_nl def # Program with a Noop
def UNK on_lparen on_rparen on_ignored_nl UNK on_ignored_nl on_ivar on_op UNK on_nl UNK on_op UNK on_lparen on_ivar on_comma on_symbeg UNK on_rparen # Performs the parsing and returns the resulting model. # The lexer holds state, and this is setup with {#parse_string}, or {#parse_file}. # # @api private #
