UNK on_const on_op on_const on_op on_const on_nl on_const on_op on_const on_op self on_nl UNK on_const on_op on_const on_op on_const on_nl # Puppet::Resource::Type represents nodes, classes and defined types. # # @api public
on_const on_op on_lbrace on_ignored_nl on_symbeg hostclass on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_symbeg node on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl # Map the names used in our documentation to the names used internally
on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg type on_nl on_ignored_nl on_const on_period each do on_op t on_op on_ignored_nl UNK # The attributes 'produces' and 'consumes' are arrays of the blueprints # of capabilities this type can produce/consume. The entries in the array # are a fairly direct representation of what goes into produces/consumes # clauses. Each entry is a hash with attributes # :capability - the type name of the capres produced/consumed # :mappings - a hash of attribute_name => Expression # These two attributes are populated in # PopsBridge::instantiate_CapabilityMapping
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg type on_nl on_ignored_nl on_const on_period each do on_op t on_op on_ignored_nl UNK on_lparen # Map from argument (aka parameter) names to Puppet Type # @return [Hash<Symbol, Puppet::Pops::Types::PAnyType] map from name to type #
UNK on_symbeg type on_nl on_ignored_nl on_const on_period each do on_op t on_op on_ignored_nl UNK on_lparen on_tstring_beg on_embexpr_beg t on_embexpr_end on_tstring_content # This should probably be renamed to 'kind' eventually, in accordance with the changes # made for serialization and API usability (#14137). At the moment that seems like # it would touch a whole lot of places in the code, though. --cprice 2012-04-23
def UNK on_lparen klass on_rparen on_ignored_nl return UNK unless parent on_nl on_ignored_nl return on_lparen klass on_op UNK on_op UNK on_op # Are we a child of the passed class? Do a recursive search up our # parentage tree to figure it out.
def UNK on_lparen resource on_comma scope on_rparen on_ignored_nl return unless UNK on_op UNK on_nl on_ignored_nl resource on_period UNK on_period UNK # Evaluate the resources produced by the given resource. These resources are # evaluated in a separate but identical scope from the rest of the resource.
return unless UNK on_op UNK on_nl on_ignored_nl resource on_period UNK on_period UNK do on_op ex on_op on_ignored_nl raise on_const on_op # Only defined types and classes can produce capabilities
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label resource on_period UNK on_comma on_label ex # Assert that the ref really is a resource reference
produced_resource on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg scope on_period catalog on_period UNK on_embexpr_end on_tstring_end on_rparen on_nl scope on_period catalog on_period # Tag the produced resource so we can later distinguish it from # copies of the resource that wind up in the catalogs of nodes that # use this resource. We tag the resource with producer:<environment>, # meaning produced resources need to be unique within their # environment # @todo lutter 2014-11-13: we would really like to use a dedicated # metadata field to indicate the producer of a resource, but that # requires changes to PuppetDB and its API; so for now, we just use # tagging
def UNK on_lparen resource on_rparen on_ignored_nl on_ignored_nl UNK on_op UNK on_lparen resource on_rparen on_nl scope on_op UNK on_op resource on_period # Now evaluate the code associated with this class or definition.
scope on_period UNK do on_ignored_nl scope on_period UNK on_lparen on_ivar on_comma UNK on_comma UNK on_rparen on_nl code on_period UNK on_lparen # Only bother setting up the ephemeral scope if there are match variables to add into it
def UNK on_lparen string on_rparen on_ignored_nl return string on_period to_s on_period downcase on_op name unless UNK on_nl on_ignored_nl on_ivar on_op # This is only used for node names, and really only when the node name # is a regexp.
def UNK on_lparen other on_rparen on_ignored_nl UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label name on_rbrace unless type # Add code from a new instance to our code.
unless other on_period code on_period UNK on_nl UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl if # It is ok to merge definitions into main even if freeze is on (definitions are nodes, classes, defines, functions, and types)
self on_period parent on_op other on_period parent on_nl on_ignored_nl if other on_period doc on_nl self on_period doc on_op on_tstring_beg on_tstring_end # We know they're either equal or only one is set, so keep whichever parent is specified.
return unless other on_period code on_nl on_ignored_nl unless self on_period code on_nl self on_period code on_op other on_period code on_nl # This might just be an empty, stub class.
def UNK on_lparen scope on_comma parameters on_op nil on_rparen on_ignored_nl resource_type on_op on_ignored_nl UNK type on_nl UNK on_symbeg UNK on_nl # Make an instance of the resource type, and place it in the catalog # if it isn't in the catalog already. This is only possible for # classes and nodes. No parameters are be supplied--if this is a # parameterized class, then all parameters take on their default # values.
if parameters on_period nil? on_nl resource on_op scope on_period catalog on_period resource on_lparen resource_type on_comma name on_rparen on_nl return resource # Do nothing if the resource already exists; this makes sure we don't # get multiple copies of the class resource, which helps provide the # singleton nature of classes. # we should not do this for classes with parameters # if parameters are passed, we should still try to create the resource # even if it exists so that we can fail # this prevents us from being able to combine param classes with include
if parent on_op on_op scope on_period catalog on_period resource on_lparen resource on_period type on_comma parent on_rparen on_nl UNK on_lparen scope # Make sure our parent class has been evaluated, if we have one.
def UNK on_lparen parameters on_comma resource on_rparen on_ignored_nl on_const on_period UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl # @deprecated Not used by Puppet # @api private
parameters on_period each do on_op name on_comma value on_op on_ignored_nl resource on_period UNK name on_comma value on_nl end on_nl end # It'd be nice to assign default parameter values here, # but we can't because they often rely on local variables # created during set_resource_parameters.
def UNK on_lparen resource on_comma scope on_rparen on_ignored_nl UNK on_op resource on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl scope on_lbracket # Validate and set any arguments passed by the resource as variables in the scope. # # This method is known to only be used on the server/compile side. # # @param resource [Puppet::Parser::Resource] the resource # @param scope [Puppet::Parser::Scope] the scope # # @api private
UNK on_op resource on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl scope on_lbracket on_const on_rbracket on_op UNK unless UNK on_period nil? # Inject parameters from using external lookup
resource on_period each on_lbrace on_op k on_comma UNK on_op param_scope on_lbracket k on_period to_s on_rbracket on_op UNK on_period value unless # Assign directly to the parameter scope to avoid scope parameter validation at this point. It # will happen anyway when the values are assigned to the scope after the parameter scoped has # been popped.
UNK on_period each on_lbrace on_op param on_comma value on_op UNK on_lbrace scope on_lbracket param on_rbracket on_op value on_rbrace on_rbrace on_nl # Assign parameter values to current scope
def UNK on_lparen resource on_comma scope on_rparen on_ignored_nl return unless type on_op on_symbeg hostclass on_nl parameters on_op resource on_period parameters # Lookup and inject parameters from external scope # @param resource [Puppet::Parser::Resource] the resource # @param scope [Puppet::Parser::Scope] the scope
return unless type on_op on_symbeg hostclass on_nl parameters on_op resource on_period parameters on_nl arguments on_period each do on_op param_name on_comma # Only lookup parameters for host classes
resource on_lbracket UNK on_rbracket on_op UNK unless UNK on_period nil? on_op on_op default on_period nil? on_nl end on_nl end on_nl # Assign bound value but don't let an undef trump a default expression
def UNK on_lparen resource on_rparen on_ignored_nl UNK on_op on_const on_period new on_lparen resource on_period UNK on_rparen on_nl UNK on_lparen resource # Validate that all parameters given to the resource are correct # @param resource [Puppet::Resource] the resource to validate
UNK on_op on_const on_period new on_lparen resource on_period UNK on_rparen on_nl UNK on_lparen resource on_comma on_ignored_nl on_const on_lbracket resource on_period # Since Sensitive values have special encoding (in a separate parameter) an unwrapped sensitive value must be # recreated as a Sensitive in order to perform correct type checking.
def UNK on_lparen param on_rparen on_ignored_nl UNK on_period UNK on_period UNK on_lparen param on_period to_s on_rparen on_nl end on_nl on_ignored_nl # Check whether a given argument is valid.
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_op nil on_nl return unless UNK on_nl UNK # Sets the argument name to Puppet Type hash used for type checking. # Names must correspond to available arguments (they must be defined first). # Arguments not mentioned will not be type-checked. #
unless on_ivar on_period UNK on_lparen name on_rparen on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op # catch internal errors
def UNK on_nl UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen name on_rparen on_ignored_nl value on_op name # Returns boolean true if an instance of this type is a capability. This # implementation always returns false. This "duck-typing" interface is # shared among other classes and makes it easier to detect capabilities # when they are intermixed with non capability instances.
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_lparen on_const on_rparen on_nl UNK on_op UNK on_period UNK # Split an fq name into a namespace and name
on_ivar on_comma _ on_op on_ivar on_op on_symbeg hostclass on_op on_lbracket on_ivar on_comma on_tstring_beg on_tstring_end on_rbracket on_op UNK on_lparen on_ivar on_rparen # Note we're doing something somewhat weird here -- we're setting # the class's namespace to its fully qualified name. This means # anything inside that class starts looking in that namespace first.
UNK on_lbracket name on_period to_s on_rbracket on_op type_factory on_period UNK on_nl end on_nl on_ignored_nl arguments on_period UNK do on_op name # TODO: Once meta parameters are typed, this should change to reflect that type
