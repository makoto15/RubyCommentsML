def self on_period UNK on_lparen UNK on_comma UNK on_op on_lbrace on_rbrace on_comma on_op UNK on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace # Create a new check mechanism. It's basically a parameter that # provides one extra 'check' method.
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl def UNK # Make output a bit prettier
def UNK on_nl if on_ivar on_period UNK on_nl return on_symbeg UNK on_nl else on_ignored_nl return self on_period should on_nl end # First verify that all of our checks pass.
if on_ivar on_period UNK on_nl return on_symbeg UNK on_nl else on_ignored_nl return self on_period should on_nl end on_nl end on_nl # We need to return :notrun to trigger evaluation; when that isn't # true, we *LIE* about what happened and return a "success" for the # value, which causes us to be treated as in_sync?, which means we # don't actually execute anything. I think. --daniel 2011-03-10
def UNK on_nl UNK on_op on_symbeg UNK on_nl tries on_op self on_period UNK on_lbracket on_symbeg tries on_rbracket on_nl try_sleep on_op # Actually execute the command.
debug on_lparen on_tstring_beg on_tstring_content UNK UNK on_op on_int UNK on_tstring_content UNK tries UNK on_tstring_end on_rparen if tries on_op on_int on_nl # Only add debug messages for tries > 1 to reduce log spam.
self on_period UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label on_ivar on_period exitstatus on_comma on_label self on_period # Don't print sensitive commands in the clear
def UNK on_lparen on_op values on_rparen on_ignored_nl on_ivar on_op values on_period UNK on_period UNK on_lbrace on_op val on_op on_ignored_nl val # Support both arrays and colon-separated fields.
end on_nl on_ignored_nl newparam on_lparen on_symbeg UNK on_comma on_symbeg UNK on_op on_const on_op on_const on_op on_const on_rparen do on_ignored_nl desc # Validation is handled by the SUIDManager class.
def check on_lparen value on_rparen on_ignored_nl if value on_op on_symbeg true on_nl false on_nl else on_ignored_nl true on_nl end on_nl # We always fail this test, because we're only supposed to run # on refresh.
if value on_op on_symbeg true on_nl false on_nl else on_ignored_nl true on_nl end on_nl end on_nl end on_nl on_ignored_nl UNK # We have to invert the values.
def check on_lparen value on_rparen on_ignored_nl debug on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label value on_rbrace on_rparen # If the file exists, return false (i.e., don't run the command), # else return true
debug on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label value on_rbrace on_rparen on_nl on_op on_const on_op on_const on_period #TRANSLATORS 'creates' is a parameter name and should not be translated
def check on_lparen value on_rparen on_ignored_nl UNK on_ignored_nl output on_comma UNK on_op provider on_period UNK on_lparen value on_comma true on_rparen # Return true if the command does not return 0.
def check on_lparen value on_rparen on_ignored_nl UNK on_ignored_nl output on_comma UNK on_op provider on_period UNK on_lparen value on_comma true on_rparen # Return true if the command returns 0.
on_ivar on_op false on_nl on_ignored_nl validate do on_ignored_nl provider on_period UNK on_lparen self on_lbracket on_symbeg command on_rbracket on_rparen on_nl end # Exec names are not isomorphic with the objects.
UNK on_lparen on_symbeg UNK on_rparen do on_ignored_nl reqs on_op on_lbracket on_rbracket on_nl on_ignored_nl reqs on_op self on_lbracket on_symbeg UNK on_rbracket # FIXME exec should autorequire any exec that 'creates' our cwd
reqs on_op self on_lbracket on_symbeg UNK on_rbracket if self on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl UNK on_op on_const on_op on_const # Stick the cwd in there if we have it
reqs on_op line on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_rbrace on_nl on_ignored_nl reqs on_period UNK on_nl on_ignored_nl reqs # And search the command line for files, adding any we # find. This will also catch the command itself if it's # fully qualified. It might not be a bad idea to add # unqualified files, but, well, that's a bit more annoying # to do.
reqs on_period UNK on_nl on_ignored_nl reqs on_nl end on_nl on_ignored_nl UNK on_lparen on_symbeg user on_rparen do on_ignored_nl user on_op self # For some reason, the += isn't causing a flattening
user on_op self on_lbracket on_symbeg user on_rbracket on_nl if user on_op user on_op on_regexp_beg on_tstring_content on_regexp_end on_nl user on_nl end # Autorequire users if they are specified by name
def UNK on_lparen UNK on_op false on_rparen on_ignored_nl self on_period UNK on_period UNK on_period each on_lbrace on_op check on_op on_ignored_nl # Verify that we pass all of the checks. The argument determines whether # we skip the :refreshonly check, which is necessary because we now check # within refresh
UNK on_op on_ivar on_lbracket on_symbeg command on_rbracket on_period sensitive on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_lbracket on_symbeg command on_rbracket on_period # Give a debug message so users can figure out what command would have been # but don't print sensitive commands or parameters in the clear
def UNK on_nl if self on_period UNK on_lparen true on_rparen on_nl UNK on_op self on_lbracket on_symbeg UNK on_rbracket on_nl if # Run the command, or optionally run a separately-specified command.
sensitive on_op false on_nl UNK on_op on_lbracket on_symbeg command on_comma on_symbeg unless on_comma on_symbeg UNK on_rbracket on_nl on_ignored_nl UNK on_period # If any are sensitive, mark all as sensitive
