on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_const on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_period UNK on_symbeg UNK # Manage systemd services using systemctl
defaultfor on_symbeg operatingsystem on_op on_symbeg on_const on_nl UNK on_symbeg operatingsystem on_op on_symbeg on_const on_comma on_symbeg operatingsystemmajrelease on_op on_lbracket on_tstring_beg on_tstring_content # These are using the "debian" method
defaultfor on_symbeg operatingsystem on_op on_symbeg UNK on_nl UNK on_symbeg operatingsystem on_op on_symbeg UNK on_comma on_symbeg operatingsystemmajrelease on_op on_lbracket on_tstring_beg on_tstring_content # These are using upstart
defaultfor on_symbeg operatingsystem on_op on_symbeg UNK on_comma on_symbeg operatingsystemmajrelease on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl # These are using upstart
def UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK on_lbracket on_symbeg output on_rbracket on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_period # Static services cannot be enabled or disabled manually. Indirect services # should not be enabled or disabled due to limitations in systemd (see # https://github.com/systemd/systemd/issues/6681).
def UNK on_lparen action on_rparen on_ignored_nl output on_op systemctl on_lparen action on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_lbracket on_symbeg name # This helper ensures that the enable state cache is always reset # after a systemctl enable operation. A particular service state is not guaranteed # after such an operation, so the cache must be emptied to prevent inconsistencies # in the provider's believed state of the service and the actual state. # @param action [String,Symbol] One of 'enable', 'disable', 'mask' or 'unmask'
if on_ivar on_lbracket on_symbeg name on_rbracket on_op UNK on_tstring_content UNK on_nl UNK on_op on_ivar on_lbracket on_symbeg name on_rbracket on_period UNK # Start links don't include '.service'. Just search for the service name.
return on_symbeg UNK if on_lparen on_ivar on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_rparen on_op on_lparen output on_op on_tstring_beg on_tstring_content # The masked state is equivalent to the disabled state in terms of # comparison so we only care to check if it is masked if we want to keep # it masked. # # We only return :mask if we're trying to mask the service. This prevents # flapping when simply trying to disable a masked service.
return on_symbeg false if output on_op on_tstring_beg on_tstring_content on_tstring_end on_nl return on_symbeg true if on_lparen UNK on_op on_int on_rparen on_nl # The indirect state indicates that the unit is not enabled.
def UNK on_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_lbracket on_symbeg # This method is required for Debian systems due to the way the SysVInit-Systemd # compatibility layer works. When we are trying to manage a service which does not # have a Systemd unit file, we need to go through the old init script to determine # whether it is enabled or not. See PUP-5016 for more details. #
if UNK on_op on_int on_nl return on_symbeg true on_nl UNK on_ignored_nl return on_symbeg false on_nl end on_nl UNK on_ignored_nl return # 101 is action not allowed, which means we have to do the check manually. # 105 is unknown, which generally means the initscript does not support query # The debian policy states that the initscript should support methods of query # For those that do not, perform the checks manually # http://www.debian.org/doc/debian-policy/ch-opersys.html
def UNK on_nl UNK on_op on_lbracket command on_lparen on_symbeg systemctl on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma # Define the daemon_reload? function to check if the unit is requiring to trigger a "systemctl daemon-reload" # If the unit file is flagged with NeedDaemonReload=yes, then a systemd daemon-reload will be run. # If multiple unit files have been updated, the first one flagged will trigger the daemon-reload for all of them. # The others will be then flagged with NeedDaemonReload=no. So the command will run only once in a puppet run. # This function is called only on start & restart unit options. # Reference: (PUP-3483) Systemd provider doesn't scan for changed units
