UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_nl # Factory is a helper class that makes construction of a Pops Model # much more convenient. It can be viewed as a small internal DSL for model # constructions. # For usage see tests using the factory. # # @todo All those uppercase methods ... they look bad in one way, but stand out nicely in the grammar... # decide if they should change into lower case names (some of the are lower case)... #
on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_nl on_const on_op on_tstring_beg # Shared build_visitor, since there are many instances of Factory being used
unless on_ivar on_period UNK on_lparen on_const on_rparen on_nl on_ivar on_lbracket on_const on_rbracket on_op on_const on_op on_const on_period locator on_lparen on_tstring_beg # Assign a default Locator if it's missing. Should only happen when the factory is used by other # means than from a parser (e.g. unit tests)
UNK UNK model on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK on_lbrace on_op key on_comma UNK on_op on_ivar on_lbracket key # Backward API compatibility
def UNK on_lparen o on_comma on_op args on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl if o on_period instance_of? on_lparen on_const # Initialize a factory with a single object, or a class with arguments applied to build of # created instance #
UNK on_comma UNK on_op locator on_period UNK on_lparen o on_period UNK on_comma o on_period UNK on_rparen on_nl on_ignored_nl o on_period # Transpose the local offset, length to global "coordinates"
o on_period UNK on_lparen on_symbeg on_tstring_content on_tstring_end on_comma UNK on_rparen on_nl o on_period UNK on_lparen on_symbeg on_tstring_content on_tstring_end on_comma UNK # mutate
o on_period UNK on_lparen on_symbeg on_tstring_content on_tstring_end on_comma locator on_period locator on_rparen if locator on_period is_a? on_const on_op on_const on_op # Change locator since the positions were transposed to the global coordinates
def UNK on_lparen on_rparen on_ignored_nl on_const on_period UNK on_lparen self on_comma on_ivar on_comma on_const on_rparen on_nl end on_nl on_ignored_nl on_ignored_nl # Polymorphic interpolate
on_ignored_nl def UNK on_lparen o on_comma UNK on_comma UNK on_comma body on_rparen on_ignored_nl on_ivar on_lbracket on_const on_rbracket on_op UNK on_nl # Building of Model classes
on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op value on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma value on_rparen on_ignored_nl # BOOLEAN is allowed in the grammar
def UNK on_lparen o on_comma functor on_comma rval_required on_comma args on_rparen on_ignored_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op functor # @param rval_required [Boolean] if the call must produce a value
on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op args on_period UNK on_lbrace on_op arg on_op arg on_period model_class on_op on_const on_op # Strip empty segments
def UNK on_lparen o on_comma name on_comma parameters on_comma UNK on_comma body on_rparen on_ignored_nl UNK on_lparen o on_comma name on_comma # @param name [String] a valid classname # @param parameters [Array<Parameter>] may be empty # @param parent_class_name [String, nil] a valid classname referencing a parent class, optional. # @param body [Array<Expression>, Expression, nil] expression that constitute the body # @return [HostClassDefinition] configured from the parameters #
on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl on_ivar on_op on_const on_nl on_ivar on_lbracket on_const on_rbracket on_op o on_nl end on_nl # Building model equivalences of Ruby objects # Allows passing regular ruby objects to the factory to produce instructions # that when evaluated produce the same thing.
def UNK on_lparen o on_rparen on_ignored_nl UNK o on_nl UNK on_symbeg UNK on_nl on_ivar on_op on_const on_nl UNK on_symbeg UNK # Creates a String literal, unless the symbol is one of the special :undef, or :default # which instead creates a LiterlUndef, or a LiteralDefault. # Supports :undef because nil creates a no-op instruction.
def UNK on_lparen o on_rparen on_ignored_nl on_ivar on_op on_const on_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op o on_period map # Creates a LiteralList instruction from an Array, where the entries are built.
def UNK on_lparen o on_rparen on_ignored_nl on_ivar on_op on_const on_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op o on_period UNK # Create a LiteralHash instruction from a hash, where keys and values are built # The hash entries are added in sorted order based on key.to_s #
b on_op f_build_body on_lparen body on_rparen on_nl on_ivar on_lbracket on_const on_rbracket on_op b unless b on_period nil? on_nl end on_nl # no nop here
def UNK on_lparen o on_comma token on_comma UNK on_rparen on_ignored_nl on_ivar on_lbracket on_const on_rbracket on_op UNK on_nl on_ivar on_lbracket on_const # Builds a SubLocatedExpression - this wraps the expression in a sublocation configured # from the given token # A SubLocated holds its own locator that is used for subexpressions holding positions relative # to what it describes. #
end on_nl on_ignored_nl def UNK on_lparen o on_comma UNK on_comma value on_rparen on_ignored_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op # index of lines in sublocated
parent on_op type_expr on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_op type_expr on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_op # KeyedEntry is used for the form: # # type Foo = Bar { ... } # # The entry contains Bar => { ... } and must be transformed into: # # Object[{parent => Bar, ... }] #
type_expr on_op on_const on_period on_const on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_lparen on_lbracket type_expr on_rbracket on_rparen on_nl end on_nl # LiteralHash is used for the form: # # type Foo = { ... } # # The hash must be transformed into: # # Object[{ ... }] #
on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op UNK on_nl on_ivar on_lbracket on_const on_rbracket on_op locator on_nl end on_nl on_ignored_nl def # non containment
def f_build_unary on_lparen klazz on_comma expr on_rparen on_ignored_nl on_const on_period new on_lparen klazz on_comma expr on_rparen on_nl end on_nl on_ignored_nl # Factory helpers
def UNK on_lparen r on_rparen f_build_binary on_lparen on_const on_comma self on_comma r on_rparen on_semicolon end on_nl on_ignored_nl def UNK on_lparen # Operator helpers
def UNK on_lparen on_op r on_rparen on_ignored_nl f_build_binary on_lparen on_const on_comma self on_comma r on_period map on_lbrace on_op arg on_op # Same as access, but with varargs and arguments that must be inferred. For testing purposes
def UNK on_lparen r on_rparen on_ignored_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_const on_period on_const on_lparen on_const on_period infer # For CaseExpression, setting the default for an already build CaseExpression
def UNK on_lparen r on_rparen on_ignored_nl f_build_binary_op on_lparen on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma self on_comma r on_rparen on_nl end # Assignment =
def UNK on_lparen r on_rparen on_ignored_nl f_build_binary_op on_lparen on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma self on_comma r on_rparen on_nl end # Assignment +=
def UNK on_lparen r on_rparen on_ignored_nl f_build_binary_op on_lparen on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma self on_comma r on_rparen on_nl end # Assignment -=
def UNK on_lparen locator on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_nl on_ivar on_lbracket on_const on_rbracket # Records the position (start -> end) and computes the resulting length. #
UNK on_op UNK on_period UNK on_nl on_ivar on_lbracket on_const on_rbracket on_op locator on_nl on_ivar on_lbracket on_const on_rbracket on_op UNK on_nl # record information directly in the Positioned object
def self on_period UNK on_lparen expr on_comma UNK on_rparen on_ignored_nl return false unless expr on_period instance_of? on_lparen self on_rparen on_op # Sets the form of the resource expression (:regular (the default), :virtual, or :exported). # Produces true if the expression was a resource expression, false otherwise. #
return false unless expr on_period instance_of? on_lparen self on_rparen on_op expr on_period model_class on_op on_const on_nl expr on_lbracket on_tstring_beg on_tstring_content # Note: Validation handles illegal combinations
def self on_period UNK on_lparen expr on_rparen on_ignored_nl if expr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_symbeg UNK on_nl elsif expr # Returns symbolic information about an expected shape of a resource expression given the LHS of a resource expr. # # * `name { }` => `:resource`, create a resource of the given type # * `Name { }` => ':defaults`, set defaults for the referenced type # * `Name[] { }` => `:override`, overrides instances referenced by LHS # * _any other_ => ':error', all other are considered illegal #
lhs on_op expr on_lbracket on_const on_rbracket on_nl if lhs on_period model_class on_op on_const on_op lhs on_lbracket on_const on_rbracket on_op on_tstring_beg # if Resource[e], then it is not resource specific
on_ignored_nl def self on_period UNK on_lparen o on_rparen on_semicolon infer on_lparen o on_rparen on_semicolon end on_nl on_ignored_nl def self on_period # Factory starting points
on_ignored_nl def UNK on_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op true on_nl end on_nl on_ignored_nl def type_expr on_lparen o # Parameters
def UNK on_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op true on_nl end on_nl on_ignored_nl def type_expr on_lparen o on_rparen # Mark parameter as capturing the rest of arguments
def type_expr on_lparen o on_rparen on_ignored_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op o on_nl end on_nl on_ignored_nl def self # Set Expression that should evaluate to the parameter's type
def self on_period UNK on_lparen o on_rparen on_ignored_nl o on_period instance_of? on_lparen on_const on_rparen on_op o on_period model_class on_op on_const # Creates a QualifiedName representation of o, unless o already represents a QualifiedName in which # case it is returned. #
def self on_period UNK on_lparen o on_rparen on_ignored_nl o on_period instance_of? on_lparen on_const on_rparen on_op o on_period model_class on_op on_const # Creates a QualifiedName representation of o, unless o already represents a QualifiedName in which # case it is returned. #
model on_op UNK on_period model on_nl locator on_op token on_period locator on_nl UNK on_period UNK on_lparen model on_comma locator on_rparen # expr is a Factory wrapped LiteralString, or ConcatenatedString # The token is SUBLOCATED token which has a SubLocator as the token's locator # Use the SubLocator to recalculate the offsets and lengths.
UNK on_nl end on_nl on_ignored_nl def self on_period on_const on_lparen expr on_rparen on_ignored_nl new on_lparen on_const on_comma infer on_lparen expr # Returned the factory wrapping the now offset/length transformed expression(s)
def self on_period on_const on_lparen o on_rparen on_ignored_nl new on_lparen on_const on_comma o on_rparen on_nl end on_nl on_ignored_nl def self # TODO_EPP
def self on_period on_const on_lparen name on_rparen on_ignored_nl new on_lparen on_const on_comma name on_rparen on_nl end on_nl on_ignored_nl def self # TODO: This is the same a fqn factory method, don't know if callers to fqn and QNAME can live with the # same result or not yet - refactor into one method when decided. #
UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl on_lbrace UNK UNK on_rbrace on_nl end on_nl end on_nl # Bad number should already have been caught by lexer - this should never happen #TRANSLATORS 'NUMBER' refers to a method name and the 'name_or_numeric' was the passed in value and should not be translated
def self on_period on_const on_lparen name on_rparen on_ignored_nl n_radix on_op on_const on_period UNK on_lparen name on_rparen on_nl if n_radix on_nl # Convert input string to either a qualified name, a LiteralInteger with radix, or a LiteralFloat #
def self on_period UNK on_lparen name on_comma rval_required on_comma on_op argument_list on_rparen on_ignored_nl new on_lparen on_const on_comma UNK on_lparen name # Same as CALL_NAMED but with inference and varargs (for testing purposes)
def self on_period UNK on_lparen args on_comma UNK on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl if args on_period UNK # Builds a BlockExpression if args size > 1, else the single expression/value in args
if on_op UNK on_period nil? on_op on_op UNK on_period nil? on_nl UNK on_period UNK on_lparen args on_period UNK on_lbracket on_const # If given a left and right brace position, use those # otherwise use the first and last element of the block
on_tstring_beg on_tstring_content on_tstring_end on_op true on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op true on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op true on_nl # discontinued, but transform it to make it call error reporting function
def self on_period UNK on_lparen name on_rparen on_ignored_nl on_const on_period UNK on_lparen name on_rparen on_nl end on_nl on_ignored_nl UNK on_const # Returns true if the given name is a "statement keyword" (require, include, contain, # error, notice, info, debug #
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen on_lbracket on_rbracket on_rparen UNK on_op UNK on_comma expr # Transforms an array of expressions containing literal name expressions to calls if followed by an # expression, or expression list. #
UNK on_period UNK on_lparen name on_lbracket on_const on_rbracket on_comma name on_comma expr on_lbracket on_op on_int on_rbracket on_rparen on_nl UNK on_lbracket # last positioned is last arg if there are several
expr on_period rval_required on_op true on_nl end on_nl elsif expr on_period is_a? on_lparen on_const on_rparen on_nl UNK on_const on_period new # Patch statement function call to expression style # This is needed because it is first parsed as a "statement" and the requirement changes as it becomes # an argument to the name to call transform above.
expr on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op false on_nl end on_nl end on_nl UNK on_nl end on_nl end on_nl on_ignored_nl # Patch rvalue expression function call to statement style. # This is not really required but done to be AST model compliant
def self on_period UNK on_lparen left on_comma UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl return nil unless UNK on_period is_a? # Transforms a left expression followed by an untitled resource (in the form of attribute_operations) # @param left [Factory, Expression] the lhs followed what may be a hash
return nil unless UNK on_period is_a? on_const on_nl return nil unless left on_period model_class on_op on_const on_nl UNK on_op UNK # Returning nil means accepting the given as a potential resource expression
self on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen c on_rparen on_ignored_nl self on_nl end on_nl on_ignored_nl def UNK # convert number to a variable
def UNK on_lparen c on_rparen on_ignored_nl lhs on_op on_ivar on_lbracket on_const on_rbracket on_nl if UNK on_lparen lhs on_rparen on_nl on_ivar # rewrite left expression to variable if it is name, number, and recurse if it is an access expression # this is for interpolation support in new lexer (${NAME}, ${NAME[}}, ${NUMBER}, ${NUMBER[]} - all # other expressions requires variables to be preceded with $ #
def UNK on_lparen c on_rparen on_ignored_nl UNK on_op on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl if UNK on_lparen UNK on_rparen # Rewrite method calls on the form ${x.each ...} to ${$x.each}
o on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_int on_nl else on_ignored_nl false on_nl end on_nl end on_nl on_ignored_nl def self # Only decimal integers can represent variables, else it is a number
