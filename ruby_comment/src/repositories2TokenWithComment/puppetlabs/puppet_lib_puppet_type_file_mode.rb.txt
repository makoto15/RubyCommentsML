on_ignored_nl on_ignored_nl UNK on_const on_nl on_const on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen on_symbeg UNK on_rparen # Manage file modes. This state should support different formats # for specification (e.g., u+rwx, or -0011), but for now only supports # specifying the full mode.
def UNK on_lparen value on_rparen on_ignored_nl if on_const on_period UNK on_lparen UNK UNK on_symbeg UNK UNK on_rparen UNK value on_op # If we're a directory, we need to be executable for all cases # that are readable. This should probably be selectable, but eh.
def UNK on_lparen currentvalue on_rparen on_ignored_nl if UNK on_period UNK on_lparen on_symbeg UNK on_rparen on_nl UNK on_op UNK on_period UNK # If we're not following links and we're a link, then we just turn # off mode management entirely.
def UNK on_nl if on_ivar on_period stat on_nl on_ivar on_op on_ivar on_period UNK UNK on_op UNK on_op UNK on_period UNK # Ideally, dirmask'ing could be done at munge time, but we don't know if 'ensure' # will eventually be a directory or something else. And unfortunately, that logic # depends on the ensure, source, and target properties. So rather than duplicate # that logic, and get it wrong, we do dirmask during retrieve, after 'ensure' has # been synced.
def UNK on_nl current on_op on_ivar on_period stat on_op on_ivar on_period stat on_period UNK on_op on_int on_nl UNK on_lparen UNK # Finally, when we sync the mode out we need to transform it; since we # don't have access to the calculated "desired" value here, or the # "current" value, only the "should" value we need to retrieve again.
UNK on_nl UNK on_ignored_nl on_tstring_beg on_tstring_content on_embexpr_beg currentvalue on_period UNK on_lparen on_int on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_embexpr_end on_tstring_content on_tstring_end # This can occur during audits---if a file is transitioning from # present to absent the mode will have a value of `:absent`.
