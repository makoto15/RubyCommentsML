on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_op on_const on_nl UNK UNK regex on_nl on_ignored_nl UNK UNK on_lparen # encoding: utf-8
if pattern on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ignored_nl elsif # A pattern starting with a hash ('#') serves as a comment # (neither includes nor excludes files). Escape the hash with a # back-slash to match a literal hash (i.e., '\#').
elsif pattern on_period UNK on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ignored_nl elsif pattern on_op UNK on_tstring_content UNK # A blank pattern is a null-operation (neither includes nor # excludes files).
elsif pattern on_op UNK on_tstring_content UNK on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ignored_nl else on_ignored_nl if pattern # Patterns containing three or more consecutive stars are invalid and # will be ignored.
else on_ignored_nl if pattern on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ivar on_op UNK on_nl pattern on_op pattern on_lbracket # We have a valid pattern!
if pattern on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ivar on_op UNK on_nl pattern on_op pattern on_lbracket on_int on_op # A pattern starting with an exclamation mark ('!') negates the # pattern (exclude instead of include). Escape the exclamation # mark with a back-slash to match a literal exclamation mark # (i.e., '\!').
pattern on_op pattern on_lbracket on_int on_op on_op on_int on_rbracket on_nl else on_ignored_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl if # Remove leading exclamation mark.
if pattern on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl pattern on_op pattern on_lbracket on_int on_op on_op on_int on_rbracket on_nl # Remove leading back-slash escape for escaped hash ('#') or # exclamation mark ('!').
pattern_segs on_op pattern on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end UNK on_op on_int on_rparen on_nl on_ignored_nl on_ignored_nl if pattern_segs on_lbracket on_int # Split pattern into segments. -1 to allow trailing slashes.
on_ignored_nl if pattern_segs on_lbracket on_int on_rbracket on_period UNK on_nl pattern_segs on_period UNK on_nl else on_ignored_nl if pattern_segs on_period UNK on_op # Normalize pattern to make processing easier.
if pattern_segs on_lbracket on_int on_rbracket on_period UNK on_nl pattern_segs on_period UNK on_nl else on_ignored_nl if pattern_segs on_period UNK on_op on_int # A pattern beginning with a slash ('/') will only match paths # directly on the root directory instead of any descendant # paths. So, remove empty first segment to make pattern relative # to root.
if pattern_segs on_period UNK on_op on_int on_op pattern_segs on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl pattern_segs on_period UNK on_lparen # A pattern without a beginning slash ('/') will match any # descendant path. This is equivalent to "**/{pattern}". So, # prepend with double-asterisks to make pattern relative to # root.
if pattern_segs on_lbracket on_op on_int on_rbracket on_period UNK on_nl pattern_segs on_lbracket on_op on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end # A pattern ending with a slash ('/') will match all descendant # paths of if it is a directory but not if it is a regular file. # This is equivalent to "{pattern}/**". So, set last segment to # double asterisks to include all descendants.
if on_const on_op on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl path_sep on_op on_tstring_beg on_tstring_content on_tstring_end on_nl else on_ignored_nl path_sep on_op on_tstring_beg # Handle platforms with backslash separated paths
regex on_op on_tstring_beg on_tstring_content on_tstring_end on_nl need_slash on_op UNK on_nl UNK on_op pattern_segs on_period size on_op on_int on_nl pattern_segs on_period # Build regular expression from pattern.
if i on_op on_int on_op i on_op UNK on_nl regex on_period concat on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl elsif # A pattern consisting solely of double-asterisks ('**') # will match every path.
elsif i on_op on_int on_nl regex on_period concat on_lparen on_tstring_beg on_tstring_content UNK path_sep UNK on_tstring_content on_tstring_end on_rparen on_nl need_slash on_op # A normalized pattern beginning with double-asterisks # ('**') will match any leading path segments.
elsif i on_op UNK on_nl regex on_period concat on_lparen on_tstring_beg UNK path_sep UNK on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl else on_ignored_nl # A normalized pattern ending with double-asterisks ('**') # will match any trailing path segments.
else on_ignored_nl regex on_period concat on_lparen on_tstring_beg on_tstring_content UNK path_sep UNK on_tstring_content on_tstring_end on_rparen on_nl need_slash on_op UNK on_nl end # A pattern with inner double-asterisks ('**') will match # multiple (or zero) inner path segments.
elsif UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl if need_slash on_nl regex on_period concat on_lparen path_sep on_rparen on_nl end on_nl on_ignored_nl # Match single path segment.
if need_slash on_nl regex on_period concat on_lparen path_sep on_rparen on_nl end on_nl on_ignored_nl regex on_period concat on_lparen UNK on_lparen UNK # Match segment glob pattern.
on_ignored_nl escape on_op UNK on_nl regex on_op on_tstring_beg on_tstring_end on_nl i on_op on_int on_nl on_ignored_nl UNK i on_op pattern on_period # NOTE: This is derived from `fnmatch.translate()` and is similar to # the POSIX function `fnmatch()` with the `FNM_PATHNAME` flag set.
char on_op pattern on_lbracket i on_rbracket on_period chr on_nl i on_op on_int on_nl on_ignored_nl if escape on_nl escape on_op UNK # Get next character.
if escape on_nl escape on_op UNK on_nl regex on_op on_const on_period escape on_lparen char on_rparen on_nl on_ignored_nl elsif char on_op # Escape the character.
elsif char on_op on_tstring_beg on_tstring_content on_tstring_end on_nl escape on_op UNK on_nl on_ignored_nl elsif char on_op on_tstring_beg on_tstring_content on_tstring_end on_nl regex # Escape character, escape next character.
elsif char on_op on_tstring_beg on_tstring_content on_tstring_end on_nl regex on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl elsif char on_op on_tstring_beg on_tstring_content on_tstring_end # Multi-character wildcard. Match any string (except slashes), # including an empty string.
elsif char on_op on_tstring_beg on_tstring_content on_tstring_end on_nl regex on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl elsif char on_op on_tstring_beg on_tstring_content on_tstring_end # Single-character wildcard. Match any single character (except # a slash).
elsif char on_op on_tstring_beg on_tstring_content on_tstring_end on_nl j on_op i on_nl if j on_op pattern on_period size on_op pattern on_lbracket # Bracket expression wildcard. Except for the beginning # exclamation mark, the whole bracket expression can be used # directly as regex but we have to find where the expression # ends. # - "[][!]" matches ']', '[' and '!'. # - "[]-]" matches ']' and '-'. # - "[!]a-]" matches any character except ']', 'a' and '-'.
if j on_op pattern on_period size on_op pattern on_lbracket j on_rbracket on_period chr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl j on_op # Pass brack expression negation.
if j on_op pattern on_period size on_op pattern on_lbracket j on_rbracket on_period chr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl j on_op # Pass first closing bracket if it is at the beginning of the # expression.
UNK j on_op pattern on_period size on_op pattern on_lbracket j on_rbracket on_period chr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl j on_op # Find closing bracket. Stop once we reach the end or find it.
if pattern on_lbracket i on_rbracket on_period chr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl expr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl i on_op # Bracket expression needs to be negated.
elsif pattern on_lbracket i on_rbracket on_period chr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl expr on_op on_tstring_beg on_tstring_content on_tstring_end on_nl i on_op # POSIX declares that the regex bracket expression negation # "[^...]" is undefined in a glob pattern. Python's # `fnmatch.translate()` escapes the caret ('^') as a # literal. To maintain consistency with undefined behavior, # I am escaping the '^' as well.
if pattern on_lbracket i on_rbracket on_period chr on_op on_tstring_beg on_tstring_content on_tstring_end on_op i on_op j on_nl expr on_op on_tstring_beg on_tstring_content # Escape brackets contained within pattern
expr on_op pattern on_lbracket i on_op j on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end UNK on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Build regex bracket expression. Escape slashes so they are # treated as literal slashes by regex as defined by POSIX.
regex on_op expr on_nl on_ignored_nl j on_op on_int on_nl i on_op j on_nl on_ignored_nl else on_ignored_nl regex on_op on_tstring_beg on_tstring_content # Add regex bracket expression to regex result.
j on_op on_int on_nl i on_op j on_nl on_ignored_nl else on_ignored_nl regex on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl # Found end of bracket expression. Increment j to be one past # the closing bracket: # # [...] # ^ ^ # i j #
i on_op j on_nl on_ignored_nl else on_ignored_nl regex on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl else on_ignored_nl regex on_op # Set i to one past the closing bracket.
else on_ignored_nl regex on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl else on_ignored_nl regex on_op on_const on_period escape on_lparen char # Failed to find closing bracket, treat opening bracket as a # bracket literal instead of as an expression.
else on_ignored_nl regex on_op on_const on_period escape on_lparen char on_rparen on_nl end on_nl end on_nl on_ignored_nl regex on_nl end on_nl # Regular character, escape it for regex.
