class on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl class on_const on_nl # Common code for AIX user/group providers.
class on_const on_nl UNK on_symbeg name on_nl on_ignored_nl def UNK on_lparen name on_comma UNK on_comma UNK on_rparen on_ignored_nl on_ivar on_op # Class representing a MappedObject, which can either be an # AIX attribute or a Puppet property. This class lets us # write something like: # # attribute = mappings[:aix_attribute][:uid] # attribute.name # attribute.convert_property_value(uid) # # property = mappings[:puppet_property][:id] # property.name # property.convert_attribute_value(id) # # NOTE: This is an internal class specific to AixObject. It is # not meant to be used anywhere else. That's why we do not have # any validation code in here. # # NOTE: See the comments in the class-level mappings method to # understand what we mean by pure and impure conversion functions. # # NOTE: The 'mapping' code, including this class, could possibly # be moved to a separate module so that it can be re-used in some # of our other providers. See PUP-9082.
UNK on_lparen on_ivar on_rparen do on_op value on_op on_ignored_nl on_ivar on_period UNK on_lparen value on_rparen on_nl end on_nl end on_nl # Our conversion function is pure, so we can go ahead # and define it. This way, we can use this MappedObject # at the class-level as well as at the instance-level.
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen on_ivar on_rparen do on_op value on_op on_ignored_nl on_ivar on_period UNK on_lparen UNK # Sets our MappedObject's provider. This only makes sense # if it has an impure conversion function. We will call this # in the instance-level mappings method after the provider # instance has been created to define our conversion function. # Note that a MappedObject with an impure conversion function # cannot be used at the class level.
on_ignored_nl def mappings on_nl return on_ivar if on_ivar on_nl on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_lbracket on_symbeg aix_attribute on_rbracket #------------- # Mappings # ------------
def UNK on_lparen info on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op UNK on_lbrace on_op UNK on_op UNK on_rbrace on_nl info # Add a mapping from a Puppet property to an AIX attribute. The info must include: # # * :puppet_property -- The puppet property corresponding to this attribute # * :aix_attribute -- The AIX attribute corresponding to this attribute. Defaults # to puppet_property if this is not provided. # * :property_to_attribute -- A lambda that converts a Puppet Property to an AIX attribute # value. Defaults to the identity function if not provided. # * :attribute_to_property -- A lambda that converts an AIX attribute to a Puppet property. # Defaults to the identity function if not provided. # # NOTE: The lambdas for :property_to_attribute or :attribute_to_property can be 'pure' # or 'impure'. A 'pure' lambda is one that needs only the value to do the conversion, # while an 'impure' lambda is one that requires the provider instance along with the # value. 'Pure' lambdas have the interface 'do |value| ...' while 'impure' lambdas have # the interface 'do |provider, value| ...'. # # NOTE: 'Impure' lambdas are useful in case we need to generate more specific error # messages or pass-in instance-specific command-line arguments.
def UNK on_lparen info on_op on_lbrace on_rbrace on_rparen on_ignored_nl property on_op info on_lbracket on_symbeg puppet_property on_rbracket on_nl on_ignored_nl info on_lbracket # Creates a mapping from a purely numeric Puppet property to # an attribute
info on_lbracket on_symbeg UNK on_rbracket on_op UNK do on_op value on_op on_ignored_nl UNK value on_period UNK on_lparen on_const on_rparen on_nl # We have this validation here b/c not all numeric properties # handle this at the property level (e.g. like the UID). Given # that, we might as well go ahead and do this validation for all # of our numeric properties. Doesn't hurt.
info on_lbracket on_symbeg UNK on_rbracket on_op UNK do on_op value on_op on_ignored_nl value on_period UNK on_nl end on_nl on_ignored_nl UNK # AIX will do the right validation to ensure numeric attributes # can't be set to non-numeric values, so no need for the extra clutter.
on_ignored_nl def UNK on_nl properties on_op on_lbracket on_symbeg attributes on_rbracket on_nl properties on_op mappings on_lbracket on_symbeg aix_attribute on_rbracket on_period UNK #------------- # Useful Class Methods # ------------
def UNK on_nl properties on_op on_lbracket on_symbeg attributes on_rbracket on_nl properties on_op mappings on_lbracket on_symbeg aix_attribute on_rbracket on_period UNK on_nl # Defines the getter and setter methods for each Puppet property that's mapped # to an AIX attribute. We define only a getter for the :attributes property. # # Provider subclasses should call this method after they've defined all of # their <puppet_property> => <aix_attribute> mappings.
properties on_op on_lbracket on_symbeg attributes on_rbracket on_nl properties on_op mappings on_lbracket on_symbeg aix_attribute on_rbracket on_period UNK on_nl properties on_period each # Define the Getter methods for each of our properties + the attributes # property
UNK on_lparen property on_rparen do on_ignored_nl UNK on_lparen property on_rparen on_nl end on_nl on_ignored_nl UNK if property on_op on_symbeg attributes # Define the getter
UNK if property on_op on_symbeg attributes on_nl on_ignored_nl UNK on_lparen on_tstring_beg on_embexpr_beg property on_embexpr_end on_tstring_content on_tstring_end on_period UNK on_rparen do # We have a custom setter for the :attributes property, # so no need to define it.
UNK on_lparen on_tstring_beg on_embexpr_beg property on_embexpr_end on_tstring_content on_tstring_end on_period UNK on_rparen do on_op value on_op on_ignored_nl UNK on_lparen property on_comma # Define the setter
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl return on_lbracket on_tstring_beg on_tstring_end on_rbracket if UNK on_period UNK on_nl on_ignored_nl UNK # This helper splits a list separated by sep into its corresponding # items. Note that a key precondition here is that none of the items # in the list contain sep. # # Let A be the return value. Then one of our postconditions is: # A.join(sep) == list # # NOTE: This function is only used by the parse_colon_separated_list # function below. It is meant to be an inner lambda. The reason it isn't # here is so we avoid having to create a proc. object for the split_list # lambda each time parse_colon_separated_list is invoked. This will happen # quite often since it is used at the class level and at the instance level. # Since this function is meant to be an inner lambda and thus not exposed # anywhere else, we do not have any unit tests for it. These test cases are # instead covered by the unit tests for parse_colon_separated_list
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_period UNK # Parses a colon-separated list. Example includes something like: # <item1>:<item2>:<item3>:<item4> # # Returns an array of the parsed items, e.g. # [ <item1>, <item2>, <item3>, <item4> ] # # Note that colons inside items are escaped by #!
UNK on_op UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_period UNK on_lbrace on_op UNK on_op UNK on_lparen # ALGORITHM: # Treat the colon_list as a list separated by '#!:' We will get # something like: # [ <chunk1>, <chunk2>, ... <chunkn> ] # # Each chunk is now a list separated by ':' and none of the items # in each chunk contains an escaped ':'. Now, split each chunk on # ':' to get: # [ [<piece11>, ..., <piece1n>], [<piece21>, ..., <piece2n], ... ] # # Now note that <item1> = <piece11>, <item2> = <piece12> in our original # list, and that <itemn> = <piece1n>#!:<piece21>. This is the main idea # behind what our inject method is trying to do at the end, except that # we replace '#!:' with ':' since the colons are no longer escaped.
def UNK on_lparen UNK on_rparen on_ignored_nl _ on_comma on_op UNK on_op UNK on_period UNK on_period UNK on_lparen UNK on_tstring_content UNK # Parses the AIX objects from the command output, returning an array of # hashes with each hash having the following schema: # { # :name => <object_name> # :attributes => <object_attributes> # } # # Output should be of the form # #name:<attr1>:<attr2> ... # <name>:<value1>:<value2> ... # #name:<attr1>:<attr2> ... # <name>:<value1>:<value2> ... # # NOTE: We need to parse the colon-formatted output in case we have # space-separated attributes (e.g. 'gecos'). ":" characters are escaped # with a "#!".
_ on_comma on_op UNK on_op UNK on_period UNK on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_nl on_ignored_nl UNK on_period UNK # Object names cannot begin with '#', so we are safe to # split individual users this way. We do not have to worry # about an empty list either since there is guaranteed to be # at least one instance of an AIX object (e.g. at least one # user or one group on the system).
def UNK on_lparen ia_module_args on_op on_lbracket on_rbracket on_rparen on_ignored_nl UNK on_op on_lbracket UNK on_lparen on_symbeg UNK on_rparen on_comma on_tstring_beg on_tstring_content # Lists all instances of the given object, taking in an optional set # of ia_module arguments. Returns an array of hashes, each hash # having the schema # { # :name => <object_name> # :id => <object_id> # }
on_ignored_nl def UNK on_nl UNK on_period UNK on_period UNK do on_op object on_op on_ignored_nl UNK on_lparen on_lbrace on_symbeg name on_op #------------- # Provider API # ------------
def mappings on_nl return on_ivar if on_ivar on_nl on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl self on_period class on_period mappings on_period # Instantiate our mappings. These need to be at the instance-level # since some of our mapped objects may have impure conversion functions # that need our provider instance.
on_ivar on_lbracket UNK on_rbracket on_lbracket UNK on_rbracket on_op UNK on_nl UNK on_nl end on_nl on_ignored_nl on_ivar on_lbracket UNK on_rbracket on_lbracket # Our mapped_object has a pure conversion function so we # can go ahead and use it as-is.
on_ivar on_lbracket UNK on_rbracket on_lbracket UNK on_rbracket on_op UNK on_period UNK on_nl on_ivar on_lbracket UNK on_rbracket on_lbracket UNK on_rbracket on_period # Otherwise, we need to dup it and set its provider to our # provider instance. The dup is necessary so that we do not # touch the class-level mapped object.
def UNK on_lparen attributes on_rparen on_ignored_nl attributes on_period UNK do on_op UNK on_comma value on_op on_ignored_nl on_tstring_beg on_embexpr_beg UNK on_embexpr_end # Converts the given attributes hash to CLI args.
def UNK on_lparen new_attributes on_rparen on_ignored_nl UNK on_lparen UNK on_lparen new_attributes on_rparen on_rparen on_nl UNK on_lparen UNK on_rparen on_nl end # Modifies the AIX object by setting its new attributes.
def UNK on_lparen property on_rparen on_ignored_nl return on_symbeg UNK UNK UNK on_nl UNK on_lbracket property on_rbracket on_op on_symbeg UNK on_nl # Gets a Puppet property's value from object_info
def UNK on_lparen property on_comma value on_rparen on_ignored_nl aix_attribute on_op mappings on_lbracket on_symbeg aix_attribute on_rbracket on_lbracket property on_rbracket on_nl UNK # Sets a mapped Puppet property's value.
def UNK on_lparen new_attributes on_rparen on_ignored_nl conflicts on_op on_lbrace on_rbrace on_nl mappings on_lbracket on_symbeg aix_attribute on_rbracket on_period each do on_op # This routine validates our new attributes property value to ensure # that it does not contain any Puppet properties.
conflicts on_op on_lbrace on_rbrace on_nl mappings on_lbracket on_symbeg aix_attribute on_rbracket on_period each do on_op property on_comma aix_attribute on_op on_ignored_nl UNK # Gather all of the <puppet property>, <aix attribute> conflicts to print # them all out when we create our error message. This makes it easy for the # user to update their manifest based on our error message.
def UNK on_lparen new_attributes on_rparen on_ignored_nl UNK on_lparen new_attributes on_rparen on_nl UNK on_lparen new_attributes on_rparen on_nl UNK on_const on_op on_const # Modifies the attribute property. Note we raise an error if the user specified # an AIX attribute corresponding to a Puppet property.
def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl return on_ivar if on_ivar on_op on_op UNK on_nl on_ivar on_op UNK on_nl # Collects the current property values of all mapped properties + # the attributes property.
UNK on_op self on_period class on_period UNK on_lparen UNK on_rparen on_period UNK on_lbracket on_symbeg attributes on_rbracket on_nl UNK on_period each # If lscmd succeeds, then output will contain our object's information. # Thus, .parse_aix_objects will always return a single element array.
if on_lparen property on_op mappings on_lbracket on_symbeg puppet_property on_rbracket on_lbracket UNK on_rbracket on_rparen on_nl on_ivar on_lbracket property on_period name on_rbracket # If our attribute has a Puppet property, then we store that. Else, we store it as part # of our :attributes property hash
on_ignored_nl def UNK on_nl on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl attributes on_op on_ivar on_period UNK #------------- # Methods that manage the ensure property # ------------
def UNK on_nl on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl attributes on_op on_ivar on_period UNK on_lparen # Check that the AIX object exists
def UNK on_nl attributes on_op on_ivar on_period UNK on_lparen on_symbeg attributes on_rparen on_op on_lbrace on_rbrace on_nl UNK on_lparen attributes on_rparen # Creates a new instance of the resource
def UNK on_nl UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK on_lparen UNK on_rparen on_nl UNK on_const on_op on_const on_op detail # Deletes this instance resource
UNK on_lparen UNK on_rparen on_nl UNK on_const on_op on_const on_op detail on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg # Recollect the object info so that our current properties reflect # the actual state of the system. Otherwise, puppet resource reports # the wrong info. at the end. Note that this should return nil.
