class on_const on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_const on_op on_const on_nl on_ignored_nl on_const on_op on_op on_const on_period UNK # This class handles all the aspects of a Puppet application/executable # * setting up options # * setting up logs # * choosing what to run # * representing execution status # # === Usage # An application is a subclass of Puppet::Application. # # For legacy compatibility, # Puppet::Application[:example].run # is equivalent to # Puppet::Application::Example.new.run # # # class Puppet::Application::Example < Puppet::Application # # def preinit # # perform some pre initialization # @all = false # end # # # run_command is called to actually run the specified command # def run_command # send Puppet::Util::CommandLine.new.args.shift # end # # # option uses metaprogramming to create a method # # and also tells the option parser how to invoke that method # option("--arg ARGUMENT") do |v| # @args << v # end # # option("--debug", "-d") do |v| # @debug = v # end # # option("--all", "-a:) do |v| # @all = v # end # # def handle_unknown(opt,arg) # # last chance to manage an option # ... # # let's say to the framework we finally handle this option # true # end # # def read # # read action # end # # def write # # writeaction # end # # end # # === Preinit # The preinit block is the first code to be called in your application, before option parsing, # setup or command execution. # # === Options # Puppet::Application uses +OptionParser+ to manage the application options. # Options are defined with the +option+ method to which are passed various # arguments, including the long option, the short option, a description... # Refer to +OptionParser+ documentation for the exact format. # * If the option method is given a block, this one will be called whenever # the option is encountered in the command-line argument. # * If the option method has no block, a default functionality will be used, that # stores the argument (or true/false if the option doesn't require an argument) in # the global (to the application) options array. # * If a given option was not defined by a the +option+ method, but it exists as a Puppet settings: # * if +unknown+ was used with a block, it will be called with the option name and argument # * if +unknown+ wasn't used, then the option/argument is handed to Puppet.settings.handlearg for # a default behavior # # --help is managed directly by the Puppet::Application class, but can be overridden. # # === Setup # Applications can use the setup block to perform any initialization. # The default +setup+ behaviour is to: read Puppet configuration and manage log level and destination # # === What and how to run # If the +dispatch+ block is defined it is called. This block should return the name of the registered command # to be run. # If it doesn't exist, it defaults to execute the +main+ command if defined. # # === Execution state # The class attributes/methods of Puppet::Application serve as a global place to set and query the execution # status of the application: stopping, restarting, etc. The setting of the application status does not directly # affect its running status; it's assumed that the various components within the application will consult these # settings appropriately and affect their own processing accordingly. Control operations (signal handlers and # the like) should set the status appropriately to indicate to the overall system that it's the process of # stopping or restarting (or just running as usual). # # So, if something in your application needs to stop the process, for some reason, you might consider: # # def stop_me! # # indicate that we're stopping # Puppet::Application.stop! # # ...do stuff... # end # # And, if you have some component that involves a long-running process, you might want to consider: # # def my_long_process(giant_list_to_munge) # giant_list_to_munge.collect do |member| # # bail if we're stopping # return if Puppet::Application.stop_requested? # process_member(member) # end # end
def UNK on_nl on_symbeg UNK on_op run_status on_nl end on_nl on_ignored_nl def UNK on_nl on_symbeg UNK on_op run_status on_nl end # Indicates that Puppet::Application.restart! has been invoked and components should # do what is necessary to facilitate a restart.
def UNK on_nl on_symbeg UNK on_op run_status on_nl end on_nl on_ignored_nl def UNK on_nl on_lbracket on_symbeg UNK on_comma on_symbeg UNK # Indicates that Puppet::Application.stop! has been invoked and components should do what is necessary # for a clean stop.
def UNK on_nl on_lbracket on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_period UNK run_status on_nl end on_nl on_ignored_nl def UNK on_nl # Indicates that one of stop! or start! was invoked on Puppet::Application, and some kind of process # shutdown/short-circuit may be necessary.
def UNK on_nl run_status on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK UNK UNK # Indicates that Puppet::Application believes that it's in usual running run_mode (no stop/restart request # currently active).
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK UNK UNK on_nl UNK on_op UNK on_period UNK on_nl on_const on_period UNK # Only executes the given block if the run status of Puppet::Application is clear (no restarts, stops, # etc. requested). # Upon block execution, checks the run status again; if a restart has been requested during the block's # execution, then controlled_run will send a new HUP signal to the current process. # Thus, long-running background processes can potentially finish their work before a restart.
def option on_lparen on_op options on_comma on_op UNK on_rparen on_ignored_nl UNK on_op options on_period UNK on_lbrace on_op opt on_op opt # used to declare code that handle an option
def UNK on_nl UNK on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen on_const on_lbracket on_symbeg UNK on_rbracket # @return [Array<String>] the names of available applications # @api public
UNK on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen on_const on_lbracket on_symbeg UNK on_rbracket on_rparen on_op on_ignored_nl # Use our configured environment to load the application, as it may # be in a module we installed locally, otherwise fallback to our # current environment (*root*). Once we load the application the # current environment will change from *root* to the application # specific environment.
def UNK on_lparen application_name on_rparen on_ignored_nl UNK on_ignored_nl require on_ivar on_period UNK on_lparen application_name on_period UNK on_period UNK on_rparen on_nl # Finds the class for a given application and loads the class. This does # not create an instance of the application, it only gets a handle to the # class. The code for the application is expected to live in a ruby file # `puppet/application/#{name}.rb` that is available on the `$LOAD_PATH`. # # @param application_name [String] the name of the application to find (eg. "apply"). # @return [Class] the Class instance of the application that was found. # @raise [Puppet::Error] if the application class was not found. # @raise [LoadError] if there was a problem loading the application file. # @api public
if on_lparen UNK on_period UNK on_rparen on_nl class_name on_op application_name on_period UNK on_nl UNK on_op UNK on_lparen class_name on_rparen on_nl ################################################################ #### Begin 2.7.x backward compatibility hack; #### eventually we need to issue a deprecation warning here, #### and then get rid of this stanza in a subsequent release. ################################################################
on_ignored_nl if UNK on_period UNK on_nl UNK on_const on_op on_const on_period new on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op ################################################################ #### End 2.7.x backward compatibility hack ################################################################
def UNK on_lparen class_name on_rparen on_ignored_nl UNK self on_period UNK on_lparen class_name on_rparen on_op UNK on_lparen class_name on_rparen on_op nil # Given the fully qualified name of a class, attempt to get the class instance. # @param [String] class_name the fully qualified name of the class to try to load # @return [Class] the Class instance, or nil? if it could not be loaded.
def UNK on_lparen mode_name on_op nil on_rparen on_ignored_nl if mode_name on_nl on_const on_period UNK on_period UNK on_op mode_name on_nl end # Sets or gets the run_mode name. Sets the run_mode name if a mode_name is # passed. Otherwise, gets the run_mode or a default run_mode #
def UNK on_lparen mode_name on_rparen on_ignored_nl UNK on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label # Sets environment_mode name # @param mode_name [Symbol] The name of the environment mode to run in. May # be one of :local, :remote, or :not_required. This impacts where the # application looks for its specified environment. If :not_required or # :remote are set, the application will not fail if the environment does # not exist on the local filesystem.
def UNK on_nl on_ivar on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_ivar on_op on_ivar on_op # Gets environment_mode name. If none is set with `environment_mode=`, # default to :local.
def UNK on_nl on_ivar on_op on_ivar on_op on_ivar on_op on_ivar on_op nil on_nl end on_nl end on_nl on_ignored_nl UNK on_symbeg # This is for testing only
option on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op arg on_op on_ignored_nl UNK on_tstring_beg UNK on_const on_period # Every app responds to --version # See also `lib/puppet/util/command_line.rb` for some special case early # handling of this.
option on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op UNK on_op on_ignored_nl UNK UNK on_nl UNK on_lparen # Every app responds to --help
def UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_op on_const on_op on_const on_op on_const on_period new on_rparen on_ignored_nl # override to execute code before running anything else
def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK # call in setup of subclass to deprecate an application
def UNK on_nl on_ignored_nl on_ignored_nl exit_on_fail on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen do on_ignored_nl UNK on_nl end on_nl # Execute the application. # @api public # @return [void]
on_ignored_nl exit_on_fail on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen do on_ignored_nl UNK on_nl end on_nl on_ignored_nl on_const on_op on_const # I don't really like the names of these lifecycle phases. It would be nice to change them to some more meaningful # names, and make deprecated aliases. --cprice 2012-03-16
def UNK on_lparen UNK on_op nil on_rparen on_ignored_nl UNK on_op on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_const on_period UNK on_comma # Output basic information about the runtime environment for debugging # purposes. # # @api public # # @param extra_info [Hash{String => #to_s}] a flat hash of extra information # to log. Intended to be passed to super by subclasses. # @return [void]
UNK on_op on_const on_period new on_lparen self on_period class on_period UNK on_rparen on_nl on_ignored_nl on_ignored_nl on_const on_period UNK on_period UNK # Create an option parser
on_ignored_nl on_const on_period UNK on_period UNK on_lparen on_lbracket on_rbracket on_rparen on_period UNK do on_op option on_op on_ignored_nl UNK on_period UNK # Here we're building up all of the options that the application may need to handle. The main # puppet settings defined in "defaults.rb" have already been parsed once (in command_line.rb) by # the time we get here; however, our app may wish to handle some of them specially, so we need to # make the parser aware of them again. We might be able to make this a bit more efficient by # re-using the parser object that gets built up in command_line.rb. --cprice 2012-03-16
on_const on_period UNK on_period UNK on_lparen on_lbracket on_rbracket on_rparen on_period UNK do on_op option on_op on_ignored_nl UNK on_period UNK on_lparen # Add all global options to it.
self on_period class on_period UNK on_period UNK do on_op options on_comma fname on_op on_ignored_nl UNK on_period UNK on_lparen on_op options # Add options that are local to this application, which were # created using the "option()" metaprogramming method. If there # are any conflicts, this application's options will be favored.
self on_period UNK on_lparen fname on_comma UNK on_rparen on_nl end on_nl end on_nl on_ignored_nl UNK on_period UNK on_lparen self on_period # Call the method that "option()" created.
UNK on_period UNK on_lparen self on_period UNK on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen opt on_comma UNK # Scan command line. We just hand any exceptions to our upper levels, # rather than printing help and exiting, so that we can meaningfully # respond with context-sensitive help if we want to. --daniel 2011-04-12
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def name on_nl self # this is used for testing
def UNK on_nl on_tstring_beg on_tstring_end on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP # The description used in top level `puppet help` output # If left empty in implementations, we will attempt to extract # the summary from the help text itself.
