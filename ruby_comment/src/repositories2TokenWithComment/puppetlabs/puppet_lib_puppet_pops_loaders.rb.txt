class on_const on_nl class on_const on_op on_const on_op on_const UNK end on_nl on_ignored_nl attr_reader on_symbeg static_loader on_nl attr_reader on_symbeg UNK # This is the container for all Loader instances. Each Loader instance has a `loader_name` by which it can be uniquely # identified within this container. # A Loader can be private or public. In general, code will have access to the private loader associated with the # location of the code. It will be parented by a loader that in turn have access to other public loaders that # can load only such entries that have been publicly available. The split between public and private is not # yet enforced in Puppet. # # The name of a private loader should always end with ' private' #
raise on_const on_period new on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen UNK environment on_period loaders on_period nil? on_nl environment # Protect against environment havoc
on_ivar on_op UNK on_lparen on_rparen on_nl on_ignored_nl on_ivar on_op if UNK on_nl on_ivar on_op UNK on_lparen on_rparen on_nl UNK on_lparen # Create the set of loaders # 1. Puppet, loads from the "running" puppet - i.e. bundled functions, types, extension points and extensions # These cannot be cached since a loaded instance will be bound to its closure scope which holds on to # a compiler and all loaded types. Subsequent request would find remains of the environment that loaded # the content. PUP-4461. #
on_ivar on_op if UNK on_nl on_ivar on_op UNK on_lparen on_rparen on_nl UNK on_lparen environment on_comma on_ivar on_rparen on_nl else on_ignored_nl # 2. Cache loader(optional) - i.e. what puppet stores on disk via pluginsync; gate behind the for_agent flag. # 3. Environment loader - i.e. what is bound across the environment, may change for each setup # TODO: loaders need to work when also running in an agent doing catalog application. There is no # concept of environment the same way as when running as a master (except when doing apply). # The creation mechanisms should probably differ between the two.
end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK on_lparen on_symbeg type on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # 4. module loaders are set up from the create_environment_loader, they register themselves
def UNK on_nl on_ivar on_period UNK on_lparen on_symbeg type on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl def self # Called after loader has been added to Puppet Context as :loaders so that dynamic types can # be pre-loaded with a fully configured loader system
def self on_period UNK on_nl on_cvar on_op nil on_nl on_const on_op on_const on_op on_const on_op on_const on_period UNK on_nl on_const # Clears the cached static and puppet_system loaders (to enable testing) #
def self on_period UNK on_lparen module_name on_rparen on_ignored_nl loaders on_period UNK on_lparen module_name on_rparen on_nl end on_nl on_ignored_nl def self # Calls {#loaders} to obtain the {{Loaders}} instance and then uses it to find the appropriate loader # for the given `module_name`, or for the environment in case `module_name` is `nil` or empty. # # @param module_name [String,nil] the name of the module # @return [Loader::Loader] the found loader # @raise [Puppet::ParseError] if no loader can be found # @api private
if on_op UNK on_lparen on_symbeg on_cvar on_rparen on_op on_cvar on_period nil? on_nl on_cvar on_op on_const on_op on_const on_period new on_lparen # The static loader can only be changed after a reboot
def self on_period UNK on_lparen obj_classes on_rparen on_ignored_nl UNK on_lparen obj_classes on_comma on_const on_op on_const on_comma static_loader on_rparen on_nl end # Register implementations using the global static loader
UNK on_period UNK on_lbrace on_op type on_op type on_period UNK on_lparen loader on_rparen on_rbrace on_nl end on_nl on_ignored_nl def self # Resolve lazy so that all types can cross reference each other
def self on_period UNK on_lparen name on_comma UNK on_rparen on_ignored_nl loaders on_op on_const on_period lookup on_lparen on_symbeg loaders on_rparen on_lbrace # Register the given type with the Runtime3TypeLoader. The registration will not happen unless # the type system has been initialized. # # @param name [String,Symbol] the name of the entity being set # @param origin [URI] the origin or the source where the type is defined # @api private
def self on_period UNK on_nl loaders on_op on_const on_period lookup on_lparen on_symbeg loaders on_rparen on_lbrace nil on_rbrace on_nl if loaders # Finds a loader to use when deserializing a catalog and then subsequenlty use user # defined types found in that catalog. #
def self on_period loaders on_nl loaders on_op on_const on_period lookup on_lparen on_symbeg loaders on_rparen on_lbrace nil on_rbrace on_nl raise on_const # Finds the `Loaders` instance by looking up the :loaders in the global Puppet context # # @return [Loaders] the loaders instance # @raise [Puppet::ParseError] if loader has been bound to the global context # @api private
def on_op on_lparen loader_name on_rparen on_ignored_nl loader on_op on_ivar on_lbracket loader_name on_rbracket on_nl if loader on_period nil? on_nl loader on_op # Lookup a loader by its unique name. # # @param [String] loader_name the name of the loader to lookup # @return [Loader] the found loader # @raise [Puppet::ParserError] if no loader is found
loader on_op UNK on_lparen loader_name on_lbracket UNK on_op on_op UNK on_rbracket on_rparen if loader_name on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # Unable to find the module private loader. Try resolving the module
def UNK on_lparen module_name on_rparen on_ignored_nl if module_name on_period nil? on_op on_const on_op module_name on_nl UNK on_nl else on_ignored_nl loader # Finds the appropriate loader for the given `module_name`, or for the environment in case `module_name` # is `nil` or empty. # # @param module_name [String,nil] the name of the module # @return [Loader::Loader] the found loader # @raise [Puppet::ParseError] if no loader can be found # @api private
UNK on_nl else on_ignored_nl loader on_op UNK on_lparen module_name on_rparen on_nl if loader on_period nil? on_nl raise on_const on_op on_const # Use the public environment loader
loader on_op UNK on_lparen module_name on_rparen on_nl if loader on_period nil? on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg # TODO : Later check if definition is private, and then add it to private_loader_for_module #
on_ivar on_op on_const on_op on_const on_period new on_lparen self on_period class on_period UNK on_rparen on_nl end on_nl on_ignored_nl def static_loader # Environment specific implementation registry
md on_period public_loader on_nl end on_nl on_ignored_nl def UNK on_lparen module_name on_rparen on_ignored_nl md on_op on_ivar on_lbracket module_name on_rbracket on_op # Note, this loader is not resolved until there is interest in the visibility of entities from the # perspective of something contained in the module. (Many request may pass through a module loader # without it loading anything. # See {#private_loader_for_module}, and not in {#configure_loaders_for_modules}
UNK md on_period UNK on_nl on_ivar on_period UNK on_lparen md on_rparen on_nl end on_nl md on_period UNK on_nl end on_nl # Since there is interest in the visibility from the perspective of entities contained in the # module, it must be resolved (to provide this visibility). # See {#configure_loaders_for_modules}
def UNK on_nl UNK on_op on_const on_op on_const on_period UNK on_nl UNK on_op on_const on_lbracket on_symbeg UNK on_rbracket on_nl program # Load the main manifest for the given environment # # There are two sources that can be used for the initial parse: # # 1. The value of `Puppet[:code]`: Puppet can take a string from # its settings and parse that as a manifest. This is used by various # Puppet applications to read in a manifest and pass it to the # environment as a side effect. This is attempted first. # 2. The contents of the environment's +manifest+ attribute: Puppet will # try to load the environment manifest. The manifest must be a file. # # @return [Model::Program] The manifest parsed into a model object
if file on_op on_const on_op on_const on_op on_const on_op on_const on_nl nil on_nl UNK on_const on_period UNK on_lparen file on_rparen # if the manifest file is a reference to a directory, parse and combine # all .pp files in that directory
def UNK on_lparen program on_comma loader on_rparen on_ignored_nl program on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_lparen UNK # Add 4.x definitions found in the given program to the given loader.
def UNK on_lparen definition on_comma loader on_rparen on_ignored_nl UNK definition on_nl UNK on_const on_op on_const on_nl UNK on_lparen definition on_comma # Add given 4.x definition to the given loader.
typed_name on_comma UNK on_op on_const on_op on_const on_period UNK on_lparen UNK on_comma loader on_rparen on_nl loader on_period UNK on_lparen typed_name # Instantiate Function, and store it in the loader
on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_comma loader on_rparen on_nl nil on_nl end on_nl on_ignored_nl # Bind the type alias to the loader using the alias
on_ignored_nl on_ignored_nl on_ignored_nl UNK on_op on_const on_period lookup on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen environment on_period name on_rparen on_nl # This defines where to start parsing/evaluating - the "initial import" (to use 3x terminology) # Is either a reference to a single .pp file, or a directory of manifests. If the environment becomes # a module and can hold functions, types etc. then these are available across all other modules without # them declaring this dependency - it is however valuable to be able to treat it the same way # bindings and other such system related configuration.
on_ignored_nl on_ignored_nl UNK on_op on_const on_period lookup on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen environment on_period name on_rparen on_nl UNK # This is further complicated by the many options available: # - The environment may not have a directory, the code comes from one appointed 'manifest' (site.pp) # - The environment may have a directory and also point to a 'manifest' # - The code to run may be set in settings (code)
on_ignored_nl UNK on_op on_const on_period lookup on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen environment on_period name on_rparen on_nl UNK on_op # Further complication is that there is nothing specifying what the visibility is into # available modules. (3x is everyone sees everything). # Puppet binder currently reads confdir/bindings - that is bad, it should be using the new environment support.
UNK on_op on_const on_period lookup on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen environment on_period name on_rparen on_nl UNK on_op UNK # env_conf is setup from the environment_dir value passed into Puppet::Environments::Directories.new
static_loader on_period UNK on_nl on_ivar on_op add_loader_by_name on_lparen on_const on_op on_const on_period new on_lparen UNK on_comma self on_comma environment on_comma # Create the 3.x resource type loader
loader on_op add_loader_by_name on_lparen on_const on_op on_const on_period new on_lparen on_ivar on_comma on_const on_op on_const on_rparen on_rparen on_nl else on_ignored_nl # Not a real directory environment, cannot work as a module TODO: Drop when legacy env are dropped?
loader on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_comma self on_comma UNK on_rparen on_nl end on_nl end on_nl on_ignored_nl # View the environment as a module to allow loading from it - this module is always called 'environment'
UNK on_lparen loader on_comma environment on_rparen on_nl on_ivar on_op loader on_nl on_ignored_nl loader on_op add_loader_by_name on_lparen on_const on_op on_const on_period # An environment has a module path even if it has a null loader
on_ivar on_op loader on_nl on_ignored_nl loader on_op add_loader_by_name on_lparen on_const on_op on_const on_period new on_lparen loader on_comma on_const on_op on_const # modules should see this loader
loader on_op add_loader_by_name on_lparen on_const on_op on_const on_period new on_lparen loader on_comma on_const on_op on_const on_comma on_ivar on_period UNK on_lparen # Code in the environment gets to see all modules (since there is no metadata for the environment) # but since this is not given to the module loaders, they can not load global code (since they can not # have prior knowledge about this
on_ivar on_period UNK on_op loader on_nl loader on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma environment on_rparen on_ignored_nl on_ivar # The module loader gets the private loader via a lazy operation to look up the module's private loader. # This does not work for an environment since it is not resolved the same way. # TODO: The EnvironmentLoader could be a specialized loader instead of using a ModuleLoader to do the work. # This is subject to future design - an Environment may move more in the direction of a Module.
md on_op on_const on_period new on_lparen puppet_module on_rparen on_nl UNK on_lbracket puppet_module on_period name on_rbracket on_op md on_nl md on_period # Create data about this module
end on_nl on_ignored_nl class on_const on_nl on_ignored_nl UNK on_symbeg public_loader on_nl UNK on_symbeg UNK on_nl UNK on_symbeg UNK on_nl on_ignored_nl # NOTE: Do not resolve all modules here - this is wasteful if only a subset of modules / functions are used # The resolution is triggered by asking for a module's private loader, since this means there is interest # in the visibility from that perspective. # If later, it is wanted that all resolutions should be made up-front (to capture errors eagerly, this # can be introduced (better for production), but may be irritating in development mode.
class on_const on_nl on_ignored_nl UNK on_symbeg public_loader on_nl UNK on_symbeg UNK on_nl UNK on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg puppet_module # =LoaderModuleData # Information about a Module and its loaders. # TODO: should have reference to real model element containing all module data; this is faking it # TODO: Should use Puppet::Module to get the metadata (as a hash) - a somewhat blunt instrument, but that is # what is available with a reasonable API. #
attr_reader on_symbeg puppet_module on_nl on_ignored_nl def UNK on_lparen puppet_module on_rparen on_ignored_nl on_ivar on_op puppet_module on_nl on_ivar on_op on_lbracket on_rbracket on_nl # The Puppet::Module this LoaderModuleData represents in the loader configuration
def UNK on_lparen puppet_module on_rparen on_ignored_nl on_ivar on_op puppet_module on_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op nil on_nl on_ivar # @param puppet_module [Puppet::Module] the module instance for the module being represented #
class on_const on_nl on_ignored_nl def UNK on_lparen loaders on_rparen on_ignored_nl on_ivar on_op loaders on_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar # Resolves module loaders - resolution of model dependencies is done by Puppet::Module #
