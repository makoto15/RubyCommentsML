UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const # This module is an integral part of the Lexer. # It defines the string slurping behavior - finding the string and non string parts in interpolated # strings, translating escape sequences in strings to their single character equivalence. # # PERFORMANCE NOTE: The various kinds of slurping could be made even more generic, but requires # additional parameter passing and evaluation of conditional logic. # TODO: More detailed performance analysis of excessive character escaping and interpolation. #
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op UNK on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep # unquoted, no escapes
on_ivar on_period UNK on_op on_int on_nl str on_op UNK on_lparen on_ivar on_comma on_const on_comma on_const on_comma on_symbeg UNK on_rparen on_nl # skip the leading '
end on_nl on_ignored_nl UNK UNK on_nl scn on_op on_ivar on_nl UNK on_op scn on_period UNK on_nl str on_op UNK on_lparen # strip closing "'" from result
terminator on_op scn on_lbracket on_int on_rbracket on_nl on_lbracket str on_lbracket on_int on_op on_lparen on_op on_int on_op terminator on_period UNK on_rparen # Terminator may be a single char '"', '$', or two characters '${' group match 1 (scn[1]) from the last slurp holds this
UNK UNK on_nl scn on_op on_ivar on_nl str on_op UNK on_lparen scn on_comma on_ivar on_lbracket on_symbeg UNK on_rbracket on_comma on_ivar # Copy from old lexer - can do much better
terminator on_op scn on_lbracket on_int on_rbracket on_nl on_lbracket str on_lbracket on_int on_op on_lparen on_op on_int on_op terminator on_period UNK on_rparen # Terminator may be a single char '$', two characters '${', or empty string '' at the end of intput. # Group match 1 holds this. # The exceptional case is found by looking at the subgroup 1 of the most recent match made by the scanner (i.e. @scanner[1]). # This is the last match made by the slurp method (having called scan_until on the scanner). # If there is a terminating character is must be stripped and returned separately. #
UNK UNK on_lparen UNK on_comma UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl str on_op UNK on_period UNK on_lparen UNK on_rparen # Slurps a string from the given scanner until the given pattern and then replaces any escaped # characters given by escapes into their control-character equivalent or in case of line breaks, replaces the # pattern \r?\n with an empty string. # The returned string contains the terminating character. Returns nil if the scanner can not scan until the given # pattern. #
UNK UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_lparen str on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen # Process unicode escapes first as they require getting 4 hex digits # If later a \u is found it is warned not to be a unicode escape
UNK on_lparen str on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen UNK UNK on_op on_lbracket on_lparen UNK on_op UNK on_rparen on_period # gsub must be repeated to cater for adjacent escapes
end on_nl end on_nl on_ignored_nl UNK on_ignored_nl str on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen UNK on_ignored_nl ch on_op UNK # empty block. Everything happens in the gsub block
UNK UNK on_period UNK on_op on_regexp_beg on_tstring_content on_regexp_end on_nl UNK on_lparen on_const on_op on_const on_rparen on_nl UNK on_ignored_nl UNK UNK # A invalid byte sequence may be the result of faulty input as well, but that could not possibly # have reached this far... Unfortunately there is no more specific error and a match on message is # required to differentiate from other internal problems.
