face on_op self on_lbracket name on_comma version on_rbracket on_nl return UNK unless face on_nl UNK on_op face on_period UNK on_lparen # If the version they request specifically doesn't exist, don't search # elsewhere. Usually this will start from :current and all...
on_lparen on_ivar on_lbracket name on_rbracket on_period UNK on_op on_lbracket on_symbeg current on_rbracket on_rparen on_period UNK on_period UNK UNK on_op UNK # ...we need to search for it bound to an o{lder,ther} version. Since # we load all actions when the face is first references, this will be in # memory in the known set of versions of the face.
def self on_period UNK on_lparen name on_comma pattern on_rparen on_ignored_nl return UNK unless on_ivar on_period UNK name on_nl return on_ivar # get face from memory, without loading.
def self on_period UNK on_lparen name on_comma version on_rparen on_ignored_nl UNK UNK name UNK on_ignored_nl UNK version on_op on_symbeg current # try to load the face, and return it.
UNK UNK name UNK on_ignored_nl UNK version on_op on_symbeg current UNK on_ignored_nl UNK on_op on_ivar on_lbracket name on_rbracket on_period UNK # We always load the current version file; the common case is that we have # the expected version and any compatibility versions in the same file, # the default. Which means that this is almost always the case. # # We use require to avoid executing the code multiple times, like any # other Ruby library that we might want to use. --daniel 2011-04-06
UNK version on_op on_symbeg current UNK on_ignored_nl UNK on_op on_ivar on_lbracket name on_rbracket on_period UNK on_period UNK on_period UNK on_nl # If we wanted :current, we need to index to find that; direct version # requests just work as they go. --daniel 2011-04-06
UNK on_op on_ivar on_lbracket name on_rbracket on_period UNK on_period UNK on_period UNK on_nl on_ivar on_lbracket name on_rbracket on_lbracket on_symbeg current # We need to find current out of this. This is the largest version # number that doesn't have a dedicated on-disk file present; those # represent "experimental" versions of faces, which we don't fully # support yet. # # We walk the versions from highest to lowest and take the first version # that is not defined in an explicitly versioned file on disk as the # current version. # # This constrains us to only ship experimental versions with *one* # version in the file, not multiple, but given you can't reliably load # them except by side-effect when you ignore that rule this seems safe # enough... # # Given those constraints, and that we are not going to ship a versioned # interface that is not :current in this release, we are going to leave # these thoughts in place, and just punt on the actual versioning. # # When we upgrade the core to support multiple versions we can solve the # problems then; as lazy as possible. # # We do support multiple versions in the same file, though, so we sort # versions here and return the last item in that set. # # --daniel 2011-04-06
UNK name on_comma version on_nl end on_nl on_ignored_nl return UNK on_lparen name on_comma version on_rparen on_nl end on_nl on_ignored_nl def # Try an obsolete version of the face, if needed, to see if that helps?
UNK on_nl UNK on_const on_op UNK on_nl UNK unless UNK on_period UNK on_op UNK UNK UNK UNK on_tstring_content UNK on_nl # ...guess we didn't find the file; return a much better problem.
UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen face on_rparen on_ignored_nl on_ivar on_lbracket UNK on_lparen face on_period name # ...but we just carry on after complaining.
UNK on_const on_comma UNK on_lparen UNK on_tstring_content UNK on_rparen on_op on_ignored_nl on_lbrace UNK name on_period UNK on_comma UNK name on_period #TRANSLATORS 'face' refers to a programming API in Puppet
