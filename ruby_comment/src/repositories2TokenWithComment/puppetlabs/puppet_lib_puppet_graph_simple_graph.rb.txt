class on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl def UNK on_nl on_ivar on_op # A hopefully-faster graph class to replace the use of GRATR.
def UNK on_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_op # # All public methods of this class must maintain (assume ^ ensure) the following invariants, where "=~=" means # equiv. up to order: # # @in_to.keys =~= @out_to.keys =~= all vertices # @in_to.values.collect { |x| x.values }.flatten =~= @out_from.values.collect { |x| x.values }.flatten =~= all edges # @in_to[v1][v2] =~= @out_from[v2][v1] =~= all edges from v1 to v2 # @in_to [v].keys =~= vertices with edges leading to v # @out_from[v].keys =~= vertices with edges leading from v # no operation may shed reference loops (for gc) # recursive operation must scale with the depth of the spanning trees, or better (e.g. no recursion over the set # of all vertices, etc.) # # This class is intended to be used with DAGs. However, if the # graph has a cycle, it will not cause non-termination of any of the # algorithms. #
def clear on_nl on_ivar on_period clear on_nl on_ivar on_period clear on_nl on_ivar on_period clear on_nl on_ivar on_period clear on_nl end # Clear our graph.
def UNK on_lparen resource on_rparen on_ignored_nl vertex? on_lparen resource on_rparen on_op UNK on_lparen resource on_rparen on_period keys on_op on_lbracket on_rbracket # Which resources depend upon the given resource.
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen vertex on_comma direction on_op on_symbeg UNK on_rparen on_ignored_nl UNK # Whether our graph is directed. Always true. Used to produce dot files.
def UNK on_lparen vertex on_comma direction on_op on_symbeg UNK on_rparen on_ignored_nl UNK on_lparen vertex on_comma direction on_rparen on_period keys on_period # Determine all of the leaf nodes below a given vertex.
def UNK on_lparen UNK on_comma UNK on_op UNK on_rparen on_ignored_nl source on_op UNK on_op UNK on_period resource on_nl on_ignored_nl unless # Collect all of the edges that the passed events match. Returns # an array of edges.
on_ivar on_lbracket source on_rbracket on_period values on_period UNK on_period UNK on_lbrace on_op edge on_op edge on_period UNK on_lparen UNK on_period # Get all of the edges that this vertex should forward events # to, which is the same thing as saying all edges directly below # This vertex in the graph.
def UNK on_nl result on_op UNK on_period class on_period new on_nl vertices on_period each on_lbrace on_op vertex on_op result on_period # Return a reversed version of this graph.
def UNK on_nl vertices on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl vertices on_nl end on_nl on_ignored_nl def UNK # Return the size of the graph.
def UNK on_lparen UNK on_comma s on_rparen on_ignored_nl UNK on_op on_lbracket on_lbrace on_symbeg node on_op UNK on_rbrace on_rbracket on_nl on_ignored_nl # This is a simple implementation of Tarjan's algorithm to find strongly # connected components in the graph; this is a fairly ugly implementation, # because I can't just decorate the vertices themselves. # # This method has an unhealthy relationship with the find_cycles_in_graph # method below, which contains the knowledge of how the state object is # maintained.
UNK on_op on_lbracket on_lbrace on_symbeg node on_op UNK on_rbrace on_rbracket on_nl on_ignored_nl UNK UNK UNK on_period empty? do on_ignored_nl frame # initialize the recursion stack we use to work around the nasty lack of a # decent Ruby stack.
frame on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_nl frame on_lbracket on_symbeg child on_rbracket on_op child on_nl UNK on_period UNK # Never seen, need to recurse.
end on_nl on_ignored_nl UNK on_symbeg UNK then on_ignored_nl s on_lbracket on_symbeg lowlink on_rbracket on_lbracket vertex on_rbracket on_op on_lbracket s on_lbracket # done with this node, finally.
def UNK on_nl UNK on_op on_lbrace on_ignored_nl on_symbeg UNK on_op on_int on_comma on_symbeg index on_op on_lbrace on_rbrace on_comma on_symbeg lowlink # Find all cycles in the graph by detecting all the strongly connected # components, then eliminating everything with a size of one as # uninteresting - which it is, because it can't be a cycle. :) # # This has an unhealthy relationship with the 'tarjan' method above, which # it uses to implement the detection of strongly connected components.
vertices on_period each do on_op vertex on_op on_ignored_nl if on_op UNK on_lbracket on_symbeg index on_rbracket on_lbracket vertex on_rbracket then on_ignored_nl # we usually have a disconnected graph, must walk all possible roots
UNK on_lbracket on_symbeg UNK on_rbracket on_period UNK do on_op component on_op on_ignored_nl UNK on_lparen component on_rparen on_op UNK on_lparen component # To provide consistent results to the user, given that a hash is never # assured to return the same order, and given our graph processing is # based on hash tables, we need to sort the cycles internally, as well as # the set of cycles. # # Given we are in a failure state here, any extra cost is more or less # irrelevant compared to the cost of a fix - which is on a human # time-scale.
def UNK on_lparen cycle on_comma UNK on_op on_int on_rparen on_ignored_nl UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen if # Perform a BFS on the sub graph representing the cycle, with a view to # generating a sufficient set of paths to report the cycle meaningfully, and # ideally usefully, for the end user. # # BFS is preferred because it will generally report the shortest paths # through the graph first, which are more likely to be interesting to the # user. I think; it would be interesting to verify that. --daniel 2011-01-23
UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen if UNK on_op on_int on_nl on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl #TRANSLATORS "negative or zero" refers to the count of paths
UNK on_op on_lbrace on_rbrace on_nl cycle on_period each do on_op vertex on_op on_ignored_nl UNK on_lbracket vertex on_rbracket on_op adjacent on_lparen # Calculate our filtered outbound vertex lists...
stack on_op on_lbracket on_lbracket cycle on_period UNK on_comma on_lbracket on_rbracket on_rbracket on_rbracket on_nl UNK frame on_op stack on_period UNK do # frame struct is vertex, [path]
if frame on_lbracket on_int on_rbracket on_period UNK on_lparen frame on_lbracket on_int on_rbracket on_rparen then on_ignored_nl UNK on_op frame on_lbracket on_int #rubocop:disable Lint/AssignmentInCondition
def UNK on_nl cycles on_op UNK on_nl UNK on_op cycles on_period UNK on_nl return if UNK on_op on_int on_nl on_ignored_nl # @return [Array] array of dependency cycles (arrays)
UNK on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_const on_period UNK on_lparen UNK on_rparen on_nl cycles on_nl #TRANSLATORS '--graph' refers to a command line option and OmniGraffle and GraphViz are program names and should not be translated
graph on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl graph on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl cycles on_period each do on_op # This does not use the DOT graph library, just writes the content # directly. Given the complexity of this, there didn't seem much point # using a heavy library to generate exactly the same content. --daniel 2011-01-27
on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace on_op f on_op f on_period UNK graph on_rbrace on_nl # DOT files are assumed to be UTF-8 by default - http://www.graphviz.org/doc/info/lang.html
def UNK on_lparen vertex on_rparen on_ignored_nl on_ivar on_lbracket vertex on_rbracket on_op on_lbrace on_rbrace on_nl on_ivar on_lbracket vertex on_rbracket on_op on_lbrace # Add a new vertex to the graph.
def UNK on_lparen v on_rparen on_ignored_nl return unless vertex? on_lparen v on_rparen on_nl on_ivar on_period clear on_nl on_ivar on_period clear # Remove a vertex from the graph.
def vertex? on_lparen v on_rparen on_ignored_nl on_ivar on_period include? on_lparen v on_rparen on_nl end on_nl on_ignored_nl def vertices on_nl on_ivar # Test whether a given vertex is in the graph.
def vertices on_nl on_ivar on_period keys on_nl end on_nl on_ignored_nl def UNK on_lparen e on_comma on_op UNK on_rparen on_ignored_nl return # Return a list of all vertices.
def UNK on_lparen e on_comma on_op UNK on_rparen on_ignored_nl return UNK on_lparen e on_comma on_op UNK on_rparen unless UNK on_period # Add a new edge. The graph user has to create the edge instance, # since they have to specify what kind of edge it is.
arr on_op on_lparen on_ivar on_lbracket e on_period target on_rbracket on_lbracket e on_period source on_rbracket on_op on_lbracket on_rbracket on_rparen on_nl arr # Avoid multiple lookups here. This code is performance critical
def UNK on_lparen source on_comma target on_rparen on_ignored_nl on_lparen on_ivar on_lbracket source on_rbracket on_op on_lbrace on_rbrace on_rparen on_lbracket target on_rbracket # Find all matching edges.
def UNK on_lparen source on_comma target on_rparen on_ignored_nl vertex? on_lparen source on_rparen UNK vertex? on_lparen target on_rparen UNK on_ivar on_lbracket # Is there an edge between the two vertices?
def UNK on_lparen e on_rparen on_ignored_nl if UNK on_lparen e on_period source on_comma e on_period target on_rparen on_nl on_ivar on_period # Remove an edge from our graph.
def adjacent on_lparen v on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl ns on_op on_lparen UNK on_lbracket on_symbeg direction on_rbracket on_op # Find adjacent edges.
def UNK on_lparen source on_comma direction on_rparen on_ignored_nl stack on_op on_lbracket source on_rbracket on_nl seen on_op on_const on_period new on_nl # Just walk the tree and pass each edge.
stack on_op on_lbracket source on_rbracket on_nl seen on_op on_const on_period new on_nl UNK stack on_period empty? on_nl node on_op stack # Use an iterative, breadth-first traversal of the graph. One could do # this recursively, but Ruby's slow function calls and even slower # recursion make the shorter, recursive algorithm cost-prohibitive.
def UNK on_lparen UNK on_comma direction on_op on_symbeg UNK on_rparen on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl UNK on_lparen UNK on_comma # A different way of walking a tree, and a much faster way than the # one that comes with GRATR.
def UNK on_lparen f on_comma t on_rparen on_ignored_nl if f on_op t on_nl on_lbracket on_rbracket on_nl UNK UNK on_lparen f # Return an array of the edge-sets between a series of n+1 vertices (f=v0,v1,v2...t=vn) # connecting the two given vertices. The ith edge set is an array containing all the # edges between v(i) and v(i+1); these are (by definition) never empty. # # * if f == t, the list is empty # * if they are adjacent the result is an array consisting of # a single array (the edges from f to t) # * and so on by induction on a vertex m between them # * if there is no path from f to t, the result is nil # # This implementation is not particularly efficient; it's used in testing where clarity # is more important than last-mile efficiency. #
on_ignored_nl def UNK on_lparen params on_op on_lbrace on_rbrace on_rparen on_ignored_nl params on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op UNK on_period class # LAK:FIXME This is just a paste of the GRATR code with slight modifications.
def UNK on_lparen params on_op on_lbrace on_rbrace on_rparen on_ignored_nl params on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op UNK on_period class on_period # Return a DOT::DOTDigraph for directed graphs or a DOT::DOTSubgraph for an # undirected Graph. _params_ can contain any graph property specified in # rdot.rb. If an edge or vertex label is a kind of Hash then the keys # which match +dot+ properties will be used as well.
def UNK on_lparen params on_op on_lbrace on_rbrace on_rparen UNK on_lparen params on_rparen on_period to_s UNK end on_nl on_ignored_nl def UNK # Output the dot format as a string
def UNK on_lparen name on_rparen on_ignored_nl return unless on_const on_lbracket on_symbeg graph on_rbracket on_nl on_ignored_nl UNK on_op on_const on_period UNK # Produce the graph files if requested.
on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace on_op f on_op on_ignored_nl f on_period UNK UNK on_lparen # DOT files are assumed to be UTF-8 by default - http://www.graphviz.org/doc/info/lang.html
class on_op UNK on_nl UNK on_symbeg UNK on_nl end on_nl UNK on_period UNK on_op UNK on_nl on_ignored_nl def UNK on_lparen # This flag may be set to true to use the new YAML serialization # format (where @vertices is a simple list of vertices rather than a # list of VertexWrapper objects). Deserialization supports both # formats regardless of the setting of this flag.
vertices on_op vertices on_period keys on_nl end on_nl vertices on_period each on_lbrace on_op v on_op UNK on_lparen v on_rparen on_rbrace # Support old (2.6) format
result on_op on_lbrace on_rbrace on_nl vertices on_period each do on_op vertex on_op on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl on_lbracket on_symbeg # Represented in YAML using the old (version 2.6) format.
