UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end # The scope class, which handles storing and retrieving variables and types and # such.
class on_const on_op on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_comma # This class is part of the internal parser/evaluator/compiler functionality of Puppet. # It is passed between the various classes that participate in evaluation. # None of its methods are API except those that are clearly marked as such. # # @api public
on_const on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_comma on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_rbracket on_period freeze on_nl on_const on_op # Variables that always exist with nil value even if not set
UNK on_symbeg UNK on_nl on_ignored_nl def environment on_nl on_ivar on_period environment on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period # Hash of hashes of default values per type name
def environment on_nl on_ivar on_period environment on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl # Alias for `compiler.environment`
def UNK on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl class on_const on_nl on_ignored_nl UNK on_symbeg parent on_nl on_ignored_nl def # Alias for `compiler.catalog`
class on_const on_nl on_ignored_nl UNK on_symbeg parent on_nl on_ignored_nl def UNK on_lparen parent on_op nil on_rparen on_ignored_nl on_ivar on_op parent # Abstract base class for LocalScope and MatchScope #
target on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl on_ignored_nl def UNK on_lparen parent on_op nil on_rparen # do not include match data ($0-$n)
on_ivar on_op name on_op on_regexp_beg on_tstring_content on_regexp_end on_nl end on_nl on_ignored_nl def on_op on_lparen name on_comma value on_rparen on_ignored_nl raise # A "match variables" scope reports all numeric variables to be bound if the scope has # match_data. Without match data the scope is transparent. #
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label name on_rbrace on_nl end on_nl on_ignored_nl # TODO: Bad choice of exception
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label name on_rbrace on_nl end on_nl on_ignored_nl # TODO: Bad choice of exception
super on_nl end on_nl on_ignored_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl class on_const on_nl UNK on_symbeg value on_nl # do not include match data ($0-$n)
class on_const on_op on_const on_nl class on_const on_nl UNK on_symbeg value on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_symbeg on_ivar # @api private
def UNK on_lparen name on_comma UNK on_comma scope on_rparen on_ignored_nl scope on_period UNK do on_ignored_nl UNK on_op UNK on_lparen on_symbeg # A parameter default must be evaluated using a special scope. The scope that is given to this method must # have a `ParameterScope` as its last ephemeral scope. This method will then push a `MatchScope` while the # given `expression` is evaluated. The method will catch any throw of `:unevaluated_parameter` and produce # an error saying that the evaluated parameter X tries to access the unevaluated parameter Y. # # @param name [String] the name of the currently evaluated parameter # @param expression [Puppet::Parser::AST] the expression to evaluate # @param scope [Puppet::Parser::Scope] a scope where a `ParameterScope` has been pushed # @return [Object] the result of the evaluation # # @api private
UNK on_op on_ivar on_period UNK on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label # Parameters are evaluated in the order they have in the @params hash.
def include? on_lparen name on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_rparen on_lbrace on_ignored_nl return on_op self on_lbracket name on_rbracket on_period # Returns true if the variable of the given name has a non nil value. # TODO: This has vague semantics - does the variable exist or not? # use ['name'] to get nil or value, and if nil check with exist?('name') # this include? is only useful because of checking against the boolean value false. #
def UNK on_lparen name on_rparen on_ignored_nl on_op on_op if name on_op on_regexp_beg on_tstring_content on_regexp_end on_nl class_name on_op UNK on_nl variable_name # Returns true if the variable of the given name is set to any value (including nil) # # @return [Boolean] if variable exists or not #
on_op on_op if name on_op on_regexp_beg on_tstring_content on_regexp_end on_nl class_name on_op UNK on_nl variable_name on_op UNK on_nl return true if # Note !! ensure the answer is boolean
klass on_op UNK on_lparen class_name on_rparen on_nl UNK on_op klass on_period nil? on_op nil on_op UNK on_lparen klass on_rparen on_nl # lookup class, but do not care if it is not evaluated since that will result # in it not existing anyway. (Tests may run with just scopes and no evaluated classes which # will result in class_scope for "" not returning topscope).
def bound? on_lparen name on_rparen on_ignored_nl UNK on_lparen false on_rparen on_period bound? on_lparen name on_rparen on_nl end on_nl on_ignored_nl def # Returns true if the given name is bound in the current (most nested) scope for assignments. #
UNK on_lparen false on_rparen on_period bound? on_lparen name on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen value on_rparen # Do not look in ephemeral (match scope), the semantics is to answer if an assignable variable is bound
def self on_period UNK on_lparen value on_rparen on_ignored_nl case value on_nl when on_tstring_beg on_tstring_end on_nl false on_nl when on_symbeg UNK # Is the value true? This allows us to control the definition of truth # in one place.
def self on_period UNK on_lparen value on_rparen on_ignored_nl case value on_nl when on_const on_nl value on_nl when on_regexp_beg on_tstring_content on_regexp_end # Coerce value to a number, or return `nil` if it isn't one.
if UNK on_op UNK on_nl self on_nl else on_ignored_nl next_scope on_op inherited_scope on_op enclosing_scope on_nl if next_scope on_period nil? on_nl # walk upwards until first found node_scope or top_scope
self on_nl else on_ignored_nl next_scope on_period UNK on_lparen on_rparen on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen # this happens when testing, and there is only a single test scope and no link to any # other scopes
def UNK on_lparen compiler on_comma on_label nil on_comma on_label nil on_rparen on_ignored_nl if compiler on_period is_a? on_const on_op on_const on_op # Initialize our new scope. Defaults to having no parent.
on_ivar on_op on_const on_period new on_lparen nil on_rparen on_nl on_ignored_nl on_ivar on_op on_lbracket on_const on_period new on_lparen on_ivar on_comma nil # The symbol table for this scope. This is where we store variables. # @symtable = Ephemeral.new(nil, true)
on_ivar on_op on_const on_period new on_lbrace on_op UNK on_comma type on_op on_ignored_nl UNK on_lbracket type on_rbracket on_op on_lbrace on_rbrace on_nl # All of the defaults set for types. It's a hash of hashes, # with the first key being the type, then the second key being # the parameter.
on_ivar on_op on_lbrace on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen name on_comma scope on_rparen on_ignored_nl if parent on_nl parent # The table for storing class singletons. This will only actually # be used by top scopes and node scopes.
def UNK on_lparen name on_comma scope on_rparen on_ignored_nl if parent on_nl parent on_period UNK on_lparen name on_comma scope on_rparen on_nl # Store the fact that we've evaluated a class, and store a reference to # the scope in which it was evaluated, so that we can look it up later.
def UNK on_lparen klass on_rparen on_ignored_nl k on_op klass on_period UNK on_lparen on_symbeg name on_rparen on_op klass on_period name on_op # Return the scope associated with a class. This is just here so # that subclasses can set their parent scopes to be the scope of # their parent class, and it's also used when looking up qualified # variables.
k on_op klass on_period UNK on_lparen on_symbeg name on_rparen on_op klass on_period name on_op klass on_nl on_ivar on_lbracket k on_rbracket # They might pass in either the class or class name
def UNK on_lparen type on_rparen on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl on_ignored_nl if parent on_nl parent on_period UNK on_lparen type # Collect all of the defaults set at any higher scopes. # This is a different type of lookup because it's # additive -- it collects all of the defaults, with defaults # in closer scopes overriding those in later scopes. # # The lookupdefaults searches in the the order: # # * inherited # * contained (recursive) # * self #
if parent on_nl parent on_period UNK on_lparen type on_rparen on_period each on_lbrace on_op UNK on_comma value on_op on_ignored_nl UNK on_lbracket # first collect the values from the parents
if on_ivar on_period include? on_lparen type on_rparen on_nl on_ivar on_lbracket type on_rbracket on_period each on_lbrace on_op UNK on_comma value on_op # then override them with any current values # this should probably be done differently
def UNK on_lparen type on_comma key on_comma value on_rparen on_ignored_nl UNK on_op on_ivar on_lbracket type on_rbracket on_nl unless UNK on_period # Check if the given value is a known default for the given type #
def UNK on_lparen name on_rparen on_ignored_nl UNK on_op environment on_period UNK on_nl UNK on_period UNK on_lparen name on_rparen on_op UNK # Look up a defined type.
UNK on_op environment on_period UNK on_nl UNK on_period UNK on_lparen name on_rparen on_op UNK on_period UNK on_lparen name on_rparen on_nl # This happens a lot, avoid making a call to make a call
def UNK on_lparen name on_comma options on_op on_const on_rparen on_ignored_nl unless name on_period is_a? on_const on_nl raise on_const on_op on_const # Lookup a variable within this scope using the Puppet language's # scoping rules. Variables can be qualified using just as in a # manifest. # # @param [String] name the variable name to lookup # @param [Hash] hash of options, only internal code should give this # @param [Boolean] if resolution is of the leaf of a qualified name - only internal code should give this # @return Object the value of the variable, or if not found; nil if `strict_variables` is false, and thrown :undefined_variable otherwise # # @api public
unless on_lparen UNK on_op name on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_period nil? on_nl return UNK on_lparen UNK # If name has '::' in it, it is resolved as a qualified variable
return UNK on_lparen UNK on_op on_int on_op name on_lbracket on_int on_op on_op on_int on_rbracket on_op name on_comma options on_rparen on_nl # Always drop leading '::' if present as that is how the values are keyed.
table on_op on_ivar on_period last on_nl val on_op table on_lbracket name on_rbracket on_nl return val unless val on_period nil? on_op # At this point, search is for a non qualified (simple) name
on_const on_op UNK on_lparen on_const on_rparen on_op on_const on_op on_const on_nl on_ignored_nl def UNK on_lparen name on_comma reason on_op nil # The exception raised when a throw is uncaught is different in different versions # of ruby. In >=2.2.0 it is UncaughtThrowError (which did not exist prior to this) #
if on_const on_period include? on_lparen name on_rparen on_op name on_op on_const on_op on_const on_op on_const on_op on_const on_nl return nil # Built in variables and numeric variables always exist
when on_symbeg UNK on_nl on_const on_period UNK on_lparen on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label name # do nothing
def on_op on_lparen UNK on_comma options on_op on_const on_rparen on_ignored_nl UNK on_lparen UNK on_comma options on_rparen on_nl end on_nl on_ignored_nl # Retrieves the variable value assigned to the name given as an argument. The name must be a String, # and namespace can be qualified with '::'. The value is looked up in this scope, its parent scopes, # or in a specific visible named scope. # # @param varname [String] the name of the variable (may be a qualified name using `(ns'::')*varname` # @param options [Hash] Additional options, not part of api. # @return [Object] the value assigned to the given varname # @see #[]= # @api public #
def inherited_scope on_nl if resource on_op resource on_period type on_op on_const on_op on_op resource on_period UNK on_period parent on_period nil? # The class scope of the inherited thing of this scope's resource. # # @return [Puppet::Parser::Scope] The scope or nil if there is not an inherited scope
def enclosing_scope on_nl if UNK on_nl if parent on_period UNK on_op parent on_period UNK on_nl parent on_nl else on_ignored_nl parent # The enclosing scope (topscope or nodescope) of this scope. # The enclosing scopes are produced when a class or define is included at # some point. The parent scope of the included class or define becomes the # scope in which it was included. The chain of parent scopes is followed # until a node scope or the topscope is found # # @return [Puppet::Parser::Scope] The scope or nil if there is no enclosing scope
def UNK on_lparen fqn on_comma options on_rparen on_ignored_nl table on_op on_ivar on_period UNK on_nl val on_op table on_lbracket fqn on_rbracket # @api private
UNK on_op fqn on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl unless UNK on_period nil? on_nl UNK on_op fqn on_lbracket # not found - search inherited scope for class
return UNK on_lparen class_name on_comma UNK on_comma options on_comma UNK on_period UNK on_rparen on_nl end on_nl end on_nl return UNK # because a failure to find the class, or inherited should be reported against given name
return UNK on_lparen on_tstring_beg on_tstring_end on_comma fqn on_comma options on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen name on_rparen on_ignored_nl # report with leading '::' by using empty class_name
def UNK on_lparen name on_rparen on_ignored_nl on_ivar on_period last on_period include? on_lparen name on_rparen on_nl end on_nl on_ignored_nl def UNK # @api private
def UNK on_lparen name on_rparen on_ignored_nl on_ivar on_period last on_lbracket name on_rbracket on_nl end on_nl on_ignored_nl def UNK on_lparen class_name # @api private
UNK on_op if UNK on_lbracket on_symbeg UNK on_rbracket on_nl on_const on_op on_const on_op on_const on_period UNK on_lparen nil on_comma UNK # Do not issue warning if strict variables are on, as an error will be raised by variable_not_found
def UNK on_lparen UNK on_op true on_comma include_undef on_op false on_rparen on_ignored_nl if UNK UNK UNK on_nl target on_op enclosing_scope # Returns a Hash containing all variables and their values, optionally (and # by default) including the values defined in parent. Local values # shadow parent values. Ephemeral scopes for match results ($0 - $n) are not included. # Optionally include the variables that are explicitly set to `undef`. #
on_ivar on_period last on_period UNK on_lparen target on_comma include_undef on_rparen on_nl target on_nl end on_nl on_ignored_nl def UNK on_lparen options # add all local scopes
def UNK on_lparen options on_op on_lbrace on_rbrace on_rparen on_ignored_nl compiler on_period UNK on_lparen self on_comma options on_rparen on_nl end on_nl # Create a new scope and set these options.
def UNK on_lparen type on_comma UNK on_rparen on_ignored_nl table on_op on_ivar on_lbracket type on_rbracket on_nl on_ignored_nl UNK on_op on_lbracket UNK # Set defaults for a type. The typename should already be downcased, # so that the syntax is isolated. We don't do any kind of type-checking # here; instead we let the resource do it when the defaults are used.
UNK on_op on_lbracket UNK on_rbracket unless UNK on_period is_a? on_lparen on_const on_rparen on_nl on_ignored_nl UNK on_period each on_lbrace on_op param # if we got a single param, it'll be in its own array
def UNK on_lparen UNK on_comma UNK on_op true on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_nl table on_op UNK on_lparen # Merge all settings for the given _env_name_ into this scope # @param env_name [Symbol] the name of the environment # @param set_in_this_scope [Boolean] if the settings variables should also be set in this instance of scope
UNK on_lbracket on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_end on_rbracket on_op value on_nl end on_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket # also write the fqn into global table for direct lookup
UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op UNK on_nl nil on_nl end on_nl on_ignored_nl def transform_setting on_lparen val on_rparen on_ignored_nl # set the 'all_local' - a hash of all settings
on_symbeg UNK on_op val on_op nil on_op val on_period UNK on_nl end on_nl end on_nl private on_symbeg transform_setting on_nl on_ignored_nl # not ideal, but required as there are settings values that are special
def setvar on_lparen name on_comma value on_comma options on_op on_const on_rparen on_ignored_nl if name on_op on_regexp_beg on_tstring_content on_regexp_end on_nl raise # Set a variable in the current scope. This will override settings # in scopes above, but will not allow variables in the current scope # to be reassigned. # It's preferred that you use self[]= instead of this; only use this # when you need to set options.
end on_nl unless name on_period is_a? on_const on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op # unless options[:ephemeral]
if on_lparen name on_op on_const on_op name on_op on_const on_rparen on_op on_op options on_lbracket on_symbeg UNK on_rbracket on_nl raise on_const # Check for reserved variable names
if name on_op on_const on_op on_op options on_lbracket on_symbeg UNK on_rbracket on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg # Check for server_facts reserved variable name
if on_ivar on_period UNK on_lparen table on_rparen on_nl if UNK on_nl compiler on_period UNK on_lbracket name on_rbracket on_op value on_nl # Assign the qualified name in the environment # Note that Settings scope has a source set to Boolean true. # # Only meaningful to set a fqn globally if table to assign to is the top of the scope's ephemeral stack
compiler on_period UNK on_lbracket name on_rbracket on_op value on_nl UNK source on_period is_a? on_lparen on_const on_op on_const on_op on_const on_rparen # the scope name is '::'
UNK on_op source on_period name on_nl compiler on_period UNK on_lbracket on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end on_rbracket # the name is the name of the class
def deep_freeze on_lparen object on_rparen on_ignored_nl case object on_nl when on_const on_nl object on_period each on_lbrace on_op v on_op deep_freeze # Deeply freezes the given object. The object and its content must be of the types: # Array, Hash, Numeric, Boolean, Regexp, NilClass, or String. All other types raises an Error. # (i.e. if they are assignable to Puppet::Pops::Types::Data type). #
when on_const on_nl object on_period freeze on_nl else on_ignored_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # do nothing
def UNK on_lparen UNK on_rparen on_ignored_nl s on_op on_ivar on_lbracket on_op on_int on_rbracket on_nl return s on_op on_ivar if UNK # Return the effective "table" for setting variables. # This method returns the first ephemeral "table" that acts as a local scope, or this # scope's symtable. If the parameter `use_ephemeral` is true, the "top most" ephemeral "table" # will be returned (irrespective of it being a match scope or a local scope). # # @param use_ephemeral [Boolean] whether the top most ephemeral (of any kind) should be used or not
def on_op on_lparen UNK on_comma value on_comma _ on_op nil on_rparen on_ignored_nl setvar on_lparen UNK on_comma value on_rparen on_nl end # Sets the variable value of the name given as an argument to the given value. The value is # set in the current scope and may shadow a variable with the same name in a visible outer scope. # It is illegal to re-assign a variable in the same scope. It is illegal to set a variable in some other # scope/namespace than the scope passed to a method. # # @param varname [String] The variable name to which the value is assigned. Must not contain `::` # @param value [String] The value to assign to the given variable name. # @param options [Hash] Additional options, not part of api and no longer used. # # @api public #
def UNK on_nl return on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_tstring_end unless on_ivar on_period nil? on_nl on_ignored_nl UNK on_op on_const # Used mainly for logging
return on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_tstring_end unless on_ivar on_period nil? on_nl on_ignored_nl UNK on_op on_const on_op on_const on_op # As this is used for logging, this should really not be done in this class at all...
UNK on_op on_const on_op on_const on_op on_const on_period UNK on_nl return on_tstring_beg on_tstring_content on_tstring_end if UNK on_period UNK on_nl on_ignored_nl # For logging of function-scope - it is now showing the file and line.
path on_op UNK on_lbracket on_int on_rbracket on_nl UNK on_op nil on_nl UNK on_op environment on_period UNK on_period UNK unless on_lparen # shorten the path if possible
UNK on_op environment on_period UNK on_period UNK on_lbrace on_op UNK on_op path on_period UNK on_lparen UNK on_rparen on_rbrace on_nl if # check module paths first since they may be in the environment (i.e. they are longer)
on_tstring_beg on_tstring_content on_embexpr_beg on_lbracket path on_comma UNK on_lbracket on_int on_rbracket on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_embexpr_end on_tstring_content # Make the output appear as "Scope(path, line)"
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_period UNK on_lparen on_ivar on_period UNK on_op UNK on_rparen on_nl end on_nl on_ignored_nl # Pop ephemeral scopes up to level and return them # # @param level [Integer] a positive integer # @return [Array] the removed ephemeral scopes # @api private
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period each on_lbrace on_op UNK on_op on_ivar on_period push on_lparen UNK on_rparen on_rbrace # Push ephemeral scopes onto the ephemeral scope stack # @param ephemeral_scopes [Array] # @api private
def UNK on_lparen UNK on_op false on_rparen on_ignored_nl if UNK on_nl on_ivar on_period push on_lparen on_const on_period new on_lparen on_ivar # TODO: Who calls this?
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen on_op UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Execute given block in global scope with no ephemerals present # # @yieldparam [Scope] global_scope the global and ephemeral less scope # @return [Object] the return of the block # # @api private
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_period new on_lparen on_ivar on_period last on_rparen on_nl UNK on_period UNK # Execute given block with a ephemeral scope containing the given variables # @api private
def UNK on_nl UNK on_op on_ivar on_nl begin on_ignored_nl on_ivar on_op on_lbracket on_ivar on_rbracket on_nl UNK on_lparen self on_rparen on_nl # Execute given block with all ephemeral popped from the ephemeral stack # # @api private
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op on_const on_period new on_lparen on_ivar on_period last on_comma UNK on_comma # Nests a parameter scope # @param [String] callee_name the name of the function, template, or resource that defines the parameters # @param [Array<String>] param_names list of parameter names # @yieldparam [ParameterScope] param_scope the nested scope # @api private
def UNK on_nl UNK on_op UNK on_nl begin on_ignored_nl UNK on_nl UNK on_ignored_nl UNK on_lparen UNK on_rparen on_nl end on_nl # Execute given block and ensure that ephemeral level is restored # # @return [Object] the return of the block # # @api private
def UNK on_lparen match_data on_rparen on_ignored_nl on_ivar on_period last on_period match_data on_op match_data on_nl end on_nl on_ignored_nl def UNK on_lparen # Sets match data in the most nested scope (which always is a MatchScope), it clobbers match data already set there #
def UNK on_lparen match_data on_rparen on_ignored_nl on_ivar on_period push on_lparen on_const on_period new on_lparen on_ivar on_period last on_comma match_data on_rparen # Nests a match data scope
UNK on_lparen true on_rparen on_nl match on_period each on_lbrace on_op k on_comma v on_op setvar on_lparen k on_comma v on_comma # Create local scope ephemeral and set all values from hash
UNK on_lparen false on_rparen on_nl else on_ignored_nl raise on_lparen on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label # Must always have an inner match data scope (that starts out as transparent) # In 3x slightly wasteful, since a new nested scope is created for a match # (TODO: Fix that problem)
UNK on_lparen match on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen type on_rparen on_ignored_nl raise on_const on_op on_const # Create a match ephemeral and set values from match data
def UNK on_lparen type on_rparen on_ignored_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # @api private
def UNK on_lparen type on_rparen on_ignored_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # @api private
def UNK on_lparen type on_rparen on_ignored_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # @api private
if UNK UNK on_nl UNK on_lparen UNK on_comma on_op UNK on_rparen on_nl else on_ignored_nl raise on_const on_op on_const on_comma _ # In odd circumstances, this might not end up defined by the previous # method, so we might as well be certain.
def UNK on_lparen type on_comma UNK on_rparen on_ignored_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # To be removed when enough time has passed after puppet 5.0.0 # @api private
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK do on_op name on_op on_ignored_nl case name on_nl when on_const on_nl # Transforms references to classes to the form suitable for # lookup in the compiler. # # Makes names passed in the names array absolute if they are relative. # # Transforms Class[] and Resource[] type references to class name # or raises an error if a Class[] is unspecific, if a Resource is not # a 'class' resource, or if unspecific (no title). # # # @param names [Array<String>] names to (optionally) make absolute # @return [Array<String>] names after transformation #
raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless name on_period class_name on_nl name on_period class_name on_period UNK on_lparen #TRANSLATORS "Class" and "Type" are Puppet keywords and should not be translated
def UNK on_lparen UNK on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_period new # Calls a 3.x or 4.x function by name with arguments given in an array using the 4.x calling convention # and returns the result. # Note that it is the caller's responsibility to rescue the given ArgumentError and provide location information # to aid the user find the problem. The problem is otherwise reported against the source location that # invoked the function that ultimately called this method. # # @return [Object] the result of the called function # @raise ArgumentError if the function does not exist
raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl unless type_name on_op on_regexp_beg on_tstring_content on_regexp_end on_nl raise #TRANSLATORS "Resource" is a class name and should not be translated
raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label type_name on_rbrace on_nl end on_nl if title on_period #TRANSLATORS "Resource" is a class name and should not be translated
raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op #TRANSLATORS "Resource" is a class name and should not be translated
