on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # The Lexer is responsible for turning source text into tokens. # This version is a performance enhanced lexer (in comparison to the 3.x and earlier "future parser" lexer. # # Old returns tokens [:KEY, value, { locator = } # Could return [[token], locator] # or Token.new([token], locator) with the same API x[0] = token_symbol, x[1] = self, x[:key] = (:value, :file, :line, :pos) etc
on_const on_op on_lbracket on_symbeg on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_comma on_int on_rbracket on_period freeze on_nl on_const on_op on_lbracket # ALl tokens have three slots, the token name (a Symbol), the token text (String), and a token text length. # All operator and punctuation tokens reuse singleton arrays Tokens that require unique values create # a unique array per token. # # PEFORMANCE NOTES: # This construct reduces the amount of object that needs to be created for operators and punctuation. # The length is pre-calculated for all singleton tokens. The length is used both to signal the length of # the token, and to advance the scanner position (without having to advance it with a scan(regexp)). #
on_ignored_nl on_const on_op on_lbracket on_symbeg on_const on_comma nil on_comma on_int on_rbracket on_period freeze on_nl on_ignored_nl on_const on_op on_lbracket on_symbeg on_const # lexed but not an operator in Puppet
on_const on_op on_lbracket on_symbeg on_const on_comma nil on_comma on_int on_rbracket on_period freeze on_nl on_const on_op on_lbracket on_symbeg on_const on_comma nil # Tokens that are always unique to what has been lexed
on_const on_op on_lbracket on_symbeg on_const on_comma nil on_comma on_int on_rbracket on_period freeze on_nl on_ignored_nl on_const on_op on_lbracket on_symbeg on_const on_comma # HEREDOC has syntax as an argument.
on_const on_op on_lbracket on_symbeg on_const on_comma nil on_comma on_int on_rbracket on_period freeze on_nl on_const on_op on_lbracket on_symbeg on_const on_comma on_tstring_beg # EPP_START is currently a marker token, may later get syntax
on_const on_op on_lbracket on_symbeg on_const on_comma nil on_comma on_int on_rbracket on_nl on_ignored_nl on_const on_op on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op # This is used for unrecognized tokens, will always be a single character. This particular instance # is not used, but is kept here for documentation purposes.
on_const on_op on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_symbeg on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_int on_rbracket on_comma on_ignored_nl # Keywords are all singleton tokens with pre calculated lengths. # Booleans are pre-calculated (rather than evaluating the strings "false" "true" repeatedly. #
on_const on_op on_lbrace on_rbrace on_nl on_const on_period each on_lbrace on_op UNK on_comma v on_op on_const on_lbracket v on_lbracket on_int on_rbracket # Reverse lookup of keyword name to string
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const # The single line comment includes the line ending.
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_ignored_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op # for replacement to ""
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_ignored_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl # for replacement to ""
on_ignored_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end # for replacement to "/"
on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl # The 3x patterns: # PATTERN_CLASSREF = %r{((::){0,1}[A-Z][-\w]*)+} # PATTERN_NAME = %r{((::)?[a-z0-9][-\w]*)(::[a-z0-9][-\w]*)*}
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl # The NAME and CLASSREF in 4x are strict. Each segment must start with # a letter a-z and may not contain dashes (\w includes letters, digits and _). #
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_nl on_ignored_nl UNK on_symbeg locator on_nl on_ignored_nl def UNK on_lparen on_rparen on_ignored_nl on_ivar # PERFORMANCE NOTE: # Comparison against a frozen string is faster (than unfrozen). #
if before on_op on_int on_op on_ivar on_period string on_period UNK on_lparen on_int on_comma before on_rparen on_lbracket on_op on_int on_rbracket on_op # Must check the preceding character to see if it is whitespace. # The fastest thing to do is to simply byteslice to get the string ending at the offset before # and then check what the last character is. (This is the same as what an locator.char_offset needs # to compute, but with less overhead of trying to find out the global offset from a local offset in the # case when this is sublocated in a heredoc).
UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl if before on_op UNK on_op on_ivar on_period string on_period UNK on_lparen UNK # If first on a line, or only whitespace between start of line and '(' # then the token is special to avoid being taken as start of a call.
on_ivar on_lbracket on_symbeg UNK on_rbracket on_op on_int on_nl emit on_lparen if on_ivar on_lbracket on_symbeg after on_rbracket on_op on_symbeg on_const on_nl # The lexer needs to help the parser since the technology used cannot deal with # lookahead of same token with different precedence. This is solved by making left brace # after ? into a separate token. #
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS @, @@, @(
UNK la on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_nl else on_ignored_nl emit on_lparen on_const on_comma scn on_period # TODO; Check if this is good for the grammar
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS |, |>, |>>
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS =, =>, ==, =~
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS '+', '+=', and '+>'
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS '-', '->', and epp '-%>' (end of interpolation with trim)
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS !, !=, !~
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS ~>, ~
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS '/', '/*' and '/ regexp /'
value on_op scn on_period scan on_lparen on_const on_rparen if UNK on_nl if value on_nl UNK UNK on_lparen value on_rparen on_nl # regexp position is a regexp, else a div
UNK UNK on_lparen value on_rparen on_nl UNK on_op scn on_period UNK on_lparen on_const on_rparen on_nl UNK emit on_lparen on_const on_comma # Ensure an escaped / was not matched
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS <, <=, <|, <<|, <<, <-, <~
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS >, >=, >>
on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl la on_op scn on_period peek on_lparen on_int on_rparen on_nl # TOKENS :, ::CLASSREF, ::NAME
UNK on_op la on_lbracket on_int on_rbracket on_nl if UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl # PERFORMANCE NOTE: This could potentially be speeded up by using a case/when listing all # upper case letters. Alternatively, the 'A', and 'Z' comparisons may be faster if they are # frozen. #
value on_op scn on_period scan on_lparen on_const on_rparen on_nl if value on_op scn on_period peek on_lparen on_int on_rparen on_op on_tstring_beg # CLASSREF or error
scn on_period pos on_op scn on_period pos on_op on_int on_nl lex_error on_lparen on_const on_op on_const on_rparen on_nl end on_nl else # move to faulty position ('::<uc-letter>' was ok)
scn on_period pos on_op scn on_period pos on_op on_int on_nl lex_error on_lparen on_const on_op on_const on_rparen on_nl end on_nl end # move to faulty position ('::' was ok)
emit on_lparen on_const on_comma before on_rparen on_nl end on_nl end on_comma on_ignored_nl on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl # consume the $ and let higher layer complain about the error instead of getting a syntax error
UNK on_nl end on_comma on_ignored_nl on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op lambda do on_ignored_nl scn on_op on_ivar on_nl before on_op scn # Recursive string interpolation, 'interpolate' either returns a STRING token, or # a DQPRE with the rest of the string's tokens placed in the @token_queue
ctx on_op on_ivar on_nl if ctx on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_period pos on_op ctx on_lbracket on_symbeg UNK on_rbracket # If heredoc_cont is in effect there are heredoc text lines to skip over # otherwise just skip the newline. #
on_rbrace on_nl on_ignored_nl on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period each on_lbrace on_op # when the peek(1) returns empty
scn on_period pos on_op before on_op on_int on_nl UNK scn on_period peek on_lparen on_int on_rparen on_op on_regexp_beg on_tstring_content on_regexp_end on_nl # preceded by a dot. Is this a bad decimal number then?
scn on_period pos on_op scn on_period pos on_op on_int on_nl UNK on_op scn on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen # move to faulty position ([a-z_] was ok)
scn on_period pos on_op scn on_period pos on_op on_int on_nl lex_error on_lparen on_const on_op on_const on_rparen on_nl end on_nl end # move to faulty position ([A-Z] was ok)
scn on_op on_ivar on_nl if scn on_period UNK on_lparen on_const on_rparen on_nl nil on_nl else on_ignored_nl emit on_lparen on_lbracket on_symbeg # In case of unicode spaces of various kinds that are captured by a regexp, but not by the # simpler case expression above (not worth handling those special cases with better performance).
emit on_lparen on_lbracket on_symbeg on_const on_comma scn on_period peek on_lparen on_int on_rparen on_comma on_int on_rbracket on_comma scn on_period pos on_rparen # "unrecognized char"
def UNK on_lparen value on_rparen on_ignored_nl UNK on_op false on_nl if value on_period UNK on_lparen on_const on_rparen on_nl value on_lbracket # Determine if last char of value is escaped by a backslash
UNK on_op on_op UNK on_nl else on_ignored_nl UNK on_op false on_nl end on_nl end on_nl end on_nl UNK on_nl end # backslash
def UNK on_lparen on_rparen on_ignored_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl end on_nl on_ignored_nl # Clears the lexer state (it is not required to call this as it will be garbage collected # and the next lex call (lex_string, lex_file) will reset the internal state. #
on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl end on_nl on_ignored_nl def UNK on_lparen string on_rparen # not really needed, but if someone wants to ensure garbage is collected as early as possible
def UNK on_lparen string on_rparen on_ignored_nl UNK on_lparen string on_comma nil on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen string # Convenience method, and for compatibility with older lexer. Use the lex_string instead which allows # passing the path to use without first having to call file= (which reads the file if it exists). # (Bad form to use overloading of assignment operator for something that is not really an assignment. Also, # overloading of = does not allow passing more than one argument). #
def UNK on_lparen string on_comma locator on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_nl UNK on_lparen string on_rparen on_nl on_ivar # Lexes an unquoted string. # @param string [String] the string to lex # @param locator [Locator] the locator to use (a default is used if nil is given) # @param escapes [Array<String>] array of character strings representing the escape sequences to transform # @param interpolate [Boolean] whether interpolation of expressions should be made or not. #
def UNK on_lparen file on_rparen on_ignored_nl UNK on_lparen file on_rparen on_nl end on_nl on_ignored_nl def file on_nl on_ivar on_op on_ivar # Convenience method, and for compatibility with older lexer. Use the lex_file instead. # (Bad form to use overloading of assignment operator for something that is not really an assignment). #
def file on_nl on_ivar on_op on_ivar on_period file on_op nil on_nl end on_nl on_ignored_nl def UNK on_lparen file on_rparen on_ignored_nl # TODO: This method should not be used, callers should get the locator since it is most likely required to # compute line, position etc given offsets. #
def UNK on_lparen file on_rparen on_ignored_nl UNK on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen file on_rparen on_op on_const # Initializes lexing of the content of the given file. An empty string is used if the file does not exist. #
on_ivar on_op on_lbrace on_ignored_nl on_symbeg UNK on_op on_int on_comma on_ignored_nl on_symbeg after on_op nil on_comma on_ignored_nl on_symbeg UNK on_op on_int # NOTE: additional keys are used; :escapes, :uq_slurp_pattern, :newline_jump, :epp_*
on_ivar on_op on_const on_lbracket on_symbeg UNK on_rbracket on_op on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_symbeg on_const on_comma on_tstring_beg on_tstring_content on_tstring_end # Use of --tasks introduces the new keyword 'plan'
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl scan on_lbrace on_op token on_op UNK on_period UNK on_lparen token on_rparen on_rbrace # Scans all of the content and returns it in an array # Note that the terminating [false, false] token is included in the result. #
def scan on_nl scn on_op on_ivar on_nl UNK on_lparen on_const on_op on_const on_rparen UNK scn on_nl on_ignored_nl ctx on_op on_ivar # A block must be passed to scan. It will be called with two arguments, a symbol for the token, # and an instance of LexerSupport::TokenValue # PERFORMANCE NOTE: The TokenValue is designed to reduce the amount of garbage / temporary data # and to only convert the lexer's internal tokens on demand. It is slightly more costly to create an # instance of a class defined in Ruby than an Array or Hash, but the gain is much bigger since transformation # logic is avoided for many of its members (most are never used (e.g. line/pos information which is only of # value in general for error messages, and for some expressions (which the lexer does not know about). #
scn on_op on_ivar on_nl UNK on_lparen on_const on_op on_const on_rparen UNK scn on_nl on_ignored_nl ctx on_op on_ivar on_nl UNK on_op # PERFORMANCE note: it is faster to access local variables than instance variables. # This makes a small but notable difference since instance member access is avoided for # every token in the lexed content. #
UNK UNK on_period UNK on_op scn on_period UNK do on_ignored_nl token on_op UNK on_period UNK on_op UNK on_lbracket scn on_period # This is the lexer's main loop
UNK on_lbracket false on_comma false on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_lbracket on_ivar on_period peek on_lparen on_int # Signals end of input
def UNK on_nl on_ivar on_lbracket on_ivar on_period peek on_lparen on_int on_rparen on_rbracket on_period UNK on_nl end on_nl on_ignored_nl def emit # This lexes one token at the current position of the scanner. # PERFORMANCE NOTE: Any change to this logic should be performance measured. #
def emit on_lparen token on_comma byte_offset on_rparen on_ignored_nl on_ivar on_period pos on_op byte_offset on_op token on_lbracket on_int on_rbracket on_nl on_lbracket # Emits (produces) a token [:tokensymbol, TokenValue] and moves the scanner's position past the token #
def emit_completed on_lparen token on_comma byte_offset on_rparen on_ignored_nl on_lbracket token on_lbracket on_int on_rbracket on_comma on_const on_period new on_lparen token on_comma # Emits the completed token on the form [:tokensymbol, TokenValue. This method does not alter # the scanner's position. #
def UNK on_lparen token on_comma byte_offset on_rparen on_ignored_nl on_ivar on_op emit_completed on_lparen token on_comma byte_offset on_rparen on_nl end on_nl on_ignored_nl # Enqueues a completed token at the given offset
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl case on_ivar on_lbracket on_symbeg # Allows subprocessors for heredoc etc to enqueue tokens that are tokenized by a different lexer instance #
def UNK on_nl case on_ivar on_lbracket on_symbeg after on_rbracket on_nl on_ignored_nl when on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const # Answers after which tokens it is acceptable to lex a regular expression. # PERFORMANCE NOTE: # It may be beneficial to turn this into a hash with default value of true for missing entries. # A case expression with literal values will however create a hash internally. Since a reference is # always needed to the hash, this access is almost as costly as a method call. #
when on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_nl false on_nl on_ignored_nl when on_symbeg on_const on_nl # Ends of (potential) R-value generating expressions
when on_symbeg on_const on_nl UNK on_nl on_ignored_nl when on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_comma # End of (potential) R-value - but must be allowed because of case expressions # Called out here to not be mistaken for a bug.
when on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg on_const on_comma on_symbeg # Operands (that can be followed by DIV (even if illegal in grammar)
