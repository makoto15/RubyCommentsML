class on_const on_nl on_const on_op on_const on_period new on_period UNK on_nl on_ignored_nl def self on_period UNK on_nl UNK on_op on_lbrace # Merges to objects into one based on an implemented strategy. #
def self on_period UNK on_lparen merge on_rparen on_ignored_nl UNK on_const on_op on_const UNK merge on_nl UNK merge if merge on_period # Finds the merge strategy for the given _merge_, creates an instance of it and returns that instance. # # @param merge [MergeStrategy,String,Hash<String,Object>,nil] The merge strategy. Can be a string or symbol denoting the key # identifier or a hash with options where the key 'strategy' denotes the key # @return [MergeStrategy] The matching merge strategy #
raise on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl UNK on_op merge on_period UNK on_op UNK on_op #TRANSLATORS 'merge' is a variable name and 'strategy' is a key and should not be translated
def self on_period UNK on_nl UNK on_period UNK on_op on_lbracket on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_nl # Returns the list of merge strategy keys known to this class # # @return [Array<Symbol>] List of strategy keys #
def self on_period add_strategy on_lparen strategy_class on_rparen on_ignored_nl UNK on_const on_op strategy_class on_nl raise on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content # Adds a new merge strategy to the map of strategies known to this class # # @param strategy_class [Class<MergeStrategy>] The class of the added strategy #
raise on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl on_lbrace UNK strategy_class on_rbrace on_nl end on_nl UNK on_lbracket #TRANSLATORS 'MergeStrategies.add_strategy' is a method, 'stratgey_class' is a variable and 'MergeStrategy' is a class name and should not be translated
def self on_period merge on_lparen e1 on_comma e2 on_comma merge on_rparen on_ignored_nl UNK on_lparen merge on_rparen on_period merge on_lparen e1 # Finds a merge strategy that corresponds to the given _merge_ argument and delegates the task of merging the elements of _e1_ and _e2_ to it. # # @param e1 [Object] The first element # @param e2 [Object] The second element # @return [Object] The result of the merge #
def UNK on_lparen options on_rparen on_ignored_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma self on_period class on_period UNK on_comma options on_rparen # Create a new instance of this strategy configured with the given _options_ # @param merge_options [Hash<String,Object>] Merge options
def merge on_lparen e1 on_comma e2 on_rparen on_ignored_nl checked_merge on_lparen on_ignored_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma value_t on_comma e1 # Merges the elements of _e1_ and _e2_ according to the rules of this strategy and options given when this # instance was created # # @param e1 [Object] The first element # @param e2 [Object] The second element # @return [Object] The result of the merge #
def UNK on_lparen lookup_variants on_rparen on_ignored_nl UNK on_lparen lookup_variants on_comma on_const on_op on_const on_period UNK on_rparen on_nl end on_nl on_ignored_nl # TODO: API 5.0 Remove this method # @deprecated
def UNK on_lparen lookup_variants on_comma UNK on_rparen on_ignored_nl UNK lookup_variants on_period UNK on_nl UNK UNK on_nl UNK on_symbeg UNK on_nl # Merges the result of yielding the given _lookup_variants_ to a given block. # # @param lookup_variants [Array] The variants to pass as second argument to the given block # @return [Object] the merged value. # @yield [} ] # @yieldparam variant [Object] each variant given in the _lookup_variants_ array. # @yieldreturn [Object] the value to merge with other values # @throws :no_such_key if the lookup was unsuccessful # # Merges the result of yielding the given _lookup_variants_ to a given block. # # @param lookup_variants [Array] The variants to pass as second argument to the given block # @return [Object] the merged value. # @yield [} ] # @yieldparam variant [Object] each variant given in the _lookup_variants_ array. # @yieldreturn [Object] the value to merge with other values # @throws :no_such_key if the lookup was unsuccessful #
def UNK on_lparen value on_rparen on_ignored_nl value on_nl end on_nl on_ignored_nl def UNK on_lparen value on_rparen on_ignored_nl value on_nl end # Converts a single value to the type expected when merging two elements # @param value [Object] the value to convert # @return [Object] the converted value
def UNK on_lparen value on_rparen on_ignored_nl value on_nl end on_nl on_ignored_nl def options on_nl on_ivar on_nl end on_nl on_ignored_nl def # Applies the merge strategy on a single element. Only applicable for `unique` # @param value [Object] the value to merge with nothing # @return [Object] the merged value
def UNK on_nl on_ivar on_op on_const on_op on_const on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content UNK key UNK on_tstring_content on_tstring_end # Returns the type used to validate the options hash # # @return [Types::PStructType] the puppet type #
def value_t on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def checked_merge on_lparen e1 on_comma e2 on_rparen # Returns the type used to validate the options hash # # @return [Types::PAnyType] the puppet type #
class on_const on_op on_const on_nl on_const on_op self on_period new on_lparen on_const on_rparen on_nl on_ignored_nl def self on_period key on_nl # Simple strategy that returns the first value found. It never merges any values. #
def UNK on_lparen lookup_variants on_comma UNK on_rparen on_ignored_nl lookup_variants on_period UNK on_lbrace on_op UNK on_op UNK on_lparen on_symbeg UNK on_rparen # Returns the first value found # # @param lookup_variants [Array] The variants to pass as second argument to the given block # @return [Object] the merged value # @throws :no_such_key unless the lookup was successful #
lookup_variants on_period UNK on_lbrace on_op UNK on_op UNK on_lparen on_symbeg UNK on_rparen on_lbrace UNK UNK on_lparen UNK on_rparen on_rbrace on_rbrace # First found does not continue when a root key was found and a subkey wasn't since that would # simulate a hash merge
class on_const on_op on_const on_nl on_const on_op self on_period new on_lparen on_const on_rparen on_nl on_ignored_nl def self on_period key on_nl # Same as {FirstFoundStrategy} but used when no strategy has been explicitly given
class on_const on_op on_const on_nl on_const on_op self on_period new on_lparen on_const on_rparen on_nl on_ignored_nl def self on_period key on_nl # Produces a new hash by merging hash e1 with hash e2 in such a way that the values of duplicate keys # will be those of e1 #
def checked_merge on_lparen e1 on_comma e2 on_rparen on_ignored_nl e2 on_period merge on_lparen e1 on_rparen on_nl end on_nl on_ignored_nl UNK on_nl # @param e1 [Hash<String,Object>] The hash that will act as the source of the merge # @param e2 [Hash<String,Object>] The hash that will act as the receiver for the merge # @return [Hash<String,Object]] The merged hash # @see Hash#merge
class on_const on_op on_const on_nl on_const on_op self on_period new on_lparen on_const on_rparen on_nl on_ignored_nl def self on_period key on_nl # Merges two values that must be either scalar or arrays into a unique set of values. # # Scalar values will be converted into a one element arrays and array values will be flattened # prior to forming the unique set. The order of the elements is preserved with e1 being the # first contributor of elements and e2 the second. #
def checked_merge on_lparen e1 on_comma e2 on_rparen on_ignored_nl UNK on_lparen e1 on_rparen on_op UNK on_lparen e2 on_rparen on_nl end on_nl # @param e1 [Array<Object>] The first array # @param e2 [Array<Object>] The second array # @return [Array<Object>] The unique set of elements #
def UNK on_lparen value on_rparen on_ignored_nl value on_period is_a? on_lparen on_const on_rparen on_op value on_period UNK on_op value on_nl end # If _value_ is an array, then return the result of calling `uniq` on that array. Otherwise, # the argument is returned. # @param value [Object] the value to merge with nothing # @return [Object] the merged value
class on_const on_op on_const on_nl on_const on_op self on_period new on_lparen on_const on_rparen on_nl on_ignored_nl def self on_period key on_nl # Documentation copied from https://github.com/danielsdeleo/deep_merge/blob/master/lib/deep_merge/core.rb # altered with respect to _preserve_unmergeables_ since this implementation always disables that option. # # The destination is dup'ed before the deep_merge is called to allow frozen objects as values. # # deep_merge method permits merging of arbitrary child elements. The two top level # elements must be hashes. These hashes can contain unlimited (to stack limit) levels # of child elements. These child elements to not have to be of the same types. # Where child elements are of the same type, deep_merge will attempt to merge them together. # Where child elements are not of the same type, deep_merge will skip or optionally overwrite # the destination element with the contents of the source element at that level. # So if you have two hashes like this: # source = {:x => [1,2,3], :y => 2} # dest = {:x => [4,5,'6'], :y => [7,8,9]} # dest.deep_merge!(source) # Results: {:x => [1,2,3,4,5,'6'], :y => 2} # # "deep_merge" will unconditionally overwrite any unmergeables and merge everything else. # # Options: # Options are specified in the last parameter passed, which should be in hash format: # hash.deep_merge!({:x => [1,2]}, {:knockout_prefix => '--'}) # - 'knockout_prefix' Set to string value to signify prefix which deletes elements from existing element. Defaults is _undef_ # - 'sort_merged_arrays' Set to _true_ to sort all arrays that are merged together. Default is _false_ # - 'merge_hash_arrays' Set to _true_ to merge hashes within arrays. Default is _false_ # # Selected Options Details: # :knockout_prefix => The purpose of this is to provide a way to remove elements # from existing Hash by specifying them in a special way in incoming hash # source = {:x => ['--1', '2']} # dest = {:x => ['1', '3']} # dest.ko_deep_merge!(source) # Results: {:x => ['2','3']} # Additionally, if the knockout_prefix is passed alone as a string, it will cause # the entire element to be removed: # source = {:x => '--'} # dest = {:x => [1,2,3]} # dest.ko_deep_merge!(source) # Results: {:x => ""} # # :merge_hash_arrays => merge hashes within arrays # source = {:x => [{:y => 1}]} # dest = {:x => [{:z => 2}]} # dest.deep_merge!(source, {:merge_hash_arrays => true}) # Results: {:x => [{:y => 1, :z => 2}]} #
on_const on_period UNK on_lparen e1 on_comma UNK on_lparen e2 on_rparen on_comma UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # e2 (the destination) is deep cloned to avoid that the passed in object mutates
def UNK on_nl on_ivar on_op on_const on_op on_const on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_tstring_beg on_tstring_content UNK key # Returns a type that allows all deep_merge options except 'preserve_unmergeables' since we force # the setting of that option to false # # @return [Types::PAnyType] the puppet type used when validating the options hash
class on_const on_op on_const on_nl def self on_period key on_nl on_symbeg UNK on_nl end on_nl on_ignored_nl def self on_period UNK # Same as {DeepMergeStrategy} but without constraint on valid merge options # (needed for backward compatibility with Hiera v3)
def self on_period UNK on_nl on_ivar on_op on_const on_op on_const on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # @return [Types::PAnyType] the puppet type used when validating the options hash
class on_const on_op on_const on_nl on_const on_op self on_period new on_lparen on_const on_rparen on_nl on_ignored_nl def self on_period key on_nl # Same as {UnconstrainedDeepMergeStrategy} but with reverse priority of merged elements. # (needed for backward compatibility with Hiera v3)
