UNK on_const on_nl UNK UNK on_period UNK on_lparen UNK on_comma typed_name on_comma source_ref on_comma UNK on_rparen on_ignored_nl UNK on_op on_const # The PuppetPlanInstantiator instantiates a Puppet::Functions::PuppetFunction given a Puppet Programming language # source that when called evaluates the Puppet logic it contains. #
UNK UNK on_period UNK on_lparen UNK on_comma typed_name on_comma source_ref on_comma UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_period # Produces an instance of the Function class with the given typed_name, or fails with an error if the # given puppet source does not produce this instance when evaluated. # # @param loader [Loader] The loader the function is associated with # @param typed_name [TypedName] the type / name of the function to load # @param source_ref [URI, String] a reference to the source / origin of the puppet code to evaluate # @param pp_code_string [String] puppet code in a string # # @return [Functions::Function] - an instantiated function with global scope closure associated with the given loader #
UNK on_op UNK on_period UNK on_lparen UNK on_comma source_ref on_rparen on_nl on_ignored_nl UNK on_op UNK on_period UNK on_period UNK on_lbrace # parse and validate
UNK on_op UNK on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_lparen on_const on_op on_const on_op on_const # The parser attaches all definitions, including those nested in apply # blocks, to the Program object. Node definitions in apply blocks are # perfectly legal and don't count as the file containing multiple # definitions for this purpose. By this point, we've already validated that # there are no node definitions *outside* apply blocks, so we simply ignore # them here.
UNK UNK on_period UNK on_nl UNK UNK on_nl UNK on_const on_comma UNK on_lparen UNK UNK UNK on_rparen on_op on_lbrace on_label # Only one plan is allowed (and no other definitions)
UNK on_ignored_nl UNK on_const on_comma UNK on_lparen UNK UNK UNK on_rparen on_op on_lbrace on_label source_ref on_comma on_label typed_name on_period name # ok
UNK on_op UNK on_period UNK on_nl on_const on_op on_const on_period UNK on_lparen the_plan_definition on_rparen on_period UNK on_op UNK on_period UNK # Adapt the function definition with loader - this is used from logic contained in it body to find the # loader to use when making calls to the new function API. Such logic have a hard time finding the closure (where # the loader is known - hence this mechanism
UNK on_op UNK on_nl on_ignored_nl UNK on_op UNK on_lparen the_plan_definition on_rparen on_nl on_ignored_nl UNK on_period new on_lparen UNK on_comma UNK # Cannot bind loaded functions to global scope, that must be done without binding that scope as # loaders survive a compilation.
on_ignored_nl UNK on_period new on_lparen UNK on_comma UNK on_rparen on_nl end on_nl on_ignored_nl UNK UNK on_period UNK on_lparen plan_definition on_comma # create the function instance - it needs closure (scope), and loader (i.e. where it should start searching for things # when calling functions etc. # It should be bound to global scope
UNK UNK on_period UNK on_lparen plan_definition on_comma UNK on_rparen on_ignored_nl UNK on_op UNK on_lparen plan_definition on_rparen on_nl typed_name on_op on_const # Creates Function class and instantiates it based on a FunctionDefinition model # @return [Array<TypedName, Functions.Function>] - array of # typed name, and an instantiated function with global scope closure associated with the given loader #
on_const on_op on_const on_period UNK on_lparen plan_definition on_period name on_comma on_const on_op on_const on_op on_const on_rparen UNK on_ignored_nl UNK on_lparen # Create a 4x function wrapper around a named closure
UNK on_lparen on_const on_op on_const on_op on_const on_period new on_lparen on_ignored_nl plan_definition on_period name on_comma on_ignored_nl on_const on_op on_const on_period # TODO: should not create a new evaluator per function
