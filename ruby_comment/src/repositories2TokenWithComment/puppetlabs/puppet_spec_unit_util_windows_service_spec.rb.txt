UNK expect_successful_status_query_and_return on_lparen query_return on_rparen on_ignored_nl expect on_lparen subject on_op on_const on_rparen on_period to receive on_lparen on_symbeg new on_rparen on_period # The following should emulate a successful call to the private function # query_status that returns the value of query_return. This should give # us a way to mock changes in service status. # # Everything else is stubbed, the emulation of the successful call is really # just an expectation of subject::SERVICE_STATUS_PROCESS.new in sequence that # returns the value passed in as a param
UNK UNK on_lparen query_return on_rparen on_ignored_nl expect on_lparen subject on_op on_const on_rparen on_period to receive on_lparen on_symbeg new on_rparen on_period # The following should emulate a successful call to the private function # query_config that returns the value of query_return. This should give # us a way to mock changes in service configuration. # # Everything else is stubbed, the emulation of the successful call is really # just an expectation of subject::QUERY_SERVICE_CONFIGW.new in sequence that # returns the value passed in as a param
UNK on_tstring_beg on_tstring_content on_tstring_end do on_op pending_state on_op on_ignored_nl UNK on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const # This shared example contains the unit tests for the wait_on_pending_state # helper as used by service actions like #start and #stop. Before including # this shared example, be sure to mock out any intermediate calls prior to # the pending transition, and make sure that the post-condition _after_ those # intermediate calls leaves the service in the pending state. Before including # this example in your tests, be sure to define the following variables in a `let` # context: # * action -- The service action
on_lbrace on_symbeg dwcurrentstate on_op pending_state on_comma on_symbeg UNK on_op on_int on_comma on_symbeg UNK on_op on_int on_rbrace on_comma on_ignored_nl on_lbrace on_symbeg # The three "pending_state" statuses simulate the scenario where the service # makes some progress during the transition right when Puppet's about to # time out.
UNK on_tstring_beg on_tstring_content on_tstring_end do on_op action on_comma valid_initial_states on_comma pending_state on_comma final_state on_op on_ignored_nl UNK on_op valid_initial_states on_period UNK # This shared example contains the unit tests for the transition_service_state # helper, which is the helper that all of our service actions like #start, #stop # delegate to. Including these tests under a shared example lets us include them in each of # those service action's unit tests. Before including this example in your tests, be # sure to define the following variables in a `let` context: # * initial_state -- The initial state of the service prior to performing the state # transition # # * mock_state_transition -- A lambda that mocks the state transition. This should mock # any code in the block that's passed to the # transition_service_state helper # # See the unit tests for the #start method to see how this shared example's # included. #
UNK on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_op valid_initial_states on_op on_lbracket final_state on_rbracket on_nl # invalid_initial_states will be empty for the #stop action
UNK on_op valid_initial_states on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK UNK on_period UNK on_nl UNK # If the service action accepts an unsafe pending state as one of the service's # initial states, then we need to test that the action waits for the service to # transition from that unsafe pending state before doing anything else.
allow on_lparen subject on_op on_const on_rparen on_period to receive on_lparen on_symbeg new on_rparen on_period and_return on_lparen on_label final_state on_rparen on_nl # This mocks the status query to return the 'final_state' by default. Otherwise, # we will fail the tests in the latter parts of the code where we wait for the # service to finish transitioning to the 'final_state'.
expect_successful_status_query_and_return on_lparen on_label UNK on_rparen on_nl on_ignored_nl UNK on_period UNK on_nl end on_nl on_ignored_nl include_examples on_tstring_beg on_tstring_content on_tstring_end on_comma UNK # Set our service's initial state
context on_tstring_beg on_tstring_content on_embexpr_beg final_state_str on_embexpr_end on_tstring_content on_embexpr_beg action on_embexpr_end on_tstring_content on_tstring_end do on_ignored_nl before on_lparen on_symbeg each on_rparen do # reads e.g. "waiting for the service to transition to the SERVICE_RUNNING state after executing the 'start' action" # # NOTE: This is really unit testing the wait_on_state_transition helper
expect_successful_status_query_and_return on_lparen on_label initial_state on_rparen on_nl on_ignored_nl UNK on_period UNK on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl # Set our service's initial state prior to performing the state transition
UNK UNK on_const on_period features on_period microsoft_windows? on_nl on_ignored_nl context on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl let on_lparen on_symbeg scm on_rparen # rspec will still try to load the tests even though # the :if => Puppet.features.microsoft_windows? filter # is passed-in to the top-level describe block on # non-Windows platforms; it just won't run them. However # on these platforms, the loading will fail because this # test uses a shared example that references variables # from the Windows::Service module when building the unit # tests, which is only available on Windows platforms. # Thus, we add the next here to ensure that rspec does not # attempt to load our test code. This is OK for us to do # because we do not want to run these tests on non-Windows # platforms.
service on_op on_const on_op on_const on_op on_const on_op on_const on_nl valid_initial_states on_op on_lbracket on_ignored_nl service on_op on_const on_comma on_ignored_nl service # Can't use rspec's subject here because that # can only be referenced inside an 'it' block.
expect_successful_status_query_and_return on_lparen on_label subject on_op on_const on_rparen on_nl on_ignored_nl allow on_lparen subject on_rparen on_period to receive on_lparen on_symbeg on_const on_rparen # We need to mock the status query because in the block for #resume, we # wait for the service to enter the SERVICE_PAUSED state prior to # performing the transition (in case it is in SERVICE_PAUSE_PENDING).
allow on_lparen subject on_op on_const on_rparen on_period to receive on_lparen on_symbeg new on_rparen on_period and_return on_lparen on_label subject on_op on_const # This mocks the status query to return the SERVICE_RUNNING state by default. # Otherwise, we will fail the tests in the latter parts of the code where we # wait for the service to finish transitioning to the 'SERVICE_RUNNING' state.
UNK on_const on_period features on_period microsoft_windows? on_nl on_lbrace on_ignored_nl on_symbeg on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op # We need to guard this section explicitly since rspec will always # construct all examples, even if it isn't going to run them.
UNK on_const on_period features on_period microsoft_windows? on_nl on_lbrace on_ignored_nl on_symbeg on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op # We need to guard this section explicitly since rspec will always # construct all examples, even if it isn't going to run them.
expect on_lparen pointer on_rparen on_period to receive on_lparen on_symbeg UNK on_rparen on_period UNK on_period and_return on_lparen on_int on_rparen on_nl expect # the first read_dword is for reading the bytes required, let that return 3 too. # the second read_dword will actually read the number of services returned
