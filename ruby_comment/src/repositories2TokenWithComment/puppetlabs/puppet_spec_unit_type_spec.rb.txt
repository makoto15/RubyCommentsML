end on_nl end on_nl end on_nl on_ignored_nl UNK on_op UNK on_lparen on_heredoc_beg on_rparen on_nl on_tstring_content on_heredoc_end on_ignored_nl expect on_lparen UNK # forces the computation of the path
type on_op on_const on_op on_const on_period newtype on_lparen on_symbeg UNK on_rparen do on_ignored_nl newparam on_lparen on_symbeg name on_rparen do end # Make a fake type
it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl allow on_lparen on_const on_op on_const on_op on_const on_rparen on_period to receive on_lparen on_symbeg UNK # This one is really hard to test :/
allow on_lparen on_const on_op on_const on_op on_const on_rparen on_period to receive on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl UNK on_op on_lbracket # We have a :confine block that calls execute in our upstart provider, which fails # on jruby. Thus, we stub it out here since we don't care to do any assertions on it. # This is only an issue if you're running these unit tests on a platform where upstart # is a default provider, like Ubuntu trusty.
expect on_lparen type_resource on_period parameters on_lbracket on_symbeg remounts on_rbracket on_rparen on_period not_to UNK on_lparen on_const on_op on_const on_rparen on_nl expect # If it's not a property it's a parameter
on_lbracket on_symbeg one on_comma on_symbeg two on_comma on_symbeg three on_rbracket on_period each on_lbrace on_op UNK on_op type on_period newproperty on_lparen # Order of assignment is significant in this test.
