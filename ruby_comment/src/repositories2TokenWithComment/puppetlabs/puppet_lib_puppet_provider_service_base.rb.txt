def UNK on_nl UNK on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_tstring_beg on_tstring_content on_tstring_end # get the proper 'ps' invocation for the platform # ported from the facter 2.x implementation, since facter 3.x # is dropping the fact (for which this was the only use)
def UNK on_nl on_ivar on_period UNK on_tstring_beg on_tstring_content on_tstring_end UNK on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_op on_const on_period # Get the process ID for a running process. Requires the 'pattern' # parameter.
table on_op on_const on_op on_const on_op on_const on_period UNK on_lparen table on_rparen on_nl table on_period UNK on_lparen on_const on_op on_const # The output of the PS command can be a mashup of several different # encodings depending on which processes are running and what # arbitrary data has been used to set their name in the process table. # # First, try a polite conversion to in order to match the UTF-8 encoding # of our regular expression.
table on_period UNK on_lparen on_const on_op on_const on_rparen UNK table on_period UNK on_op on_const on_op on_const on_nl table on_op table # If that fails, force to UTF-8 and then scrub as most uses are scanning # for ACII-compatible program names.
def UNK on_nl if on_ivar on_lbracket on_symbeg UNK on_rbracket UNK UNK on_nl UNK on_lparen on_symbeg UNK on_comma UNK on_rparen on_nl # Check if the process is running. Prefer the 'status' parameter, # then 'statuscmd' method, then look in the process table. We give # the object the option to not return a status command, which might # happen if, for instance, it has an init script (and thus responds to # 'statuscmd') but does not have 'hasstatus' enabled.
UNK on_lparen on_symbeg UNK on_comma UNK on_rparen on_nl on_ignored_nl if UNK on_period UNK on_op UNK on_nl return on_symbeg UNK on_nl # Don't fail when the exit status is not 0.
if UNK on_period UNK on_op UNK on_nl return on_symbeg UNK on_nl else on_ignored_nl return on_symbeg UNK on_nl end on_nl else # Explicitly calling exitstatus to facilitate testing
def UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # There is no default command, which causes other methods to be used
def UNK on_nl UNK on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl if on_ivar on_lbracket on_symbeg UNK # Run the 'start' parameter command, or the specified 'startcmd'.
def UNK on_nl if on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl return on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl else on_ignored_nl UNK # The command used to start. Generated if the 'binary' argument # is passed.
def UNK on_nl if on_ivar on_lbracket on_symbeg UNK on_rbracket UNK UNK on_nl UNK on_lparen on_symbeg UNK on_rparen on_nl else on_ignored_nl # Stop the service. If a 'stop' parameter is specified, it # takes precedence; otherwise checks if the object responds to # a 'stopcmd' method, and if so runs that; otherwise, looks # for the process in the process table. # This method will generally not be overridden by submodules.
def UNK on_nl end on_nl end on_nl on_ignored_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # There is no default command, which causes other methods to be used
