UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl on_ignored_nl def fail on_lparen issue on_comma semantic on_comma # A module with bindings between the new evaluator and the 3x runtime. # The intention is to separate all calls into scope, compiler, resource, etc. in this module # to make it easier to later refactor the evaluator for better implementations of the 3x classes. # # @api private
def fail on_lparen issue on_comma semantic on_comma options on_op on_lbrace on_rbrace on_comma except on_op nil on_rparen on_ignored_nl UNK on_lparen issue # Fails the evaluation of _semantic_ with a given issue. # # @param issue [Issue] the issue to report # @param semantic [ModelPopsObject] the object for which evaluation failed in some way. Used to determine origin. # @param options [Hash] hash of optional named data elements for the given issue # @return [!] this method does not return # @raise [Puppet::ParseError] an evaluation error initialized from the arguments (TODO: Change to EvaluationError?) #
UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen issue on_comma semantic on_comma # an error should have been raised since fail always fails
def UNK on_lparen issue on_comma semantic on_comma options on_op on_lbrace on_rbrace on_comma except on_op nil on_rparen on_ignored_nl if except on_period # Optionally (based on severity) Fails the evaluation of _semantic_ with a given issue # If the given issue is configured to be of severity < :error it is only reported, and the function returns. # # @param issue [Issue] the issue to report # @param semantic [ModelPopsObject] the object for which evaluation failed in some way. Used to determine origin. # @param options [Hash] hash of optional named data elements for the given issue # @return [!] this method does not return # @raise [Puppet::ParseError] an evaluation error initialized from the arguments (TODO: Change to EvaluationError?) #
UNK on_ignored_nl UNK on_const on_period new on_lparen on_rparen on_nl UNK on_const on_op UNK on_nl except on_op UNK on_nl end on_nl # Want a stacktrace, and it must be passed as an exception
def UNK on_lparen issue on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl file on_comma line on_op on_const on_op on_const on_op on_const # Optionally (based on severity) Fails the evaluation with a given issue # If the given issue is configured to be of severity < :error it is only reported, and the function returns. # The location the issue is reported against is found is based on the top file/line in the puppet call stack # # @param issue [Issue] the issue to report # @param options [Hash] hash of optional named data elements for the given issue # @return [!] this method may not return, nil if it does # @raise [Puppet::ParseError] an evaluation error initialized from the arguments #
file on_comma line on_op on_const on_op on_const on_op on_const on_period UNK on_nl on_ignored_nl semantic on_op on_const on_op on_const on_op on_const # Get position from puppet runtime stack
semantic on_op on_const on_op on_const on_op on_const on_period new on_lparen issue on_comma nil on_comma options on_period UNK on_lparen on_lbrace on_symbeg # Use a SemanticError as the sourcepos
def UNK on_lparen name on_comma value on_comma o on_comma scope on_rparen on_ignored_nl if name on_op on_tstring_beg on_tstring_content on_tstring_end on_nl fail # Binds the given variable name to the given value in the given scope. # The reference object `o` is intended to be used for origin information - the 3x scope implementation # only makes use of location when there is an error. This is now handled by other mechanisms; first a check # is made if a variable exists and an error is raised if attempting to change an immutable value. Errors # in name, numeric variable assignment etc. have also been validated prior to this call. In the event the # scope.setvar still raises an error, the general exception handling for evaluation of the assignment # expression knows about its location. Because of this, there is no need to extract the location for each # setting (extraction is somewhat expensive since 3x requires line instead of offset). #
if name on_op on_tstring_beg on_tstring_content on_tstring_end on_nl fail on_lparen on_const on_op on_const on_comma o on_comma on_lbrace on_symbeg name on_op name # Scope also checks this but requires that location information are passed as options. # Those are expensive to calculate and a test is instead made here to enable failing with better information. # The error is not specific enough to allow catching it - need to check the actual message text. # TODO: Improve the messy implementation in Scope. #
def UNK on_lparen name on_comma o on_comma scope on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_rparen on_lbrace on_ignored_nl x on_op scope # Returns the value of the variable (nil is returned if variable has no value, or if variable does not exist) #
UNK on_lparen on_symbeg UNK on_rparen on_lbrace on_ignored_nl x on_op scope on_period UNK on_lparen name on_period UNK on_rparen on_nl UNK on_symbeg # Puppet 3x stores all variables as strings (then converts them back to numeric with a regexp... to see if it is a match variable) # Not ideal, scope should support numeric lookup directly instead. # TODO: consider fixing scope
UNK on_symbeg UNK on_period UNK on_lparen x on_rparen on_op nil on_op x on_nl on_rbrace on_nl unless name on_op on_const on_op # Must convert :undef back to nil - this can happen when an undefined variable is used in a # parameter's default value expression - there nil must be :undef to work with the rest of 3x. # Now that the value comes back to 4x it is changed to nil.
unless name on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_lparen on_const on_op on_const on_op on_const on_op on_const # It is always ok to reference numeric variables even if they are not assigned. They are always undef # if not set by a match expression. #
end on_nl on_ignored_nl def UNK on_lparen name on_comma scope on_rparen on_ignored_nl scope on_period UNK on_lparen name on_period UNK on_rparen on_nl # in case unknown variable is configured as a warning or ignore
def UNK on_lparen name on_comma scope on_rparen on_ignored_nl scope on_period UNK on_lparen name on_period UNK on_rparen on_nl end on_nl on_ignored_nl # Returns true if the variable of the given name is set in the given most nested scope. True is returned even if # variable is bound to nil. #
def UNK on_lparen name on_comma scope on_rparen on_ignored_nl scope on_period UNK on_lparen name on_period UNK on_rparen on_nl end on_nl on_ignored_nl # Returns true if the variable is bound to a value or nil, in the scope or it's parent scopes. #
unless UNK on_period UNK on_nl scope on_period UNK on_lparen UNK on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen # See set_variable for rationale for not passing file and line to ephemeral_from. # NOTE: The 3x scope adds one ephemeral(match) to its internal stack per match that succeeds ! It never # clears anything. Thus a context that performs many matches will get very deep (there simply is no way to # clear the match variables without rolling back the ephemeral stack.) # This implementation does not attempt to fix this, it behaves the same bad way.
def UNK on_lparen UNK on_comma scope on_rparen on_ignored_nl UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless UNK on_period # Creates a local scope with vairalbes set from a hash of variable name to value #
UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless UNK on_period is_a? on_lparen on_const on_rparen on_nl scope on_period UNK # two dummy values are needed since the scope tries to give an error message (can not happen in this # case - it is just wrong, the error should be reported by the caller who knows in more detail where it # is in the source. #
def UNK on_lparen scope on_rparen on_ignored_nl scope on_period UNK on_lparen nil on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen scope # Creates a nested match scope
scope on_period UNK on_lparen nil on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen scope on_rparen on_ignored_nl scope on_period UNK on_nl # Create a transparent match scope (for future matches)
scope on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen source on_comma UNK on_comma UNK on_comma scope # 3x uses this method to reset the level,
def UNK on_lparen source on_comma UNK on_comma UNK on_comma scope on_rparen on_ignored_nl if source on_period is_a? on_lparen on_const on_op on_const # Adds a relationship between the given `source` and `target` of the given `relationship_type` # @param source [Puppet:Pops::Types::PCatalogEntryType] the source end of the relationship (from) # @param target [Puppet:Pops::Types::PCatalogEntryType] the target end of the relationship (to) # @param relationship_type [:relationship, :subscription] the type of the relationship #
if source on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl UNK on_op source on_nl else on_ignored_nl type on_comma title on_op # The 3x way is to record a Puppet::Parser::Relationship that is evaluated at the end of the compilation. # This means it is not possible to detect any duplicates at this point (and signal where an attempt is made to # add a duplicate. There is also no location information to signal the original place in the logic. The user will have # to go fish. # The 3.x implementation is based on Strings :-o, so the source and target must be transformed. The resolution is # done by Catalog#resource(type, title). To do that, it creates a Puppet::Resource since it is responsible for # translating the name/type/title and create index-keys used by the catalog. The Puppet::Resource has bizarre parsing of # the type and title (scan for [] that is interpreted as type/title (but it gets it wrong). # Moreover if the type is "" or "component", the type is Class, and if the type is :main, it is :main, all other cases # undergo capitalization of name-segments (foo::bar becomes Foo::Bar). (This was earlier done in the reverse by the parser). # Further, the title undergoes the same munging !!! # # That bug infested nest of messy logic needs serious Exorcism! # # Unfortunately it is not easy to simply call more intelligent methods at a lower level as the compiler evaluates the recorded # Relationship object at a much later point, and it is responsible for invoking all the messy logic. # # TODO: Revisit the below logic when there is a sane implementation of the catalog, compiler and resource. For now # concentrate on transforming the type references to what is expected by the wacky logic. # # HOWEVER, the Compiler only records the Relationships, and the only method it calls is @relationships.each{|x| x.evaluate(catalog) } # Which means a smarter Relationship class could do this right. Instead of obtaining the resource from the catalog using # the borked resource(type, title) which creates a resource for the purpose of looking it up, it needs to instead # scan the catalog's resources # # GAAAH, it is even worse! # It starts in the parser, which parses "File['foo']" into an AST::ResourceReference with type = File, and title = foo # This AST is evaluated by looking up the type/title in the scope - causing it to be loaded if it exists, and if not, the given # type name/title is used. It does not search for resource instances, only classes and types. It returns symbolic information # [type, [title, title]]. From this, instances of Puppet::Resource are created and returned. These only have type/title information # filled out. One or an array of resources are returned. # This set of evaluated (empty reference) Resource instances are then passed to the relationship operator. It creates a # Puppet::Parser::Relationship giving it a source and a target that are (empty reference) Resource instances. These are then remembered # until the relationship is evaluated by the compiler (at the end). When evaluation takes place, the (empty reference) Resource instances # are converted to String (!?! WTF) on the simple format "#{type}[#{title}]", and the catalog is told to find a resource, by giving # it this string. If it cannot find the resource it fails, else the before/notify parameter is appended with the target. # The search for the resource begin with (you guessed it) again creating an (empty reference) resource from type and title (WTF?!?!). # The catalog now uses the reference resource to compute a key [r.type, r.title.to_s] and also gets a uniqueness key from the # resource (This is only a reference type created from title and type). If it cannot find it with the first key, it uses the # uniqueness key to lookup. # # This is probably done to allow a resource type to munge/translate the title in some way (but it is quite unclear from the long # and convoluted path of evaluation. # In order to do this in a way that is similar to 3.x two resources are created to be used as keys. # # And if that is not enough, a source/target may be a Collector (a baked query that will be evaluated by the # compiler - it is simply passed through here for processing by the compiler at the right time). #
UNK on_op source on_nl else on_ignored_nl type on_comma title on_op on_const on_period UNK on_period UNK on_lparen source on_rparen on_nl type # use verbatim - behavior defined by 3x
type on_comma title on_op on_const on_period UNK on_period UNK on_lparen source on_rparen on_nl type on_op on_const on_period UNK on_lparen scope # transform into the wonderful String representation in 3x
UNK on_op UNK on_nl else on_ignored_nl type on_comma title on_op on_const on_period UNK on_period UNK on_lparen UNK on_rparen on_nl type # use verbatim - behavior defined by 3x
type on_comma title on_op on_const on_period UNK on_period UNK on_lparen UNK on_rparen on_nl type on_op on_const on_period UNK on_lparen scope # transform into the wonderful String representation in 3x
scope on_period UNK on_period UNK on_lparen on_const on_op on_const on_op on_const on_period new on_lparen UNK on_comma UNK on_comma UNK on_rparen # Add the relationship to the compiler for later evaluation.
def UNK on_lparen v on_comma o on_comma scope on_rparen on_ignored_nl if v on_period is_a? on_lparen on_const on_rparen on_nl UNK v # Coerce value `v` to numeric or fails. # The given value `v` is coerced to Numeric, and if that fails the operation # calls {#fail}. # @param v [Object] the value to convert # @param o [Object] originating instruction # @param scope [Object] the (runtime specific) scope where evaluation of o takes place # @return [Numeric] value `v` converted to Numeric. #
UNK on_lparen on_const on_op on_const on_comma o on_comma on_lbrace on_symbeg UNK on_op v on_comma on_symbeg UNK on_op UNK on_rbrace on_rparen # this point is reached if there was a conversion
def UNK on_lparen name on_comma args on_comma scope on_comma on_op block on_rparen on_ignored_nl UNK on_op scope on_period UNK on_period UNK # Provides the ability to call a 3.x or 4.x function from the perspective of a 3.x function or ERB template. # The arguments to the function must be an Array containing values compliant with the 4.x calling convention. # If the targeted function is a 3.x function, the values will be transformed. # @param name [String] the name of the function (without the 'function_' prefix used by scope) # @param args [Array] arguments, may be empty # @param scope [Object] the (runtime specific) scope where evaluation takes place # @raise [ArgumentError] 'unknown function' if the function does not exist #
UNK on_op scope on_period UNK on_period UNK on_nl loader on_op UNK on_period UNK on_nl func on_op loader on_period UNK on_lparen # Call via 4x API if the function exists there
loader on_op UNK on_period UNK on_nl func on_op loader on_period UNK on_lparen on_symbeg UNK on_comma name on_rparen if loader on_nl # Since this is a call from non puppet code, it is not possible to relate it to a module loader # It is known where the call originates by using the scope associated module - but this is the calling scope # and it does not defined the visibility of functions from a ruby function's perspective. Instead, # this is done from the perspective of the environment.
UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace UNK name on_rbrace unless on_const on_op on_const on_op on_const # Call via 3x API if function exists there
UNK on_op on_const on_period UNK on_lparen args on_comma scope on_comma on_tstring_beg on_tstring_end on_rparen on_nl UNK on_op scope on_period UNK on_lparen # Arguments must be mapped since functions are unaware of the new and magical creatures in 4x. # NOTE: Passing an empty string last converts nil/:undef to empty string
on_const on_op on_const on_op on_const on_period UNK on_lparen name on_rparen on_op UNK on_op nil on_nl end on_nl on_ignored_nl def UNK # Prevent non r-value functions from leaking their result (they are not written to care about this)
UNK on_const on_op on_const on_op on_const on_period UNK on_lparen file on_op on_tstring_beg on_tstring_end on_comma line on_comma func on_comma on_symbeg UNK # Add stack frame when calling.
fail on_lparen on_const on_op on_const on_comma o on_comma on_lbrace on_symbeg name on_op name on_rbrace on_rparen unless on_const on_op on_const on_op # Call via 3x API if function exists there without having been autoloaded
UNK on_op on_const on_period UNK on_lparen args on_comma scope on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_const on_op on_const on_op on_const on_period # Arguments must be mapped since functions are unaware of the new and magical creatures in 4x. # NOTE: Passing an empty string last converts nil/:undef to empty string
on_const on_op on_const on_op on_const on_period UNK on_lparen file on_comma line on_comma scope on_comma on_tstring_beg on_tstring_content UNK name UNK on_tstring_end # The 3x function performs return value mapping and returns nil if it is not of rvalue type
def UNK on_lparen o on_comma scope on_comma name on_comma value on_comma UNK on_rparen on_ignored_nl file on_comma line on_op UNK on_lparen # The o is used for source reference
on_symbeg source on_op scope on_period source on_comma on_symbeg line on_op line on_comma on_symbeg file on_op file on_comma on_ignored_nl on_symbeg UNK # converted to 3x since 4x supports additional objects / types
file on_comma line on_op UNK on_lparen o on_rparen on_nl on_const on_period UNK on_lparen file on_comma line on_comma scope on_comma UNK # Not 100% accurate as this is the resource expression location and each title is processed separately # The titles are however the result of evaluation and they have no location at this point (an array # of positions for the source expressions are required for this to work). # TODO: Revisit and possible improve the accuracy. #
def UNK on_lparen o on_comma scope on_comma type_name on_comma evaluated_parameters on_rparen on_ignored_nl scope on_period UNK on_lparen UNK on_lparen type_name on_rparen # Defines default parameters for a type with the given name. #
scope on_period UNK on_lparen UNK on_lparen type_name on_rparen on_comma evaluated_parameters on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Note that name must be capitalized in this 3x call # The 3x impl creates a Resource instance with a bogus title and then asks the created resource # for the type of the name. # Note, locations are available per parameter. #
def UNK on_lparen name on_rparen on_ignored_nl name on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_period UNK on_lparen on_op on_symbeg UNK # Capitalizes each segment of a qualified name #
def UNK on_lparen o on_comma scope on_comma UNK on_comma evaluated_parameters on_rparen on_ignored_nl file on_comma line on_op UNK on_lparen o on_rparen # Creates resource overrides for all resource type objects in evaluated_resources. The same set of # evaluated parameters are applied to all. #
file on_comma line on_op UNK on_lparen o on_rparen on_nl evaluated_parameters on_op evaluated_parameters on_period UNK on_nl UNK on_period UNK UNK on_op # Not 100% accurate as this is the resource expression location and each title is processed separately # The titles are however the result of evaluation and they have no location at this point (an array # of positions for the source expressions are required for this to work. # TODO: Revisit and possible improve the accuracy. #
evaluated_parameters on_op evaluated_parameters on_period UNK on_nl UNK on_period UNK UNK on_op r on_op on_ignored_nl unless r on_period is_a? on_lparen on_const # A *=> results in an array of arrays
on_symbeg source on_op scope on_period source on_comma on_ignored_nl on_symbeg scope on_op scope on_nl on_rbrace on_comma UNK on_rparen on_nl on_ignored_nl scope # WTF is this? Which source is this? The file? The name of the context ?
on_rparen on_nl on_ignored_nl scope on_period UNK on_period UNK on_lparen resource on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen # defaults should not override
def UNK on_lparen scope on_comma type_name on_comma title on_rparen on_ignored_nl scope on_period UNK on_period UNK on_lparen type_name on_comma title on_rparen # Finds a resource given a type and a title. #
def UNK on_lparen scope on_comma resource on_comma UNK on_rparen on_ignored_nl UNK on_op resource on_lbracket UNK on_rbracket on_nl on_ignored_nl if resource # Returns the value of a resource's parameter by first looking up the parameter in the resource # and then in the defaults for the resource. Since the resource exists (it must in order to look up its # parameters, any overrides have already been applied). Defaults are not applied to a resource until it # has been finished (which typically has not taken place when this is evaluated; hence the dual lookup). #
UNK on_op resource on_lbracket UNK on_rbracket on_nl on_ignored_nl if resource on_period is_a? on_lparen on_const on_op on_const on_op on_const on_rparen on_nl # This gets the parameter value, or nil (for both valid parameters and parameters that do not exist).
if resource on_period is_a? on_lparen on_const on_op on_const on_op on_const on_rparen on_nl UNK on_op resource on_period scope on_nl UNK on_op # Sometimes the resource is a Puppet::Parser::Resource and sometimes it is # a Puppet::Resource. The Puppet::Resource case occurs when puppet language # is evaluated against an already completed catalog (where all instances of # Puppet::Parser::Resource are converted to Puppet::Resource instances). # Evaluating against an already completed catalog is really only found in # the language specification tests, where the puppet language is used to # test itself.
UNK on_op resource on_period scope on_nl UNK on_op UNK on_period UNK on_lparen resource on_period type on_rparen if UNK on_period UNK # The defaults must be looked up in the scope where the resource was created (not in the given # scope where the lookup takes place.
UNK on_op UNK on_lbracket UNK on_period UNK on_rbracket on_nl UNK on_op UNK on_period UNK on_op nil on_op UNK on_period value # NOTE: 3x resource keeps defaults as hash using symbol for name as key to Parameter which (again) holds # name and value. # NOTE: meta parameters that are unset ends up here, and there are no defaults for those encoded # in the defaults, they may receive hardcoded defaults later (e.g. 'tag').
UNK on_op UNK on_period UNK on_op nil on_op UNK on_period value on_nl end on_nl end on_nl UNK on_nl end on_nl # Some parameters (meta parameters like 'tag') does not return a param from which the value can be obtained # at all times. Instead, they return a nil param until a value has been set.
def UNK on_lparen scope on_comma resource on_comma name on_rparen on_ignored_nl UNK UNK unless name on_period is_a? on_lparen on_const on_rparen on_nl # Returns true, if the given name is the name of a resource parameter. #
UNK on_period UNK on_lparen resource on_rparen on_period type on_nl end on_nl on_ignored_nl def UNK on_lparen value on_comma o on_rparen on_ignored_nl # inference returns the meta type since the 3x Resource is an alternate way to describe a type
def UNK on_lparen value on_comma o on_rparen on_ignored_nl UNK value on_nl UNK on_symbeg UNK on_nl UNK on_nl UNK on_const on_nl # This is the same type of "truth" as used in the current Puppet DSL. #
UNK value on_nl UNK on_symbeg UNK on_nl UNK on_nl UNK on_const on_nl UNK on_nl else on_ignored_nl on_op on_op value on_nl # Is the value true? This allows us to control the definition of truth # in one place.
UNK on_symbeg UNK on_nl UNK on_nl UNK on_const on_nl UNK on_nl else on_ignored_nl on_op on_op value on_nl end on_nl end # Support :undef since it may come from a 3x structure
def UNK x on_nl x on_period is_a? on_lparen on_const on_rparen on_op x on_period is_a? on_lparen on_const on_rparen on_nl end on_nl # Utility method for TrueClass || FalseClass # @param x [Object] the object to test if it is instance of TrueClass or FalseClass
def UNK on_nl on_const on_op on_const on_period new on_lparen on_ignored_nl on_const on_period new on_lparen on_rparen on_comma on_const on_period new on_lparen # Creates a diagnostic producer
on_const on_period new on_lparen on_rparen on_comma on_const on_op on_const on_period new on_lparen on_rparen on_rparen on_nl end on_nl on_ignored_nl UNK on_const # Raises exception on all issues
on_const on_op on_const on_period new on_lparen on_rparen on_rparen on_nl end on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl on_const # All issues are errors
UNK on_const on_op on_const on_op on_const on_nl on_const on_op on_const on_nl on_ignored_nl def UNK on_nl UNK on_nl p on_op UNK # Configure the severity of failures
if on_const on_lbracket on_symbeg UNK on_rbracket on_nl p on_lbracket on_const on_op on_const on_rbracket on_op on_symbeg warning on_nl else on_ignored_nl p # Issues triggering warning only if --debug is on
if on_const on_lbracket on_symbeg UNK on_rbracket on_nl p on_lbracket on_const on_op on_const on_rbracket on_op on_symbeg UNK on_nl UNK on_const on_lbracket # if strict variables are on, an error is raised # if strict variables are off, the Puppet[strict] defines what is done #
p on_lbracket on_const on_op on_const on_rbracket on_op on_const on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_op on_symbeg warning on_nl p # Store config issues, ignore or warning
UNK on_const on_op on_const on_op on_const on_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_nl on_const on_period UNK on_lparen UNK # An acceptor of diagnostics that immediately raises an exception.
on_symbeg UNK on_op on_const on_op on_const on_nl on_rbrace on_rparen on_nl if UNK on_nl UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content # log warnings
