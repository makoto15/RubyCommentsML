UNK on_const on_op on_const on_op on_const on_nl UNK UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op UNK on_nl UNK # # @api private # # Parse information relating to responses containing a Retry-After headers #
UNK UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl UNK # # @api private # # Create a handler to allow the system to sleep between HTTP requests # # @param [Integer] retry_limit number of retries allowed # @param [Integer] max_sleep maximum sleep time allowed #
UNK UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK UNK on_period UNK on_nl UNK UNK on_comma UNK on_nl UNK on_nl # # @api private # # Does the response from the server tell us to wait until we attempt the next # retry? # # @param [Net::HTTP] request # @param [Puppet::HTTP::Response] response # # @return [Boolean] Return true if the response code is 429 or 503, return # false otherwise #
UNK UNK on_lparen UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_const on_op on_const on_op on_const on_period UNK on_lparen UNK # # @api private # # The amount of time to wait before attempting a retry # # @param [Net::HTTP] request # @param [Puppet::HTTP::Response] response # @param [Integer] retries number of retries attempted so far # # @return [Integer] the amount of time to wait # # @raise [Puppet::HTTP::TooManyRetryAfters] raise if we have hit our retry # limit #
UNK UNK on_comma UNK UNK on_period UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl UNK UNK on_lparen retry_after on_rparen on_ignored_nl # if retry-after is far in the future, we could end up sleeping repeatedly # for 30 minutes, effectively waiting indefinitely, seems like we should wait # in total for 30 minutes, in which case this upper limit needs to be enforced # by the client.
