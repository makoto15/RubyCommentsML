UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_symbeg UNK on_op # The commands we are using on an AIX box are installed standard # (except nimclient) nimclient needs the bos.sysmgt.nim.client fileset.
UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl # If NIM has not been configured, /etc/niminfo will not be present. # However, we have no way of knowing if the NIM server is not configured # properly.
UNK on_op output on_lbracket on_int on_rbracket on_nl on_ignored_nl UNK UNK on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end # the 6th index in the colon-delimited output contains a " " for installp/BFF # packages, and an "R" for RPMS. (duh.)
unless UNK on_lparen on_rparen on_period UNK on_nl self on_period fail _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label on_ivar # installp will return an exit code of zero even if it didn't uninstall # anything... so let's make sure it worked.
UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg source on_embexpr_end on_tstring_content on_tstring_end on_nl if on_lparen UNK on_rparen on_nl version on_op on_ivar on_period UNK # This is unfortunate for a couple of reasons. First, because of a subtle # difference in the command-line syntax for installing an RPM vs an # installp/BFF package, we need to know ahead of time which type of # package we're trying to install. This means we have to execute an # extra command. # # Second, the command is easiest to deal with and runs fastest if we # pipe it through grep on the shell. Unfortunately, the way that # the provider `make_command_methods` metaprogramming works, we can't # use that code path to execute the command (because it treats the arguments # as an array of args that all apply to `nimclient`, which fails when you # hit the `|grep`.) So here we just call straight through to P::U.execute # with a single string argument for the full command, rather than going # through the metaprogrammed layer. We could get rid of the grep and # switch back to the metaprogrammed stuff, and just parse all of the output # in Ruby... but we'd be doing an awful lot of unnecessary work.
if on_lparen version on_rparen on_nl if on_lparen UNK on_op on_symbeg UNK on_rparen on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl else # This part is a bit tricky. If there are multiple versions of the # package available, then `version` will be set to a value, and we'll need # to add that value to our installation command. However, if there is only # one version of the package available, `version` will be set to `nil`, and # we don't need to add the version string to the command.
if on_lparen UNK on_op on_symbeg UNK on_rparen on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl else on_ignored_nl UNK on_op on_tstring_beg on_tstring_content # Now we know if the package type is RPM or not, and we can adjust our # `pkg` string for passing to the install command accordingly.
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl else on_ignored_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl pkg on_op UNK # RPMs expect a hyphen between the package name and the version number
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl pkg on_op UNK on_op version on_nl end on_nl on_ignored_nl output on_op # installp/BFF packages expect a space between the package name and the # version number.
output on_op UNK on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # NOTE: the installp flags here are ignored (but harmless) for RPMs
UNK UNK on_nl when on_symbeg UNK on_nl if output on_op on_regexp_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_lparen on_ivar on_lbracket on_symbeg # If the package is superseded, it means we're trying to downgrade and we # can't do that.
on_ignored_nl self on_op on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl self on_op on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl self on_op on_const ## UTILITY METHODS FOR PARSING `nimclient -o showres` output
self on_op on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl self on_op on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl self on_op on_const on_op # This makes me very sad. These regexes seem pretty fragile, but # I spent a lot of time trying to figure out a solution that didn't # require parsing the `nimclient -o showres` output and was unable to # do so.
on_ignored_nl on_ignored_nl def UNK on_lparen showres_output on_rparen on_ignored_nl UNK on_op UNK on_lparen showres_output on_rparen on_nl packages on_op on_lbrace on_rbrace on_nl # Here is some sample output that shows what the above regexes will be up # against: # FOR AN INSTALLP PACKAGE: # # mypackage.foo ALL @@I:mypackage.foo _all_filesets # @ 1.2.3.1 MyPackage Runtime Environment @@I:mypackage.foo 1.2.3.1 # + 1.2.3.4 MyPackage Runtime Environment @@I:mypackage.foo 1.2.3.4 # + 1.2.3.8 MyPackage Runtime Environment @@I:mypackage.foo 1.2.3.8 # # FOR AN RPM PACKAGE: # # mypackage.foo ALL @@R:mypackage.foo _all_filesets # @@R:mypackage.foo-1.2.3-1 1.2.3-1 # @@R:mypackage.foo-1.2.3-4 1.2.3-4 # @@R:mypackage.foo-1.2.3-8 1.2.3-8
def UNK on_lparen showres_output on_rparen on_ignored_nl UNK on_op UNK on_lparen showres_output on_rparen on_nl packages on_op on_lbrace on_rbrace on_nl UNK on_period # Parse the output of a `nimclient -o showres` command. Returns a two-dimensional # hash, where the first-level keys are package names, the second-level keys are # version number strings for all of the available version numbers for a package, # and the values indicate the package type (:rpm / :installp)
def UNK on_lparen showres_output on_rparen on_ignored_nl showres_output on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_period UNK on_lbrace on_op UNK on_op # This method basically just splits the multi-line input string into chunks # based on lines that contain nothing but whitespace. It also strips any # leading or trailing whitespace (including newlines) from the resulting # strings and then returns them as an array.
unless line on_period match on_lparen self on_period UNK on_op on_const on_rparen on_nl self on_period fail _ on_lparen on_tstring_beg on_tstring_content on_tstring_end # This method doesn't produce any meaningful output; it's basically just # meant to validate that the header line for the package listing output # looks sane, so we know we're dealing with the kind of output that we # are capable of handling.
def UNK on_lparen showres_output on_comma package_name on_rparen on_ignored_nl packages on_op UNK on_lparen showres_output on_rparen on_nl unless packages on_period UNK on_lparen # Given a blob of output from `nimclient -o showres` and a package name, # this method checks to see if there are multiple versions of the package # available on the lpp_source. If there are, the method returns # [package_type, latest_version] (where package_type is one of :installp or :rpm). # If there is only one version of the package available, it returns # [package_type, nil], because the caller doesn't need to pass the version # string to the command-line command if there is only one version available. # If the package is not available at all, the method simply returns nil (instead # of a tuple).
