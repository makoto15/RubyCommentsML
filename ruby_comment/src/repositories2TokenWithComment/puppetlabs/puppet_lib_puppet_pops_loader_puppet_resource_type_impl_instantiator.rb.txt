UNK on_const on_nl UNK UNK on_period UNK on_lparen UNK on_comma typed_name on_comma source_ref on_comma UNK on_rparen on_ignored_nl UNK on_op on_const # The PuppetResourceTypeImplInstantiator instantiates a Puppet::Pops::ResourceTypeImpl object. # given a Puppet Programming language source that when called evaluates the Puppet logic it contains. #
UNK UNK on_period UNK on_lparen UNK on_comma typed_name on_comma source_ref on_comma UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_period # Produces an instance of Puppet::Pops::ResourceTypeImpl, or fails with an error if the # given puppet source does not produce such an instance when evaluated. # # @param loader [Loader] The loader the function is associated with # @param typed_name [TypedName] the type / name of the resource type impl to load # @param source_ref [URI, String] a reference to the source / origin of the puppet code to evaluate # @param pp_code_string [String] puppet code in a string # # @return [Puppet::Pops::ResourceTypeImpl] - an instantiated ResourceTypeImpl #
model on_op UNK on_period UNK on_lparen UNK on_comma source_ref on_rparen on_nl statements on_op UNK model on_period is_a? on_lparen on_const on_op # parse and validate
on_const on_op on_const on_period UNK on_lparen resource_type_impl on_rparen on_period UNK on_op UNK on_period UNK on_nl resource_type_impl on_nl end on_nl on_ignored_nl # Adapt the resource type definition with loader - this is used from logic contained in it body to find the # loader to use when making calls to the new function API. Such logic have a hard time finding the closure (where # the loader is known - hence this mechanism
