UNK on_const on_op on_const on_nl on_const on_op on_int on_nl on_ignored_nl UNK on_symbeg agent on_comma on_symbeg server on_comma on_symbeg UNK on_nl # Run periodic actions and a network server in a daemonized process. # # A Daemon has 3 parts: # * config reparse # * (optional) an agent that responds to #run # * (optional) a server that response to #stop, #start, and #wait_for_shutdown # # The config reparse will occur periodically based on Settings. The server will # be started and is expected to manage its own run loop (and so not block the # start call). The server will, however, still be waited for by using the # #wait_for_shutdown method. The agent is run periodically and a time interval # based on Settings. The config reparse will update this time interval when # needed. # # The Daemon is also responsible for signal handling, starting, stopping, # running the agent on demand, and reloading the entire process. It ensures # that only one Daemon is running by using a lockfile. # # @api private
def UNK on_nl UNK on_op UNK on_nl if UNK on_nl on_const on_period UNK on_lparen UNK on_rparen on_nl exit on_lparen on_int # Put the daemon into the background.
on_const on_op on_const on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl on_const on_period UNK on_nl on_const on_period UNK # Get rid of console logging
def UNK on_period UNK on_lparen on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_ignored_nl UNK on_period # Close stdin/stdout/stderr so that we can finish our transition into 'daemon' mode. # @return nil
def UNK on_lparen on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_const on_op # Convenience signature for calling Puppet::Daemon.close_streams
def UNK on_nl on_lbracket on_symbeg on_const on_comma on_symbeg on_const on_rbracket on_period UNK do on_op signal on_op on_ignored_nl on_const on_period UNK # Trap a couple of the main signals. This should probably be handled # in a way that anyone else can register callbacks for traps, but, eh.
if on_op on_const on_op on_const on_op on_const on_period UNK on_nl UNK on_op UNK on_symbeg on_const on_op on_symbeg UNK on_comma on_symbeg # extended signals not supported under windows
def UNK on_lparen UNK on_op UNK on_symbeg exit on_op UNK UNK on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_nl on_ignored_nl # Stop everything
server on_period UNK if server on_nl on_ignored_nl UNK on_nl on_ignored_nl server on_period UNK if server on_nl end on_nl on_ignored_nl UNK # Start the listening server, if required.
UNK on_nl on_ignored_nl server on_period UNK if server on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_nl UNK on_tstring_beg # Finally, loop forever running events - or, at least, until we exit.
def UNK on_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period UNK on_embexpr_end on_tstring_end UNK on_ivar on_period UNK on_nl end on_nl on_ignored_nl # Create a pidfile for our daemon, so we can be stopped and others # don't try to start.
def UNK on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_const on_op on_const on_period UNK # Remove the pid file for our daemon.
agent on_period UNK on_lparen on_symbeg UNK on_op UNK on_rparen on_nl end on_nl on_ignored_nl UNK on_op on_const on_op on_const on_period UNK # Splay for the daemon is handled in the scheduler
on_const on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg method on_embexpr_end on_tstring_end on_nl UNK on_lparen method on_rparen on_nl end on_nl end on_nl on_ignored_nl #rubocop:disable Lint/AssignmentInCondition
