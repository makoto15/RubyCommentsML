UNK on_const on_op on_const on_op on_const on_nl UNK on_symbeg path on_comma on_symbeg UNK on_comma on_symbeg links on_nl UNK on_symbeg UNK # Operate recursively on a path, returning a set of file paths.
def self on_period UNK on_lparen on_op UNK on_rparen on_ignored_nl result on_op on_lbrace on_rbrace on_nl on_ignored_nl UNK on_period UNK do on_op # Produce a hash of files, with merged so that earlier files # with the same postfix win. E.g., /dir1/subfile beats /dir2/subfile. # It's a hash because we need to know the relative path of each file, # and the base directory. # This will probably only ever be used for searching for plugins.
path on_op path on_period UNK on_lparen on_const on_op on_const on_rparen unless path on_op UNK on_tstring_content UNK on_nl UNK on_ignored_nl path # REMIND: UNC path
self on_period UNK on_op on_lbracket on_rbracket on_nl self on_period links on_op on_symbeg UNK on_nl on_ivar on_op UNK on_nl on_ivar on_op # Set our defaults.
UNK on_const on_period new on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen if on_ivar on_period UNK on_lparen on_const on_rparen on_nl #TRANSLATORS "recurse" and "recurselimit" are parameter names and should not be translated
def UNK on_nl UNK on_op UNK on_nl on_ignored_nl result on_op UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK # Return a list of all files in our fileset. This is different from the # normal definition of find in that we support specific levels # of recursion, which means we need to know when we're going another # level deep, which Find doesn't do.
result on_op UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_lparen UNK on_tstring_content UNK on_const on_period UNK on_lparen # Now strip off the leading path, so each file becomes relative, and remove # any slashes that might end up at the beginning of the path.
result on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl result on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen # And add the path itself.
UNK on_lparen on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace UNK links on_rbrace on_rparen unless on_lbracket on_symbeg UNK #TRANSLATORS ":links" is a parameter name and should not be translated
value on_op UNK on_period options on_lbracket param on_rbracket on_nl UNK UNK on_period options on_period UNK on_lparen param on_period UNK on_rparen # use 'include?' so the values can be false
def UNK on_nl UNK on_op on_lbracket on_const on_period new on_lparen UNK on_comma on_ivar on_comma on_ivar on_comma on_ivar on_rparen on_rbracket on_nl # Pull the recursion logic into one place. It's moderately hairy, and this # allows us to keep the hairiness apart from what we do with the files.
if UNK on_lparen UNK on_period UNK on_op UNK on_rparen on_nl UNK on_period UNK on_period UNK do on_op child on_op on_ignored_nl #rubocop:disable Lint/AssignmentInCondition
self on_period UNK on_op on_lparen self on_period UNK on_op on_symbeg UNK on_op UNK on_op self on_period UNK on_rparen on_nl end # recurse if told to, and infinite recursion or current depth not at the limit
