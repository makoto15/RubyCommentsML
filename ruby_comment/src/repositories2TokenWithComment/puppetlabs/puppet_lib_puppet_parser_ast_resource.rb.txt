UNK on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg # Instruction for Resource instantiation. # Instantiates resources of both native and user defined types. #
UNK UNK on_lparen scope on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_op UNK on_period UNK on_nl on_ignored_nl UNK on_period UNK # Evaluates resources by adding them to the compiler for lazy evaluation # and returning the produced resource references. #
UNK on_op UNK on_period UNK on_op UNK on_period UNK on_nl on_ignored_nl UNK on_period UNK UNK on_op UNK on_op on_ignored_nl on_ignored_nl # We want virtual to be true if exported is true. We can't # just set :virtual => self.virtual in the initialization, # because sometimes the :virtual attribute is set *after* # :exported, in which case it clobbers :exported if :exported # is true. Argh, this was a very tough one to track down.
UNK on_period UNK UNK on_op UNK on_op on_ignored_nl on_ignored_nl UNK on_op UNK on_period UNK on_period UNK UNK on_op UNK on_op # First level of implicit iteration: build a resource for each # instance. This handles things like: # file { '/foo': owner => blah; '/bar': owner => blah }
UNK on_op UNK on_period UNK on_period UNK UNK on_op UNK on_op UNK on_period UNK on_lparen scope on_rparen UNK on_nl on_ignored_nl # Evaluate all of the specified params.
resource_titles on_op UNK resource_titles UNK UNK resource_titles on_period UNK on_lparen on_const on_rparen on_nl on_ignored_nl UNK on_comma resource_titles on_op scope on_period # it's easier to always use an array, even for only one name
resource_titles on_period UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_symbeg UNK on_op on_const on_op on_const UNK on_ignored_nl resource # Second level of implicit iteration; build a resource for each # title. This handles things like: # file { ['/foo', '/bar']: owner => blah }
