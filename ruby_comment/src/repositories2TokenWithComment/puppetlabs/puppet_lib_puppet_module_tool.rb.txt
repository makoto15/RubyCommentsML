require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK # encoding: UTF-8 # Load standard libraries
on_const on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg # Directory and names that should not be checksummed.
def self on_period UNK on_lparen path on_rparen on_ignored_nl UNK on_const on_period UNK on_lparen path on_rparen on_nl UNK on_op on_const on_nl # Is this a directory that shouldn't be checksummed? # # TODO: Should this be part of Checksums? # TODO: Rename this method to reflect its purpose? # TODO: Shouldn't this be used when building packages too?
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_lparen on_const on_rparen on_nl if UNK on_nl # Return the +username+ and +modname+ for a given +full_module_name+, or raise an # ArgumentError if the argument isn't parseable.
def self on_period UNK on_lparen path on_rparen on_ignored_nl path on_op on_const on_period UNK on_lparen path on_rparen if path on_period UNK # Find the module root when given a path by checking each directory up from # its current location until it finds one that satisfies is_module_root? # # @param path [Pathname, String] path to start from # @return [Pathname, nil] the root path of the module directory or nil if # we cannot find one
def self on_period UNK on_lparen path on_rparen on_ignored_nl path on_op on_const on_period UNK on_lparen path on_rparen if path on_period UNK # Analyse path to see if it is a module root directory by detecting a # file named 'metadata.json' # # @param path [Pathname, String] path to analyse # @return [Boolean] true if the path is a module root, false otherwise
def self on_period UNK on_lparen UNK on_comma UNK on_op UNK on_rparen on_ignored_nl str on_op on_tstring_beg on_tstring_end on_nl UNK on_period UNK # Builds a formatted tree from a list of node hashes containing +:text+ # and +:dependencies+ keys.
def self on_period UNK on_lparen options on_rparen on_ignored_nl UNK on_op UNK on_lparen options on_rparen on_nl on_ignored_nl UNK on_op on_lbracket options # @param options [Hash<Symbol,String>] This hash will contain any # command-line arguments that are not Settings, as those will have already # been extracted by the underlying application code. # # @note Unfortunately the whole point of this method is the side effect of # modifying the options parameter. This same hash is referenced both # when_invoked and when_rendering. For this reason, we are not returning # a duplicate. # @todo Validate the above note... # # An :environment_instance and a :target_dir are added/updated in the # options parameter. # # @api private
options on_lbracket on_symbeg UNK on_rbracket on_op UNK on_period UNK on_period UNK on_nl on_ignored_nl end on_nl on_ignored_nl def self on_period UNK # Note: environment will have expanded the path
def self on_period UNK on_lparen options on_rparen on_ignored_nl if options on_lbracket on_symbeg UNK on_rbracket on_nl path on_op options on_lbracket on_symbeg # Given a hash of options, we should discover or create a # {Puppet::Node::Environment} instance that reflects the provided options. # # Generally speaking, the `:modulepath` parameter should supersede all # others, the `:environment` parameter should follow after that, and we # should default to Puppet's current environment. # # @param options [{Symbol => Object}] the options to derive environment from # @return [Puppet::Node::Environment] the environment described by the options
on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_period UNK on_lparen options on_lbracket on_symbeg UNK on_rbracket on_rparen on_nl UNK on_ignored_nl on_const # This use of looking up an environment is correct since it honours # a request to get a particular environment via environment name.
def self on_period UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK # Handles parsing of module dependency expressions into proper # {SemanticPuppet::VersionRange}s, including reasonable error handling. # # @param where [String] a description of the thing we're parsing the # dependency expression for # @param dep [Hash] the dependency description to parse # @return [Array(String, SemanticPuppet::VersionRange, String)] a tuple of the # dependent module's name, the version range dependency, and the # unparsed range expression.
require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl # Load remaining libraries
