UNK on_const on_nl on_const on_op on_const on_period UNK on_lparen on_lbracket on_const on_op on_const on_comma on_const on_op on_const on_rbracket on_rparen on_nl # The {ImplementationRegistry} maps names types in the Puppet Type System to names of corresponding implementation # modules/classes. Each mapping is unique and bidirectional so that for any given type name there is only one # implementation and vice versa. # # @api private
def UNK on_lparen UNK on_op nil on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op UNK UNK on_nl on_ivar on_op UNK # Create a new instance. This method is normally only called once # # @param parent [ImplementationRegistry, nil] the parent of this registry
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op nil on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_tstring_content UNK on_comma # Register a bidirectional type mapping. # # @overload register_type_mapping(runtime_type, puppet_type) # @param runtime_type [PRuntimeType] type that represents the runtime module or class to map to a puppet type # @param puppet_type [PAnyType] type that will be mapped to the runtime module or class # @overload register_type_mapping(runtime_type, pattern_replacement) # @param runtime_type [PRuntimeType] type containing the pattern and replacement to map the runtime type to a puppet type # @param puppet_type [Array(Regexp,String)] the pattern and replacement to map a puppet type to a runtime type
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_nl UNK on_lparen # Register a bidirectional namespace mapping # # @param type_namespace [String] the namespace for the puppet types # @param impl_namespace [String] the namespace for the implementations
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op nil on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_nl # Register a bidirectional regexp mapping # # @param type_name_subst [Array(Regexp,String)] regexp and replacement mapping type names to runtime names # @param impl_name_subst [Array(Regexp,String)] regexp and replacement mapping runtime names to type names
def UNK on_lparen type on_comma impl_module on_comma UNK on_op nil on_rparen on_ignored_nl type on_op type on_period name if type on_period # Register a bidirectional mapping between a type and an implementation # # @param type [PAnyType,String] the type or type name # @param impl_module[Module,String] the module or module name
def UNK on_lparen type on_rparen on_ignored_nl type on_op type on_period name if type on_period UNK on_lparen on_const on_rparen on_nl name # Find the name for the module that corresponds to the given type or type name # # @param type [PAnyType,String] the name of the type # @return [String,nil] the name of the implementation module, or `nil` if no mapping was found
def UNK on_lparen type on_rparen on_ignored_nl name on_op UNK on_lparen type on_rparen on_nl name on_period nil? on_op nil on_op on_const # Find the module that corresponds to the given type or type name # # @param type [PAnyType,String] the name of the type # @return [Module,nil] the name of the implementation module, or `nil` if no mapping was found
name on_period nil? on_op nil on_op on_const on_period UNK on_lparen name on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen impl_module # TODO Shouldn't ClassLoader be module specific?
def UNK on_lparen impl_module on_rparen on_ignored_nl impl_module on_op impl_module on_period name if impl_module on_period UNK on_lparen on_const on_rparen on_nl name # Find the type name and loader that corresponds to the given runtime module or module name # # @param impl_module [Module,String] the implementation class or class name # @return [String,nil] the name of the type, or `nil` if no mapping was found
def UNK on_lparen impl_module on_rparen on_ignored_nl name on_op UNK on_lparen impl_module on_rparen on_nl if name on_period nil? on_nl nil on_nl # Find the name for, and then load, the type that corresponds to the given runtime module or module name # The method will return `nil` if no mapping is found, a TypeReference if a mapping was found but the # loader didn't find the type, or the loaded type. # # @param impl_module [Module,String] the implementation class or class name # @return [PAnyType,nil] the type, or `nil` if no mapping was found
