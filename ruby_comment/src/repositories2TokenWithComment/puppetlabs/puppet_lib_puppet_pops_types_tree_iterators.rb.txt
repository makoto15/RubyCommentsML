def UNK on_lparen UNK on_comma options on_op on_const on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_nl on_ivar on_op # Creates a TreeIterator that by default treats all Array, Hash and Object instances as # containers - the 'containers' option can be set to a type that denotes which types of values # should be treated as containers - a `Variant[Array, Hash]` would for instance not treat # Object values as containers, whereas just `Object` would only treat objects as containers. # # Unrecognized options are silently ignored # # @param [Hash] options the options # @option options [PTypeType] :container_type ('Variant[Hash, Array, Object]') The type(s) that should be treated as containers. The # given type(s) must be assignable to the default container_type. # @option options [Boolean] :include_root ('true') If the root container itself should be included in the iteration (requires # `include_containers` to also be `true` to take effect). # @option options [Boolean] :include_containers ('true') If containers should be included in the iteration # @option options [Boolean] :include_values ('true') If non containers (values) should be included in the iteration # @option options [Boolean] :include_refs ('false') If (non containment) referenced values in Objects should be included #
def UNK on_lparen on_op block on_rparen on_ignored_nl loop do on_ignored_nl if block on_period UNK on_op on_int on_nl UNK on_lparen UNK # Yields each `path, value` if the block arity is 2, and only `value` if arity is 1 #
def UNK on_lparen UNK on_comma options on_op on_const on_rparen on_ignored_nl UNK on_nl end on_nl on_ignored_nl def next on_nl loop do # Creates a DepthFirstTreeIterator that by default treats all Array, Hash and Object instances as # containers - the 'containers' option can be set to a type that denotes which types of values # should be treated as containers - a `Variant[Array, Hash]` would for instance not treat # Object values as containers, whereas just `Object` would only treat objects as containers. # # @param [Hash] options the options # @option options [PTypeType] :containers ('Variant[Hash, Array, Object]') The type(s) that should be treated as containers # @option options [Boolean] :with_root ('true') If the root container itself should be included in the iteration #
if on_ivar on_period empty? on_nl on_ivar on_op indexer_on on_lparen on_ivar on_rparen on_nl on_ivar on_op true on_nl UNK on_lbracket on_lbracket on_rbracket # first call
on_ivar on_op true on_nl on_ivar on_op value on_nl on_ivar on_op indexer on_nl UNK unless on_ivar on_nl UNK on_ignored_nl UNK unless # recurse
at_the_very_end on_op false on_nl loop do on_ignored_nl UNK on_nl at_the_very_end on_op on_ivar on_period empty? on_nl UNK if at_the_very_end on_op UNK # end of current value's range of content # pop all until out of next values
if on_ivar on_period empty? on_nl on_ivar on_op indexer_on on_lparen on_ivar on_rparen on_nl on_ivar on_op true on_nl UNK on_lbracket on_lbracket on_rbracket # first call
at_the_very_end on_op false on_nl loop do on_ignored_nl UNK on_nl at_the_very_end on_op on_ivar on_period empty? on_nl UNK if at_the_very_end on_op UNK # end of current value's range of content # shift all until out of next values
