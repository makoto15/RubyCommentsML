on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK # Algorithms and Containers project is Copyright (c) 2009 Kanwei Li # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the 'Software'), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE. # # A RbTreeMap is a map that is stored in sorted order based on the order of its keys. This ordering is # determined by applying the function <=> to compare the keys. No duplicate values for keys are allowed, # so duplicate values are overwritten. # # A major advantage of RBTreeMap over a Hash is the fact that keys are stored in order and can thus be # iterated over in order. This is useful for many datasets. # # The implementation is adapted from Robert Sedgewick's Left Leaning Red-Black Tree implementation, # which can be found at https://www.cs.princeton.edu/~rs/talks/LLRB/Java/RedBlackBST.java # # Most methods have O(log n) complexity.
def UNK on_nl on_ivar on_op nil on_nl on_ivar on_op on_int on_nl end on_nl on_ignored_nl def UNK on_lparen key on_comma value # Create and initialize a new empty TreeMap.
def UNK on_lparen key on_comma value on_rparen on_ignored_nl on_ivar on_op UNK on_lparen on_ivar on_comma key on_comma value on_rparen on_nl on_ivar # Insert an item with an associated key into the TreeMap, and returns the item inserted # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") #=> "Massachusetts" # map.get("MA") #=> "Massachusetts"
def UNK on_lparen key on_rparen on_ignored_nl on_op UNK on_lparen on_ivar on_comma key on_rparen on_period nil? on_nl end on_nl on_ignored_nl def # Return true if key is found in the TreeMap, false otherwise # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") # map.push("GA", "Georgia") # map.has_key?("GA") #=> true # map.has_key?("DE") #=> false
def UNK on_lparen key on_rparen on_ignored_nl node on_op UNK on_lparen on_ivar on_comma key on_rparen on_nl node on_op node on_period value # Return the item associated with the key, or nil if none found. # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") # map.push("GA", "Georgia") # map.get("GA") #=> "Georgia"
def UNK on_nl on_ivar on_period nil? on_op nil on_op UNK on_lparen on_ivar on_rparen on_period key on_nl end on_nl on_ignored_nl def # Return the smallest key in the map. # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") # map.push("GA", "Georgia") # map.min_key #=> "GA"
def UNK on_nl on_ivar on_period nil? on_op nil on_op UNK on_lparen on_ivar on_rparen on_period key on_nl end on_nl on_ignored_nl def # Return the largest key in the map. # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") # map.push("GA", "Georgia") # map.max_key #=> "MA"
def UNK on_lparen key on_rparen on_ignored_nl result on_op nil on_nl if on_ivar on_nl return UNK UNK key on_nl on_ivar on_comma # Deletes the item and key if it's found, and returns the item. Returns nil # if key is not present. # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") # map.push("GA", "Georgia") # map.delete("MA") #=> "Massachusetts"
def UNK on_nl on_ivar on_period nil? on_nl end on_nl on_ignored_nl def UNK on_nl result on_op nil on_nl if on_ivar on_nl # Returns true if the tree is empty, false otherwise
def UNK on_nl result on_op nil on_nl if on_ivar on_nl on_ivar on_comma result on_op UNK on_lparen on_ivar on_rparen on_nl on_ivar # Deletes the item with the smallest key and returns the item. Returns nil # if key is not present. # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") # map.push("GA", "Georgia") # map.delete_min #=> "Massachusetts" # map.size #=> 1
def UNK on_nl result on_op nil on_nl if on_ivar on_nl on_ivar on_comma result on_op UNK on_lparen on_ivar on_rparen on_nl on_ivar # Deletes the item with the largest key and returns the item. Returns nil # if key is not present. # # Complexity: O(log n) # # map = Containers::TreeMap.new # map.push("MA", "Massachusetts") # map.push("GA", "Georgia") # map.delete_max #=> "Georgia" # map.size #=> 1
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_lparen on_ivar on_comma on_op UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Yields [key, value] pairs in order by key.
UNK on_symbeg color on_comma on_symbeg key on_comma on_symbeg value on_comma on_symbeg left on_comma on_symbeg right on_nl def UNK on_lparen key # :nodoc: all
