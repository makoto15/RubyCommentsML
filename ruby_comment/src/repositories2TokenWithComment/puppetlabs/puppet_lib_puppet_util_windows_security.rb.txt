on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_op # This class maps POSIX owner, group, and modes to the Windows # security model, and back. # # The primary goal of this mapping is to ensure that owner, group, and # modes can be round-tripped in a consistent and deterministic # way. Otherwise, Puppet might think file resources are out-of-sync # every time it runs. A secondary goal is to provide equivalent # permissions for common use-cases. For example, setting the owner to # "Administrators", group to "Users", and mode to 750 (which also # denies access to everyone else. # # There are some well-known problems mapping windows and POSIX # permissions due to differences between the two security # models. Search for "POSIX permission mapping leak". In POSIX, access # to a file is determined solely based on the most specific class # (user, group, other). So a mode of 460 would deny write access to # the owner even if they are a member of the group. But in Windows, # the entire access control list is walked until the user is # explicitly denied or allowed (denied take precedence, and if neither # occurs they are denied). As a result, a user could be allowed access # based on their group membership. To solve this problem, other people # have used deny access control entries to more closely model POSIX, # but this introduces a lot of complexity. # # In general, this implementation only supports "typical" permissions, # where group permissions are a subset of user, and other permissions # are a subset of group, e.g. 754, but not 467. However, there are # some Windows quirks to be aware of. # # * The owner can be either a user or group SID, and most system files # are owned by the Administrators group. # * The group can be either a user or group SID. # * Unexpected results can occur if the owner and group are the # same, but the user and group classes are different, e.g. 750. In # this case, it is not possible to allow write access to the owner, # but not the group. As a result, the actual permissions set on the # file would be 770. # * In general, only privileged users can set the owner, group, or # change the mode for files they do not own. In 2003, the user must # be a member of the Administrators group. In Vista/2008, the user # must be running with elevated privileges. # * A file/dir can be deleted by anyone with the DELETE access right # OR by anyone that has the FILE_DELETE_CHILD access right for the # parent. See https://support.microsoft.com/kb/238018. But on Unix, # the user must have write access to the file/dir AND execute access # to all of the parent path components. # * Many access control entries are inherited from parent directories, # and it is common for file/dirs to have more than 3 entries, # e.g. Users, Power Users, Administrators, SYSTEM, etc, which cannot # be mapped into the 3 class POSIX model. The get_mode method will # set the S_IEXTRA bit flag indicating that an access control entry # was found whose SID is neither the owner, group, or other. This # enables Puppet to detect when file/dirs are out-of-sync, # especially those that Puppet did not create, but is attempting # to manage. # * A special case of this is S_ISYSTEM_MISSING, which is set when the # SYSTEM permissions are *not* present on the DACL. # * On Unix, the owner and group can be modified without changing the # mode. But on Windows, an access control entry specifies which SID # it applies to. As a result, the set_owner and set_group methods # automatically rebuild the access control list based on the new # (and different) owner or group.
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # file modes
on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int # represents an extra ace
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_ignored_nl on_const on_op on_const # constants that are missing from Windows::Security
def UNK on_lparen UNK on_comma path on_rparen on_ignored_nl sd on_op get_security_descriptor on_lparen path on_rparen on_nl on_ignored_nl if UNK on_op sd # Set the owner of the object referenced by +path+ to the specified # +owner_sid+. The owner sid should be of the form "S-1-5-32-544" # and can either be a user or group. Only a user with the # SE_RESTORE_NAME privilege in their process token can overwrite the # object's owner to something other than the current user.
def UNK on_lparen path on_rparen on_ignored_nl UNK unless UNK on_lparen path on_rparen on_nl on_ignored_nl get_security_descriptor on_lparen path on_rparen on_period owner # Get the owner of the object referenced by +path+. The returned # value is a SID string, e.g. "S-1-5-32-544". Any user with read # access to an object can get the owner. Only a user with the # SE_BACKUP_NAME privilege in their process token can get the owner # for objects they do not have read access to.
def UNK on_lparen UNK on_comma path on_rparen on_ignored_nl sd on_op get_security_descriptor on_lparen path on_rparen on_nl on_ignored_nl if UNK on_op sd # Set the owner of the object referenced by +path+ to the specified # +group_sid+. The group sid should be of the form "S-1-5-32-544" # and can either be a user or group. Any user with WRITE_OWNER # access to the object can change the group (regardless of whether # the current user belongs to that group or not).
def UNK on_lparen path on_rparen on_ignored_nl UNK unless UNK on_lparen path on_rparen on_nl on_ignored_nl get_security_descriptor on_lparen path on_rparen on_period group # Get the group of the object referenced by +path+. The returned # value is a SID string, e.g. "S-1-5-32-544". Any user with read # access to an object can get the group. Only a user with the # SE_BACKUP_NAME privilege in their process token can get the group # for objects they do not have read access to.
UNK on_op on_tstring_beg UNK UNK UNK on_tstring_content on_tstring_end unless UNK on_op UNK on_tstring_content UNK on_nl on_ignored_nl on_const on_op on_const on_period # 'A trailing backslash is required'
def UNK on_lparen path on_rparen on_ignored_nl UNK unless UNK on_lparen path on_rparen on_nl on_ignored_nl UNK on_op on_const on_op on_const on_op # Get the mode of the object referenced by +path+. The returned # integer value represents the POSIX-style read, write, and execute # modes for the user, group, and other classes, e.g. 0640. Any user # with read access to an object can get the mode. Only a user with # the SE_BACKUP_NAME privilege in their process token can get the # mode for objects they do not have read access to.
mode on_op on_const on_nl end on_nl on_ignored_nl if ace on_period sid on_op well_known_system_sid on_nl mode on_op on_op on_const on_nl end #puts "Warning, unable to map SID into POSIX mode: #{ace.sid}"
if sd on_period owner on_op sd on_period group on_nl mode on_op on_lparen on_lparen mode on_op on_const on_rparen on_op on_int on_rparen # if owner and group the same, then user and group modes are the OR of both
end on_nl end on_nl on_ignored_nl mode on_nl end on_nl on_ignored_nl on_const on_op on_lbrace on_ignored_nl on_const on_op on_const on_op on_const on_comma #puts "owner: #{sd.group}, 0x#{ace.mask.to_s(16)}, #{mode.to_s(8)}"
mode on_nl end on_nl on_ignored_nl on_const on_op on_lbrace on_ignored_nl on_const on_op on_const on_op on_const on_comma on_ignored_nl on_const on_op on_const on_op #puts "get_mode: #{mode.to_s(8)}"
def UNK on_lparen mode on_comma path on_comma UNK on_op UNK on_comma UNK on_op UNK on_comma UNK on_op UNK on_rparen on_ignored_nl # Set the mode of the object referenced by +path+ to the specified # +mode+. The mode should be specified as POSIX-style read, write, # and execute modes for the user, group, and other classes, # e.g. 0640. The sticky bit, S_ISVTX, is supported, but is only # meaningful for directories. If set, group and others are not # allowed to delete child objects for which they are not the owner. # By default, the DACL is set to protected, meaning it does not # inherit access control entries from parent objects. This can be # changed by setting +protected+ to false. The owner of the object # (with READ_CONTROL and WRITE_DACL access) can always change the # mode. Only a user with the SE_BACKUP_NAME and SE_RESTORE_NAME # privileges in their process token can change the mode for objects # that they do not have read and write access to.
group_allow on_op on_const on_op on_const on_op on_ignored_nl on_const on_op on_const on_op on_ignored_nl on_const on_op on_const on_nl other_allow on_op on_const on_op # this prevents a mode that is not 7 from taking ownership of a file based # on group membership and rewriting it / making it executable
if on_lparen on_lparen mode on_op on_const on_rparen on_op on_const on_rparen on_nl group_allow on_op on_const on_op on_const on_op on_const on_op on_const # With a mode value of '7' for group / other, the value must then include # additional perms beyond STANDARD_RIGHTS_READ to allow DACL modification
if on_op on_lbracket sd on_period owner on_comma sd on_period group on_rbracket on_period UNK well_known_system_sid on_nl UNK on_op on_const on_op on_const # caller is NOT managing SYSTEM by using group or owner, so set to FULL
UNK on_op on_const on_op on_const on_nl UNK on_ignored_nl if on_lparen sd on_period owner on_op well_known_system_sid on_rparen on_op on_lparen owner_allow on_op # we don't check S_ISYSTEM_MISSING bit, but automatically carry over existing SYSTEM perms # by default set SYSTEM perms to full
if on_lparen sd on_period owner on_op well_known_system_sid on_rparen on_op on_lparen owner_allow on_op on_const on_op on_const on_rparen on_nl if UNK on_op # It is possible to set SYSTEM with a mode other than Full Control (7) however this makes no sense and in practical terms # should not be done. We can trap these instances and correct them before being applied.
if UNK on_op on_lparen on_op isownergroup on_op UNK on_rparen on_nl on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op # If owner and group are both SYSTEM but group is unmanaged the control rights of system will be set to FullControl by # the unmanaged group, so there is no need for the warning
on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label path on_rbrace on_nl UNK UNK on_op isownergroup on_nl #TRANSLATORS 'SYSTEM' is a Windows name and should not be translated
on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label path on_rbrace on_nl UNK on_ignored_nl on_const on_period UNK #TRANSLATORS 'SYSTEM' is a Windows name and should not be translated
on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label mode on_period UNK on_lparen on_int on_rparen on_comma on_label #TRANSLATORS 'SYSTEM' is a Windows name and should not be translated
if UNK on_op on_lparen on_op isownergroup on_op UNK on_rparen on_nl on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op # If owner and group are both SYSTEM but owner is unmanaged the control rights of system will be set to FullControl by # the unmanaged owner, so there is no need for the warning.
on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label path on_rbrace on_nl UNK UNK on_op isownergroup on_nl #TRANSLATORS 'SYSTEM' is a Windows name and should not be translated
on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label path on_rbrace on_nl UNK on_ignored_nl on_const on_period UNK #TRANSLATORS 'SYSTEM' is a Windows name and should not be translated
on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label mode on_period UNK on_lparen on_int on_rparen on_comma on_label #TRANSLATORS 'SYSTEM' is a Windows name and should not be translated
if on_lparen mode on_op on_lparen on_const on_op on_const on_rparen on_rparen on_op on_lparen on_const on_op on_const on_rparen on_nl owner_allow on_op on_const # even though FILE_DELETE_CHILD only applies to directories, it can be set on files # this is necessary to do to ensure a file ends up with (F) FullControl
if isownergroup on_nl owner_allow on_op group_allow on_nl end on_nl on_ignored_nl if on_lparen on_lparen owner_allow on_op group_allow on_op other_allow on_rparen on_op # if owner and group the same, then map group permissions to the one owner ACE
if on_lparen on_lparen owner_allow on_op group_allow on_op other_allow on_rparen on_op on_const on_op on_const on_rparen on_op on_const on_op on_const on_nl on_const # if any ACE allows write, then clear readonly bit, but do this before we overwrite # the DACl and lose our ability to set the attribute
flags on_op on_op UNK on_op on_int on_op on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_ignored_nl on_const # TODO: system should be first?
UNK on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl if UNK on_nl inherit on_op UNK on_op on_const # add inherit-only aces for child dirs and files that are created within the dir
UNK on_op on_op on_lparen on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_rparen on_nl dacl on_period allow # allow any previously set bits *except* for these
nil on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma mask on_comma sid on_comma inherit on_op nil on_rparen on_ignored_nl inherit # ensure this method is void if it doesn't raise
nil on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl if on_const on_lparen UNK on_rparen on_op on_const on_op on_const # ensure this method is void if it doesn't raise
if on_const on_lparen UNK on_rparen on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const on_op on_const on_period new # REMIND: need to handle NULL DACL
UNK dacl if UNK on_op on_int on_nl on_ignored_nl on_int on_period UNK on_lparen UNK on_op on_int on_rparen do on_op UNK on_op # deny all
ace on_op on_const on_period new on_lparen UNK on_period UNK on_lparen on_int on_rparen on_rparen on_ignored_nl UNK on_op ace on_lbracket on_symbeg on_const # ACE structures vary depending on the type. We are only concerned with # ACCESS_ALLOWED_ACE and ACCESS_DENIED_ACEs, which have the same layout
on_ignored_nl UNK on_op ace on_lbracket on_symbeg on_const on_rbracket on_lbracket on_symbeg on_const on_rbracket on_nl if UNK on_op on_const on_op on_const on_op #deref LPVOID *
sid on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen ace on_period pointer on_op on_const on_period UNK on_lparen # using pointer addition gives the FFI::Pointer a size, but that's OK here
def UNK on_lparen path on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl handle on_op on_const on_lparen on_ignored_nl UNK on_lparen path on_rparen # Open an existing file with the specified access mode, and execute a # block with the opened file HANDLE.
on_const on_op on_const on_comma on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_comma on_ignored_nl on_const on_op on_const on_op on_const on_rparen # security_attributes
on_ignored_nl if handle on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const # template
nil on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl UNK on_lparen UNK on_comma UNK on_rparen # handle has already had CloseHandle called against it, nothing to return
def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl UNK on_lparen UNK on_comma UNK on_rparen on_nl UNK on_nl UNK on_ignored_nl # Execute a block with the specified privilege enabled
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK unless on_const on_period UNK on_period UNK on_nl on_ignored_nl on_const on_op on_const # Enable or disable a privilege. Note this doesn't add any privileges the # user doesn't already has, it just enables privileges that are disabled.
UNK on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_period new on_lparen UNK on_rparen on_nl UNK on_lbracket on_symbeg # allocate unmanaged memory for structs that we clean up afterwards
if on_const on_lparen UNK on_comma on_const on_op on_const on_comma on_ignored_nl UNK on_comma UNK on_period UNK on_comma on_ignored_nl on_const on_op on_const # size is correct given we only have 1 LUID, otherwise would be: # [:PrivilegeCount].size + [:PrivilegeCount] * LUID_AND_ATTRIBUTES.size
UNK on_nl end on_nl on_ignored_nl def get_security_descriptor on_lparen path on_rparen on_ignored_nl sd on_op nil on_nl on_ignored_nl UNK on_lparen on_const on_rparen # token / luid structs freed by this point, so return true as nothing raised
UNK on_rparen raise on_const on_op on_const on_op on_const on_op on_const on_period new on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen #sacl
raise on_const on_op on_const on_op on_const on_op on_const on_period new on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen if UNK #sec desc
owner on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_period UNK on_lparen on_int on_rparen on_rparen on_nl # these 2 convenience params are not freed since they point inside sd_ptr
on_const on_period UNK on_op UNK on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen path on_comma sd on_rparen on_ignored_nl on_const # https://msdn.microsoft.com/en-us/library/windows/desktop/aa378853(v=vs.85).aspx # To calculate the initial size of an ACL, add the following together, and then align the result to the nearest DWORD: # * Size of the ACL structure. # * Size of each ACE structure that the ACL is to contain minus the SidStart member (DWORD) of the ACE. # * Length of the SID that each ACE is to contain.
def UNK on_lparen path on_comma sd on_rparen on_ignored_nl on_const on_op on_const on_period new on_lparen on_symbeg UNK on_comma UNK on_lparen sd # setting DACL requires both READ_CONTROL and WRITE_DACL access rights, # and their respective privileges, SE_BACKUP_NAME and SE_RESTORE_NAME.
UNK on_lparen acl_ptr on_comma ace on_period mask on_comma ace on_period sid on_comma ace on_period flags on_rparen on_nl when on_const on_op #puts "ace: allow, sid #{Puppet::Util::Windows::SID.sid_to_name(ace.sid)}, mask 0x#{ace.mask.to_s(16)}"
UNK on_lparen acl_ptr on_comma ace on_period mask on_comma ace on_period sid on_comma ace on_period flags on_rparen on_nl UNK on_ignored_nl raise #puts "ace: deny, sid #{Puppet::Util::Windows::SID.sid_to_name(ace.sid)}, mask 0x#{ace.mask.to_s(16)}"
end on_nl end on_nl on_ignored_nl flags on_op on_const on_op on_const on_op on_const on_nl flags on_op sd on_period UNK on_op on_const # TODO: this should have been a warning in an earlier commit
flags on_op on_const on_op on_const on_op on_const on_nl flags on_op sd on_period UNK on_op on_const on_op on_const on_nl on_ignored_nl UNK # protected means the object does not inherit aces from its parent
ffi_lib on_symbeg UNK on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg UNK on_comma on_symbeg dword on_comma on_symbeg dword on_comma on_symbeg # https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx # HANDLE WINAPI CreateFile( # _In_ LPCTSTR lpFileName, # _In_ DWORD dwDesiredAccess, # _In_ DWORD dwShareMode, # _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, # _In_ DWORD dwCreationDisposition, # _In_ DWORD dwFlagsAndAttributes, # _In_opt_ HANDLE hTemplateFile # );
ffi_lib on_symbeg UNK on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg dword on_comma on_symbeg # https://msdn.microsoft.com/en-us/library/windows/desktop/aa364993(v=vs.85).aspx # BOOL WINAPI GetVolumeInformation( # _In_opt_ LPCTSTR lpRootPathName, # _Out_opt_ LPTSTR lpVolumeNameBuffer, # _In_ DWORD nVolumeNameSize, # _Out_opt_ LPDWORD lpVolumeSerialNumber, # _Out_opt_ LPDWORD lpMaximumComponentLength, # _Out_opt_ LPDWORD lpFileSystemFlags, # _Out_opt_ LPTSTR lpFileSystemNameBuffer, # _In_ DWORD nFileSystemNameSize # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg pointer on_comma on_symbeg dword on_comma on_symbeg dword on_comma on_symbeg # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374951(v=vs.85).aspx # BOOL WINAPI AddAccessAllowedAceEx( # _Inout_ PACL pAcl, # _In_ DWORD dwAceRevision, # _In_ DWORD AceFlags, # _In_ DWORD AccessMask, # _In_ PSID pSid # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg pointer on_comma on_symbeg dword on_comma on_symbeg dword on_comma on_symbeg # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374964(v=vs.85).aspx # BOOL WINAPI AddAccessDeniedAceEx( # _Inout_ PACL pAcl, # _In_ DWORD dwAceRevision, # _In_ DWORD AceFlags, # _In_ DWORD AccessMask, # _In_ PSID pSid # );
UNK on_const on_op on_const on_op on_const on_nl UNK on_symbeg on_const on_comma on_symbeg UNK on_comma on_ignored_nl on_symbeg on_const on_comma on_symbeg UNK # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374931(v=vs.85).aspx # typedef struct _ACL { # BYTE AclRevision; # BYTE Sbz1; # WORD AclSize; # WORD AceCount; # WORD Sbz2; # } ACL, *PACL;
UNK on_const on_op on_const on_op on_const on_nl UNK on_symbeg on_const on_comma on_symbeg UNK on_comma on_ignored_nl on_symbeg on_const on_comma on_symbeg UNK # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374912(v=vs.85).aspx # ACE types # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374919(v=vs.85).aspx # typedef struct _ACE_HEADER { # BYTE AceType; # BYTE AceFlags; # WORD AceSize; # } ACE_HEADER, *PACE_HEADER;
on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl UNK on_int on_nl UNK on_symbeg on_const on_comma on_const on_comma on_ignored_nl on_symbeg on_const # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374892(v=vs.85).aspx # ACCESS_MASK
UNK on_const on_op on_const on_op on_const on_nl UNK on_int on_nl UNK on_symbeg on_const on_comma on_const on_comma on_ignored_nl on_symbeg on_const on_comma # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374847(v=vs.85).aspx # typedef struct _ACCESS_ALLOWED_ACE { # ACE_HEADER Header; # ACCESS_MASK Mask; # DWORD SidStart; # } ACCESS_ALLOWED_ACE, *PACCESS_ALLOWED_ACE; # # https://msdn.microsoft.com/en-us/library/windows/desktop/aa374879(v=vs.85).aspx # typedef struct _ACCESS_DENIED_ACE { # ACE_HEADER Header; # ACCESS_MASK Mask; # DWORD SidStart; # } ACCESS_DENIED_ACE, *PACCESS_DENIED_ACE;
UNK on_int on_nl UNK on_symbeg on_const on_comma on_const on_comma on_ignored_nl on_symbeg on_const on_comma on_symbeg dword on_comma on_ignored_nl on_symbeg on_const on_comma # ACE structures must be aligned on DWORD boundaries. All Windows # memory-management functions return DWORD-aligned handles to memory
on_const on_op on_int on_nl on_const on_op on_const on_period UNK on_lparen on_symbeg on_const on_rparen on_op on_ignored_nl on_const on_nl on_ignored_nl ffi_lib on_symbeg # https://stackoverflow.com/a/1792930
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg pointer on_comma on_symbeg dword on_comma on_symbeg pointer on_rbracket on_comma # https://msdn.microsoft.com/en-us/library/windows/desktop/aa446634(v=vs.85).aspx # BOOL WINAPI GetAce( # _In_ PACL pAcl, # _In_ DWORD dwAceIndex, # _Out_ LPVOID *pAce # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_symbeg win32_bool on_comma on_symbeg pointer on_comma on_symbeg # https://msdn.microsoft.com/en-us/library/windows/desktop/aa375202(v=vs.85).aspx # BOOL WINAPI AdjustTokenPrivileges( # _In_ HANDLE TokenHandle, # _In_ BOOL DisableAllPrivileges, # _In_opt_ PTOKEN_PRIVILEGES NewState, # _In_ DWORD BufferLength, # _Out_opt_ PTOKEN_PRIVILEGES PreviousState, # _Out_opt_ PDWORD ReturnLength # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg pointer on_comma on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_comma # https://msdn.microsoft.com/en-us/library/windows/hardware/ff556610(v=vs.85).aspx # https://msdn.microsoft.com/en-us/library/windows/desktop/aa379561(v=vs.85).aspx # https://msdn.microsoft.com/en-us/library/windows/desktop/aa446647(v=vs.85).aspx # typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL; # BOOL WINAPI GetSecurityDescriptorControl( # _In_ PSECURITY_DESCRIPTOR pSecurityDescriptor, # _Out_ PSECURITY_DESCRIPTOR_CONTROL pControl, # _Out_ LPDWORD lpdwRevision # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg pointer on_comma on_symbeg dword on_comma on_symbeg dword on_rbracket on_comma # https://msdn.microsoft.com/en-us/library/windows/desktop/aa378853(v=vs.85).aspx # BOOL WINAPI InitializeAcl( # _Out_ PACL pAcl, # _In_ DWORD nAclLength, # _In_ DWORD dwAclRevision # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg pointer on_rbracket on_comma on_symbeg win32_bool on_nl on_ignored_nl on_const on_op # https://msdn.microsoft.com/en-us/library/windows/desktop/aa379142(v=vs.85).aspx # BOOL WINAPI IsValidAcl( # _In_ PACL pAcl # );
on_const on_op UNK on_lparen on_ignored_nl on_symbeg on_const on_comma on_int on_comma on_ignored_nl on_symbeg on_const on_comma on_ignored_nl on_symbeg on_const on_comma on_ignored_nl on_symbeg # https://msdn.microsoft.com/en-us/library/windows/desktop/aa379593(v=vs.85).aspx
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_const on_comma on_symbeg dword on_comma on_symbeg pointer # https://msdn.microsoft.com/en-us/library/windows/desktop/aa446654(v=vs.85).aspx # DWORD WINAPI GetSecurityInfo( # _In_ HANDLE handle, # _In_ SE_OBJECT_TYPE ObjectType, # _In_ SECURITY_INFORMATION SecurityInfo, # _Out_opt_ PSID *ppsidOwner, # _Out_opt_ PSID *ppsidGroup, # _Out_opt_ PACL *ppDacl, # _Out_opt_ PACL *ppSacl, # _Out_opt_ PSECURITY_DESCRIPTOR *ppSecurityDescriptor # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_const on_comma on_symbeg dword on_comma on_symbeg pointer # https://msdn.microsoft.com/en-us/library/windows/desktop/aa379588(v=vs.85).aspx # DWORD WINAPI SetSecurityInfo( # _In_ HANDLE handle, # _In_ SE_OBJECT_TYPE ObjectType, # _In_ SECURITY_INFORMATION SecurityInfo, # _In_opt_ PSID psidOwner, # _In_opt_ PSID psidGroup, # _In_opt_ PACL pDacl, # _In_opt_ PACL pSacl # );
attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_const on_comma on_symbeg dword on_comma on_symbeg pointer on_comma on_symbeg pointer on_comma # TODO: SECURITY_INFORMATION is actually a bitmask the size of a DWORD
