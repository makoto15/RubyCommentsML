UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl on_ignored_nl def self on_period UNK on_lparen parent_loader on_comma # =ModuleLoaders # A ModuleLoader loads items from a single module. # The ModuleLoaders (ruby) module contains various such loaders. There is currently one concrete # implementation, ModuleLoaders::FileBased that loads content from the file system. # Other implementations can be created - if they are based on name to path mapping where the path # is relative to a root path, they can derive the base behavior from the ModuleLoaders::AbstractPathBasedModuleLoader class. # # Examples of such extensions could be a zip/jar/compressed file base loader. # # Notably, a ModuleLoader does not configure itself - it is given the information it needs (the root, its name etc.) # Logic higher up in the loader hierarchy of things makes decisions based on the "shape of modules", and "available # modules" to determine which module loader to use for each individual module. (There could be differences in # internal layout etc.) # # A module loader is also not aware of the mapping of name to relative paths. # # @api private #
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl on_ignored_nl def self on_period UNK on_lparen parent_loader on_comma loaders on_rparen on_ignored_nl on_const # Wildcard module name for module loaders, makes loading possible from any namespace.
def self on_period UNK on_lparen parent_loader on_comma loaders on_rparen on_ignored_nl on_const on_period new on_lparen parent_loader on_comma on_ignored_nl loaders on_comma on_ignored_nl # This is exactly the same as the #system_loader_from method, but the argument for path is changed to # location where pluginsync stores functions. It also accepts definitions in any namespace since pluginsync # places all of them in the same directory. #
UNK on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen on_const on_period UNK on_lparen UNK on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end # Puppet system may be installed in a fixed location via RPM, installed as a Gem, via source etc. # The only way to find this across the different ways puppet can be installed is # to search up the path from this source file's __FILE__ location until it finds the base of # puppet. #
on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_lbracket on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_rparen on_nl end on_nl on_ignored_nl # may or may not have a 'lib' above 'puppet'
on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen parent_loader on_comma loaders on_comma UNK on_rparen on_ignored_nl if UNK on_period # only load ruby functions and types from "puppet"
attr_reader on_symbeg module_name on_nl on_ignored_nl on_ignored_nl attr_reader on_symbeg path on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl # The name of the module, or nil, if this is a global "component", or "any module" if set to the `NAMESPACE_WILDCARD` (*)
attr_reader on_symbeg path on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen parent_loader on_comma # The path to the location of the module/component - semantics determined by subclass
attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen parent_loader on_comma loaders on_comma module_name on_comma path # A map of type to smart-paths that help with minimizing the number of paths to scan
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen parent_loader on_comma loaders on_comma module_name on_comma path on_comma loader_name on_comma loadables on_rparen # A Module Loader has a private loader, it is lazily obtained on request to provide the visibility # for entities contained in the module. Since a ModuleLoader also represents an environment and it is # created a different way, this loader can be set explicitly by the loaders bootstrap logic. # # @api private
def UNK on_lparen parent_loader on_comma loaders on_comma module_name on_comma path on_comma loader_name on_comma loadables on_rparen on_ignored_nl UNK parent_loader on_comma loader_name # Initialize a kind of ModuleLoader for one module # @param parent_loader [Loader] loader with higher priority # @param loaders [Loaders] the container for this loader # @param module_name [String] the name of the module (non qualified name), may be nil for a global "component" # @param path [String] the path to the root of the module (semantics defined by subclass) # @param loader_name [String] a name that is used for human identification (useful when module_name is nil) #
raise on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl loaders on_period UNK on_lparen self on_rparen on_nl end #TRANSLATORS 'loadables' is a variable containing loadable modules and should not be translated
def UNK on_lparen typed_name on_rparen on_ignored_nl return nil unless typed_name on_period UNK on_op on_const on_op on_const on_nl on_ignored_nl name_parts on_op # Finds typed/named entity in this module # @param typed_name [TypedName] the type/name to find # @return [Loader::NamedEntry, nil found/created entry, or nil if not found #
return nil unless typed_name on_period UNK on_op on_const on_op on_const on_nl on_ignored_nl name_parts on_op typed_name on_period name_parts on_nl on_ignored_nl if # This loader is tailored to only find entries in the current runtime
name_parts on_op typed_name on_period name_parts on_nl on_ignored_nl if name_parts on_period UNK on_op on_int on_nl on_ignored_nl return nil unless name_parts on_lbracket # Assume it is a global name, and that all parts of the name should be used when looking up
if name_parts on_period UNK on_op on_int on_nl on_ignored_nl return nil unless name_parts on_lbracket on_int on_rbracket on_op module_name on_op module_name on_op # Certain types and names can be disqualified up front
on_ignored_nl return nil unless name_parts on_lbracket on_int on_rbracket on_op module_name on_op module_name on_op on_const on_nl else on_ignored_nl on_ignored_nl UNK typed_name # The name is in a name space.
return nil unless name_parts on_lbracket on_int on_rbracket on_op module_name on_op module_name on_op on_const on_nl else on_ignored_nl on_ignored_nl UNK typed_name on_period # Then entity cannot possible be in this module unless the name starts with the module name. # Note: # * If "module" represents a "global component", the module_name is nil and cannot match which is # ok since such a "module" cannot have namespaced content). # * If this loader is allowed to have namespaced content, the module_name can be set to NAMESPACE_WILDCARD `*` #
on_ignored_nl UNK typed_name on_period type on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK # The name is in the global name space.
on_ignored_nl UNK on_symbeg UNK on_nl if on_op global? on_nl return nil unless name_parts on_lbracket on_int on_rbracket on_op module_name on_nl on_ignored_nl # Can be defined in module using a global name. No action required
return nil unless name_parts on_lbracket on_int on_rbracket on_op module_name on_nl on_ignored_nl origin on_comma smart_path on_op find_existing_path on_lparen UNK on_rparen on_nl # Global name must be the name of the module
origin on_comma smart_path on_op find_existing_path on_lparen UNK on_rparen on_nl return smart_path on_period nil? on_op nil on_op UNK on_lparen smart_path on_comma # Look for the special 'init' plan.
return nil unless name_parts on_lbracket on_int on_rbracket on_op module_name on_nl on_ignored_nl origin on_comma smart_path on_op find_existing_path on_lparen UNK on_rparen on_nl # Global name must be the name of the module
origin on_comma smart_path on_op find_existing_path on_lparen UNK on_rparen on_nl return smart_path on_period nil? on_op nil on_op UNK on_lparen smart_path on_comma # Look for the special 'init' Task
unless name_parts on_lbracket on_int on_rbracket on_op module_name on_op module_name on_op on_const on_nl origin on_comma smart_path on_op find_existing_path on_lparen typed_name on_rparen # Global name must be the name of the module
origin on_comma smart_path on_op find_existing_path on_lparen typed_name on_rparen on_nl return smart_path on_period UNK on_lparen on_const on_op on_const on_rparen on_op UNK # Check for ruby defined data type in global namespace before giving up
origin on_comma smart_path on_op find_existing_path on_lparen UNK on_rparen on_nl return nil if smart_path on_period nil? on_nl on_ignored_nl value on_op smart_path # Look for the special 'init_typeset' TypeSet
return UNK on_lparen typed_name on_comma value on_comma origin on_rparen on_nl end on_nl on_ignored_nl raise on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content # cache the entry and return it
raise on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl UNK UNK origin on_comma UNK name_parts on_lbracket on_int on_rbracket # TRANSLATORS 'TypeSet' should not be translated
return nil on_nl end on_nl end on_nl on_ignored_nl origin on_comma smart_path on_op find_existing_path on_lparen typed_name on_rparen on_nl return UNK on_lparen # anything else cannot possibly be in this module # TODO: should not be allowed anyway... may have to revisit this decision
origin on_comma smart_path on_op find_existing_path on_lparen typed_name on_rparen on_nl return UNK on_lparen smart_path on_comma typed_name on_comma origin on_rparen unless smart_path # Get the paths that actually exist in this module (they are lazily processed once and cached). # The result is an array (that may be empty). # Find the file to instantiate, and instantiate the entity if file is found
ts_name on_op typed_name on_period UNK on_nl UNK ts_name on_nl tse on_op UNK on_lparen ts_name on_rparen on_nl tse on_op UNK on_lparen # Search for TypeSet using parent name
tse on_op UNK on_lparen ts_name on_rparen on_nl tse on_op UNK on_lparen ts_name on_rparen if tse on_period nil? on_op tse on_period # Do not traverse parents here. This search must be confined to this loader
UNK on_period UNK on_lparen self on_rparen on_nl UNK on_op UNK on_lparen typed_name on_rparen on_nl return UNK unless UNK on_period nil? # The TypeSet might be unresolved at this point. If so, it must be resolved using # this loader. That in turn, adds all contained types to this loader.
UNK on_lparen typed_name on_comma value on_comma origin on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen smart_path on_rparen on_ignored_nl raise on_const # cache the entry and return it
def UNK on_lparen smart_path on_rparen on_ignored_nl raise on_const on_period new on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl # Abstract method that subclasses override that checks if it is meaningful to search using a generic smart path. # This optimization is performed to not be tricked into searching an empty directory over and over again. # The implementation may perform a deep search for file content other than directories and cache this in # and index. It is guaranteed that a call to meaningful_to_search? takes place before checking any other # path with relative_path_exists?. # # This optimization exists because many modules have been created from a template and they have # empty directories for functions, types, etc. (It is also the place to create a cached index of the content). # # @param smart_path [String] a path relative to the module's root # @return [Boolean] true if there is content in the directory appointed by the relative path #
def UNK on_lparen UNK on_rparen on_ignored_nl raise on_const on_period new on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl # Abstract method that subclasses override to answer if the given relative path exists, and if so returns that path # # @param resolved_path [String] a path resolved by a smart path against the loader's root (if it has one) # @return [String, nil] the found path or nil if no such path was found #
def UNK on_lparen UNK on_rparen on_ignored_nl raise on_const on_period new on_nl end on_nl on_ignored_nl def UNK on_lparen effective_path on_rparen on_ignored_nl # Abstract method that subclasses override to return an array of paths that may be associated with the resolved path. # # @param resolved_path [String] a path, without extension, resolved by a smart path against the loader's root (if it has one) # @return [Array<String>] #
def UNK on_lparen effective_path on_rparen on_ignored_nl raise on_const on_period new on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl # Abstract method that subclasses override to produce the content of the effective path. # It should either succeed and return a String or fail with an exception. # # @param effective_path [String] a path as resolved by a smart path # @return [String] the content of the file #
def UNK on_lparen UNK on_rparen on_ignored_nl raise on_const on_period new on_nl end on_nl on_ignored_nl def global? on_nl module_name on_period nil? # Abstract method that subclasses override to produce a source reference String used to identify the # system resource (resource in the URI sense). # # @param relative_path [String] a path relative to the module's root # @return [String] a reference to the source file (in file system, zip file, or elsewhere). #
def global? on_nl module_name on_period nil? on_op module_name on_op on_const on_op module_name on_op on_const on_nl end on_nl on_ignored_nl def UNK # Answers the question if this loader represents a global component (true for resource type loader and environment loader) # # @return [Boolean] `true` if this loader represents a global component #
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_lparen global? on_op self on_op on_ivar on_period # Answers `true` if the loader used by this instance is rooted beneath 'lib'. This is # typically true for the the system_loader. It will have a path relative to the parent # of 'puppet' instead of the parent of 'lib/puppet' since the 'lib' directory of puppet # is renamed during install. This is significant for loaders that load ruby code. # # @return [Boolean] a boolean answering if the loader is rooted beneath 'lib'.
def UNK on_nl on_ivar on_op on_lparen global? on_op self on_op on_ivar on_period UNK on_lparen module_name on_rparen on_rparen on_nl end on_nl # Produces the private loader for the module. If this module is not already resolved, this will trigger resolution #
on_ivar on_op on_lparen global? on_op self on_op on_ivar on_period UNK on_lparen module_name on_rparen on_rparen on_nl end on_nl on_ignored_nl def UNK # The system loader has a nil module_name and it does not have a private_loader as there are no functions # that can only by called by puppet runtime - if so, it acts as the private loader directly.
def UNK on_lparen smart_path on_rparen on_ignored_nl raise on_const on_period new on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_nl # Return all paths that matches the given smart path. The returned paths are # relative to the `#generic_path` of the given smart path. # # @param smart_path [SmartPath] the path to find relative paths for # @return [Array<String>] found paths
def UNK on_nl on_ivar on_op on_const on_period new on_lparen on_symbeg type on_comma on_tstring_beg on_embexpr_beg module_name on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl # @return [TypedName] the fake typed name that maps to the init_typeset path for this module
def UNK on_nl on_ivar on_op on_const on_period new on_lparen on_symbeg UNK on_comma on_tstring_beg on_embexpr_beg module_name on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl # @return [TypedName] the fake typed name that maps to the path of an init[arbitrary extension] # file that represents a task named after the module
def UNK on_nl on_ivar on_op on_const on_period new on_lparen on_symbeg UNK on_comma on_tstring_beg on_embexpr_beg module_name on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl # @return [TypedName] the fake typed name that maps to the path of an init.pp file that represents # a plan named after the module
def find_existing_path on_lparen typed_name on_rparen on_ignored_nl UNK on_op global? on_nl UNK on_period UNK on_lparen typed_name on_period type on_rparen on_period UNK # Find an existing path or paths for the given `typed_name`. Return `nil` if no path is found # @param typed_name [TypedName] the `typed_name` to find a path for # @return [Array,nil] `nil`or a two element array where the first element is an effective path or array of paths # (depending on the `SmartPath`) and the second element is the `SmartPath` that produced the effective path or # paths. A path is a String
if origin on_period UNK on_lparen on_const on_rparen on_nl origins on_op origin on_period UNK UNK on_op UNK on_op UNK on_lparen UNK # If there are multiple *specific* paths for the file, find # whichever ones exist. Otherwise, find all paths that *might* be # related to origin
UNK on_const on_op on_const on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen parent_loader on_comma # @api private #
def UNK on_lparen parent_loader on_comma loaders on_comma module_name on_comma path on_comma loader_name on_comma loadables on_op on_const on_rparen on_ignored_nl UNK on_nl # Create a kind of ModuleLoader for one module (Puppet Module, or module like) # # @param parent_loader [Loader] typically the loader for the environment or root # @param module_name [String] the name of the module (non qualified name), may be nil for "modules" only containing globals # @param path [String] the path to the root of the module (semantics defined by subclass) # @param loader_name [String] a name that identifies the loader #
on_ivar on_period UNK on_lparen effective_path on_rparen on_op effective_path on_op nil on_nl end on_nl on_ignored_nl def UNK on_lparen effective_path on_rparen on_ignored_nl # Optimized, checks index instead of visiting file system
if UNK on_period UNK UNK on_op UNK on_op on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op UNK # At least one file has to match what we're loading, or it certainly doesn't exist
found on_op found on_period UNK UNK on_op UNK on_op on_const on_period UNK on_lparen UNK on_rparen UNK if smart_path on_period UNK # The reason for not always rejecting directories here is performance (avoid extra stat calls). The # false positives (directories with a matching extension) is an error in any case and will be caught # later.
def UNK on_lparen smart_path on_rparen on_ignored_nl UNK on_op smart_path on_period UNK on_nl found on_op on_lbracket on_rbracket on_nl on_ivar on_period UNK # Return all paths that matches the given smart path. The returned paths are # relative to the `#generic_path` of the given smart path. # # This method relies on the cache and does not perform any file system access # # @param smart_path [SmartPath] the path to find relative paths for # @return [Array<String>] found paths
UNK on_const on_op on_const on_nl def UNK on_nl UNK on_nl end on_nl end on_nl on_ignored_nl UNK on_const on_op on_const on_nl # Specialization used by the system_loader which is limited to see what's beneath 'lib' and hence # cannot be rooted in its parent. The 'lib' directory is renamed during install so any attempt # to traverse into it from above would fail. # # @api private #
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen parent_loader on_comma loaders # Loads from a gem specified as a URI, gem://gemname/optional/path/in/gem, or just a String gemname. # The source reference (shown in errors etc.) is the expanded path of the gem as this is believed to be more # helpful - given the location it should be quite obvious which gem it is, without the location, the user would # need to go on a hunt for where the file actually is located. # # TODO: How does this get instantiated? Does the gemname refelect the name of the module (the namespace) # or is that specified a different way? Can a gem be the container of multiple modules? # # @api private #
def UNK on_lparen parent_loader on_comma loaders on_comma module_name on_comma UNK on_comma loader_name on_comma loadables on_op on_const on_rparen on_ignored_nl on_ivar on_op # Create a kind of ModuleLoader for one module # The parameters are: # * parent_loader - typically the loader for the root # * module_name - the name of the module (non qualified name) # * gem_ref - [URI, String] gem reference to the root of the module (URI, gem://gemname/optional/path/in/gem), or # just the gem's name as a String. #
