on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const # The EMPTY_xxx declarations is for backward compatibility. They should not be explicitly referenced
on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op # @api private # @deprecated
on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl class on_const # @api private # @deprecated
on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl class on_const on_op on_const on_nl include on_const on_nl include on_const on_nl # @api private # @deprecated
class on_const on_op on_const on_nl include on_const on_nl include on_const on_nl include on_const on_nl on_ignored_nl def self on_period UNK on_nl # The Types model is a model of Puppet Language types. # # The {TypeCalculator} should be used to answer questions about types. The {TypeFactory} or {TypeParser} should be used # to create an instance of a type whenever one is needed. # # The implementation of the Types model contains methods that are required for the type objects to behave as # expected when comparing them and using them as keys in hashes. (No other logic is, or should be included directly in # the model's classes). # # @api public #
class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl on_ivar on_op on_const on_op # Base type for all types # @api public #
args on_period empty? on_op self on_op on_const on_op new on_lparen on_op args on_rparen on_nl end on_nl on_ignored_nl def accept on_lparen # NOTE! Important to use self::DEFAULT and not just DEFAULT since the latter yields PAnyType::DEFAULT
def accept on_lparen visitor on_comma guard on_rparen on_ignored_nl visitor on_period UNK on_lparen self on_comma guard on_rparen on_nl end on_nl on_ignored_nl # Accept a visitor that will be sent the message `visit`, once with `self` as the # argument. The visitor will then visit all types that this type contains. #
def assignable? on_lparen o on_comma guard on_op nil on_rparen on_ignored_nl case o on_nl when on_const on_nl _assignable? on_lparen on_const on_period # Checks if _o_ is a type that is assignable to this type. # If _o_ is a `Class` then it is first converted to a type. # If _o_ is a Variant, then it is considered assignable when all its types are assignable # # The check for assignable must be guarded against self recursion since `self`, the given type _o_, # or both, might be a `TypeAlias`. The initial caller of this method will typically never care # about this and hence pass only the first argument, but as soon as a check of a contained type # encounters a `TypeAlias`, then a `RecursionGuard` instance is created and passed on in all # subsequent calls. The recursion is allowed to continue until self recursion has been detected in # both `self` and in the given type. At that point the given type is considered to be assignable # to `self` since all checks up to that point were positive. # # @param o [Class,PAnyType] the class or type to test # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [Boolean] `true` when _o_ is assignable to this type # @api public
_assignable? on_lparen on_const on_period singleton on_period type on_lparen o on_rparen on_comma guard on_rparen on_nl when on_const on_nl true on_nl when # Safe to call _assignable directly since a Class never is a Unit or Variant
if o on_period UNK on_nl guard on_op on_const on_period new on_nl if guard on_period UNK on_lparen o on_rparen on_op on_const # An alias may contain self recursive constructs.
true on_nl else on_ignored_nl assignable? on_lparen o on_period resolved_type on_comma guard on_rparen on_nl end on_nl else on_ignored_nl assignable? on_lparen o # Recursion detected both in self and other. This means that other is assignable # to self. This point would not have been reached otherwise
return true if self on_period class on_op on_const on_nl return _assignable? on_lparen o on_comma guard on_rparen if is_a? on_lparen on_const # Assignable if all contained types are assignable, or if this is exactly Any
return _assignable? on_lparen o on_comma guard on_rparen if is_a? on_lparen on_const on_rparen on_op o on_period types on_period empty? on_nl on_op # An empty variant may be assignable to NotUndef[T] if T is assignable to empty variant
assignable? on_lparen on_const on_op on_const on_rparen on_op on_lparen o on_period type on_period nil? on_op assignable? on_lparen o on_period type on_rparen # Assignable if undef and contained type is assignable
def UNK on_lparen UNK on_comma guard on_op nil on_rparen on_ignored_nl UNK on_period is_a? on_lparen on_const on_rparen on_op kind_of_callable? on_op UNK # Returns `true` if this instance is a callable that accepts the given _args_type_ type # # @param args_type [PAnyType] the arguments to test # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [Boolean] `true` if this instance is a callable that accepts the given _args_
def UNK on_lparen args on_comma block on_op nil on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def callable_args? on_lparen callable on_comma # Returns `true` if this instance is a callable that accepts the given _args_ # # @param args [Array] the arguments to test # @param block [Proc] block, or nil if not called with a block # @return [Boolean] `true` if this instance is a callable that accepts the given _args_
def callable_args? on_lparen callable on_comma guard on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl end # Returns `true` if this instance is considered valid as arguments to the given `callable` # @param callable [PAnyType] the callable # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [Boolean] `true` if this instance is considered valid as arguments to the given `callable` # @api private
def UNK on_lparen UNK on_rparen on_ignored_nl end on_nl on_ignored_nl def generalize on_nl self on_nl end on_nl on_ignored_nl def loader on_nl # Called from the `PTypeAliasType` when it detects self recursion. The default is to do nothing # but some self recursive constructs are illegal such as when a `PObjectType` somehow inherits itself # @param originator [PTypeAliasType] the starting point for the check # @raise Puppet::Error if an illegal self recursion is detected # @api private
def generalize on_nl self on_nl end on_nl on_ignored_nl def loader on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def normalize # Generalizes value specific types. Types that are not value specific will return `self` otherwise # the generalized type is returned. # # @return [PAnyType] The generalized type # @api public
self on_nl end on_nl on_ignored_nl def loader on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def normalize on_lparen guard on_op # Applicable to all types that have no variables
def loader on_nl on_const on_period UNK on_nl end on_nl on_ignored_nl def normalize on_lparen guard on_op nil on_rparen on_ignored_nl self on_nl # Returns the loader that loaded this type. # @return [Loaders::Loader] the loader
def normalize on_lparen guard on_op nil on_rparen on_ignored_nl self on_nl end on_nl on_ignored_nl def resolve on_lparen loader on_rparen on_ignored_nl self # Normalizes the type. This does not change the characteristics of the type but it will remove duplicates # and constructs like NotUndef[T] where T is not assignable from Undef and change Variant[*T] where all # T are enums into an Enum. # # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [PAnyType] The iterable type that this type is assignable to or `nil` # @api public
def resolve on_lparen loader on_rparen on_ignored_nl self on_nl end on_nl on_ignored_nl def kind_of_callable? on_lparen optional on_op true on_comma guard on_op # Called from the TypeParser once it has found a type using the Loader to enable that this type can # resolve internal type expressions using a loader. Presently, this method is a no-op for all types # except the {{PTypeAliasType}}. # # @param loader [Loader::Loader] loader to use # @return [PTypeAliasType] the receiver of the call, i.e. `self` # @api private
def kind_of_callable? on_lparen optional on_op true on_comma guard on_op nil on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def iterable? on_lparen # Responds `true` for all callables, variants of callables and unless _optional_ is # false, all optional callables. # @param optional [Boolean] # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [Boolean] `true`if this type is considered callable # @api private
def iterable? on_lparen guard on_op nil on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def iterable_type on_lparen guard on_op nil on_rparen # Returns `true` if an instance of this type is iterable, `false` otherwise # The method #iterable_type must produce a `PIterableType` instance when this # method returns `true` # # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [Boolean] flag to indicate if instances of this type is iterable.
def iterable_type on_lparen guard on_op nil on_rparen on_ignored_nl nil on_nl end on_nl on_ignored_nl def hash on_nl self on_period class on_period # Returns the `PIterableType` that this type should be assignable to, or `nil` if no such type exists. # A type that returns a `PIterableType` must respond `true` to `#iterable?`. # # @example # Any Collection[T] is assignable to an Iterable[T] # A String is assignable to an Iterable[String] iterating over the strings characters # An Integer is assignable to an Iterable[Integer] iterating over the 'times' enumerator # A Type[T] is assignable to an Iterable[Type[T]] if T is an Integer or Enum # # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [PIterableType,nil] The iterable type that this type is assignable to or `nil` # @api private
def instance? on_lparen o on_comma guard on_op nil on_rparen on_ignored_nl true on_nl end on_nl on_ignored_nl def really_instance? on_lparen o on_comma # Returns true if the given argument _o_ is an instance of this type # @param guard [RecursionGuard] guard against recursion. Only used by internal calls # @return [Boolean] # @api public
def really_instance? on_lparen o on_comma guard on_op nil on_rparen on_ignored_nl instance? on_lparen o on_comma guard on_rparen on_op on_int on_op on_op # An object is considered to really be an instance of a type when something other than a # TypeAlias or a Variant responds true to a call to {#instance?}. # # @return [Integer] -1 = is not instance, 0 = recursion detected, 1 = is instance # @api private
def self on_period UNK on_nl on_ivar on_op on_lparen on_ignored_nl n on_op name on_nl n on_lbracket n on_period UNK on_lparen on_const # Strips the class name from all module prefixes, the leading 'P' and the ending 'Type'. I.e. # an instance of PVariantType will return 'Variant' # @return [String] the simple name of this type
def name on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op args on_rparen on_ignored_nl on_const on_period UNK on_lparen nil # Returns the name of the type, without parameters # @return [String] the name of the type # @api public
def new_function on_nl self on_period class on_period new_function on_lparen self on_rparen on_nl end on_nl on_ignored_nl def self on_period new_function on_lparen # Create an instance of this type. # The default implementation will just dispatch the call to the class method with the # same name and pass `self` as the first argument. # # @return [Function] the created function # @raises ArgumentError #
def self on_period new_function on_lparen type on_rparen on_ignored_nl raise on_const on_period new on_lparen on_tstring_beg on_tstring_content on_embexpr_beg type on_embexpr_end on_tstring_content on_tstring_end # This default implementation of of a new_function raises an Argument Error. # Types for which creating a new instance is supported, should create and return # a Puppet Function class by using Puppet:Loaders.create_loaded_function(:new, loader) # and return that result. # # @param type [PAnyType] the type to create a new function for # @return [Function] the created function # @raises ArgumentError #
def UNK on_nl false on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new on_nl on_ignored_nl protected on_nl on_ignored_nl def _assignable? # Answers the question if instances of this type can represent themselves as a string that # can then be passed to the create method # # @return [Boolean] whether or not the instance has a canonical string representation
on_const on_op on_const on_period new on_nl on_ignored_nl protected on_nl on_ignored_nl def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period # The default instance of this type. Each type in the type system has this constant # declared. #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_nl end on_nl on_ignored_nl def UNK # @api private
def UNK on_lparen UNK on_comma to on_comma index on_rparen on_ignored_nl UNK on_op on_lparen UNK on_period types on_period size on_op on_int # Produces the tuple entry at the given index given a tuple type, its from/to constraints on the last # type, and an index. # Produces nil if the index is out of bounds # from must be less than to, and from may not be less than 0 # # @api private #
UNK on_period types on_lbracket on_op on_int on_rbracket on_nl else on_ignored_nl nil on_nl end on_nl end on_nl on_ignored_nl def alter_type_array on_lparen # in the varargs part
def alter_type_array on_lparen types on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl modified on_op false on_nl UNK on_op types on_period map # Applies a transformation by sending the given _method_ and _method_args_ to each of the types of the given array # and collecting the results in a new array. If all transformation calls returned the type instance itself (i.e. no # transformation took place), then this method will return `self`. If a transformation did occur, then this method # will either return the transformed array or in case a block was given, the result of calling a given block with # the transformed array. # # @param types [Array<PAnyType>] the array of types to transform # @param method [Symbol] The method to call on each type # @param method_args [Object] The arguments to pass to the method, if any # @return [Object] self, the transformed array, or the result of calling a given block with the transformed array # @yieldparam altered_types [Array<PAnyType>] the altered type array # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl end on_nl on_ignored_nl attr_reader on_symbeg # @abstract Encapsulates common behavior for a type that contains one type # @api public
end on_nl on_ignored_nl attr_reader on_symbeg type on_nl on_ignored_nl def initialize on_lparen type on_rparen on_ignored_nl on_ivar on_op type on_nl end on_nl # Abstract type. It doesn't register anything
class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma # The type of types. # @api public #
def self on_period new_function on_lparen type on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period create_loaded_function on_lparen on_symbeg UNK on_comma type # Returns a new function that produces a Type instance #
case on_ivar on_nl when on_const on_nl on_const on_period new on_lparen on_ivar on_rparen on_nl when on_const on_nl on_ivar on_period UNK on_op # The types PIntegerType and PEnumType are Iterable
on_const on_period new on_lparen on_ivar on_rparen on_nl when on_const on_nl on_ivar on_period UNK on_op on_const on_period new on_lparen on_ivar on_rparen # @type describes the element type perfectly since the iteration is made over the # contained choices.
on_ivar on_period UNK on_op on_const on_period new on_lparen on_ivar on_rparen on_op nil on_nl else on_ignored_nl nil on_nl end on_nl end # @type describes the element type perfectly since the iteration is made over the # specified range.
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return false unless o on_period is_a? on_lparen on_const on_rparen on_nl return true # @api private
return false if o on_period type on_period nil? on_ivar on_period assignable? on_lparen o on_period type on_comma guard on_rparen on_nl end # wide enough to handle all types
on_ivar on_period assignable? on_lparen o on_period type on_comma guard on_rparen on_nl end on_nl end on_nl on_ignored_nl on_const on_op on_const on_nl # wider than t
on_const on_op on_const on_nl on_ignored_nl class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl # For backward compatibility
on_const on_period new on_lparen n on_period type on_period type on_rparen on_period normalize on_nl elsif on_op n on_period type on_period assignable? # No point in having an optional in a NotUndef
n on_period type on_nl else on_ignored_nl n on_nl end on_nl end on_nl end on_nl on_ignored_nl def new_function on_nl if type # THe type is NotUndef anyway, so it can be stripped of
if type on_period nil? on_nl on_const on_period new_function on_lparen self on_rparen on_nl else on_ignored_nl type on_period new_function on_nl end on_nl # If only NotUndef, then use Unit's null converter
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_op o on_period assignable? on_lparen # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
def callable_args? on_lparen UNK on_comma guard on_rparen on_ignored_nl UNK on_period assignable? on_lparen on_const on_comma guard on_rparen on_nl end on_nl on_ignored_nl # @api private
UNK on_period assignable? on_lparen on_const on_comma guard on_rparen on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new on_nl on_ignored_nl protected # if callable_t is Optional (or indeed PUndefType), this means that 'missing callable' is accepted
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_nl end on_nl end on_nl on_ignored_nl # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # A type private to the type system that describes "ignored type" - i.e. "I am what you are" # @api private #
def self on_period new_function on_lparen type on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period create_loaded_function on_lparen on_symbeg UNK on_comma type # A "null" implementation - that simply returns the given argument
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl true on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
on_symbeg default on_op o on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new on_nl on_ignored_nl protected on_nl def _assignable? on_lparen # Ensure that Symbol.== is called here instead of something unknown # that is implemented on o
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_nl end on_nl end on_nl on_ignored_nl # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # Type that is a Scalar # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_ignored_nl on_const on_op on_const on_period # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # Like Scalar but limited to Json Data. # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_ignored_nl on_const on_op on_const on_period # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # A string type describing the set of strings having one of the given values # @api public #
def each on_lparen on_op block on_rparen on_ignored_nl r on_op on_const on_period UNK on_lparen self on_rparen on_nl block_given? on_op r on_period # Returns Enumerator if no block is given, otherwise, calls the given # block with each of the strings for this enum
if on_ivar on_period empty? on_nl on_const on_op on_const on_nl else on_ignored_nl range on_op on_ivar on_period map on_lparen on_op on_symbeg size # General form of an Enum is a String
on_const on_op on_const on_nl end on_nl on_ignored_nl def hash on_nl on_ivar on_period hash on_op on_ivar on_period hash on_nl end on_nl # An instance of an Enum is a String
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return true if self on_op o on_nl UNK on_op values on_nl if # @api private
instance? on_lparen o on_period value on_comma guard on_rparen on_nl when on_const on_nl on_op o on_period values on_period empty? on_op on_lparen # if the contained string is found in the set of enums
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
return on_const on_lparen from on_rparen on_nl end on_nl end on_nl on_ignored_nl on_const on_op on_const on_op on_const on_period UNK on_lparen from # use built in conversion
def UNK on_lparen o on_rparen on_ignored_nl self on_period class on_op o on_period class on_op on_op on_lparen on_ivar on_op o on_period # Checks if this numeric range intersects with another # # @param o [PNumericType] the range to compare with # @return [Boolean] `true` if this range intersects with the other range # @api public
def from on_nl on_ivar on_op on_op on_const on_op on_const on_op nil on_op on_ivar on_nl end on_nl on_ignored_nl def to on_nl # Returns the lower bound of the numeric range or `nil` if no lower bound is set. # @return [Float,Integer]
def to on_nl on_ivar on_op on_const on_op on_const on_op nil on_op on_ivar on_nl end on_nl on_ignored_nl def numeric_from on_nl on_ivar # Returns the upper bound of the numeric range or `nil` if no upper bound is set. # @return [Float,Integer]
def numeric_from on_nl on_ivar on_nl end on_nl on_ignored_nl def numeric_to on_nl on_ivar on_nl end on_nl on_ignored_nl def hash on_nl on_ivar # Same as #from but will return `-Float::Infinity` instead of `nil` if no lower bound is set. # @return [Float,Integer]
def numeric_to on_nl on_ivar on_nl end on_nl on_ignored_nl def hash on_nl on_ivar on_period hash on_op on_ivar on_period hash on_nl end # Same as #to but will return `Float::Infinity` instead of `nil` if no lower bound is set. # @return [Float,Integer]
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return false unless o on_period is_a? on_lparen self on_period class on_rparen on_nl # @api_private
on_ivar on_op o on_period numeric_from on_op on_ivar on_op o on_period numeric_to on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new # If o min and max are within the range of t
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
def UNK on_nl on_ivar on_op on_op on_const on_op on_const on_op on_ivar on_op on_const on_op on_const on_nl end on_nl on_ignored_nl def # Will respond `true` for any range that is bounded at both ends. # # @return [Boolean] `true` if the type describes a finite range.
def UNK on_lparen o on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_lparen on_ivar on_op on_int on_op o on_period # Checks if this range is adjacent to the given range # # @param o [PIntegerType] the range to compare with # @return [Boolean] `true` if this range is adjacent to the other range # @api public
def UNK on_lparen o on_rparen on_ignored_nl if UNK on_lparen o on_rparen on_op UNK on_lparen o on_rparen on_nl min on_op on_ivar # Concatenates this range with another range provided that the ranges intersect or # are adjacent. When that's not the case, this method will return `nil` # # @param o [PIntegerType] the range to concatenate with this range # @return [PIntegerType,nil] the concatenated range or `nil` when the ranges were apart # @api public
on_const on_period new on_lparen on_const on_op on_const on_rparen on_nl end on_nl on_ignored_nl def size on_nl return on_const on_op on_const if # It's unknown if the iterable will be a range (min, max) or a "times" (0, max)
def size on_nl return on_const on_op on_const if on_ivar on_op on_op on_const on_op on_const on_op on_ivar on_op on_const on_op on_const # Returns Float.Infinity if one end of the range is unbound
def range on_nl on_lbracket on_ivar on_comma on_ivar on_rbracket on_nl end on_nl on_ignored_nl def each on_lparen on_op block on_rparen on_ignored_nl r # Returns the range as an array ordered so the smaller number is always first. # The number may be Infinity or -Infinity.
def each on_lparen on_op block on_rparen on_ignored_nl r on_op on_const on_period UNK on_lparen self on_rparen on_nl block_given? on_op r on_period # Returns Enumerator if no block is given # Returns nil if size is infinity (does not yield)
def UNK on_nl on_ivar on_op on_int on_op self on_op on_const on_period new on_lparen on_int on_comma on_ivar on_op on_int on_op on_int # Returns a range where both to and from are positive numbers. Negative # numbers are converted to zero # @return [PIntegerType] a positive range
match on_op on_const on_op on_const on_period match on_lparen from on_rparen on_nl if match on_nl begin on_ignored_nl return from_args on_lparen match # Test for special case where there is whitespace between sign and number
return from_args on_lparen match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_comma radix on_rparen on_nl rescue on_const on_nl end # Try again, this time with whitespace removed
end on_nl end on_nl raise on_const on_period new on_lparen e on_period message on_rparen on_nl end on_nl end on_nl end on_nl # Ignored to retain original error
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
def UNK on_lparen o on_rparen on_ignored_nl if UNK on_lparen o on_rparen on_nl min on_op on_ivar on_op o on_period from on_op # Concatenates this range with another range provided that the ranges intersect. When that's not the case, this # method will return `nil` # # @param o [PFloatType] the range to concatenate with this range # @return [PFloatType,nil] the concatenated range or `nil` when the ranges were apart # @api public
def self on_period new_function on_lparen type on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period create_loaded_function on_lparen on_symbeg UNK on_comma type # Returns a new function that produces a Float value #
if from on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_op from on_lbracket on_int on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # support a binary as float
match on_op on_const on_op on_const on_period match on_lparen from on_rparen on_nl if match on_nl begin on_ignored_nl return from_args on_lparen match # Test for special case where there is whitespace between sign and number
return from_args on_lparen match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_rparen on_nl rescue on_const on_nl end on_nl end # Try again, this time with whitespace removed
end on_nl end on_nl raise on_const on_period new on_lparen e on_period message on_rparen on_nl end on_nl end on_nl end on_nl # Ignored to retain original error
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
if o on_period instance_of? on_lparen on_const on_rparen on_op o on_period instance_of? on_lparen on_const on_rparen on_nl on_ivar on_period nil? on_op on_ivar # The inferred type of a class derived from Array or Hash is either Runtime or Object. It's not assignable to the Collection type.
def size_range on_nl on_lparen on_ivar on_op on_const on_rparen on_period range on_nl end on_nl on_ignored_nl def UNK on_nl from on_comma to # Returns an array with from (min) size to (max) size
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl case o on_nl when on_const on_nl on_lparen on_ivar on_op on_const on_rparen on_period # @api private #
size_s on_op size_type on_op on_const on_nl size_o on_op o on_period size_type on_nl if size_o on_period nil? on_nl type_count on_op o # compute the tuple's min/max size, and check if that size matches
case o on_nl when on_const on_comma on_const on_comma on_const on_comma on_const on_comma on_const on_comma on_const on_nl true on_nl when on_const # Any element_type will do
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl if on_ivar on_period nil? on_op on_ivar on_period assignable? on_lparen on_const on_op on_const # @api private
o on_period iterable? on_nl else on_ignored_nl o on_op o on_period iterable_type on_nl o on_period nil? on_op o on_period element_type on_period # Don't request the iterable_type. Since this Iterable accepts Any element, it is enough that o is iterable.
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_lparen on_ivar on_period nil? on_op # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen #TRANSLATORS 'PStringType#initialize' is a class and method name and should not be translated
if o on_period is_a? on_lparen on_const on_rparen on_nl if on_ivar on_period is_a? on_lparen on_const on_rparen on_nl on_ivar on_period instance? on_lparen # true if size compliant
def values on_nl if on_const on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # @deprecated # @api private
on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl #TRANSLATORS 'PStringType#values' and '#value' are classes and method names and should not be translated
on_const on_op on_const on_period new on_lparen on_const on_period new on_lparen on_const on_period new on_lparen on_int on_comma on_int on_rparen on_rparen on_rparen # Iterates over each character of the string
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl if on_ivar on_period is_a? on_lparen on_const on_rparen on_nl case o on_nl when # @api private
case o on_nl when on_const on_nl on_ivar on_period assignable? on_lparen o on_period UNK on_comma guard on_rparen on_nl on_ignored_nl when on_const # A general string is assignable by any other string or pattern restricted string # if the string has a size constraint it does not match since there is no reasonable way # to compute the min/max length a pattern will match. For enum, it is possible to test that # each enumerator value is within range
on_ivar on_period assignable? on_lparen on_const on_op on_const on_comma guard on_rparen on_nl else on_ignored_nl UNK on_op o on_period values on_period map # enum represents all enums, and thus all strings, a sized constrained string can thus not # be assigned any enum (unless it is max size).
UNK on_op o on_period values on_period map on_lparen on_op on_symbeg size on_rparen on_period UNK on_nl UNK on_op on_ivar on_period range # true if all enum values are within range
UNK on_lbracket on_int on_rbracket on_op UNK on_lbracket on_int on_rbracket on_op UNK on_lbracket on_int on_rbracket on_op UNK on_lbracket on_int on_rbracket on_nl # If o min and max are within the range of t
on_ivar on_period assignable? on_lparen on_const on_op on_const on_comma guard on_rparen on_nl else on_ignored_nl false on_nl end on_nl else on_ignored_nl case # true if size constraint is at least 0 to +Infinity (which is the same as the default)
false on_nl end on_nl else on_ignored_nl case o on_nl when on_const on_nl on_ivar on_period nil? on_op on_ivar on_op o on_period # no other type matches string
on_ivar on_period nil? on_op on_ivar on_op o on_period size_type_or_value on_nl when on_const on_nl on_ivar on_period nil? on_op true on_op o # Must match exactly when value is a string
false on_nl end on_nl end on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl def self on_period register_ptype # All others are false, since no other type describes the same set of specific strings
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
def self on_period new_function on_lparen type on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period create_loaded_function on_lparen on_symbeg UNK on_comma type # Returns a new function that produces a Regexp instance #
def self on_period UNK on_lparen regexp on_rparen on_ignored_nl regexp on_period options on_op on_int on_op regexp on_period UNK on_op on_tstring_beg on_tstring_content # @param regexp [Regexp] the regular expression # @return [String] the Regexp as a slash delimited string with slashes escaped
def self on_period UNK on_lparen regexp on_rparen on_ignored_nl UNK on_lparen regexp on_period UNK on_comma regexp on_period options on_rparen on_nl end # @param regexp [Regexp] the regular expression # @return [String] the Regexp as a string without escaped slash
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_lparen on_ivar on_period nil? on_op # @api private #
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # Represents a subtype of String that narrows the string to those matching the patterns # If specified without a pattern it is basically the same as the String type. # # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return true if self on_op o on_nl case o on_nl when on_const # @api private #
on_ivar on_period empty? on_nl else on_ignored_nl regexps on_op on_ivar on_period map on_lbrace on_op p on_op p on_period regexp on_rbrace on_nl # Strings cannot all match a pattern, but if there is no pattern it is ok # (There should really always be a pattern, but better safe than sorry).
regexps on_op on_ivar on_period map on_lbrace on_op p on_op p on_period regexp on_rbrace on_nl regexps on_period empty? on_op regexps on_period # the string in String type must match one of the patterns in Pattern type, # or Pattern represents all Patterns == all Strings
on_ivar on_period empty? on_nl else on_ignored_nl regexps on_op on_ivar on_period map on_lbrace on_op p on_op p on_period regexp on_rbrace on_nl # Enums (unknown which ones) cannot all match a pattern, but if there is no pattern it is ok # (There should really always be a pattern, but better safe than sorry).
regexps on_op on_ivar on_period map on_lbrace on_op p on_op p on_period regexp on_rbrace on_nl regexps on_period empty? on_op o on_period # all strings in String/Enum type must match one of the patterns in Pattern type, # or Pattern represents all Patterns == all Strings
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_lparen on_ivar on_period nil? on_op # @api private #
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl on_ivar on_op on_const on_op UNK # @api public # # @api public #
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl # Special boostrap method to overcome the hen and egg problem with the Object initializer that contains # types that are derived from Object (such as Annotation) # # @api private
class on_const on_op on_const on_nl include on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype # @api public #
return false unless o on_period instance_of? on_lparen on_const on_rparen on_nl matched on_op on_int on_nl on_ivar on_period all? do on_op e # The inferred type of a class derived from Hash is either Runtime or Object. It's not assignable to the Struct type.
e on_period key_type on_period assignable? on_lparen on_const on_op on_const on_comma guard on_rparen on_nl else on_ignored_nl matched on_op on_int on_nl e # Entry is missing. Only OK when key is optional
on_const on_period new_function on_lparen self on_rparen on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new on_lparen on_const on_rparen on_nl on_ignored_nl # Simply delegate to Hash type and let the higher level assertion deal with # compliance with the Struct type regarding the produced result.
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl if o on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl UNK on_op # @api private
true on_nl else on_ignored_nl UNK on_op on_int on_nl if e on_period value_type on_period assignable? on_lparen o on_period value_type on_comma guard # Element is optional so Hash does not need to provide it
key_type on_period generalize on_period assignable? on_lparen o on_period key_type on_rparen on_nl else on_ignored_nl false on_nl end on_nl end on_nl end # Hash must have something that is assignable. We don't care about the name or size of the key though # because we have no instance of a hash to compare against.
class on_const on_op on_const on_nl include on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype # @api public #
attr_reader on_symbeg size_type on_nl on_ignored_nl attr_reader on_symbeg types on_nl on_ignored_nl def accept on_lparen visitor on_comma guard on_rparen on_ignored_nl super on_nl # If set, describes min and max required of the given types - if max > size of # types, the last type entry repeats #
def callable_args? on_lparen UNK on_comma guard on_rparen on_ignored_nl unless size_type on_period nil? on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl # @api private
return false if UNK on_period nil? on_nl on_ignored_nl return false unless UNK on_period assignable? on_lparen UNK on_comma guard on_rparen on_nl # Can't pass a block to a callable that doesn't accept one
return false unless UNK on_period assignable? on_lparen UNK on_comma guard on_rparen on_nl on_ignored_nl UNK on_op UNK on_period size on_op on_int # Check that the block is of the right tyṕe
UNK on_op UNK on_period size on_op on_int on_nl UNK on_op UNK on_period size_type on_op on_const on_period new on_lparen on_op UNK # Check other arguments
UNK on_period assignable? on_lparen self on_comma guard on_rparen on_op on_lparen UNK on_period nil? on_op UNK on_period assignable? on_lparen on_const on_op # Check that tuple is assignable and that the block (if declared) is optional
def each on_nl if block_given? on_nl types on_period each on_lbrace on_op UNK on_op yield UNK on_rbrace on_nl else on_ignored_nl types # Returns Enumerator for the types if no block is given, otherwise, calls the given # block with each of the types in this tuple
return false unless o on_period instance_of? on_lparen on_const on_rparen on_nl if on_ivar on_nl return false unless on_ivar on_period instance? on_lparen # The inferred type of a class derived from Array is either Runtime or Object. It's not assignable to the Tuple type.
def size_range on_nl if on_ivar on_period nil? on_nl types_size on_op on_ivar on_period size on_nl types_size on_op on_int on_op on_lbracket on_int # Returns the number of elements accepted [min, max] in the tuple
def UNK on_nl if on_ivar on_period nil? on_nl return on_lbracket on_int on_comma on_int on_rbracket on_nl end on_nl types_size on_op on_ivar # Returns the number of accepted occurrences [min, max] of the last type in the tuple # The defaults is [1,1] #
on_const on_period new_function on_lparen self on_rparen on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new on_lparen on_const on_rparen on_nl on_ignored_nl # Simply delegate to Array type and let the higher level assertion deal with # compliance with the Tuple type regarding the produced result.
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return true if self on_op o on_nl return false unless o on_period # @api private
return false if UNK on_period nil? on_nl on_lbracket s_types on_period size on_comma size_o on_period range on_lbracket on_int on_rbracket on_rbracket on_period # Array of anything can not be assigned (unless tuple is tuple of anything) - this case # was handled at the top of this method. #
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # @api public #
attr_reader on_symbeg return_type on_nl on_ignored_nl attr_reader on_symbeg param_types on_nl on_ignored_nl attr_reader on_symbeg block_type on_nl on_ignored_nl def initialize on_lparen param_types on_comma # @return [PAnyType] The type for the values returned by this callable. Returns `nil` if return value is unconstrained
attr_reader on_symbeg param_types on_nl on_ignored_nl attr_reader on_symbeg block_type on_nl on_ignored_nl def initialize on_lparen param_types on_comma block_type on_op nil on_comma return_type # Types of parameters as a Tuple with required/optional count, or an Integer with min (required), max count # @return [PTupleType] the tuple representing the parameter types
attr_reader on_symbeg block_type on_nl on_ignored_nl def initialize on_lparen param_types on_comma block_type on_op nil on_comma return_type on_op nil on_rparen on_ignored_nl on_ivar # Although being an abstract type reference, only Callable, or all Callables wrapped in # Optional or Variant are supported # If not set, the meaning is that block is not supported. # @return [PAnyType|nil] the block type
def initialize on_lparen param_types on_comma block_type on_op nil on_comma return_type on_op nil on_rparen on_ignored_nl on_ivar on_op param_types on_nl on_ivar on_op # @param param_types [PTupleType] # @param block_type [PAnyType] # @param return_type [PAnyType]
def UNK on_lparen args on_comma block on_op nil on_rparen on_ignored_nl return true if on_ivar on_period nil? on_nl return false unless # Returns `true` if this instance is a callable that accepts the given _args_ # # @param args [Array] the arguments to test # @return [Boolean] `true` if this instance is a callable that accepts the given _args_
return true if on_ivar on_period nil? on_nl return false unless on_ivar on_period instance? on_lparen args on_rparen on_nl if on_ivar on_period # nil param_types and compatible return type means other Callable is assignable
def callable_args? on_lparen UNK on_comma guard on_rparen on_ignored_nl UNK on_period assignable? on_lparen self on_comma guard on_rparen on_nl end on_nl on_ignored_nl # @api private
UNK on_period assignable? on_lparen self on_comma guard on_rparen on_nl end on_nl on_ignored_nl def kind_of_callable? on_lparen optional on_op true on_comma guard # If the required callable is equal or more specific than self, self is acceptable arguments
def size_range on_nl on_ivar on_period nil? on_op nil on_op on_ivar on_period size_range on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar # Returns the number of accepted arguments [min, max]
def UNK on_nl on_ivar on_period nil? on_op nil on_op on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl case # Returns the number of accepted arguments for the last parameter type [min, max] #
def UNK on_nl case block_type on_nl when on_const on_nl on_lbracket on_int on_comma on_int on_rbracket on_nl when on_const on_comma on_const on_nl # Range [0,0], [0,1], or [1,1] for the block #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return false unless o on_period is_a? on_lparen on_const on_rparen on_nl return false # @api private
return true if on_ivar on_period nil? on_nl on_ignored_nl UNK on_op o on_period param_types on_nl on_ignored_nl return false if UNK on_period # nil param_types and compatible return type means other Callable is assignable
UNK on_op o on_period param_types on_nl on_ignored_nl return false if UNK on_period nil? on_op on_op UNK on_period assignable? on_lparen on_ivar # NOTE: these tests are made in reverse as it is calling the callable that is constrained # (it's lower bound), not its upper bound
UNK on_op on_ivar on_op on_const on_op on_const on_nl UNK on_op o on_period block_type on_op on_const on_op on_const on_nl UNK on_period # names are ignored, they are just information # Blocks must be compatible
class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma # @api public #
def callable_args? on_lparen callable on_comma guard on_op nil on_rparen on_ignored_nl UNK on_op callable on_period param_types on_nl block_t on_op callable on_period # @api private
on_lparen UNK on_period nil? on_op UNK on_period assignable? on_lparen self on_comma guard on_rparen on_rparen on_op on_lparen block_t on_period nil? on_op # does not support calling with a block, but have to check that callable is ok with missing block
return false unless o on_period instance_of? on_lparen on_const on_rparen on_nl return false unless o on_period all? on_lbrace on_op UNK on_op # The inferred type of a class derived from Array is either Runtime or Object. It's not assignable to the Array type.
def self on_period new_function on_lparen type on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period create_loaded_function on_lparen on_symbeg UNK on_comma type # Returns a new function that produces an Array #
from on_period UNK on_period UNK on_period UNK on_nl else on_ignored_nl on_const on_period UNK on_lparen from on_rparen on_period UNK on_nl end # For older rubies, the #bytes method returns an Enumerator that must be rolled out
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl if o on_period is_a? on_lparen on_const on_rparen on_nl o_types on_op o on_period # Array is assignable if o is an Array and o's element type is assignable, or if o is a Tuple # @api private
class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma # @api public #
on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen #TRANSLATOR 'Puppet::Pops::Types::PHashType#element_type' and '#value_type' are class and method names and should not be translated
return false unless o on_period instance_of? on_lparen on_const on_rparen on_nl if o on_period UNK on_period all? on_lbrace on_op UNK on_op # The inferred type of a class derived from Hash is either Runtime or Object. It's not assignable to the Hash type.
def self on_period new_function on_lparen type on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period create_loaded_function on_lparen on_symbeg UNK on_comma type # Returns a new function that produces a Hash #
on_ignored_nl UNK on_op UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl result on_op on_lbrace on_rbrace on_nl UNK on_period each do on_op UNK # only remaining possible options is 'tree' or 'hash_tree'
if value on_period is_a? on_lparen on_const on_rparen on_nl value on_period UNK on_lbrace on_op v on_comma idx on_op result on_lbracket idx # root node (index [] was included - values merge into the result) # An array must be changed to a hash first as this is the root # (Cannot return an array from a Hash.new)
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl case o on_nl when on_const on_nl size_s on_op size_type on_nl return true # Hash is assignable if o is a Hash and o's key and element types are assignable # @api private
UNK on_op o on_period elements on_nl on_lparen size_type on_op on_const on_rparen on_period instance? on_lparen UNK on_period size on_comma guard on_rparen # hash must accept String as key type # hash must accept all value types # hash must accept the size of the struct
class on_const on_op on_const on_nl include on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype # A flexible type describing an any? of other types # @api public #
def self on_period maybe_create on_lparen types on_rparen on_ignored_nl types on_op UNK on_lparen types on_rparen on_period UNK on_nl types on_period size # Checks if the number of unique types in the given array is greater than one, and if so # creates a Variant with those types and returns it. If only one unique type is found, # that type is instead returned. # # @param types [Array<PAnyType>] the variants # @return [PAnyType] the resulting type # @api public
def initialize on_lparen types on_rparen on_ignored_nl on_ivar on_op types on_period freeze on_nl end on_nl on_ignored_nl def accept on_lparen visitor on_comma # @param types [Array[PAnyType]] the variants
modified on_op false on_nl types on_op alter_type_array on_lparen on_ivar on_comma on_symbeg normalize on_comma guard on_rparen on_nl if types on_op self # Normalize all contained types
on_const on_period new on_lparen on_const on_period maybe_create on_lparen types on_period UNK on_lbrace on_op t on_op t on_period is_a? on_lparen on_const # Undef entry present. Use an OptionalType with a normalized Variant without Undefs and Optional wrappers
types on_op on_const on_period UNK on_lparen types on_rparen on_nl UNK on_op types on_period size on_nl on_ignored_nl types on_op UNK on_lparen # Merge all variants into this one
on_ivar on_period any? on_lbrace on_op type on_op type on_period instance? on_lparen o on_comma guard on_rparen on_rbrace on_nl end on_nl on_ignored_nl # instance of variant if o is instance? of any of variant's types
if o on_period is_a? on_lparen on_const on_rparen on_op types on_period empty? on_nl return false on_nl end on_nl on_ignored_nl return super # an empty Variant does not match Undef (it is void - not even undef)
return true if types on_period empty? on_nl on_op o on_period types on_period empty? on_op o on_period types on_period all? on_lbrace # If empty, all Variant types match irrespective of the types they hold (including being empty)
on_op o on_period types on_period empty? on_op o on_period types on_period all? on_lbrace on_op UNK on_op super on_lparen UNK on_comma # Since this variant is not empty, an empty Variant cannot match, because it matches nothing # otherwise all types in o must be assignable to this
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl types on_period any? on_lbrace on_op UNK on_op UNK on_period assignable? on_lparen o # @api private
types on_period any? on_lbrace on_op UNK on_op UNK on_period assignable? on_lparen o on_comma guard on_rparen on_rbrace on_nl end on_nl on_ignored_nl # A variant is assignable if o is assignable to any of its types
def UNK on_lparen array on_rparen on_ignored_nl if array on_period size on_op on_int on_nl parts on_op array on_period partition on_lbrace on_op # @api private
def UNK on_lparen array on_rparen on_ignored_nl if array on_period size on_op on_int on_nl parts on_op array on_period partition on_lbrace on_op # @api private
if array on_period size on_op on_int on_nl parts on_op array on_period partition on_lbrace on_op t on_op t on_period is_a? on_lparen # Merge case sensitive enums and strings
if array on_period size on_op on_int on_nl parts on_op array on_period partition on_lbrace on_op t on_op t on_period is_a? on_lparen # Merge case insensitive enums
def UNK on_lparen array on_rparen on_ignored_nl if array on_period size on_op on_int on_nl parts on_op array on_period partition on_lbrace on_op # @api private
def UNK on_lparen UNK on_comma array on_rparen on_ignored_nl if array on_period size on_op on_int on_nl parts on_op array on_period partition # @api private
def UNK on_lparen ranges on_rparen on_ignored_nl result on_op on_lbracket on_rbracket on_nl UNK ranges on_period empty? on_nl UNK on_op on_lbracket on_rbracket # @api private
class on_const on_op on_const on_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma ir # Abstract representation of a type that can be placed in a Catalog. # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_nl end on_nl end on_nl on_ignored_nl # @api private
class on_const on_op on_const on_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl # Represents a (host-) class in the Puppet Language. # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return false unless o on_period is_a? on_lparen on_const on_rparen on_nl return true # @api private
return true if on_ivar on_period nil? on_nl on_ivar on_op o on_period UNK on_nl end on_nl end on_nl on_ignored_nl on_const on_op # Class = Class[name}, Class[name] != Class
on_ivar on_op o on_period UNK on_nl end on_nl end on_nl on_ignored_nl on_const on_op on_const on_nl on_ignored_nl on_ignored_nl class on_const on_op # Class[name] = Class[name]
on_const on_op on_const on_nl on_ignored_nl on_ignored_nl class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir # For backward compatibility
class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma # Represents a Resource Type in the Puppet Language # @api public #
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_lparen on_ivar on_period nil? on_op # @api private
class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma # Represents a type that accept PUndefType instead of the type parameter # required_type - is a short hand for Variant[T, Undef] # @api public #
on_const on_period new on_lparen n on_period type on_period type on_rparen on_period normalize on_nl elsif n on_period type on_period assignable? on_lparen # No point in having an NotUndef in an Optional
n on_period type on_nl else on_ignored_nl n on_nl end on_nl end on_nl end on_nl on_ignored_nl def new_function on_nl UNK on_period # THe type is Optional anyway, so it can be stripped of
def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl return true if o on_period is_a? on_lparen on_const on_rparen on_nl return true # @api private
o on_op self on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # A type must be assignable to itself or a lot of unit tests will break
class on_const on_op on_const on_nl on_ignored_nl def self on_period register_ptype on_lparen loader on_comma ir on_rparen on_ignored_nl create_ptype on_lparen loader on_comma # Describes a named alias for another Type. # The alias is created with a name and an unresolved type expression. The type expression may # in turn contain other aliases (including the alias that contains it) which means that an alias # might contain self recursion. Whether or not that is the case is computed and remembered when the alias # is resolved since guarding against self recursive constructs is relatively expensive. # # @api public
def initialize on_lparen name on_comma UNK on_comma resolved_type on_op nil on_rparen on_ignored_nl on_ivar on_op name on_nl on_ivar on_op UNK on_nl # @param name [String] The name of the type # @param type_expr [Model::PopsObject] The expression that describes the aliased type # @param resolved_type [PAnyType] the resolve type (only used for the DEFAULT initialization)
def resolved_type on_nl raise on_const on_op on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_end unless on_ivar on_nl on_ivar on_nl end # Returns the resolved type. The type must have been resolved by a call prior to calls to this # method or an error will be raised. # # @return [PAnyType] The resolved type of this alias. # @raise [Puppet::Error] unless the type has been resolved prior to calling this method
class on_const on_nl def initialize on_nl on_ivar on_op false on_nl end on_nl on_ignored_nl def UNK on_lparen type on_comma _ on_rparen # Acceptor used when checking for self recursion and that a type contains # something other than aliases or type references # # @api private
class on_const on_nl def UNK on_lparen type on_comma _ on_rparen on_ignored_nl type on_period UNK if type on_period is_a? on_lparen on_const # Acceptor used when re-checking for self recursion after a self recursion has been detected # # @api private
end on_nl on_ignored_nl def resolve on_lparen loader on_rparen on_ignored_nl on_ivar on_op loader on_nl if on_ivar on_period nil? on_nl on_ivar on_op # no difference
def resolve on_lparen loader on_rparen on_ignored_nl on_ivar on_op loader on_nl if on_ivar on_period nil? on_nl on_ivar on_op on_const on_op on_const # Called from the TypeParser once it has found a type using the Loader. The TypeParser will # interpret the contained expression and the resolved type is remembered. This method also # checks and remembers if the resolve type contains self recursion. # # @param type_parser [TypeParser] type parser that will interpret the type expression # @param loader [Loader::Loader] loader to use when loading type aliases # @return [PTypeAliasType] the receiver of the call, i.e. `self` # @api private
on_ivar on_op on_const on_op on_const on_nl on_ivar on_op true begin on_ignored_nl if on_ivar on_period is_a? on_lparen on_const on_rparen on_nl on_ivar # resolved to PTypeReferenceType::DEFAULT during resolve to avoid endless recursion
begin on_ignored_nl if on_ivar on_period is_a? on_lparen on_const on_rparen on_nl on_ivar on_op on_ivar on_period resolve on_lparen loader on_rparen on_nl else # assumed while it being found out below
guard on_op on_const on_period new on_nl real_type_asserter on_op on_const on_period new on_nl accept on_lparen real_type_asserter on_comma guard on_rparen on_nl unless # Find out if this type is recursive. A recursive type has performance implications # on several methods and this knowledge is used to avoid that for non-recursive # types.
if on_ivar on_nl accept on_lparen on_const on_period new on_comma on_const on_period new on_rparen on_nl UNK on_nl end on_nl rescue on_nl # All aliases involved must re-check status since this alias is now resolved
on_ivar on_period resolve on_lparen loader on_rparen unless on_ivar on_period equal? on_lparen on_const on_op on_const on_rparen on_nl end on_nl self on_nl # An alias may appoint an Object type that isn't resolved yet. The default type # reference is used to prevent endless recursion and should not be resolved here.
def UNK on_nl on_const on_period singleton on_period UNK on_lparen self on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen name on_comma # Returns the expanded string the form of the alias, e.g. <alias name> = <resolved type> # # @return [String] the expanded form of this alias # @api public
def UNK on_lparen name on_comma UNK on_rparen on_ignored_nl resolved_type on_period UNK on_lparen name on_comma UNK on_rparen on_nl end on_nl on_ignored_nl # Delegates to resolved type
def UNK on_lparen name on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl super if on_ivar on_period equal? on_lparen on_const on_op # Delegates to resolved type
def really_instance? on_lparen o on_comma guard on_op nil on_rparen on_ignored_nl if on_ivar on_nl guard on_op on_const on_period new on_nl guard # @api private
def UNK on_nl nil on_nl end on_nl on_ignored_nl protected on_nl on_ignored_nl def _assignable? on_lparen o on_comma guard on_rparen on_ignored_nl resolved_type # @return `nil` to prevent serialization of the type_expr used when first initializing this instance # @api private
UNK on_op on_ivar on_period types on_nl UNK on_op UNK on_period UNK do on_op type on_op on_ignored_nl UNK false if type # Drop variants that are not real types
guard on_op on_const on_period new on_nl accept on_lparen on_const on_op on_const on_comma guard on_rparen on_nl on_ivar on_op guard on_period UNK # Drop self recursion status in case it's not self recursive anymore
