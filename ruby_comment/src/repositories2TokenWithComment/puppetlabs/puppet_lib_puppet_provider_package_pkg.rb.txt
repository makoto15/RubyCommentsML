on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg install_options on_nl # https://docs.oracle.com/cd/E19963-01/html/820-6572/managepkgs.html # A few notes before we start: # Opensolaris pkg has two slightly different formats (as of now.) # The first one is what is distributed with the Solaris 11 Express 11/10 dvd # The latest one is what you get when you update package. # To make things more interesting, pkg version just returns a sha sum. # dvd: pkg version => 052adf36c3f4 # updated: pkg version => 630e1ffc7a19 # Thankfully, Solaris has not changed the commands to be used. # TODO: We still have to allow packages to specify a preferred publisher.
def self on_period UNK on_lparen flags on_rparen on_ignored_nl on_lparen on_ignored_nl case flags on_lbracket on_int on_op on_int on_rbracket on_nl when on_tstring_beg # The IFO flag field is just what it names, the first field can have either # i_nstalled or -, and second field f_rozen or -, and last # o_bsolate or r_rename or - # so this checks if the installed field is present, and also verifies that # if not the field is -, else we don't know what we are doing and exit with # out doing more damage.
def self on_period UNK on_lparen flags on_rparen on_ignored_nl on_lbrace on_rbrace on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen UNK # The UFOXI field is the field present in the older pkg # (solaris 2009.06 - snv151a) # similar to IFO, UFOXI is also an either letter or - # u_pdate indicates that an update for the package is available. # f_rozen(n/i) o_bsolete x_cluded(n/i) i_constrained(n/i) # note that u_pdate flag may not be trustable due to constraints. # so we dont rely on it # Frozen was never implemented in UFOXI so skipping frozen here.
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl case UNK on_nl when on_regexp_beg on_tstring_content on_regexp_end on_nl on_lbrace on_symbeg status on_op # pkg state was present in the older version of pkg (with UFOXI) but is # no longer available with the IFO field version. When it was present, # it was used to indicate that a particular version was present (installed) # and later versions were known. Note that according to the pkg man page, # known never lists older versions of the package. So we can rely on this # field to make sure that if a known is present, then the pkg is upgradable.
def self on_period UNK on_lparen line on_rparen on_ignored_nl on_lparen case line on_period UNK on_nl when on_regexp_beg on_tstring_content on_regexp_end on_nl on_lbrace # Here is (hopefully) the only place we will have to deal with multiple # formats of output for different pkg versions.
when on_regexp_beg on_tstring_content on_regexp_end on_nl on_lbrace on_symbeg UNK on_op on_backref on_comma on_symbeg name on_op on_backref on_comma on_symbeg ensure on_op on_backref # FMRI IFO # pkg://omnios/SUNWcs@0.5.11,5.11-0.151008:20131204T022241Z ---
when on_regexp_beg on_tstring_content on_regexp_end on_nl on_lbrace on_symbeg UNK on_op on_backref on_comma on_symbeg name on_op on_backref on_comma on_symbeg ensure on_op on_backref # FMRI STATE UFOXI # pkg://solaris/SUNWcs@0.5.11,5.11-0.151.0.1:20101105T001108Z installed u----
should on_op on_ivar on_lbracket on_symbeg ensure on_rbracket on_nl if on_regexp_beg on_tstring_content on_regexp_end on_op should on_nl name on_op on_ivar on_lbracket on_symbeg # this is called after the generic version matching logic (insync? for the # type), so we only get here if should != is, and 'should' is a version # number. 'is' might not be, though.
if on_regexp_beg on_tstring_content on_regexp_end on_op should on_nl name on_op on_ivar on_lbracket on_symbeg name on_rbracket on_nl UNK on_op pkg on_lparen on_symbeg # NB: it is apparently possible for repository administrators to publish # packages which do not include build or branch versions, but component # version must always be present, and the timestamp is added by pkgsend # publish.
name on_op on_ivar on_lbracket on_symbeg name on_rbracket on_nl UNK on_op pkg on_lparen on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # We have a less-than-explicit version string, which we must accept for # backward compatibility. We can find the real version this would match # by asking pkg for the all matching versions, and selecting the first # installable one [0]; this can change over time when remote repositories # are updated, but the principle of least astonishment should still hold: # if we allow users to specify less-than-explicit versions, the # functionality should match that of the package manager. # # [0]: we could simply get the newest matching version with 'pkg list # -n', but that isn't always correct, since it might not be installable. # If that were the case we could potentially end up returning false for # insync? here but not actually changing the package version in install # (ie. if the currently installed version is the latest matching version # that is installable, we would falsely conclude here that since the # installed version is not the latest matching version, we're not in # sync). 'pkg list -a' instead of '-n' would solve this, but # unfortunately it doesn't consider downgrades 'available' (eg. with # installed foo@1.0, list -a foo@0.9 would fail).
return UNK on_nl when on_int on_nl UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label p on_lbracket on_symbeg # if the first installable match would cause no changes, we're in sync
def UNK on_nl pkg on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl UNK on_op pkg on_lparen on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end # Return the version of the package. Note that the bug # http://defect.opensolaris.org/bz/show_bug.cgi?id=19159% # notes that we can't use -Ha for the same even though the manual page reads that way.
pkg on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl UNK on_op pkg on_lparen on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_lbracket # Refresh package metadata before looking for latest versions
UNK on_op UNK on_period UNK on_lbrace on_op line on_op line on_op on_regexp_beg on_tstring_content on_regexp_end on_rbrace on_nl UNK UNK on_period UNK # remove certificate expiration warnings from the output, but report them
UNK on_op UNK on_period UNK on_lbrace on_op p on_op p on_lbracket on_symbeg status on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_rbrace on_nl # Now we know there is a newer version. But is that installable? (i.e are there any constraints?) # return the first known we find. The only way that is currently available is to do a dry run of # pkg update and see if could get installed (`pkg update -n res`).
on_lparen UNK on_period UNK on_lbrace on_op p on_op p on_lbracket on_symbeg status on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_rbrace on_op on_lbrace # If not, then return the installed, else nil
def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl name on_op on_ivar on_lbracket on_symbeg name on_rbracket on_nl should on_op on_ivar on_lbracket # install the package and accept all licenses.
def UNK on_nl cmd on_op on_lbracket on_symbeg UNK on_rbracket on_nl case on_lparen pkg on_symbeg UNK on_rparen on_period UNK on_nl when # uninstall the package. The complication comes from the -r_ecursive flag which is no longer # present in newer package version.
def UNK on_nl r on_op UNK on_lparen UNK on_rparen on_nl return if on_lbracket on_int on_comma on_int on_rbracket on_period UNK r # update the package to the latest version available
return if on_lbracket on_int on_comma on_int on_rbracket on_period UNK r on_lbracket on_symbeg exit on_rbracket on_nl raise on_const on_op on_const on_comma # 4 == /No updates available for this image./
def UNK on_nl r on_op exec_cmd on_lparen command on_lparen on_symbeg pkg on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # list a specific package
