UNK on_tstring_beg on_tstring_content on_tstring_end UNK t on_period types on_period UNK on_nl t on_nl end on_nl on_ignored_nl def type_alias_t on_lparen name # assert this to ensure we did get an empty variant (or tests may pass when not being empty)
on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen t on_comma c on_rparen on_ignored_nl on_const on_period runtime on_lparen t # Cannot be created via factory, the type is private to the type system
context on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl r1 on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content # Deal with cases not covered by computing common type
on_const on_rbracket on_rparen on_period map on_lbrace on_op c on_op c on_op on_const on_rbrace on_nl on_ignored_nl UNK on_op variant_t on_lparen on_const # Avoid comparison with t
on_rbracket on_rparen on_period map on_lbrace on_op c on_op c on_op on_const on_rbrace on_nl on_ignored_nl UNK on_op variant_t on_lparen on_const on_op # DEFAULT resolves to PTypeReferenceType::DEFAULT, i.e. t
UNK on_op variant_t on_lparen on_const on_op on_const on_comma on_const on_op on_const on_rparen on_nl UNK on_op type_alias_t on_lparen on_tstring_beg on_tstring_content on_tstring_end # Add a non-empty variant
UNK on_op type_alias_t on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period resolve on_lparen nil on_rparen on_nl on_ignored_nl UNK # Add a type alias that doesn't resolve to 't'
expect on_lparen v on_rparen on_period to be_assignable_to on_lparen variant_t on_lparen range_t on_lparen on_int on_comma on_int on_rparen on_comma range_t on_lparen on_int # test that both types are assignable to one of the variants OK
expect on_lparen v on_rparen on_period to be_assignable_to on_lparen variant_t on_lparen range_t on_lparen on_int on_comma on_int on_rparen on_comma range_t on_lparen on_int # test where each type is assignable to different types in a variant is OK
expect on_lparen v on_rparen on_period not_to be_assignable_to on_lparen range_t on_lparen on_int on_comma on_int on_rparen on_rparen on_nl expect on_lparen v on_rparen # not acceptable
expect on_lparen calculator on_period assignable? on_lparen UNK on_comma t on_rparen on_rparen on_period to be_truthy on_nl end on_nl end on_nl end # True because String is iterable and an instance of Enum is a String
expect on_lparen calculator on_period instance? on_lparen UNK on_comma UNK on_rparen on_rparen on_period to be_truthy on_nl expect on_lparen calculator on_period instance? # Any callable
expect on_lparen calculator on_period instance? on_lparen callable_t on_lparen on_const on_rparen on_comma UNK on_rparen on_rparen on_period to be_truthy on_nl end on_nl # Callable[String]
expect on_lparen calculator on_period instance? on_lparen UNK on_comma UNK on_rparen on_rparen on_period to eq on_lparen false on_rparen on_nl end on_nl # i.e. Type[Integer] =~ Type[Type[Integer]] # false
