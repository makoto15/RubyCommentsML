UNK on_const on_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_nl UNK on_symbeg UNK on_nl def UNK UNK # The RelationshipOperator implements the semantics of the -> <- ~> <~ operators creating relationships or notification # relationships between the left and right hand side's references to resources. # # This is separate class since a second level of evaluation is required that transforms string in left or right hand # to type references. The task of "making a relationship" is delegated to the "runtime support" class that is included. # This is done to separate the concerns of the new evaluator from the 3x runtime; messy logic goes into the runtime support # module. Later when more is cleaned up this can be simplified further. #
UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_nl UNK on_symbeg UNK on_nl def UNK UNK on_nl on_ivar on_op UNK # Provides access to the Puppet 3.x runtime (scope, etc.) # This separation has been made to make it easier to later migrate the evaluator to an improved runtime. #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl UNK on_const on_period UNK on_lparen o on_rparen on_nl end on_nl on_ignored_nl def # Catch all non transformable objects # @api private
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_lparen o on_period type on_comma o on_period # A Resource is by definition a Catalog type, but of 3.x type # @api private
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl UNK on_lparen on_const on_op on_const on_period UNK on_period UNK on_lparen o on_rparen # A string must be a type reference in string format # @api private
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_lparen o on_period UNK on_rparen on_nl end # A qualified name is short hand for a class with this name # @api private
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl UNK on_lparen o on_comma scope on_rparen on_nl end on_nl on_ignored_nl def UNK # Types are what they are, just check the type # @api private
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl o on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen # This transforms a 3x Collector (the result of evaluating a 3x AST::Collection). # It is passed through verbatim since it is evaluated late by the compiler. At the point # where the relationship is evaluated, it is simply recorded with the compiler for later evaluation. # If one of the sides of the relationship is a Collector it is evaluated before the actual # relationship is formed. (All of this happens at a later point in time. #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl o on_period UNK on_lbrace on_op UNK on_op UNK on_lparen UNK on_comma scope # Array content needs to be transformed
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl UNK on_ivar on_period UNK on_lparen on_ivar on_comma o on_rparen on_nl UNK on_const # Asserts (and returns) the type if it is a PCatalogEntryType # (A PCatalogEntryType is the base class of PClassType, and PResourceType). #
o on_nl end on_nl on_ignored_nl on_const on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma # TODO must check if this is an abstract PResourceType (i.e. without a type_name) - which should fail ? # e.g. File -> File (and other similar constructs) - maybe the catalog protects against this since references # may be to future objects...
def UNK on_lparen UNK on_comma relationship_expression on_comma scope on_rparen on_ignored_nl UNK on_const on_period UNK on_lparen relationship_expression on_period UNK on_rparen on_nl # Evaluate a relationship. # TODO: The error reporting is not fine grained since evaluation has already taken place # There is no references to the original source expressions at this point, only the overall # relationship expression. (e.g.. the expression may be ['string', func_call(), etc.] -> func_call()) # To implement this, the general evaluator needs to be able to track each evaluation result and associate # it with a corresponding expression. This structure should then be passed to the relationship operator. #
UNK on_const on_period UNK on_lparen relationship_expression on_period UNK on_rparen on_nl UNK on_lparen on_const on_op on_const on_comma relationship_expression on_comma on_lbrace on_symbeg # assert operator (should have been validated, but this logic makes assumptions which would # screw things up royally). Better safe than sorry.
real on_op UNK on_period UNK on_lbrace on_op UNK on_op on_lbracket UNK on_rbracket on_period UNK on_period UNK on_lbrace on_op UNK on_op # Turn each side into an array of types (this also asserts their type) # (note wrap in array first if value is not already an array) # # TODO: Later when objects are Puppet Runtime Objects and know their type, it will be more efficient to check/infer # the type first since a chained operation then does not have to visit each element again. This is not meaningful now # since inference needs to visit each object each time, and this is what the transformation does anyway). # # real is [left, right], and both the left and right may be a single value or an array. In each case all content # should be flattened, and then transformed to a type. left or right may also be a value that is transformed # into an array, and thus the resulting left and right must be flattened individually # Once flattened, the operands should be sets (to remove duplicate entries) #
UNK on_comma UNK on_op UNK on_lparen relationship_expression on_rparen on_op real on_period UNK on_op real on_nl on_ignored_nl UNK on_period UNK on_lbrace # reverse order if operator is Right to Left
UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_lbrace on_op UNK on_op UNK on_lparen UNK on_comma UNK on_comma # Add the relationships to the catalog
UNK real on_lbracket on_int on_rbracket on_period UNK on_nl UNK on_op real on_lbracket on_int on_rbracket on_nl UNK on_ignored_nl UNK on_op real # The result is the transformed source RHS unless it is empty, in which case the transformed LHS is returned. # This closes the gap created by an empty set of references in a chain of relationship # such that X -> [ ] -> Y results in X -> Y. #result = real[1].empty? ? real[0] : real[1]
UNK on_op real on_lbracket on_int on_rbracket on_nl UNK on_ignored_nl UNK on_op real on_lbracket on_int on_rbracket on_nl UNK UNK on_period UNK # right side empty, simply use the left (whatever it may be)
UNK on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_lbracket on_int on_rbracket on_rparen on_nl UNK on_period # the collector when evaluated later may result in an empty set, if so, the # lazy relationship forming logic needs to have access to the left value.
