UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl def self on_period assignable? on_lparen t1 on_comma t2 on_rparen # The TypeCalculator can answer questions about puppet types. # # The Puppet type system is primarily based on sub-classing. When asking the type calculator to infer types from Ruby in general, it # may not provide the wanted answer; it does not for instance take module inclusions and extensions into account. In general the type # system should be unsurprising for anyone being exposed to the notion of type. The type `Data` may require a bit more explanation; this # is an abstract type that includes all scalar types, as well as Array with an element type compatible with Data, and Hash with key # compatible with scalar and elements compatible with Data. Expressed differently; Data is what you typically express using JSON (with # the exception that the Puppet type system also includes Pattern (regular expression) as a scalar. # # Inference # --------- # The `infer(o)` method infers a Puppet type for scalar Ruby objects, and for Arrays and Hashes. # The inference result is instance specific for single typed collections # and allows answering questions about its embedded type. It does not however preserve multiple types in # a collection, and can thus not answer questions like `[1,a].infer() =~ Array[Integer, String]` since the inference # computes the common type Scalar when combining Integer and String. # # The `infer_generic(o)` method infers a generic Puppet type for scalar Ruby object, Arrays and Hashes. # This inference result does not contain instance specific information; e.g. Array[Integer] where the integer # range is the generic default. Just `infer` it also combines types into a common type. # # The `infer_set(o)` method works like `infer` but preserves all type information. It does not do any # reduction into common types or ranges. This method of inference is best suited for answering questions # about an object being an instance of a type. It correctly answers: `[1,a].infer_set() =~ Array[Integer, String]` # # The `generalize!(t)` method modifies an instance specific inference result to a generic. The method mutates # the given argument. Basically, this removes string instances from String, and range from Integer and Float. # # Assignability # ------------- # The `assignable?(t1, t2)` method answers if t2 conforms to t1. The type t2 may be an instance, in which case # its type is inferred, or a type. # # Instance? # --------- # The `instance?(t, o)` method answers if the given object (instance) is an instance that is assignable to the given type. # # String # ------ # Creates a string representation of a type. # # Creation of Type instances # -------------------------- # Instance of the classes in the {Types type model} are used to denote a specific type. It is most convenient # to use the {TypeFactory} when creating instances. # # @note # In general, new instances of the wanted type should be created as they are assigned to models using containment, and a # contained object can only be in one container at a time. Also, the type system may include more details in each type # instance, such as if it may be nil, be empty, contain a certain count etc. Or put differently, the puppet types are not # singletons. # # All types support `copy` which should be used when assigning a type where it is unknown if it is bound or not # to a parent type. A check can be made with `t.eContainer().nil?` # # Equality and Hash # ----------------- # Type instances are equal in terms of Ruby eql? and `==` if they describe the same type, but they are not `equal?` if they are not # the same type instance. Two types that describe the same type have identical hash - this makes them usable as hash keys. # # Types and Subclasses # -------------------- # In general, the type calculator should be used to answer questions if a type is a subtype of another (using {#assignable?}, or # {#instance?} if the question is if a given object is an instance of a given type (or is a subtype thereof). # Many of the types also have a Ruby subtype relationship; e.g. PHashType and PArrayType are both subtypes of PCollectionType, and # PIntegerType, PFloatType, PStringType,... are subtypes of PScalarType. Even if it is possible to answer certain questions about # type by looking at the Ruby class of the types this is considered an implementation detail, and such checks should in general # be performed by the type_calculator which implements the type system semantics. # # The PRuntimeType # ------------- # The PRuntimeType corresponds to a type in the runtime system (currently only supported runtime is 'ruby'). The # type has a runtime_type_name that corresponds to a Ruby Class name. # A Runtime[ruby] type can be used to describe any ruby class except for the puppet types that are specialized # (i.e. PRuntimeType should not be used for Integer, String, etc. since there are specialized types for those). # When the type calculator deals with PRuntimeTypes and checks for assignability, it determines the # "common ancestor class" of two classes. # This check is made based on the superclasses of the two classes being compared. In order to perform this, the # classes must be present (i.e. they are resolved from the string form in the PRuntimeType to a # loaded, instantiated Ruby Class). In general this is not a problem, since the question to produce the common # super type for two objects means that the classes must be present or there would have been # no instances present in the first place. If however the classes are not present, the type # calculator will fall back and state that the two types at least have Any in common. # # @see TypeFactory for how to create instances of types # @see TypeParser how to construct a type instance from a String # @see Types for details about the type model # # Using the Type Calculator # ----- # The type calculator can be directly used via its class methods. If doing time critical work and doing many # calls to the type calculator, it is more performant to create an instance and invoke the corresponding # instance methods. Note that inference is an expensive operation, rather than inferring the same thing # several times, it is in general better to infer once and then copy the result if mutation to a more generic form is # required. # # @api public #
def self on_period assignable? on_lparen t1 on_comma t2 on_rparen on_ignored_nl singleton on_period assignable? on_lparen t1 on_comma t2 on_rparen on_nl end # @api public
def self on_period UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl singleton on_period UNK on_lparen UNK on_comma UNK on_rparen on_nl end # Answers, does the given callable accept the arguments given in args (an array or a tuple) # @param callable [PCallableType] - the callable # @param args [PArrayType, PTupleType] args optionally including a lambda callable at the end # @return [Boolean] true if the callable accepts the arguments # # @api public
def self on_period infer on_lparen o on_rparen on_ignored_nl singleton on_period infer on_lparen o on_rparen on_nl end on_nl on_ignored_nl def self # @api public
def self on_period UNK on_lparen o on_rparen on_ignored_nl if on_lparen o on_period is_a? on_lparen on_const on_rparen on_op on_ignored_nl o on_period # Infers a type if given object may have callable members, else returns nil. # Caller must check for nil or if returned type supports members. # This is a much cheaper call than doing a call to the general infer(o) method. # # @api private
if on_lparen o on_period is_a? on_lparen on_const on_rparen on_op on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op on_ignored_nl o on_period # If being a value that cannot have Pcore based methods callable from Puppet Language
infer on_lparen o on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen o on_rparen on_ignored_nl singleton on_period UNK on_lparen # For other objects (e.g. PObjectType instances, and runtime types) full inference needed, since that will # cover looking into the runtime type registry. #
def self on_period UNK on_lparen o on_rparen on_ignored_nl singleton on_period UNK on_lparen o on_rparen on_nl end on_nl on_ignored_nl def self # @api public
def self on_period infer_set on_lparen o on_rparen on_ignored_nl singleton on_period infer_set on_lparen o on_rparen on_nl end on_nl on_ignored_nl def self # @api public
def self on_period UNK on_lparen t on_rparen on_ignored_nl singleton on_period UNK on_lparen t on_rparen on_nl end on_nl on_ignored_nl def UNK # @api public
def UNK on_nl UNK on_op on_const on_period new on_lparen nil on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_int on_comma on_int on_rparen on_nl # @api public #
def assignable? on_lparen t on_comma t2 on_rparen on_ignored_nl if t on_period is_a? on_lparen on_const on_rparen on_nl t on_op type on_lparen # Answers 'can an instance of type t2 be assigned to a variable of type t'. # Does not accept nil/undef unless the type accepts it. # # @api public #
def UNK on_lparen t on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl UNK on_lparen # Returns an iterable if the t represents something that can be iterated
on_const on_period UNK on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl UNK on_lparen t on_rparen on_nl end on_nl on_ignored_nl #TRANSLATOR 'TypeCalculator.enumerable' and 'iterable' are methods and should not be translated
def UNK on_lparen t on_rparen on_ignored_nl on_const on_period UNK on_lparen t on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # Returns an iterable if the t represents something that can be iterated
on_const on_period UNK on_lparen t on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_period # Create an iterable on the type if possible
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_period is_a? on_lparen on_const on_rparen on_op UNK on_period UNK on_lparen UNK # Answers, does the given callable accept the arguments given in args (an array or a tuple) #
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl return UNK UNK UNK on_period is_a? on_lparen on_const on_rparen on_op UNK on_period # Answers if the two given types describe the same type
UNK on_op UNK on_op on_lparen assignable? on_lparen UNK on_comma UNK on_rparen on_op assignable? on_lparen UNK on_comma UNK on_rparen on_rparen on_nl # Types compare per class only - an extra test must be made if the are mutually assignable # to find all types that represent the same type of instance #
def type on_lparen c on_rparen on_ignored_nl UNK on_const on_comma on_tstring_beg on_tstring_content on_tstring_end UNK c on_period is_a? on_const on_nl on_ignored_nl UNK # Answers 'what is the Puppet Type corresponding to the given Ruby class' # @param c [Module] the class for which a puppet type is wanted # @api public #
UNK on_ignored_nl when c on_op on_const on_nl type on_op on_const on_op on_const on_nl when c on_op on_const on_nl type on_op # Can't use a visitor here since we don't have an instance of the class
type on_op on_const on_op on_const on_nl when c on_op on_const on_nl type on_op on_const on_op on_const on_nl else on_ignored_nl type # Assume array of any
type on_op on_const on_op on_const on_nl else on_ignored_nl type on_op on_const on_period new on_lparen on_symbeg UNK on_comma c on_period name # Assume hash of any
def UNK on_lparen o on_rparen on_ignored_nl o on_period is_a? on_lparen on_const on_rparen on_op o on_period UNK on_op o on_nl end # Generalizes value specific types. The generalized type is returned. # @api public
def infer on_lparen o on_rparen on_ignored_nl if o on_period is_a? on_lparen on_const on_rparen on_nl UNK on_lparen o on_rparen on_nl elsif # Answers 'what is the single common Puppet Type describing o', or if o is an Array or Hash, what is the # single common type of the elements (or keys and elements for a Hash). # @api public #
if o on_period is_a? on_lparen on_const on_rparen on_nl UNK on_lparen o on_rparen on_nl elsif o on_period is_a? on_lparen on_const on_rparen # Optimize the most common cases into direct calls. # Explicit if/elsif/else is faster than case
UNK on_lparen o on_rparen on_nl elsif o on_period is_a? on_lparen on_const on_rparen on_nl UNK on_lparen o on_rparen on_nl elsif o # need subclasses for Ruby < 2.4
def infer_set on_lparen o on_rparen on_ignored_nl if o on_period instance_of? on_lparen on_const on_rparen on_nl UNK on_lparen o on_rparen on_nl elsif # Answers 'what is the set of Puppet Types of o' # @api public #
def self on_period instance? on_lparen t on_comma o on_rparen on_ignored_nl singleton on_period instance? on_lparen t on_comma o on_rparen on_nl end # Answers 'is o an instance of type t' # @api public #
def instance? on_lparen t on_comma o on_rparen on_ignored_nl if t on_period is_a? on_lparen on_const on_rparen on_nl t on_op type on_lparen # Answers 'is o an instance of type t' # @api public #
def UNK on_lparen t on_rparen on_ignored_nl t on_period is_a? on_lparen on_const on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen t # Answers if t is a puppet type # @api public #
def UNK on_lparen t on_rparen on_ignored_nl t on_period nil? on_op t on_period is_a? on_lparen on_const on_rparen on_nl end on_nl on_ignored_nl # Answers if t represents the puppet type PUndefType # @api public #
def common_type on_lparen t1 on_comma t2 on_rparen on_ignored_nl UNK on_const on_comma on_tstring_beg on_tstring_content on_tstring_end UNK on_lparen UNK on_lparen t1 on_rparen # Answers, 'What is the common type of t1 and t2?' # # TODO: The current implementation should be optimized for performance # # @api public #
if UNK on_lparen t1 on_rparen on_nl return t2 on_nl elsif UNK on_lparen t2 on_rparen on_nl return t1 on_nl end on_nl # TODO: This is not right since Scalar U Undef is Any # if either is nil, the common type is the other
if t1 on_period is_a? on_lparen on_const on_rparen on_nl return t2 on_nl elsif t2 on_period is_a? on_lparen on_const on_rparen on_nl return # If either side is Unit, it is the other type
if assignable? on_lparen t1 on_comma t2 on_rparen on_nl return t1 on_nl elsif assignable? on_lparen t2 on_comma t1 on_rparen on_nl return # Simple case, one is assignable to the other
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl return on_const on_period new on_lparen # when both are arrays, return an array with common element type
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl UNK on_op common_type on_lparen t1 # when both are hashes, return a hash with common key- and element type
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl return on_const on_op on_const on_nl # when both are host-classes, reduce to PHostClass[] (since one was not assignable to the other)
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl return t1 on_period UNK on_op # when both are resources, reduce to Resource[T] or Resource[] (since one was not assignable to the other)
return t1 on_period UNK on_op t2 on_period UNK on_op on_const on_period new on_lparen t1 on_period UNK on_comma nil on_rparen on_op # only Resource[] unless the type name is the same
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl return on_const on_period new on_lparen # Integers have range, expand the range to the common range
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl return on_const on_period new on_lparen # Floats have range, expand the range to the common range
if t2 on_period is_a? on_lparen on_const on_rparen on_nl return on_const on_period new on_lparen t1 on_period values on_op t2 on_period values # The common type is one that complies with either set
return on_const on_period UNK on_lparen t1 on_period types on_op t2 on_period types on_rparen on_nl end on_nl on_ignored_nl if t1 on_period # The common type is one that complies with either set
return on_const on_op on_const on_nl end on_nl on_ignored_nl if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen # if they were identical, the general rule would return a parameterized regexp # since they were not, the result is a generic regexp type
return on_const on_op on_const on_nl end on_nl on_ignored_nl if UNK on_lparen t1 on_comma t2 on_rparen on_nl return on_const on_op on_const # They do not have the same signature, and one is not assignable to the other, # what remains is the most general form of Callable
if UNK on_lparen t1 on_comma t2 on_rparen on_nl return on_const on_op on_const on_nl end on_nl on_ignored_nl if UNK on_lparen t1 # Common abstract types, from most specific to most general
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl return on_const on_period new on_lparen # Meta types Type[Integer] + Type[String] => Type[Data]
if t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_nl if t1 on_period UNK on_op # If both are Runtime types
UNK on_op on_const on_period UNK on_lparen t1 on_rparen on_nl UNK on_op on_const on_period UNK on_lparen t2 on_rparen on_nl if UNK # finding the common super class requires that names are resolved to class # NOTE: This only supports runtime type of :ruby
t1 on_period is_a? on_lparen on_const on_rparen on_op t2 on_period is_a? on_lparen on_const on_rparen on_op on_const on_op on_const on_op nil on_nl # They better both be Any type, or the wrong thing was asked and nil is returned
def UNK on_lparen c on_rparen on_ignored_nl UNK on_op on_lbracket c on_rbracket on_nl UNK UNK on_op c on_period UNK UNK on_op # Produces the superclasses of the given class, including the class
UNK on_op UNK on_nl c on_op UNK on_nl end on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen #rubocop:disable Lint/AssignmentInCondition
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen nil on_rparen on_lbrace on_op UNK on_comma t on_op common_type on_lparen # Reduces an enumerable of types to a single common type. # @api public #
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen UNK on_period map on_lbrace on_op o on_op infer on_lparen o on_rparen on_rbrace # Reduce an enumerable of objects to a single common type # @api public #
def UNK on_lparen o on_rparen on_ignored_nl on_const on_op new on_lparen on_const on_period new on_lparen on_symbeg UNK on_comma o on_period name # The type of all modules is PTypeType # @api private #
def UNK on_lparen o on_rparen on_ignored_nl o on_period type on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl on_const # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # @api private
def UNK on_lparen o on_rparen on_ignored_nl o on_period UNK on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen # @api private
def UNK on_lparen o on_rparen on_ignored_nl if o on_period is_a? on_lparen on_const on_rparen on_nl o on_period UNK on_nl else on_ignored_nl # @api private
UNK on_op on_const on_period UNK on_nl type on_op UNK on_period nil? on_op nil on_op UNK on_period UNK on_lparen name on_rparen # anonymous class that doesn't implement PuppetObject is impossible to infer
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o # The type of all types is PTypeType # @api private #
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o # The type of all types is PTypeType # This is the metatype short circuit. # @api private #
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl min # @api private
def UNK on_lparen o on_rparen on_ignored_nl min on_op on_int on_nl max on_op on_int on_nl UNK on_op o on_period UNK on_period # @api private # @param o [Proc]
def UNK on_lparen o on_rparen on_ignored_nl UNK on_lparen o on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o # @api private
def UNK on_lparen o on_rparen on_ignored_nl UNK o on_nl when on_symbeg UNK on_nl on_const on_op on_const on_nl when on_symbeg UNK # Inference of :default as PDefaultType, and all other are Ruby[Symbol] # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen infer on_lparen o on_period UNK on_rparen on_rparen on_nl end on_nl # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl on_const # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl on_const # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o # @api private
def UNK on_lparen o on_rparen on_ignored_nl UNK on_op o on_period UNK on_nl UNK on_op on_tstring_beg on_tstring_end if on_symbeg UNK on_op # @api private # A Puppet::Parser::Resource, or Puppet::Resource #
UNK on_op o on_period UNK on_nl UNK on_op on_tstring_beg on_tstring_end if on_symbeg UNK on_op UNK on_nl on_const on_period new on_lparen # Only Puppet::Resource can have a title that is a symbol :undef, a PResource cannot. # A mapping must be made to empty string. A nil value will result in an error later
def UNK on_lparen o on_rparen on_ignored_nl if o on_period instance_of? on_lparen on_const on_rparen on_nl if o on_period UNK on_nl on_const # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl on_const # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl on_const # @api private
def UNK on_lparen o on_rparen on_ignored_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl if # @api private
def UNK on_lparen o on_rparen on_ignored_nl if o on_period instance_of? on_lparen on_const on_rparen on_nl if o on_period UNK on_nl on_const # @api private
def UNK on_lparen o on_rparen on_ignored_nl infer on_lparen o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl # Common case for everything that intrinsically only has a single type
def UNK on_lparen o on_rparen on_ignored_nl on_const on_period new on_lparen on_lbracket on_const on_op on_const on_period new on_lparen o on_comma o # @api private
def UNK on_lparen UNK on_rparen on_ignored_nl return on_lbracket on_int on_comma on_int on_rbracket if UNK on_period nil? on_nl UNK on_op UNK # Transform int range to a size constraint # if range == nil the constraint is 1,1 # if range.from == nil min size = 1 # if range.to == nil max size == Infinity #
def self on_period UNK on_lparen t on_comma UNK on_op UNK on_rparen on_ignored_nl t on_period is_a? on_lparen on_const on_rparen on_op t # @api private
def UNK on_lparen UNK on_comma UNK on_comma to on_comma UNK on_rparen on_ignored_nl UNK on_op on_lparen UNK on_period types on_period size # Produces the tuple entry at the given index given a tuple type, its from/to constraints on the last # type, and an index. # Produces nil if the index is out of bounds # from must be less than to, and from may not be less than 0 # # @api private #
UNK on_period types on_lbracket on_op on_int on_rbracket on_nl else on_ignored_nl nil on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl # in the varargs part
def UNK on_nl on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen t1 on_comma t2 on_rparen # Debugging to_s to reduce the amount of output
