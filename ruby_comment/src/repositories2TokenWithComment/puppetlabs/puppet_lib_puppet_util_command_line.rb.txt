if UNK UNK on_op on_const on_nl UNK on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_const on_nl end on_nl end on_nl # Bundler and rubygems maintain a set of directories from which to # load gems. If Bundler is loaded, let it determine what can be # loaded. If it's not loaded, then use rubygems. But do this before # loading any puppet code, so that our gem loading system is sane.
UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op UNK on_tstring_content UNK on_nl on_ignored_nl def UNK # This is the main entry point for all puppet applications / faces; it # is basically where the bootstrapping process / lifecycle of an app # begins.
def UNK on_lparen UNK on_op UNK on_comma UNK on_op on_const on_comma UNK on_op on_const on_rparen on_ignored_nl on_ivar on_op on_const on_period # @param zero [String] the name of the executable # @param argv [Array<String>] the arguments passed on the command line # @param stdin [IO] (unused)
def subcommand_name on_nl UNK on_ivar if on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl if on_ivar on_period UNK on_op on_const on_nl # @return [String] name of the subcommand is being executed # @api public
def args on_nl UNK on_ivar if on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl if subcommand_name on_period UNK on_nl on_ivar on_nl # @return [Array<String>] the command line arguments being passed to the subcommand # @api public
def UNK on_nl UNK on_op UNK on_nl if on_ivar on_period UNK on_op UNK on_tstring_content UNK on_nl UNK on_op UNK on_nl # Run the puppet subcommand. If the subcommand is determined to be an # external executable, this method will never return and the current # process will be replaced via {Kernel#exec}. # # @return [void]
def UNK on_nl on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content UNK subcommand_name UNK on_tstring_end on_rparen on_nl end on_nl on_ignored_nl # @api private
UNK on_const on_nl def UNK on_lparen subcommand_name on_comma command_line on_rparen on_ignored_nl on_ivar on_op subcommand_name on_nl on_ivar on_op command_line on_nl end # @api private
on_ignored_nl UNK on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end # For most applications, we want to be able to load code from the modulepath, # such as apply, describe, resource, and faces. # For agent and device in agent mode, we only want to load pluginsync'ed code from libdir. # For master, we shouldn't ever be loading per-environment code into the master's # ruby process, but that requires fixing (#17210, #12173, #8750). So for now # we try to restrict to only code that can be autoloaded from the node's # environment.
UNK on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen on_ivar on_op on_tstring_beg on_tstring_content on_tstring_end on_op # PUP-2114 - at this point in the bootstrapping process we do not # have an appropriate application-wide current_environment set. # If we cannot find the configured environment, which may not exist, # we do not attempt to add plugin directories to the load path.
on_const on_period UNK on_nl end on_nl end on_nl on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_rparen on_period # Puppet requires Facter, which initializes its lookup paths. Reset Facter to # pickup the new $LOAD_PATH.
UNK on_const on_nl def UNK on_lparen UNK on_comma command_line on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op command_line on_nl end # @api private
UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl def UNK on_lparen command_line on_rparen on_ignored_nl on_ivar on_op command_line # @api private
UNK UNK on_lparen on_symbeg UNK on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op UNK UNK args on_lbracket on_int on_rbracket UNK # If the subcommand is truly nil and there is an arg, it's an option; print out the invalid option message
UNK on_const on_op on_const on_nl def UNK on_lparen subcommand_name on_comma command_line on_rparen on_ignored_nl on_ivar on_op subcommand_name on_nl UNK on_lparen command_line # @api private
