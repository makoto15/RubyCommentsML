on_ignored_nl on_ignored_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK UNK on_op on_const on_period new on_nl writer on_op on_const on_op on_const # Simulate a compressed response body containing PSON containing UTF-8 # using different UTF-8 widths:
on_ignored_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK UNK on_op on_const on_period new on_nl writer on_op on_const on_op on_const on_period # \u06ff - ۿ - http://www.fileformat.info/info/unicode/char/06ff/index.htm - 0xDB 0xBF / 219 191 # \u16A0 - ᚠ - http://www.fileformat.info/info/unicode/char/16A0/index.htm - 0xE1 0x9A 0xA0 / 225 154 160 # \u{2070E} - 𠜎 - http://www.fileformat.info/info/unicode/char/2070E/index.htm - 0xF0 0xA0 0x9C 0x8E / 240 160 156 142
UNK on_op on_const on_period new on_nl writer on_op on_const on_op on_const on_period new on_lparen UNK on_rparen on_nl writer on_period UNK # unicode expression eqivalent of "foo\xDB\xBF\xE1\x9A\xA0\xF0\xA0\x9C\x8E\" per above
expect on_lparen UNK on_period UNK on_rparen on_period to eq on_lparen on_const on_op on_const on_rparen on_nl expect on_lparen UNK on_rparen on_period # By default Zlib::GzipReader decompresses into Encoding.default_external, and we want to ensure our result is BINARY too
