UNK on_const on_nl on_const on_op UNK UNK UNK on_period UNK on_nl on_const on_op UNK UNK UNK on_period UNK on_nl on_ignored_nl # Utility class to help resolve instances of Puppet::Pops::Types::PDeferredType::Deferred #
def UNK on_period UNK on_lparen UNK on_comma catalog on_rparen on_ignored_nl compiler on_op on_const on_op on_const on_op on_const on_period UNK on_lparen # Resolves and replaces all Deferred values in a catalog's resource attributes # found as direct values or nested inside Array, Hash or Sensitive values. # Deferred values inside of custom Object instances are not resolved as this # is expected to be done by such objects. # # @param facts [Puppet::Node::Facts] the facts object for the node # @param catalog [Puppet::Resource::Catalog] the catalog where all deferred values should be replaced # @return [nil] does not return anything - the catalog is modified as a side effect #
on_ignored_nl UNK on_period UNK on_lparen catalog on_rparen on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_period resolve on_lparen UNK on_comma # TODO: # # When scripting the trusted data are always local, but set them anyway # @scope.set_trusted(node.trusted_data) # # # Server facts are always about the local node's version etc. # @scope.set_server_facts(node.server_facts)
def UNK on_period resolve on_lparen UNK on_comma compiler on_rparen on_ignored_nl UNK on_op UNK on_lparen compiler on_rparen on_nl UNK on_period resolve # Resolves a value such that a direct Deferred, or any nested Deferred values # are resolved and used instead of the deferred value. # A direct Deferred value, or nested deferred values inside of Array, Hash or # Sensitive values are resolved and replaced inside of freshly created # containers. # # The resolution takes place in the topscope of the given compiler. # Variable values are supposed to already have been set. # # @param value [Object] the (possibly nested) value to resolve # @param compiler [Puppet::Parser::ScriptCompiler, Puppet::Parser::Compiler] the compiler in effect # @return [Object] the resolved value (a new Array, Hash, or Sensitive if needed), with all deferred values resolved #
on_ivar on_op on_ivar on_period UNK on_nl on_ivar on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_period UNK on_nl # Always resolve in top scope
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_period UNK on_lparen UNK on_period UNK on_op on_lbrace on_rbrace on_op UNK on_period UNK # @param facts [Puppet::Node::Facts] the facts to set in $facts in the compiler's topscope #
UNK UNK on_period UNK on_lparen on_const on_op on_const on_op on_const on_op on_const on_op on_const on_rparen on_nl UNK on_op UNK on_period # If the value is instance of Sensitive - assign the unwrapped value # and mark it as sensitive if not already marked #
on_const on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen resolve on_lparen x on_period UNK on_rparen on_rparen on_nl # rewrap in a new Sensitive after resolving any nested deferred values
x on_period UNK on_nl UNK on_ignored_nl x on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK # use the ASCII-8BIT string that it wraps
UNK on_op UNK on_period UNK on_nl UNK on_op UNK on_lparen UNK on_period UNK on_rparen on_nl UNK UNK on_lbracket UNK on_rbracket # If any of the arguments to a future is a future it needs to be resolved first
UNK UNK on_lbracket UNK on_rbracket on_op on_const on_nl UNK on_op UNK on_lbracket UNK on_op on_op UNK on_rbracket on_nl UNK on_op # if name starts with $ then this is a call to dig
on_ivar on_period UNK on_lparen UNK on_comma UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lbracket # call the function (name in deferred, or 'dig' for a variable)
