UNK on_const on_nl UNK on_op on_const on_op on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen # The ClassLoader provides a Class instance given a class name or a meta-type. # If the class is not already loaded, it is loaded using the Puppet Autoloader. # This means it can load a class from a gem, or from puppet modules. #
def self on_period UNK on_lparen name on_rparen on_ignored_nl UNK name on_nl when on_const on_nl UNK on_lparen name on_rparen on_nl on_ignored_nl # Returns a Class given a fully qualified class name. # Lookup of class is never relative to the calling namespace. # @param name [String, Array<String>, Array<Symbol>, PAnyType] A fully qualified # class name String (e.g. '::Foo::Bar', 'Foo::Bar'), a PAnyType, or a fully qualified name in Array form where each part # is either a String or a Symbol, e.g. `%w{Puppetx Puppetlabs SomeExtension}`. # @return [Class, nil] the looked up class or nil if no such class is loaded # @raise ArgumentError If the given argument has the wrong type # @api public #
on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl when on_const on_nl on_const on_nl on_ignored_nl when on_const on_nl UNK on_lparen # There is no other thing to load except this Enum meta type
on_const on_nl on_ignored_nl when on_const on_nl UNK on_lparen type on_period UNK on_rparen on_nl on_ignored_nl when on_const on_semicolon on_const on_nl when # TODO: PTypeType should have a type argument (a PAnyType) so the Class' class could be returned # (but this only matters in special circumstances when meta programming has been used).
UNK on_lparen type on_period UNK on_rparen on_nl on_ignored_nl when on_const on_semicolon on_const on_nl when on_const on_semicolon on_const on_nl when on_const # cannot make a distinction between optional and its type
when on_const on_semicolon on_const on_nl when on_const on_semicolon on_const on_nl when on_const on_semicolon on_const on_nl when on_const on_semicolon on_const on_nl # Although not expected to be the first choice for getting a concrete class for these # types, these are of value if the calling logic just has a reference to type. #
name_path on_period UNK UNK name_path UNK UNK UNK on_period UNK on_nl UNK on_lparen name on_comma name_path on_rparen on_nl end on_nl # always from the root, so remove an empty first segment
result on_op UNK on_lparen name_path on_rparen on_nl on_ignored_nl UNK result on_period UNK on_lparen on_const on_rparen on_nl UNK on_op UNK on_nl # If class is already loaded, try this first
UNK on_op UNK on_nl UNK UNK on_lparen name_path on_rparen on_period UNK UNK on_op UNK on_op UNK on_op UNK on_semicolon UNK # Attempt to load it using the auto loader
UNK on_const on_nl UNK UNK on_nl end on_nl end on_nl end on_nl UNK on_symbeg UNK on_nl on_ignored_nl def self on_period # don't search ancestors
UNK UNK on_period UNK UNK on_op UNK on_op UNK on_lparen UNK on_rparen UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # search two entries, one where all parts are decamelized, and one with names just downcased # TODO:this is not perfect - it will not produce the correct mix if a mix of styles are used # The alternative is to test many additional paths. #
