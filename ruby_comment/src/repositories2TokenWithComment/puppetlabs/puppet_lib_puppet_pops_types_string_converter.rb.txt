class on_const on_nl on_ignored_nl class on_const on_op on_const on_nl def UNK on_lparen UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK # Converts Puppet runtime objects to String under the control of a Format. # Use from Puppet Language is via the function `new`. # # @api private #
class on_const on_op on_const on_nl def UNK on_lparen UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg UNK # @api private
class on_const on_nl attr_reader on_symbeg UNK on_nl UNK on_symbeg alt? on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg width on_nl attr_reader on_symbeg # Format represents one format specification that is textually represented by %<flags><width>.<precision><format> # Format parses and makes the individual parts available when an instance is created. # # @api private #
attr_reader on_symbeg UNK on_nl UNK on_symbeg alt? on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg width on_nl attr_reader on_symbeg UNK on_nl attr_reader # Boolean, alternate form (varies in meaning)
attr_reader on_symbeg width on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg format on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl # Nil or Integer with width of field > 0
attr_reader on_symbeg UNK on_nl attr_reader on_symbeg format on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl # Nil or Integer precisions
attr_reader on_symbeg format on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl # One char symbol denoting the format
attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg container_string_formats # Symbol, :space, :plus, :ignore
attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg container_string_formats on_nl on_ignored_nl UNK on_symbeg # Boolean, left adjust in given width or not
attr_reader on_symbeg UNK on_nl attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg container_string_formats on_nl on_ignored_nl UNK on_symbeg separator on_nl on_ignored_nl UNK # Boolean left_pad with zero instead of space
attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg container_string_formats on_nl on_ignored_nl UNK on_symbeg separator on_nl on_ignored_nl UNK on_symbeg separator2 on_nl on_ignored_nl # Delimiters for containers, a "left" char representing the pair <[{(
UNK on_symbeg container_string_formats on_nl on_ignored_nl UNK on_symbeg separator on_nl on_ignored_nl UNK on_symbeg separator2 on_nl on_ignored_nl attr_reader on_symbeg orig_fmt on_nl on_ignored_nl # Map of type to format for elements contained in an object this format applies to
UNK on_symbeg separator on_nl on_ignored_nl UNK on_symbeg separator2 on_nl on_ignored_nl attr_reader on_symbeg orig_fmt on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end # Separator string inserted between elements in a container
UNK on_symbeg separator2 on_nl on_ignored_nl attr_reader on_symbeg orig_fmt on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_const on_period # Separator string inserted between sub elements in a container
def UNK on_lparen UNK on_rparen on_ignored_nl result on_op on_const on_period new on_lparen UNK on_period orig_fmt on_rparen on_nl result on_period separator # Merges one format into this and returns a new `Format`. The `other` format overrides this. # @param [Format] other # @returns [Format] a merged format #
def self on_period UNK on_lparen lower on_comma higher on_rparen on_ignored_nl unless lower on_op higher on_nl return lower on_op higher on_nl # Merges two formats where the `higher` format overrides the `lower`. Produces a new `Format` # @param [Format] lower # @param [Format] higher # @returns [Format] the merged result #
def self on_period UNK on_lparen lower on_comma higher on_rparen on_ignored_nl unless lower on_op higher on_nl return lower on_op higher on_nl # Merges a type => format association and returns a new merged and sorted association. # @param [Format] lower # @param [Format] higher # @returns [Hash] the merged type => format result #
lower on_op lower on_period UNK on_lbrace on_op UNK on_comma _ on_op higher on_period UNK on_period UNK on_lbrace on_op UNK on_op # drop all formats in lower than is more generic in higher. Lower must never # override higher
def self on_period UNK on_lparen format_map on_rparen on_ignored_nl format_map on_op format_map on_period UNK do on_op on_lparen a on_comma _ on_rparen # Sorts format based on generality of types - most specific types before general #
UNK on_op UNK on_lparen a on_rparen on_nl UNK on_op UNK on_lparen b on_rparen on_nl if UNK on_op on_int on_op UNK # arbitrary order if disjunct (based on name of type)
def self on_period UNK on_lparen t on_rparen on_ignored_nl case t on_nl when on_const on_nl on_int on_nl when on_const on_nl on_int # Ranks type on specificity where it matters # lower number means more specific
def UNK on_lparen UNK on_op on_const on_op on_const on_rparen on_ignored_nl on_const on_lbracket on_ivar on_op on_ivar on_rbracket on_op UNK on_nl end # Returns an array with a delimiter pair derived from the format. # If format does not contain a delimiter specification the given default is returned # # @param [Array<String>] the default delimiters # @returns [Array<String>] a tuple with left, right delimiters #
def self on_period UNK on_lparen value on_comma string_formats on_op on_symbeg UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen value on_comma string_formats # @api public
def UNK on_nl on_ivar on_op on_const on_period new on_lparen self on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_int on_comma on_int on_rparen on_nl # @api private #
on_const on_op on_lbrace on_ignored_nl on_const on_op on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period freeze on_comma on_rbrace # format used by default for values in a container # (basically strings are quoted since they may contain a ',')) #
on_rbrace on_period freeze on_nl on_ignored_nl on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_const on_period separator on_op # quoted string (Ruby inspect)
on_const on_op on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period freeze on_comma on_const on_op on_const on_op on_const # call with initialization hash
on_const on_op on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period freeze on_comma on_const on_op on_const on_op on_const # float
on_const on_op on_const on_op on_const on_period freeze on_comma on_ignored_nl on_const on_op on_const on_op on_const on_period freeze on_comma on_ignored_nl on_const on_op # decimal number
on_const on_op on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period freeze on_comma on_rbrace on_period freeze on_nl on_ignored_nl # strict base64 string unquoted
on_rbrace on_period freeze on_nl on_ignored_nl on_const on_op on_lbrace on_ignored_nl on_const on_op on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_const on_op # unquoted string
def UNK on_lparen value on_comma string_formats on_op on_symbeg UNK on_rparen on_ignored_nl UNK on_op on_const on_nl on_ignored_nl UNK on_op on_const on_period # Converts the given value to a String, under the direction of formatting rules per type. # # When converting to string it is possible to use a set of built in conversion rules. # # A format is specified on the form: # # ´´´ # %[Flags][Width][.Precision]Format # ´´´ # # `Width` is the number of characters into which the value should be fitted. This allocated space is # padded if value is shorter. By default it is space padded, and the flag 0 will cause padding with 0 # for numerical formats. # # `Precision` is the number of fractional digits to show for floating point, and the maximum characters # included in a string format. # # Note that all data type supports the formats `s` and `p` with the meaning "default to-string" and # "default-programmatic to-string". # # ### Integer # # | Format | Integer Formats # | ------ | --------------- # | d | Decimal, negative values produces leading '-' # | x X | Hexadecimal in lower or upper case. Uses ..f/..F for negative values unless # is also used # | o | Octal. Uses ..0 for negative values unless # is also used # | b B | Binary with prefix 'b' or 'B'. Uses ..1/..1 for negative values unless # is also used # | c | numeric value representing a Unicode value, result is a one unicode character string, quoted if alternative flag # is used # | s | same as d, or d in quotes if alternative flag # is used # | p | same as d # | eEfgGaA | converts integer to float and formats using the floating point rules # # Defaults to `d` # # ### Float # # | Format | Float formats # | ------ | ------------- # | f | floating point in non exponential notation # | e E | exponential notation with 'e' or 'E' # | g G | conditional exponential with 'e' or 'E' if exponent < -4 or >= the precision # | a A | hexadecimal exponential form, using 'x'/'X' as prefix and 'p'/'P' before exponent # | s | converted to string using format p, then applying string formatting rule, alternate form # quotes result # | p | f format with minimum significant number of fractional digits, prec has no effect # | dxXobBc | converts float to integer and formats using the integer rules # # Defaults to `p` # # ### String # # | Format | String # | ------ | ------ # | s | unquoted string, verbatim output of control chars # | p | programmatic representation - strings are quoted, interior quotes and control chars are escaped # | C | each :: name segment capitalized, quoted if alternative flag # is used # | c | capitalized string, quoted if alternative flag # is used # | d | downcased string, quoted if alternative flag # is used # | u | upcased string, quoted if alternative flag # is used # | t | trims leading and trailing whitespace from the string, quoted if alternative flag # is used # # Defaults to `s` at top level and `p` inside array or hash. # # ### Boolean # # | Format | Boolean Formats # | ---- | ------------------- # | t T | 'true'/'false' or 'True'/'False' , first char if alternate form is used (i.e. 't'/'f' or 'T'/'F'). # | y Y | 'yes'/'no', 'Yes'/'No', 'y'/'n' or 'Y'/'N' if alternative flag # is used # | dxXobB | numeric value 0/1 in accordance with the given format which must be valid integer format # | eEfgGaA | numeric value 0.0/1.0 in accordance with the given float format and flags # | s | 'true' / 'false' # | p | 'true' / 'false' # # ### Regexp # # | Format | Regexp Formats (%/) # | ---- | ------------------ # | s | / / delimiters, alternate flag replaces / delimiters with quotes # | p | / / delimiters # # ### Undef # # | Format | Undef formats # | ------ | ------------- # | s | empty string, or quoted empty string if alternative flag # is used # | p | 'undef', or quoted '"undef"' if alternative flag # is used # | n | 'nil', or 'null' if alternative flag # is used # | dxXobB | 'NaN' # | eEfgGaA | 'NaN' # | v | 'n/a' # | V | 'N/A' # | u | 'undef', or 'undefined' if alternative # flag is used # # ### Default (value) # # | Format | Default formats # | ------ | --------------- # | d D | 'default' or 'Default', alternative form # causes value to be quoted # | s | same as d # | p | same as d # # ### Binary (value) # # | Format | Default formats # | ------ | --------------- # | s | binary as unquoted characters # | p | 'Binary("<base64strict>")' # | b | '<base64>' - base64 string with newlines inserted # | B | '<base64strict>' - base64 strict string (without newlines inserted) # | u | '<base64urlsafe>' - base64 urlsafe string # | t | 'Binary' - outputs the name of the type only # | T | 'BINARY' - output the name of the type in all caps only # # The alternate form flag `#` will quote the binary or base64 text output # The width and precision values are applied to the text part only in `%p` format. # # ### Array & Tuple # # | Format | Array/Tuple Formats # | ------ | ------------- # | a | formats with `[ ]` delimiters and `,`, alternate form `#` indents nested arrays/hashes # | s | same as a # | p | same as a # # See "Flags" `<[({\|` for formatting of delimiters, and "Additional parameters for containers; Array and Hash" for # more information about options. # # The alternate form flag `#` will cause indentation of nested array or hash containers. If width is also set # it is taken as the maximum allowed length of a sequence of elements (not including delimiters). If this max length # is exceeded, each element will be indented. # # ### Hash & Struct # # | Format | Hash/Struct Formats # | ------ | ------------- # | h | formats with `{ }` delimiters, `,` element separator and ` => ` inner element separator unless overridden by flags # | s | same as h # | p | same as h # | a | converts the hash to an array of [k,v] tuples and formats it using array rule(s) # # See "Flags" `<[({\|` for formatting of delimiters, and "Additional parameters for containers; Array and Hash" for # more information about options. # # The alternate form flag `#` will format each hash key/value entry indented on a separate line. # # ### Type # # | Format | Array/Tuple Formats # | ------ | ------------- # | s | The same as p, quoted if alternative flag # is used # | p | Outputs the type in string form as specified by the Puppet Language # # ### Flags # # | Flag | Effect # | ------ | ------ # | (space) | space instead of + for numeric output (- is shown), for containers skips delimiters # | # | alternate format; prefix 0x/0x, 0 (octal) and 0b/0B for binary, Floats force decimal '.'. For g/G keep trailing 0. # | + | show sign +/- depending on value's sign, changes x,X, o,b, B format to not use 2's complement form # | - | left justify the value in the given width # | 0 | pad with 0 instead of space for widths larger than value # | <[({\| | defines an enclosing pair <> [] () {} or \| \| when used with a container type # # # ### Additional parameters for containers; Array and Hash # # For containers (Array and Hash), the format is specified by a hash where the following keys can be set: # * `'format'` - the format specifier for the container itself # * `'separator'` - the separator string to use between elements, should not contain padding space at the end # * `'separator2'` - the separator string to use between association of hash entries key/value # * `'string_formats'´ - a map of type to format for elements contained in the container # # Note that the top level format applies to Array and Hash objects contained/nested in an Array or a Hash. # # Given format mappings are merged with (default) formats and a format specified for a narrower type # wins over a broader. # # @param mode [String, Symbol] :strict or :extended (or :default which is the same as :strict) # @param string_formats [String, Hash] format tring, or a hash mapping type to a format string, and for Array and Hash types map to hash of details #
if on_const on_op on_const on_op on_const on_op on_const on_op on_const on_period assignable? on_lparen UNK on_rparen on_nl string_formats on_op on_lbrace on_const # For Array and Hash, the format is given as a Hash where 'format' key is the format for the collection itself
string_formats on_op on_lbrace on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_op string_formats on_rbrace # add the format given for the exact type
string_formats on_op on_lbrace on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_op string_formats on_rbrace # add the format given for the exact type
string_formats on_op on_lbrace UNK on_op string_formats on_rbrace on_nl end on_nl end on_nl on_ignored_nl case string_formats on_nl when on_symbeg UNK on_nl # add the format given for the exact type
on_ignored_nl when on_const on_nl string_formats on_op UNK on_lparen string_formats on_rparen on_nl UNK on_op on_const on_period UNK on_lparen on_const on_comma string_formats # do nothing, use default formats
string_formats on_op UNK on_lparen string_formats on_rparen on_nl UNK on_op on_const on_period UNK on_lparen on_const on_comma string_formats on_rparen on_nl else on_ignored_nl # Convert and validate user input
UNK on_op on_const on_period UNK on_lparen on_const on_comma string_formats on_rparen on_nl else on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg string_formats # Merge user given with defaults such that user options wins, merge is deep and format specific
on_ignored_nl def _convert on_lparen val_type on_comma value on_comma format_map on_comma indentation on_rparen on_ignored_nl on_ivar on_period UNK on_lparen self on_comma val_type # # A method only used for manual debugging as the default output of the formatting rules is # # very hard to read otherwise. # # # # @api private # def dump_string_formats(f, indent = 1) # return f.to_s unless f.is_a?(Hash) # "{#{f.map {|k,v| "#{k.to_s} => #{dump_string_formats(v,indent+1)}"}.join(",\n#{' '*indent} ")}}" # end
if val on_period is_a? on_lparen on_const on_rparen on_nl UNK on_op val on_period UNK on_nl return UNK on_lparen val_type on_comma UNK # Before giving up on this, and use a string representation of the unknown # object, a check is made to see if the object can present itself as # a hash or an array. If it can, then that representation is used instead.
return UNK on_lparen val_type on_comma UNK on_comma format_map on_comma UNK on_rparen if UNK on_period UNK on_lparen on_const on_rparen on_nl elsif # Ensure that the returned value isn't derived from Hash
return UNK on_lparen val_type on_comma UNK on_comma format_map on_comma UNK on_rparen if UNK on_period UNK on_lparen on_const on_rparen on_nl end # Ensure that the returned value isn't derived from Array
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # Basically string_PAnyType converts the value to a String and then formats it according # to the resulting type # # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma indentation on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
str_bool on_op val on_period to_s on_nl apply_string_flags on_lparen f on_comma f on_period alt? on_op str_bool on_lbracket on_int on_rbracket on_op str_bool # 'true'/'false' or 't'/'f' if in alt mode
str_bool on_op val on_period to_s on_period UNK on_nl apply_string_flags on_lparen f on_comma f on_period alt? on_op str_bool on_lbracket on_int on_rbracket # 'True'/'False' or 'T'/'F' if in alt mode
str_bool on_op val on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_nl apply_string_flags on_lparen f on_comma f on_period alt? on_op # 'yes'/'no' or 'y'/'n' if in alt mode
str_bool on_op val on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_nl apply_string_flags on_lparen f on_comma f on_period alt? on_op # 'Yes'/'No' or 'Y'/'N' if in alt mode
numeric_bool on_op val on_op on_int on_op on_int on_nl string_formats on_op on_lbrace on_const on_op on_const on_op on_const on_op on_const on_op on_const # Boolean in numeric form, formated by integer rule
numeric_bool on_op val on_op UNK on_op UNK on_nl string_formats on_op on_lbrace on_const on_op on_const on_op on_const on_op on_const on_op on_const # Boolean in numeric form, formated by float rule
def apply_string_flags on_lparen f on_comma UNK on_rparen on_ignored_nl if f on_period UNK on_op f on_period width on_op f on_period UNK # Performs post-processing of literals to apply width and precision flags
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
val_to_convert on_op val_to_convert on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl unless val_to_convert on_period UNK on_nl val_to_convert on_op # Assume it is valid UTF-8
unless val_to_convert on_period UNK on_nl val_to_convert on_op val on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # If it isn't
val_to_convert on_op val on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl else on_ignored_nl val_to_convert on_op val # try to convert and fail with details about what is wrong
on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period format on_lparen f on_period orig_fmt on_period tr on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # width & precision applied to string, not the the name of the type
on_const on_period format on_lparen f on_period orig_fmt on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma substitute on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end # Output as the type without any data
on_const on_period format on_lparen f on_period orig_fmt on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma substitute on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end # Output as the type without any data in all caps
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
c_val on_op val on_period UNK on_nl f on_period alt? on_op apply_string_flags on_lparen f on_comma puppet_quote on_lparen c_val on_rparen on_rparen on_op # trim
def puppet_quote on_lparen str on_comma UNK on_op false on_rparen on_ignored_nl if UNK on_nl return UNK on_lparen str on_rparen on_nl end # Performs a '%p' formatting of the given _str_ such that the output conforms to Puppet syntax. An ascii string # without control characters, dollar, single-qoute, or backslash, will be quoted using single quotes. All other # strings will be quoted using double quotes. # # @param [String] str the string that should be formatted # @param [Boolean] enforce_double_quotes if true the result will be double quoted (even if single quotes would be possible) # @return [String] the formatted string # # @api public
bld on_op on_tstring_beg on_tstring_content on_tstring_end on_nl bld on_period UNK on_lparen str on_period UNK on_rparen on_nl UNK on_op false on_nl str # Assume that the string can be single quoted
return UNK on_lparen str on_rparen if codepoint on_op on_int on_nl on_ignored_nl if UNK on_nl bld on_op on_int on_op codepoint on_nl # Control characters and non-ascii characters cannot be present in a single quoted string
bld on_op on_int if UNK on_nl on_ignored_nl bld on_op on_tstring_beg on_tstring_content on_tstring_end on_nl bld on_nl end on_nl on_ignored_nl def UNK # If string ended with a backslash, then that backslash must be escaped
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
indentation on_op indentation on_period UNK on_lparen format on_period alt? on_op indentation on_period is_indenting? on_rparen on_nl on_ignored_nl case format on_period format # Make indentation active, if array is in alternative format, or if nested in indenting
children_indentation on_op indentation on_period UNK on_lparen format on_period alt? on_rparen UNK on_op val on_period UNK do on_op v on_op on_ignored_nl # Make a first pass to format each element
UNK on_op val on_period UNK do on_op v on_op on_ignored_nl if children_indentation on_period first? on_nl children_indentation on_op children_indentation on_period UNK # tell children they are expected to indent
if format on_period alt? on_op format on_period width on_nl UNK on_op val on_period UNK on_period UNK on_lparen on_lbracket on_int on_rbracket # compute widest run in the array, skip nested arrays and hashes # then if size > width, set flag if a break on each element should be performed
if is_a_or_h? on_lparen UNK on_lbracket on_int on_rbracket on_rparen on_nl UNK on_op on_int on_nl else on_ignored_nl UNK on_lbracket on_op on_int on_rbracket # array or hash breaks
children_indentation on_op indentation on_period UNK on_lparen format on_period alt? on_rparen on_nl val on_period UNK do on_op v on_comma UNK on_op # output each element with breaks and padding
if UNK on_op on_op is_a_or_h? on_lparen v on_rparen on_nl buf on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl else on_ignored_nl buf # if breaking, indent first element by one
if on_lparen UNK on_op on_op is_a_or_h? on_lparen v on_rparen on_rparen on_op on_lparen format on_period alt? on_op UNK on_op on_int on_op # if break on each (and breaking will not occur because next is an array or hash) # or, if indenting, and previous was an array or hash, then break and continue on next line # indented.
buf on_period UNK if buf on_lbracket on_op on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_op str_val on_lbracket on_int on_rbracket on_op on_tstring_beg # remove trailing space added by separator if followed by break
def UNK on_lparen val_type on_comma val on_comma format_map on_comma indentation on_rparen on_ignored_nl UNK on_lparen val_type on_comma val on_comma format_map on_comma # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma indentation on_rparen on_ignored_nl v on_op val on_period UNK on_nl _convert on_lparen # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma indentation on_rparen on_ignored_nl format on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
UNK on_op val on_period UNK on_nl _convert on_lparen on_const on_period infer_set on_lparen UNK on_rparen on_comma UNK on_comma format_map on_comma indentation # Convert to array and use array rules
buf on_op val on_period UNK do on_op k on_comma v on_op on_ignored_nl UNK on_op on_const on_period infer_set on_lparen k on_rparen # break after opening delimiter if pretty printing
def UNK on_lparen val_type on_comma val on_comma format_map on_comma indentation on_rparen on_ignored_nl UNK on_lparen val_type on_comma val on_comma format_map on_comma # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma _ on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
def UNK on_lparen val_type on_comma val on_comma format_map on_comma indentation on_rparen on_ignored_nl f on_op get_format on_lparen val_type on_comma format_map on_rparen # @api private
def get_format on_lparen UNK on_comma UNK on_rparen on_ignored_nl fmt on_op UNK on_period UNK on_lbrace on_op k on_comma _ on_op k # Maps the inferred type of o to a formatting rule
