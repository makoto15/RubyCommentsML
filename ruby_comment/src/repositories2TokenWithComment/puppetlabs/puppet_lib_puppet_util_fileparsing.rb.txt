on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl # A mini-language for parsing files. This is only used file the ParsedFile # provider, but it makes more sense to split it out so it's easy to maintain # in one place. # # You can use this module to create simple parser/generator classes. For instance, # the following parser should go most of the way to parsing /etc/passwd: # # class Parser # include Puppet::Util::FileParsing # record_line :user, :fields => %w{name password uid gid gecos home shell}, # :separator => ":" # end # # You would use it like this: # # parser = Parser.new # lines = parser.parse(File.read("/etc/passwd")) # # lines.each do |type, hash| # type will always be :user, since we only have one # p hash # end # # Each line in this case would be a hash, with each field set appropriately. # You could then call 'parser.to_line(hash)' on any of those hashes to generate # the text line again.
def UNK on_lparen fields on_rparen on_ignored_nl on_ivar on_op fields on_period UNK do on_op field on_op on_ignored_nl UNK on_op field on_period # Customize this so we can do a bit of validation.
self on_period absent on_op on_tstring_beg on_tstring_end on_nl self on_period UNK on_op UNK on_tstring_content UNK on_nl self on_period UNK on_op on_tstring_beg # Now set defaults.
if on_ivar on_op on_symbeg UNK on_nl UNK on_lparen on_op block on_rparen on_nl else on_ignored_nl UNK on_lparen on_ivar on_comma on_op block # Allow the developer to specify that a block should be instance-eval'ed.
def UNK on_lparen details on_rparen on_ignored_nl UNK on_op self on_period UNK on_nl on_ignored_nl fields on_period UNK on_lbrace on_op field on_op # Convert a record into a line by joining the fields together appropriately. # This is pulled into a separate method so it can be called by the hooks.
if details on_lbracket field on_rbracket on_op on_symbeg absent UNK details on_lbracket field on_rbracket on_op on_lbracket on_symbeg absent on_rbracket UNK details # If the field is marked absent, use the appropriate replacement
def UNK on_lparen optional on_rparen on_ignored_nl on_ivar on_op optional on_period UNK do on_op field on_op on_ignored_nl field on_period intern on_nl # Customize this so we can do a bit of validation.
def UNK on_lparen block on_rparen on_ignored_nl UNK on_lparen on_symbeg post_parse on_comma on_op block on_rparen on_nl end on_nl on_ignored_nl def UNK # Create a hook that modifies the hash resulting from parsing.
def UNK on_lparen block on_rparen on_ignored_nl UNK on_lparen on_symbeg pre_gen on_comma on_op block on_rparen on_nl end on_nl on_ignored_nl def UNK # Create a hook that modifies the hash just prior to generation.
def UNK on_nl type on_op on_symbeg text on_nl end on_nl on_ignored_nl def UNK on_lparen block on_rparen on_ignored_nl UNK on_lparen on_symbeg # Are we a text type?
def UNK on_nl on_ivar on_period UNK on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl def fields on_lparen type on_rparen on_ignored_nl # Clear all existing record definitions. Only used for testing.
def UNK on_lparen line on_comma record on_rparen on_ignored_nl line on_op record on_period match on_op on_lbrace on_symbeg record_type on_op record on_period # Try to match a specific text line.
def UNK on_lparen line on_comma record on_rparen on_ignored_nl ret on_op nil on_nl if record on_period UNK on_lparen on_symbeg UNK on_rparen # Try to match a record. # # @param [String] line The line to be parsed # @param [Puppet::Util::FileType] record The filetype to use for parsing # # @return [Hash<Symbol, Object>] The parsed elements of the line
match on_op regex on_period match on_lparen line on_rparen on_nl if match on_nl ret on_op on_lbrace on_rbrace on_nl record on_period fields # In this case, we try to match the whole line and then use the # match captures to get our fields.
if UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op UNK on_tstring_content UNK on_nl end on_nl UNK on_op line on_period UNK # String "helpfully" replaces ' ' with /\s+/ in splitting, so we # have to work around it.
def UNK on_lparen text on_rparen on_ignored_nl text on_period UNK on_lparen self on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Split text into separate lines using the record separator.
text on_period UNK on_lparen self on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen text on_rparen on_ignored_nl UNK on_op # NOTE: We do not have to remove trailing separators because split will ignore # them by default (unless you pass -1 as a second parameter)
def UNK on_lparen text on_rparen on_ignored_nl UNK on_op UNK on_nl UNK on_lparen text on_rparen on_period UNK do on_op line on_op # Split a bunch of text into lines and then parse them individually.
def UNK on_lparen line on_rparen on_ignored_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless UNK on_nl # Handle parsing a single line.
UNK on_op on_tstring_beg on_tstring_content UNK record on_period type UNK on_tstring_content on_tstring_end on_nl if UNK on_lparen UNK on_rparen on_nl UNK on_op # These are basically either text or record lines.
def UNK on_lparen name on_comma options on_comma on_op block on_rparen on_ignored_nl raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Define a new type of record. These lines get split into hashes. Valid # options are: # * <tt>:absent</tt>: What to use as value within a line, when a field is # absent. Note that in the record object, the literal :absent symbol is # used, and not this value. Defaults to "". # * <tt>:fields</tt>: The list of fields, as an array. By default, all # fields are considered required. # * <tt>:joiner</tt>: How to join fields together. Defaults to '\t'. # * <tt>:optional</tt>: Which fields are optional. If these are missing, # you'll just get the 'absent' value instead of an ArgumentError. # * <tt>:rts</tt>: Whether to remove trailing whitespace. Defaults to false. # If true, whitespace will be removed; if a regex, then whatever matches # the regex will be removed. # * <tt>:separator</tt>: The record separator. Defaults to /\s+/.
def UNK on_nl UNK on_lparen on_ivar on_rparen UNK on_op on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen name # Are there any record types defined?
def UNK on_lparen name on_comma options on_comma on_op block on_rparen on_ignored_nl raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Define a new type of text record.
def UNK on_lparen UNK on_rparen on_ignored_nl text on_op UNK on_period UNK on_lbrace on_op record on_op to_line on_lparen record on_rparen on_rbrace # Generate a file from a bunch of hash records.
def to_line on_lparen details on_rparen on_ignored_nl record on_op record_type on_lparen details on_lbracket on_symbeg record_type on_rbracket on_rparen on_nl unless record on_nl # Convert our parsed record into a text record.
if regex on_op UNK on_nl regex on_op UNK on_tstring_content UNK on_nl end on_nl return line on_period UNK on_lparen regex on_comma # If they say true, then use whitespace; else, use their regex.
def UNK on_nl if UNK on_lparen on_ivar on_rparen on_nl return on_ivar on_nl else on_ignored_nl return UNK on_nl end on_nl end # Whether to add a trailing separator to the file. Defaults to true
def UNK on_lparen record on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ignored_nl raise on_const on_comma # Define a new type of record.
def record_type on_lparen type on_rparen on_ignored_nl on_ivar on_lbracket type on_period intern on_rbracket on_nl end on_nl end on_nl on_ignored_nl EMP EMP # Retrieve the record object.
