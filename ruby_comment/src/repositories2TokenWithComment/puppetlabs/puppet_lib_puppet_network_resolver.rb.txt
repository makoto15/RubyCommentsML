on_ivar on_op UNK UNK on_nl end on_nl on_ignored_nl def UNK on_lparen domain on_comma service_name on_op on_symbeg UNK on_comma on_op UNK # Stores DNS records per service, along with their TTL # and the time at which they were resolved, for cache # eviction.
def UNK on_lparen domain on_comma service_name on_op on_symbeg UNK on_comma on_op UNK on_rparen on_ignored_nl if on_lparen domain on_period UNK UNK # Iterate through the list of records for this service # and yield each server and port pair. Records are only fetched # via DNS query the first time and cached for the duration of their # service's TTL thereafter. # @param [String] domain the domain to search for # @param [Symbol] service_name the key of the service we are querying # @yields [String, Integer] server and port of selected record
UNK on_lparen domain on_comma on_symbeg UNK on_comma on_op UNK on_rparen on_nl UNK on_ignored_nl UNK on_lparen records on_rparen UNK on_op UNK # Try the generic :puppet service if no SRV records were found # for the specific service.
on_const on_period UNK on_tstring_beg on_tstring_content on_embexpr_beg UNK on_period UNK on_embexpr_end on_tstring_content on_embexpr_beg UNK on_period UNK on_embexpr_end on_tstring_end on_nl UNK UNK #rubocop:disable Lint/AssignmentInCondition
def UNK on_lparen records on_rparen on_ignored_nl return UNK if records on_period UNK on_op records on_period UNK on_nl return records on_period # Given a list of records of the same priority, chooses a random one # from among them, favoring those with higher weights. # @param [[Resolv::DNS::Resource::IN::SRV]] records a list of records # of the same priority # @return [Resolv::DNS::Resource::IN:SRV] the chosen record
UNK on_op records on_period UNK on_lparen on_int on_rparen UNK on_op UNK on_comma record on_op on_ignored_nl UNK on_op UNK on_lparen record # Calculate the sum of all weights in the list of resource records, # This is used to then select hosts until the weight exceeds what # random number we selected. For example, if we have weights of 1 8 and 3: # # |-|--------|---| # ^ # We generate a random number 5, and iterate through the records, adding # the current record's weight to the accumulator until the weight of the # current record plus previous records is greater than the random number.
def ttl on_lparen service_name on_rparen on_ignored_nl return on_ivar on_lbracket service_name on_rbracket on_period ttl on_nl end on_nl on_ignored_nl def UNK on_lparen # Returns TTL for the cached records for this service. # @param [String] service_name the service whose TTL we want # @return [Integer] the TTL for this service, in seconds
def UNK on_lparen service_name on_rparen on_ignored_nl UNK on_op on_ivar on_lbracket service_name on_rbracket on_nl if UNK on_nl return on_const on_period UNK # Checks if the cached entry for the given service has expired. # @param [String] service_name the name of the service to check # @return [Boolean] true if the entry has expired, false otherwise. # Always returns true if the record had no TTL.
def UNK on_lparen records on_rparen on_ignored_nl UNK on_op records on_period UNK on_lparen UNK UNK on_rparen UNK on_op UNK on_comma UNK # Groups the records by their priority and yields the groups # in order of highest to lowest priority (lowest to highest numbers), # one at a time. # { 1 => [records], 2 => [records], etc. } # # @param [[Resolv::DNS::Resource::IN::SRV]] records the list of # records for a given service # @yields [[Resolv::DNS::Resource::IN::SRV]] a group of records of # the same priority
