UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl def UNK on_nl on_ivar # This module defines methods dealing with Type management. # This module gets included into the Puppet::Type class, it's just split out here for clarity. # @api public #
def UNK on_nl on_ivar on_period UNK on_lbrace on_op name on_comma UNK on_op on_ignored_nl UNK on_period UNK on_nl on_rbrace on_nl end # An implementation specific method that removes all type instances during testing. # @note Only use this method for testing purposes. # @api private #
def UNK on_nl UNK on_ivar on_period UNK on_nl on_ivar on_period UNK on_lbrace on_op UNK on_comma UNK on_op UNK on_period UNK # Clears any types that were used but absent when types were last loaded. # @note Used after each catalog compile when always_retry_plugins is false # @api private #
def UNK on_nl on_ivar on_period UNK UNK on_op name on_comma UNK on_op on_ignored_nl UNK UNK on_nl end on_nl end on_nl # Iterates over all already loaded Type subclasses. # @yield [t] a block receiving each type # @yieldparam t [Puppet::Type] each defined type # @yieldreturn [Object] the last returned object is also returned from this method # @return [Object] the last returned value from the block.
UNK UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_period UNK on_lparen on_const on_period UNK on_lparen on_symbeg # Only consider types that have names #if ! type.parameters.empty? or ! type.validproperties.empty?
end on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_period UNK on_lparen on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_rparen #end
def UNK on_nl UNK on_period UNK on_lparen on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_rparen on_nl end on_nl on_ignored_nl def # Loads all types. # @note Should only be used for purposes such as generating documentation as this is potentially a very # expensive operation. # @return [void] #
def UNK on_lparen name on_comma UNK on_op on_lbrace on_rbrace on_comma on_op UNK on_rparen on_ignored_nl on_ivar on_period UNK UNK on_ignored_nl UNK # Defines a new type or redefines an existing type with the given name. # A convenience method on the form `new<name>` where name is the name of the type is also created. # (If this generated method happens to clash with an existing method, a warning is issued and the original # method is kept). # # @param name [String] the name of the type to create or redefine. # @param options [Hash] options passed on to {Puppet::Util::ClassGen#genclass} as the option `:attributes`. # @option options [Puppet::Type] # Puppet::Type. This option is not passed on as an attribute to genclass. # @yield [ ] a block evaluated in the context of the created class, thus allowing further detailing of # that class. # @return [Class<inherits Puppet::Type>] the created subclass # @see Puppet::Util::ClassGen.genclass # # @dsl type # @api public
UNK UNK on_period UNK on_lparen on_const on_rparen on_nl on_const on_period UNK on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl # Handle backward compatibility
on_const on_period UNK on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl on_lbrace UNK name on_comma UNK UNK on_period UNK #TRANSLATORS 'Puppet::Type.newtype' should not be translated
name on_op name on_period UNK on_nl UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end on_nl on_ignored_nl UNK on_op UNK on_nl # First make sure we don't have a method sitting around
UNK on_op UNK on_nl on_ignored_nl if on_ivar on_period UNK on_lparen name on_rparen on_nl if UNK on_period UNK on_lparen UNK on_rparen # Used for method manipulation.
UNK on_period UNK on_lparen on_symbeg UNK on_comma UNK on_rparen on_nl end on_nl end on_nl on_ignored_nl on_ignored_nl klass on_op UNK on_lparen # Remove the old newmethod
on_ignored_nl klass on_op UNK on_lparen on_ignored_nl name on_comma on_ignored_nl on_symbeg UNK on_op on_const on_op on_const on_comma on_ignored_nl on_symbeg UNK on_op # Then create the class.
if UNK on_period UNK UNK on_nl on_const on_period UNK on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace UNK name # Now define a "new<type>" method for convenience.
on_const on_period UNK on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace UNK name on_period UNK on_rbrace on_rparen on_nl UNK # Refuse to overwrite existing methods like 'newparam' or 'newtype'. #TRANSLATORS 'new%{method}' will become a method name, do not translate this string
klass on_period UNK if klass on_period UNK UNK on_op klass on_period UNK on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl on_ignored_nl klass # If they've got all the necessary methods defined and they haven't # already added the property, then do so now.
on_ignored_nl klass on_period UNK on_op on_const on_op on_const on_op on_const on_period UNK on_lparen klass on_comma on_tstring_beg on_tstring_content on_embexpr_beg klass on_period # Now set up autoload any providers that might exist for this type.
klass on_period UNK on_period UNK on_lparen on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_rparen on_nl klass on_period UNK UNK klass # We have to load everything so that we can figure out the default provider.
def UNK on_lparen name on_rparen on_ignored_nl on_ignored_nl UNK on_lparen name on_comma on_symbeg UNK on_op on_ivar on_rparen on_nl on_ignored_nl UNK on_period # Removes an existing type. # @note Only use this for testing. # @api private
on_ignored_nl UNK on_lparen name on_comma on_symbeg UNK on_op on_ivar on_rparen on_nl on_ignored_nl UNK on_period UNK on_lparen on_symbeg UNK on_comma on_tstring_beg # Then create the class.
def UNK on_lparen name on_rparen on_ignored_nl on_ivar on_period UNK UNK on_ignored_nl if name on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content # Returns a Type instance by name. # This will load the type if not already defined. # @param [String, Symbol] name of the wanted Type # @return [Puppet::Type, nil] the type or nil if the type was not defined and could not be loaded #
if name on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK UNK on_nl end on_nl on_ignored_nl UNK on_ivar # Avoid loading if name obviously is not a type name
UNK on_ivar on_lbracket name on_rbracket if on_ivar on_period UNK name on_nl on_ignored_nl if name on_period UNK on_const on_nl name on_op # We are overwhelmingly symbols here, which usually match, so it is worth # having this special-case to return quickly. Like, 25K symbols vs. 300 # strings in this method. --daniel 2012-07-17
if name on_period UNK on_const on_nl name on_op name on_period UNK on_period UNK on_nl UNK on_ivar on_lbracket name on_rbracket if # Try mangling the name, if it is a string.
if UNK on_period UNK on_lparen name on_comma on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_rparen on_nl on_const on_period UNK on_lparen # Try loading the type.
on_const on_period UNK on_lparen UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace UNK name on_rbrace on_rparen UNK on_ivar on_period UNK #TRANSLATORS 'puppet/type/%{name}' should not be translated
on_ivar on_lbracket name on_rbracket on_op UNK on_nl end on_nl on_ignored_nl UNK on_ivar on_lbracket name on_rbracket on_nl end on_nl end on_nl # PUP-5482 - Only look for a type once if plugin retry is disabled
UNK on_ivar on_lbracket name on_rbracket on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK on_lparen on_ivar on_rparen on_nl # ...and I guess that is that, eh.
def UNK on_nl UNK UNK on_lparen on_ivar on_rparen on_nl on_ivar on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK # Creates a loader for Puppet types. # Defaults to an instance of {Puppet::Util::Autoload} if no other auto loader has been set. # @return [Puppet::Util::Autoload] the loader to use. # @api private
