UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK # Maintain a graph of scopes, along with a bunch of data # about the individual catalog we're compiling.
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg on_ivar on_comma on_symbeg on_op on_comma on_symbeg UNK on_nl # Access to the configured loaders for 4x # @return [Puppet::Pops::Loader::Loaders] the configured loaders # @api private
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg on_ivar on_comma on_symbeg on_op on_comma on_symbeg UNK on_nl UNK on_symbeg on_ivar on_comma on_symbeg # The id of code input to the compiler. # @api private
UNK on_symbeg on_ivar on_comma on_symbeg on_op on_comma on_symbeg UNK on_nl UNK on_symbeg on_ivar on_comma on_symbeg on_op on_comma on_symbeg UNK on_nl # Add a collection to the global list.
def UNK on_lparen override on_rparen on_ignored_nl resource on_op on_ivar on_period resource on_lparen override on_period ref on_rparen on_nl if resource on_nl # Store a resource override.
resource on_op on_ivar on_period resource on_lparen override on_period ref on_rparen on_nl if resource on_nl resource on_period UNK on_lparen override on_rparen # If possible, merge the override in immediately.
on_ivar on_lbracket override on_period ref on_rbracket on_op override on_nl end on_nl end on_nl on_ignored_nl def add_resource on_lparen scope on_comma resource # Otherwise, store the override for later; these # get evaluated in Resource#finish.
on_const on_period UNK on_tstring_beg on_tstring_content UNK resource UNK on_tstring_end on_nl return unless on_ivar on_period UNK do on_op comp on_op on_ignored_nl # We are in the process of pulling application components out that # apply to this node
on_ivar on_period add_resource on_lparen resource on_rparen on_nl on_ignored_nl if UNK resource on_period UNK UNK resource on_lbracket on_symbeg UNK on_rbracket on_nl # Note that this will fail if the resource is not unique.
raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label resource on_rbrace on_nl end on_nl on_ignored_nl return if #TRANSLATORS "stage" is a keyword in Puppet and should not be translated
return if resource on_period UNK on_nl on_ignored_nl unless resource on_period UNK on_nl on_ivar on_period UNK on_lparen scope on_period resource on_comma # Stages should not be inside of classes. They are always a # top-level container, regardless of where they appear in the # manifest.
unless resource on_period UNK on_nl on_ivar on_period UNK on_lparen scope on_period resource on_comma resource on_rparen on_nl end on_nl end on_nl # This adds a resource to the class it lexically appears in in the # manifest.
return if scope on_period resource on_period type on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op on_ivar on_period UNK on_lparen scope on_period # directly contained in a Site
UNK on_op on_ivar on_period UNK on_lparen scope on_period resource on_rparen on_nl if UNK on_nl return if UNK on_period UNK on_period # contained in something that may be contained in Site
raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label resource on_rbrace on_nl end on_nl end on_nl on_ignored_nl #TRANSLATORS "Site" is a puppet keyword and should not be translated
def UNK on_lparen name on_rparen on_ignored_nl on_ivar on_period UNK on_lparen name on_rparen unless name on_op on_tstring_beg on_tstring_end on_nl end on_nl # Store the fact that we've evaluated a class
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl nil on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lparen # Add a catalog validator that will run at some stage to this compiler # @param catalog_validators [Class<CatalogValidator>] The catalog validator class to add
UNK on_symbeg on_ivar on_comma on_symbeg classes on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_op on_tstring_beg on_tstring_end on_comma on_op # Return a list of all of the defined classes.
def UNK on_nl on_const on_period override on_lparen on_ivar on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label node on_period # Compiler our catalog. This mostly revolves around finding and evaluating classes. # This is the main entry into our catalog.
on_const on_op on_const on_op on_const on_period profile on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_comma on_lbracket on_symbeg compiler on_comma on_symbeg # Set the client's parameters into the top scope.
on_const on_op on_const on_op on_const on_period profile on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_comma on_lbracket on_symbeg compiler on_comma on_symbeg #TRANSLATORS "main" is a function name and should not be translated
on_const on_op on_const on_op on_const on_period profile on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_comma on_lbracket on_symbeg compiler on_comma on_symbeg # New capability mappings may have been defined when the site was evaluated
def UNK on_lparen on_rparen on_ignored_nl on_lbrace on_ignored_nl on_symbeg UNK on_op environment on_comma on_ignored_nl on_symbeg UNK on_op on_ivar on_comma on_symbeg UNK # Constructs the overrides for the context
on_symbeg UNK on_op on_ivar on_comma on_rbrace on_nl end on_nl on_ignored_nl UNK on_symbeg on_ivar on_comma on_symbeg UNK on_comma on_symbeg UNK on_nl # 4x placeholder for new global scope
on_rbrace on_nl end on_nl on_ignored_nl UNK on_symbeg on_ivar on_comma on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def environment on_nl node # 4x loaders
def environment on_nl node on_period environment on_nl end on_nl on_ignored_nl def UNK on_nl if on_ivar on_period classes on_period is_a? on_const # Return the node's environment.
def UNK on_nl if on_ivar on_period classes on_period is_a? on_const on_nl UNK on_comma UNK on_op on_ivar on_period classes on_period UNK # Evaluate all of the classes specified by the node. # Classes with parameters are evaluated as if they were declared. # Classes without parameters or with an empty set of parameters are evaluated # as if they were included. This means classes with an empty set of # parameters won't conflict even if the class has already been included.
UNK on_op on_const on_lbracket UNK on_rbracket on_nl UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl else on_ignored_nl UNK on_op # The results from Hash#partition are arrays of pairs rather than hashes, # so we have to convert to the forms evaluate_classes expects (Hash, and # Array of class names)
def UNK on_nl UNK on_op environment on_period known_resource_types on_period UNK on_lparen on_rparen on_nl unless UNK on_nl UNK on_lparen on_rparen on_nl # Evaluates the site - the top container for an environment catalog # The site contain behaves analogous to a node - for the environment catalog, node expressions are ignored # as the result is cross node. The site expression serves as a container for everything that is across # all nodes. # # @api private #
UNK on_op environment on_period known_resource_types on_period UNK on_lparen on_rparen on_nl unless UNK on_nl UNK on_lparen on_rparen on_nl return on_nl end # Has a site been defined? If not, do nothing but issue a warning. #
resource on_op UNK on_period UNK on_lparen topscope on_rparen on_nl on_ignored_nl on_ivar on_op topscope on_period class_scope on_lparen UNK on_rparen on_nl on_ignored_nl # Create a resource to model this site and add it to catalog
on_ivar on_op topscope on_period class_scope on_lparen UNK on_rparen on_nl on_ignored_nl resource on_period evaluate on_nl end on_nl on_ignored_nl def UNK on_nl # The site sets node scope to be able to shadow what is in top scope
resource on_period evaluate on_nl end on_nl on_ignored_nl def UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl # Evaluates the logic contain in the site expression
def UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_ivar # @api private
end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_ivar on_period resource on_lparen # do nothing
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_ivar on_period resource on_lparen on_tstring_beg on_tstring_content on_tstring_end # Prunes the catalog by dropping all resources are contained under the Site (if a site expression is used). # As a consequence all edges to/from dropped resources are also dropped. # Once the pruning is performed, this compiler returns the pruned list when calling the #resources method. # The pruning does not alter the order of resources in the resources list. # # @api private
UNK on_op on_ivar on_period resource on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl if UNK on_nl to_be_removed # Everything under Site[site] should be pruned as that is for the environment catalog, not a node #
to_be_removed on_op on_ivar on_period UNK on_lparen UNK on_rparen on_period UNK on_nl on_ignored_nl if to_be_removed on_period empty? on_nl to_be_removed on_op UNK # Get downstream vertexes returns a hash where the keys are the resources and values nesting level
if to_be_removed on_period empty? on_nl to_be_removed on_op UNK on_nl end on_nl else on_ignored_nl to_be_removed on_op on_lbracket on_rbracket on_nl end on_nl # Drop the Site[site] resource if it has no content
UNK on_op on_ivar on_period UNK on_lbrace on_op UNK on_op UNK on_period type on_op on_tstring_beg on_tstring_content on_tstring_end on_rbrace on_nl UNK on_op # keep_from_site is populated with any App resources.
UNK on_op UNK on_nl UNK on_op UNK on_period UNK on_lbrace on_op app on_op on_ivar on_period UNK on_lparen app on_rparen on_rbrace # keep all applications plus what is directly referenced from applications
on_ivar on_op on_ivar on_period resources on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period each do on_op app on_op on_ignored_nl # set the pruned result
def UNK on_nl on_ivar on_period each do on_op app on_op on_ignored_nl UNK on_op on_lbracket on_rbracket on_nl UNK on_op app on_period # @api private
on_ivar on_period add_resource on_lparen on_ivar on_rparen on_nl on_ivar on_period evaluate on_nl end on_nl UNK on_ignored_nl on_ivar on_op nil on_nl on_ivar # Add the app itself since components mapped to the current node # will have a containment edge for it # @todo lutter 2015-01-28: the node mapping winds up in the # catalog, but probably shouldn't
def UNK on_nl krt on_op environment on_period known_resource_types on_nl return unless krt on_period UNK on_ignored_nl astnode on_op nil on_nl on_ivar # If ast nodes are enabled, then see if we can find and evaluate one. # # @api private
on_ignored_nl astnode on_op nil on_nl on_ivar on_period UNK on_period each do on_op name on_op on_ignored_nl astnode on_op krt on_period node #ast_nodes?
astnode on_op nil on_nl on_ivar on_period UNK on_period each do on_op name on_op on_ignored_nl astnode on_op krt on_period node on_lparen # Now see if we can find the node.
resource on_op astnode on_period UNK on_lparen topscope on_rparen on_nl on_ignored_nl resource on_period evaluate on_nl on_ignored_nl on_ivar on_op topscope on_period class_scope # Create a resource to model this node, and then add it to the list # of resources.
def UNK on_lparen classes on_comma scope on_comma UNK on_op UNK on_rparen on_ignored_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg # Evaluates each specified class in turn. If there are any classes that # can't be found, an error is raised. This method really just creates resource objects # that point back to the classes, and then the resources are themselves # evaluated later in the process. #
if classes on_period UNK on_op on_const on_nl UNK on_op classes on_nl classes on_op classes on_period UNK on_nl end on_nl on_ignored_nl # if we are a param class, save the classes hash # and transform classes to be the keys
UNK on_symbeg on_ivar on_comma on_symbeg resource on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen node on_comma on_label nil on_rparen on_ignored_nl # Return a resource by either its ref or its type and title.
on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op UNK on_nl UNK on_nl UNK # Array of resources representing all application instances we've found
on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op UNK on_nl UNK on_nl UNK on_nl on_ivar on_op on_lbrace on_rbrace # We use @current_app and @current_components to signal to the # evaluator that we are in the middle of evaluating an # application. They are set in evaluate_applications to the application # instance, resp. to an array of the components of that application # that is mapped to the current node. They are only non-nil when we are # in the middle of executing evaluate_applications
on_ivar on_op on_lbrace on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK # Resolutions of fully qualified variable names
def UNK on_lparen UNK on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op topscope on_nl scope on_op on_const on_op on_const # Create a new scope, with either a specified parent scope or # using the top scope.
def UNK on_lparen resource on_rparen on_ignored_nl on_ivar on_lbracket resource on_period ref on_rbracket on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def # Return any overrides for the given resource.
if UNK on_period is_a? on_lparen on_const on_op on_const on_op on_const on_op on_const on_rparen on_nl UNK on_op UNK on_period UNK on_nl # That component_ref is either a QREF or a Class['literal'|QREF] is asserted during validation so no # need to check that here
end on_nl on_ignored_nl def UNK on_nl return UNK if on_ivar on_period empty? on_nl on_ignored_nl UNK do on_ignored_nl on_const on_op on_const # No longer needed
def UNK on_nl return UNK if on_ivar on_period empty? on_nl on_ignored_nl UNK do on_ignored_nl on_const on_op on_const on_op on_const on_period # Evaluate our collections and return true if anything returned an object. # The 'true' is used to continue a loop, so it's important.
on_const on_op on_const on_op on_const on_period profile on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_comma on_lbracket on_symbeg compiler on_comma on_symbeg # We have to iterate over a dup of the array because # collections can delete themselves from the list, which # changes its length and causes some collections to get missed.
def UNK on_nl UNK do on_ignored_nl on_const on_op on_const on_op on_const on_period profile on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Make sure all of our resources have been evaluated into native resources. # We return true if any resources have, so that we know to continue the # evaluate_generators loop.
UNK on_lparen on_const on_op on_const on_op on_const on_op on_const on_comma detail on_comma on_lbrace on_symbeg detail on_op detail on_period UNK on_rbrace # needs to be handled specifically as the error has the file/line/position where this # occurred rather than the resource
UNK on_lparen on_const on_op on_const on_op on_const on_op on_const on_comma resource on_comma on_lbrace on_symbeg detail on_op e on_period UNK on_rbrace # PuppetError has the ability to wrap an exception, if so, use the wrapped exception's # call stack instead
def UNK on_nl UNK on_op on_int on_nl UNK do on_ignored_nl UNK on_op UNK on_nl on_ignored_nl on_const on_op on_const on_op on_const # Iterate over collections and resources until we're sure that the whole # compile is evaluated. This is necessary because both collections # and defined resources can generate new resources, which themselves could # be defined resources.
UNK on_op UNK if UNK on_nl UNK on_op UNK if UNK on_nl end on_nl on_ignored_nl UNK if UNK on_nl on_ignored_nl # Call collections first, then definitions.
def UNK on_nl krt on_op environment on_period known_resource_types on_nl on_ivar on_op krt on_period UNK on_lparen on_tstring_beg on_tstring_end on_rparen on_op krt # Find and evaluate our main object, if possible.
def UNK on_nl UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl remaining on_op on_ivar on_period UNK on_period UNK # Make sure the entire catalog is evaluated.
def UNK on_nl remaining on_op on_ivar on_period UNK on_period UNK on_period UNK on_lparen on_op on_symbeg ref on_rparen on_nl on_ignored_nl if # If there are any resource overrides remaining, then we could # not find the resource they were supposed to override, so we # want to throw an exception.
def UNK on_nl remaining on_op on_ivar on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_period UNK on_nl if on_op # Make sure there are no remaining collections that are waiting for # resources that have not yet been instantiated. If this occurs it # is an error (missing resource - it could not be realized). #
def UNK on_nl UNK on_nl on_ignored_nl resources on_period each do on_op resource on_op on_ignored_nl UNK on_op UNK on_lparen resource on_rparen # Make sure all of our resources and such have done any last work # necessary.
UNK on_op UNK on_lparen resource on_rparen on_nl if UNK on_nl UNK on_period each do on_op UNK on_op on_ignored_nl resource on_period # Add in any resource overrides.
UNK on_period UNK on_nl end on_nl on_ignored_nl resource on_period UNK if resource on_period UNK on_lparen on_symbeg UNK on_rparen on_nl end # Remove the overrides, so that the configuration knows there # are none left.
raise _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_period UNK #TRANSLATORS "main" is a function name and should not be translated
data on_lbracket source on_rbracket on_op UNK on_nl UNK on_period each do on_op param on_comma value on_op on_ignored_nl target on_lbracket param # only store anything in the data hash if we've actually got # data
data on_op on_lbrace on_rbrace on_nl data on_lbracket param on_rbracket on_op resource on_lbracket param on_rbracket on_nl end on_nl end on_nl data # Because we could be creating a hash for every resource, # and we actually probably don't often have any data here at all, # we're optimizing a bit by only creating a hash if there's # any data to put in it.
def UNK on_nl on_ivar on_op on_const on_period new do on_op UNK on_comma ref on_op on_ignored_nl UNK on_lbracket ref on_rbracket on_op # Set up all of our internal variables.
on_ivar on_op on_const on_period new do on_op UNK on_comma ref on_op on_ignored_nl UNK on_lbracket ref on_rbracket on_op on_lbracket on_rbracket on_nl # The list of overrides. This is used to cache overrides on objects # that don't exist yet. We store an array of each override.
on_ivar on_op on_lbracket on_rbracket on_nl on_ignored_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ignored_nl on_ivar on_op on_const on_op on_const on_op on_const on_period # The list of collections that have been created. This is a global list, # but they each refer back to the scope that created them.
on_ivar on_op on_lbracket on_rbracket on_nl on_ignored_nl on_ivar on_op on_const on_op on_const on_op on_const on_period new on_lparen on_ivar on_period name on_comma # The list of relationships to evaluate.
on_ivar on_op on_const on_op on_const on_op on_const on_period new on_lparen on_ivar on_period name on_comma on_ivar on_period environment on_comma on_ivar on_rparen # For maintaining the relationship between scopes and their resources.
on_ivar on_op on_const on_op on_const on_op on_const on_period new on_lparen UNK on_rparen on_nl on_ignored_nl on_ivar on_op on_const on_op on_const on_op # MOVED HERE - SCOPE IS NEEDED (MOVE-SCOPE) # Create the initial scope, it is needed early
on_ivar on_op on_const on_op on_const on_op on_const on_period new on_lparen environment on_rparen on_nl on_ignored_nl on_ivar on_op UNK on_lparen on_rparen on_nl # Initialize loaders and Pcore
on_ivar on_op UNK on_lparen on_rparen on_nl on_ignored_nl on_const on_period override on_lparen on_ivar on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen # Need to compute overrides here, and remember them, because we are about to # enter the magic zone of known_resource_types and initial import. # Expensive entries in the context are bound lazily.
on_const on_period override on_lparen on_ivar on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen do on_ignored_nl on_ivar on_period UNK on_op environment # This construct ensures that initial import (triggered by instantiating # the structure 'known_resource_types') has a configured context # It cannot survive the initvars method, and is later reinstated # as part of compiling... #
on_ivar on_period UNK on_op environment on_period known_resource_types on_period UNK on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl on_ivar on_period add_resource # THE MAGIC STARTS HERE ! This triggers parsing, loading etc.
on_ivar on_op on_lbracket on_rbracket on_nl on_ignored_nl if on_ivar on_period classes on_period UNK on_op on_const on_nl on_ivar on_period UNK on_lparen on_op # local resource array to maintain resource ordering
if on_ivar on_period classes on_period UNK on_op on_const on_nl on_ivar on_period UNK on_lparen on_op on_ivar on_period classes on_period UNK on_rparen # Make sure any external node classes are in our class list
def UNK on_nl node on_period parameters on_period each do on_op param on_comma value on_op on_ignored_nl UNK if param on_period UNK # Set the node's parameters into the top-scope as variables.
UNK if param on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_lbracket param on_period UNK on_rbracket on_op value on_period is_a? # We don't want to set @topscope['environment'] from the parameters, # instead we want to get that from the node's environment itself in # case a custom node terminus has done any mucking about with # node.parameters.
on_ivar on_lbracket param on_period UNK on_rbracket on_op value on_period is_a? on_lparen on_const on_rparen on_op value on_period UNK on_op value on_nl # Ensure node does not leak Symbol instances in general
catalog on_period UNK on_op node on_period parameters on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl catalog on_period UNK on_op node on_period parameters # These might be nil.
on_ignored_nl scope on_op on_ivar on_period class_scope on_lparen settings_type on_rparen on_nl scope on_period UNK on_lparen environment on_period name on_rparen on_nl end # Prevents settings from being reevaluated
def UNK on_nl resources on_period UNK on_lbrace on_op resource on_op resource on_period UNK UNK resource on_period UNK UNK resource on_period # Return an array of all of the unevaluated resources. These will be definitions, # which need to get evaluated into native resources.
resources on_period UNK on_lbrace on_op resource on_op resource on_period UNK UNK resource on_period UNK UNK resource on_period UNK on_rbrace on_nl # The order of these is significant for speed due to short-circuiting
