require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl # coding: utf-8
on_lbracket on_lbracket on_regexp_beg on_tstring_content on_regexp_end on_comma on_lbracket on_lbracket on_symbeg path on_rbracket on_rbracket on_rbracket on_rbracket on_nl end on_nl on_ignored_nl newparam on_lparen # strip trailing slashes from path but allow the root directory, including # for example "/" or "C:/"
on_op on_const on_period UNK on_lparen value on_rparen on_nl else on_ignored_nl on_op on_const on_period UNK on_lparen on_op on_const on_period split on_lparen # This is a UNC path pointing to a share, so don't add a trailing slash
value on_op value on_period UNK if value on_period is_a? on_lparen on_const on_rparen on_nl on_ignored_nl UNK value on_nl when false on_comma # I don't really know how this is happening.
on_op on_const on_period UNK on_lparen value on_rparen on_nl else on_ignored_nl on_op on_const on_period UNK on_lparen on_op on_const on_period split on_lparen # This is a UNC path pointing to a share, so don't add a trailing slash
UNK on_lparen on_symbeg file on_rparen do on_ignored_nl UNK on_op on_lbracket on_rbracket on_nl path on_op on_const on_period UNK on_lparen self on_lbracket # Autorequire the nearest ancestor directory found in the catalog.
UNK on_op path on_period parent on_period UNK on_lparen on_symbeg UNK on_rparen on_nl found on_op UNK on_period UNK on_lbrace on_op p # Start at our parent, to avoid autorequiring ourself
UNK on_op self on_lbracket on_symbeg target on_rbracket if self on_lbracket on_symbeg target on_rbracket on_nl UNK on_nl end on_nl on_ignored_nl on_lbrace # if the resource is a link, make sure the target is created first
on_lbrace on_symbeg UNK on_op on_symbeg owner on_comma on_symbeg UNK on_op on_symbeg UNK on_rbrace on_period each do on_op type on_comma property # Autorequire the owner and group of the file.
should on_op on_ivar on_lbracket property on_rbracket on_period UNK on_nl next unless should on_nl UNK on_op should on_lbracket on_int on_rbracket on_nl # The user/group property automatically converts to IDs
on_ivar on_lbracket on_symbeg content on_rbracket on_period value on_op on_ivar on_lbracket on_symbeg checksum on_rbracket on_period UNK on_lparen on_ivar on_lbracket on_symbeg content # Now that we know the checksum, update content (in case it was created before checksum was known).
def UNK on_nl if self on_period should on_lparen on_symbeg owner on_rparen on_op on_op self on_period should on_lparen on_symbeg owner on_rparen # Determine the user to write files as.
UNK on_op self on_period should on_lparen on_symbeg owner on_rparen if UNK on_nl end on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl # If the parent directory is writeable, then we execute # as the user in question. Otherwise we'll rely on # the 'owner' property to do things.
def UNK on_nl stat on_op true on_op false on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl super on_op # Does the file currently exist? Just checks for whether # we have a stat
def UNK on_nl UNK on_nl super on_nl end on_nl on_ignored_nl def UNK on_nl return on_lbracket on_rbracket unless self on_period UNK # We have to do some extra finishing, to retrieve our bucket if # there is one.
UNK on_nl super on_nl end on_nl on_ignored_nl def UNK on_nl return on_lbracket on_rbracket unless self on_period UNK on_nl on_ignored_nl recurse # Look up our bucket, if there is one
def UNK on_nl return on_lbracket on_rbracket unless self on_period UNK on_nl on_ignored_nl recurse on_nl end on_nl on_ignored_nl def UNK on_nl # Create any children via recursion or whatever.
on_ivar on_period each do on_op UNK on_comma param on_op on_ignored_nl param on_period UNK if param on_period UNK on_lparen on_symbeg UNK # We want to make sure we retrieve metadata anew on each transaction.
on_ivar on_op on_lbrace on_rbrace on_nl on_ignored_nl super on_nl on_ignored_nl unless self on_lbracket on_symbeg ensure on_rbracket on_nl if self on_lbracket on_symbeg # Used for caching clients
unless self on_lbracket on_symbeg ensure on_rbracket on_nl if self on_lbracket on_symbeg target on_rbracket on_nl self on_lbracket on_symbeg ensure on_rbracket on_op # If they've specified a source, we get our 'should' values # from it.
def UNK on_lparen children on_rparen on_ignored_nl children on_period each do on_op UNK on_comma UNK on_op on_ignored_nl next if UNK on_lbracket # Configure discovered resources to be purged.
def UNK on_lparen path on_rparen on_ignored_nl UNK on_op on_op on_const on_period UNK on_lparen self on_lbracket on_symbeg path on_rbracket on_comma path # Create a new file or directory object as a child to the current # object.
UNK on_op on_ivar on_period UNK on_lparen on_symbeg path on_op UNK on_rparen on_period UNK on_lbrace on_op param on_comma value on_op value # Add some new values to our original arguments -- these are the ones # set at initialization. We specifically want to exclude any param # values set by the :source property or any default values. # LAK:NOTE This is kind of silly, because the whole point here is that # the values set at initialization should live as long as the resource # but values set by default or by :source should only live for the transaction # or so. Unfortunately, we don't have a straightforward way to manage # the different lifetimes of this data, so we kludge it like this. # The right-side hash wins in the merge.
on_lbracket on_symbeg parent on_comma on_symbeg ensure on_comma on_symbeg recurse on_comma on_symbeg UNK on_comma on_symbeg target on_comma on_symbeg UNK on_comma on_symbeg # These should never be passed to our children.
def UNK on_nl parent on_op parent on_lparen on_rparen on_nl if parent on_nl if parent on_period is_a? on_lparen self on_period class # Files handle paths specially, because they just lengthen their # path names, rather than including the full parent's title each # time.
parent on_op parent on_lparen on_rparen on_nl if parent on_nl if parent on_period is_a? on_lparen self on_period class on_rparen on_nl UNK # We specifically need to call the method here, so it looks # up our parent in the catalog graph.
if parent on_period is_a? on_lparen self on_period class on_rparen on_nl UNK on_op parent on_period UNK on_nl UNK on_period UNK return # We only need to behave specially when our parent is also # a file
UNK on_op parent on_period UNK on_nl UNK on_period UNK return UNK on_op self on_period UNK on_nl else on_ignored_nl return super # Remove the parent file name
return UNK on_op self on_period UNK on_nl else on_ignored_nl return super on_nl end on_nl else on_ignored_nl return on_lbracket self on_period # remove the parent's path info
def recurse on_nl children on_op on_lparen self on_lbracket on_symbeg recurse on_rbracket on_op on_symbeg remote on_rparen on_op on_lbrace on_rbrace on_op UNK # Recursively generate a list of file resources, which will # be used to copy remote files, manage local files, and/or make links # to map to another directory.
UNK on_lparen children on_rparen if self on_period UNK on_nl on_ignored_nl result on_op children on_period UNK on_period UNK on_lbrace on_op UNK # If we're purging resources, then delete any resource that isn't on the # remote system.
def self on_period UNK on_lparen UNK on_comma UNK on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl UNK on_op UNK on_period split # This is to fix bug #2296, where two files recurse over the same # set of files. It's a rare case, and when it does happen you're # not likely to have many actual conflicts, which is good, because # this is a pretty inefficient implementation.
UNK on_op UNK on_period split on_lparen on_op on_const on_op on_const on_rparen on_nl UNK on_op UNK on_period on_ignored_nl UNK on_lbrace on_op # REVISIT: is this Windows safe? AltSeparator?
def UNK on_nl self on_lbracket on_symbeg recurse on_rbracket on_op true or self on_lbracket on_symbeg recurse on_rbracket on_op on_symbeg remote on_nl # A simple method for determining whether we should be recursing.
def UNK on_lparen children on_rparen on_ignored_nl UNK on_lparen self on_lbracket on_symbeg target on_rbracket on_rparen on_period each do on_op meta on_op # Recurse the target of the link.
def UNK on_nl result on_op UNK on_lparen self on_lbracket on_symbeg path on_rbracket on_rparen on_nl return on_lbrace on_rbrace unless result on_nl # Recurse the file itself, returning a Metadata instance for every found file.
def UNK on_lparen children on_rparen on_ignored_nl UNK on_period each do on_op meta on_op on_ignored_nl if meta on_period relative_path on_op on_tstring_beg # Recurse against our remote file.
UNK on_op catalog on_period UNK on_lbracket UNK on_rbracket on_nl if UNK on_nl result on_op UNK on_lbracket source on_rbracket on_nl else # For each inlined file resource, the catalog contains a hash mapping # source path to lists of metadata returned by a server-side search.
data on_period source on_op on_tstring_beg on_embexpr_beg source on_embexpr_end on_tstring_content on_embexpr_beg data on_period relative_path on_embexpr_end on_tstring_end on_nl end on_nl end on_nl # REMIND: appending file paths to URL may not be safe, e.g. foo+bar
unless UNK on_op on_symbeg UNK on_nl found on_op on_lbracket on_rbracket on_nl UNK on_period UNK do on_op data on_op on_ignored_nl result # This only happens if we have sourceselect == :all
def UNK on_lparen should on_rparen on_ignored_nl wanted_type on_op should on_period to_s on_nl current_type on_op UNK on_nl on_ignored_nl if current_type on_period # Back up and remove the file or directory at `self[:path]`. # # @param [Symbol] should The file type replacing the current content. # @return [Boolean] True if the file was removed, else False # @raises [fail???] If the file could not be backed up or could not be removed.
self on_period fail _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label current_type on_rbrace on_nl end on_nl end on_nl on_ignored_nl # Including: “blockSpecial”, “characterSpecial”, “unknown”
if on_const on_op on_const on_op on_const on_period UNK on_op parameter on_lparen on_symbeg source on_rparen on_op on_ignored_nl on_lbracket on_symbeg UNK on_comma # This check is done in retrieve to ensure it happens before we try to use # metadata in `copy_source_values`, but so it only fails the resource and not # catalog validation (because that would be a breaking change from Puppet 4).
UNK on_op _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if self on_lbracket on_symbeg owner on_rbracket on_op nil on_op self on_lbracket #TRANSLATORS "source_permissions => ignore" should not be translated
self on_period fail UNK on_nl else on_ignored_nl self on_period warning UNK on_nl end on_nl end on_nl on_ignored_nl if on_lparen source # Fail on Windows if source permissions are being used and the file resource # does not have mode owner, group, and mode all set (which would take precedence).
self on_period warning UNK on_nl end on_nl end on_nl on_ignored_nl if on_lparen source on_op parameter on_lparen on_symbeg source on_rparen on_rparen # Warn if use source permissions is specified on Windows
if on_lparen source on_op parameter on_lparen on_symbeg source on_rparen on_rparen on_op property on_lparen on_symbeg UNK on_rparen on_period nil? on_nl source # `checksum_value` implies explicit management of all metadata, so skip metadata # retrieval. Otherwise, if source is set, retrieve metadata for source.
def UNK on_lparen UNK on_op nil on_rparen on_ignored_nl if on_ivar on_period include? on_symbeg checksum on_nl if UNK on_nl on_ivar on_lbracket # Set the checksum, from another property. There are multiple # properties that modify the contents of a file, and they need the # ability to make sure that the checksum value is in sync.
UNK on_op on_ivar on_lbracket on_symbeg checksum on_rbracket on_period UNK on_nl on_ivar on_lbracket on_symbeg checksum on_rbracket on_period checksum on_op UNK on_nl # If they didn't pass in a sum, then tell checksum to # figure it out.
def UNK on_nl return true if self on_lbracket on_symbeg ensure on_rbracket on_op on_symbeg file on_nl on_ignored_nl return false if self # Should this thing be a normal file? This is a relatively complex # way of determining whether we're trying to create a normal file, # and it's here so that the logic isn't visible in the content property.
return false if self on_lbracket on_symbeg ensure on_rbracket on_op self on_lbracket on_symbeg ensure on_rbracket on_op on_symbeg UNK on_nl on_ignored_nl if # I.e., it's set to something like "directory"
if self on_lbracket on_symbeg ensure on_rbracket on_op on_symbeg UNK on_nl return true unless stat on_nl return on_lparen stat on_period UNK # The user doesn't really care, apparently
return true if self on_lbracket on_symbeg content on_rbracket on_nl return true if stat and stat on_period UNK on_op on_tstring_beg on_tstring_content # If we've gotten here, then :ensure isn't set
def stat on_nl return on_ivar unless on_ivar on_op on_symbeg UNK on_nl on_ignored_nl UNK on_op on_symbeg stat on_nl on_ignored_nl if on_lparen # Stat our file. Depending on the value of the 'links' attribute, we # use either 'stat' or 'lstat', and we expect the properties to use the # resulting stat object accordingly (mostly by testing the 'ftype' # value). # # We use the initial value :needs_stat to ensure we only stat the file once, # but can also keep track of a failed stat (@stat == nil). This also allows # us to re-stat on demand by setting @stat = :needs_stat.
if on_lparen self on_period class on_period UNK on_op on_symbeg file and self on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_rparen # Files are the only types that support links
def UNK on_lparen property on_op nil on_rparen on_ignored_nl UNK on_lparen on_symbeg file on_rparen on_nl on_ignored_nl mode on_op self on_period should # Write out the file. To write content, pass the property as an argument # to delegate writing to; must implement a #write method that takes the file # as an argument.
UNK on_op mode on_op UNK on_lparen mode on_comma on_const on_op on_const on_op on_const on_rparen on_op nil on_nl on_ignored_nl if UNK # might be nil
end on_nl on_ignored_nl UNK on_lparen file on_period path on_comma UNK on_rparen if UNK on_nl end on_nl else on_ignored_nl UNK on_op # fsync may not be implemented by Ruby on all platforms, but # there is absolutely no recovery path if we detect that. So, we just # ignore the return code. # # However, don't be fooled: that is accepting that we are running in # an unsafe fashion. If you are porting to a new platform don't stub # that out.
UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl if UNK on_period include? on_lparen on_symbeg # make sure all of the modes are actually correct
def UNK on_lparen UNK on_rparen on_ignored_nl if UNK on_period include? on_lparen on_symbeg content on_rparen on_nl UNK on_lparen on_symbeg ensure on_rparen # Carry the context of sensitive parameters to the the properties that will actually handle that # sensitive data. # # The file type can accept file content from a number of origins and depending on the current # state of the system different properties will be responsible for synchronizing the file # content. This method handles the necessary mapping of originating parameters to the # responsible parameters.
if UNK on_period include? on_lparen on_symbeg content on_rparen on_nl UNK on_lparen on_symbeg ensure on_rparen on_period UNK on_op true on_nl end # If we have content that's marked as sensitive but the file doesn't exist then the ensure # property will be responsible for syncing content, so we have to mark ensure as sensitive as well.
UNK on_lparen on_symbeg ensure on_rparen on_period UNK on_op true on_nl end on_nl on_ignored_nl if UNK on_period include? on_lparen on_symbeg source # The `ensure` parameter is not guaranteed to be defined either and will be conditionally set when # the `content` property is set, so we need to force the creation of the `ensure` property to # set the sensitive context.
if UNK on_period include? on_lparen on_symbeg source on_rparen on_nl UNK on_period UNK on_lparen on_symbeg source on_rparen on_nl parameter on_lparen on_symbeg # The source parameter isn't actually a property but works by injecting information into the # content property. In order to preserve the intended sensitive context we need to mark content # as sensitive as well.
UNK on_lparen on_symbeg content on_rparen on_period UNK on_op true on_nl UNK on_lparen on_symbeg ensure on_rparen on_period UNK on_op true on_nl # The `source` parameter will generate the `content` property when the resource state is retrieved # but that's long after we've set the sensitive context. Force the early creation of the `content` # attribute so we can mark it as sensitive.
UNK on_lparen on_symbeg ensure on_rparen on_period UNK on_op true on_nl end on_nl on_ignored_nl super on_lparen UNK on_rparen on_nl end on_nl # As noted above, making the `content` property sensitive requires making the `ensure` property # sensitive as well.
def UNK on_nl UNK on_op stat on_nl if UNK on_nl UNK on_period UNK on_period to_s on_nl else on_ignored_nl nil on_nl # @return [String] The type of the current file, cast to a string.
def UNK on_lparen type on_rparen on_ignored_nl if type on_op on_tstring_beg on_tstring_content on_tstring_end and UNK on_nl true on_nl UNK type on_op # @return [Boolean] If the current file should be backed up and can be backed up.
true on_nl UNK type on_op on_tstring_beg on_tstring_content on_tstring_end or type on_op on_tstring_beg on_tstring_content on_tstring_end on_nl true on_nl else on_ignored_nl false # (#18110) Directories cannot be removed without :force, # so it doesn't make sense to back them up unless removing with :force.
false on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen wanted_type on_rparen on_ignored_nl if UNK on_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg # Including: “blockSpecial”, “characterSpecial”, "fifo", "socket", “unknown”
def UNK on_lparen wanted_type on_rparen on_ignored_nl if UNK on_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg wanted_type on_embexpr_end on_tstring_end on_nl on_const on_period UNK # @return [Boolean] if the directory was removed (which is always true currently) # @api private
def UNK on_lparen current_type on_comma wanted_type on_rparen on_ignored_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg current_type on_embexpr_end on_tstring_content on_embexpr_beg wanted_type on_embexpr_end on_tstring_end on_nl # @return [Boolean] if the file was removed (which is always true currently) # @api private
def UNK on_nl unless UNK on_nl UNK on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # Back up the existing file at a given prior to it being removed # @api private # @raise [Puppet::Error] if the file backup failed # @return [void]
UNK on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl #TRANSLATORS refers to a file which could not be backed up
def UNK on_nl self on_lbracket on_symbeg checksum on_rbracket on_op on_regexp_beg on_tstring_content on_regexp_end on_nl end on_nl on_ignored_nl def UNK on_lparen path # Should we validate the checksum of the file we're writing?
def UNK on_lparen path on_comma UNK on_rparen on_ignored_nl UNK on_op parameter on_lparen on_symbeg checksum on_rparen on_period UNK on_lparen path on_rparen # Make sure the file we wrote out is what we think it is.
on_lparen UNK on_op property on_lparen on_symbeg content on_rparen and UNK on_period UNK on_rparen on_op on_ivar on_lbracket on_symbeg source on_rbracket on_nl # Unfortunately we don't know the source file size before fetching it so # let's assume the file won't be empty. Why isn't it part of the metadata?
def UNK on_nl UNK on_period each do on_op UNK on_op on_ignored_nl next unless on_lbracket on_symbeg mode on_comma on_symbeg owner on_comma # There are some cases where all of the work does not get done on # file creation/modification, so we have to do some extra checking.
on_ivar on_op on_symbeg UNK on_nl UNK on_op UNK on_period UNK on_nl UNK on_period UNK unless UNK on_period UNK on_lparen UNK # Make sure we get a new stat object
require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content # We put all of the properties in separate files, because there are so many # of them. The order these are loaded is important, because it determines # the order they are in the property lit.
require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end # can create the file
require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content # can create the file
require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg # can create the file, in place of content
require on_tstring_beg on_tstring_content on_tstring_end require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require # creates a different type of file
require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl # can create the file
require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # SELinux file context
