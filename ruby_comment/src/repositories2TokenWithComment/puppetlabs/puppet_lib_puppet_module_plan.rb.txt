def self on_period UNK on_lparen UNK on_rparen on_ignored_nl name on_op on_const on_period basename on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Determine whether a plan file has a legal name and extension
def self on_period UNK on_lparen name on_comma plan_files on_rparen on_ignored_nl basename on_op name on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Executables list should contain the full path of all possible implementation files
UNK on_op plan_files on_period UNK on_lbrace on_op UNK on_op on_const on_period basename on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op # If implementations isn't defined, then we use executables matching the # plan name, and only one may exist.
UNK on_op UNK on_period UNK on_period UNK on_nl on_ignored_nl on_lbracket on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_op on_const on_period basename on_lparen UNK # Select .pp before .yaml, since .pp comes before .yaml alphabetically.
plan_files on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen pup_module on_period UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_ignored_nl # Search e.g. 'modules/<pup_module>/plans' for all plans
def UNK on_lparen pup_module on_comma plan_name on_comma plan_files on_rparen on_ignored_nl UNK on_comma UNK on_op on_const on_op on_const on_op on_const on_period # file paths must be relative to the modules plan directory
on_ivar on_op on_lbrace on_rbrace on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op self on_period class on_period UNK on_lparen on_ivar # Nothing to go here unless plans eventually support metadata.
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl return on_const on_period basename on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Abstracted here so we can add support for subdirectories later
