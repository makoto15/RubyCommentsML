UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period # This implementation of {Evaluator} performs evaluation using the puppet 3.x runtime system # in a manner largely compatible with Puppet 3.x, but adds new features and introduces constraints. # # The evaluation uses _polymorphic dispatch_ which works by dispatching to the first found method named after # the class or one of its super-classes. The EvaluatorImpl itself mainly deals with evaluation (it currently # also handles assignment), and it uses a delegation pattern to more specialized handlers of some operators # that in turn use polymorphic dispatch; this to not clutter EvaluatorImpl with too much responsibility). # # Since a pattern is used, only the main entry points are fully documented. The parameters _o_ and _scope_ are # the same in all the polymorphic methods, (the type of the parameter _o_ is reflected in the method's name; # either the actual class, or one of its super classes). The _scope_ parameter is always the scope in which # the evaluation takes place. If nothing else is mentioned, the return is always the result of evaluation. # # See {Visitable} and {Visitor} for more information about # polymorphic calling. #
UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl on_ignored_nl on_const on_op on_const on_nl # Provides access to the Puppet 3.x runtime (scope, etc.) # This separation has been made to make it easier to later migrate the evaluator to an improved runtime. #
on_const on_op on_const on_nl on_ignored_nl def UNK on_nl on_cvar on_op UNK on_nl on_ignored_nl UNK on_op on_const on_period UNK on_lparen on_symbeg # Reference to Issues name space makes it easier to refer to issues # (Issues are shared with the validator). #
UNK on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_lbrace on_const on_op on_const on_period UNK on_rbrace on_nl end on_nl on_ignored_nl # Use null migration checker unless given in context
def UNK on_nl on_cvar on_op on_const on_period new on_lparen self on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_int on_comma on_int on_rparen on_nl # @api private
def type_calculator on_nl on_cvar on_nl end on_nl on_ignored_nl def evaluate on_lparen target on_comma scope on_rparen on_ignored_nl begin on_ignored_nl on_cvar on_period # @api private
def evaluate on_lparen target on_comma scope on_rparen on_ignored_nl begin on_ignored_nl on_cvar on_period UNK on_lparen self on_comma target on_comma scope on_rparen # Evaluates the given _target_ object in the given scope. # # @overload evaluate(target, scope) # @param target [Object] evaluation target - see methods on the pattern assign_TYPE for actual supported types. # @param scope [Object] the runtime specific scope class where evaluation should take place # @return [Object] the result of the evaluation # # @api public #
fail on_lparen e on_period UNK on_comma e on_period UNK on_op target on_comma e on_period UNK on_comma e on_rparen on_nl on_ignored_nl # A raised issue may not know the semantic target, use errors call stack, but fill in the # rest from a supplied semantic object, or the target instruction if there is not semantic # object. #
raise e on_nl on_ignored_nl rescue on_const on_op on_const on_op e on_nl if e on_period UNK on_op e on_period UNK on_nl # Already formatted with location information, and with the wanted call stack. # Note this is currently a specialized ParseError, so rescue-order is important #
if e on_period UNK on_op e on_period UNK on_nl raise e on_nl else on_ignored_nl fail on_lparen on_const on_op on_const on_comma # ParseError may be raised in ruby code without knowing the location # in puppet code. # Accept a ParseError that has file or line information available # as an error that should be used verbatim. (Tests typically run without # setting a file name). # ParseError can supply an original - it is impossible to determine which # call stack that should be propagated, using the ParseError's backtrace. #
fail on_lparen on_const on_op on_const on_comma target on_comma on_lbrace on_symbeg detail on_op e on_period message on_rbrace on_comma e on_rparen on_nl # Since it had no location information, treat it as user intended a general purpose # error. Pass on its call stack.
fail on_lparen on_const on_op on_const on_comma target on_comma on_lbrace on_symbeg detail on_op e on_period message on_rbrace on_comma e on_period UNK # PuppetError has the ability to wrap an exception, if so, use the wrapped exception's # call stack instead
raise e on_nl on_ignored_nl rescue on_const on_op e on_nl fail on_lparen on_const on_op on_const on_comma target on_comma on_lbrace on_symbeg detail # Ensure these are not rescued as StandardError
fail on_lparen on_const on_op on_const on_comma target on_comma on_lbrace on_symbeg detail on_op e on_period message on_rbrace on_comma e on_rparen on_nl # All other errors, use its message and call stack
def UNK on_lparen target on_comma value on_comma o on_comma scope on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma target on_comma # Assigns the given _value_ to the given _target_. The additional argument _o_ is the instruction that # produced the target/value tuple and it is used to set the origin of the result. # # @param target [Object] assignment target - see methods on the pattern assign_TYPE for actual supported types. # @param value [Object] the value to assign to `target` # @param o [Model::PopsObject] originating instruction # @param scope [Object] the runtime specific scope where evaluation should take place # # @api private #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_comma scope on_rparen on_nl end # Computes a value that can be used as the LHS in an assignment. # @param o [Object] the expression to evaluate as a left (assignable) entity # @param scope [Object] the runtime specific scope where evaluation should take place # # @api private #
def string on_lparen o on_comma scope on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_comma scope on_rparen on_nl end # Produces a String representation of the given object _o_ as used in interpolation. # @param o [Object] the expression of which a string representation is wanted # @param scope [Object] the runtime specific scope where evaluation should take place # # @api public #
def UNK on_lparen scope on_comma UNK on_comma UNK on_rparen on_ignored_nl scope on_period UNK do on_ignored_nl UNK on_lparen UNK on_comma scope # Evaluate a BlockExpression in a new scope with variables bound to the # given values. # # @param scope [Puppet::Parser::Scope] the parent scope # @param variable_bindings [Hash{String => Object}] the variable names and values to bind (names are keys, bound values are values) # @param block [Model::BlockExpression] the sequence of expressions to evaluate in the new scope # # @api private #
UNK on_lparen UNK on_comma scope on_rparen on_nl evaluate on_lparen UNK on_comma scope on_rparen on_nl end on_nl end on_nl on_ignored_nl def # change to create local scope_from - cannot give it file and line - # that is the place of the call, not "here"
def UNK on_lparen left on_comma right on_rparen on_ignored_nl on_cvar on_period UNK on_lparen left on_comma right on_comma nil on_rparen on_nl end # Implementation of case option matching. # # This is the type of matching performed in a case option, using == for every type # of value except regular expression where a match is performed. #
evaluate on_lparen o on_period expr on_comma scope on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen on_ignored_nl # evaluate the name
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl fail on_lparen on_const on_op on_const on_comma o on_rparen on_nl end on_nl on_ignored_nl # Catches all illegal lvalues #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl o on_period values on_period map on_lbrace on_op x on_op UNK on_lparen x # An array is assignable if all entries are lvalues
def UNK on_lparen name on_comma value on_comma o on_comma scope on_rparen on_ignored_nl if name on_op UNK on_tstring_content UNK on_nl fail # Assign value to named variable. # The '$' sign is never part of the name. # @example In Puppet DSL # $name = value # @param name [String] name of variable without $ # @param value [Object] value to assign to the variable # @param o [Model::PopsObject] originating instruction # @param scope [Object] the runtime specific scope where evaluation should take place # @return [value<Object>] #
def UNK on_lparen name on_comma value on_comma o on_comma scope on_rparen on_ignored_nl fail on_lparen on_const on_op on_const on_comma o on_rparen # Catches all illegal assignment (e.g. 1 = 2, {'a'=>1} = 2, etc) #
UNK on_op UNK on_lparen scope on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma values on_period UNK on_rparen on_nl if UNK on_nl UNK on_op # assign variables from class variables # lookup class resource and return one or more parameter values # TODO: behavior when class_name is nil
def UNK o on_comma scope on_nl o on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen on_ignored_nl nil # Evaluates any object not evaluated to something else to itself.
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl nil on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen # Allows nil to be used as a Nop, Evaluates to nil
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl nil on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen # Evaluates Nop to nil.
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl o on_period value on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma # Captures all LiteralValues not handled elsewhere. #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl if on_op o on_period UNK on_nl fail on_lparen on_const on_op on_const on_comma # Reserved Words fail to evaluate #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl type on_op on_const on_op on_const on_period UNK on_period UNK on_lparen o on_rparen # A QualifiedReference (i.e. a capitalized qualified name such as Foo, or Foo::Bar) evaluates to a PTypeType #
on_lbracket candidate on_rbracket on_nl end on_nl end on_nl on_ignored_nl def UNK o on_comma scope on_nl on_lbracket evaluate on_lparen o on_period # turns anything else into an array (so result can be unfolded)
def UNK o on_comma scope on_nl on_lbracket evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_comma evaluate on_lparen o on_period # Abstract evaluation, returns array [left, right] with the evaluated result of left_expr and # right_expr # @return <Array<Object, Object>> array with result of evaluating left and right expressions #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl name on_op UNK on_lparen o on_period left_expr on_comma scope on_rparen on_nl value # Evaluates assignment with operators =, +=, -= and # # @example Puppet DSL # $a = 1 # $a += 1 # $a -= 1 #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl left on_op evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_nl right # Handles binary expression where lhs and rhs are array/hash or numeric and operator is +, - , *, % / << >> #
def UNK on_lparen left on_comma right on_comma bin_expr on_comma scope on_rparen on_ignored_nl operator on_op bin_expr on_period operator on_nl unless on_const # Handles binary expression where lhs and rhs are array/hash or numeric and operator is +, - , *, % / << >> #
case operator on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_lparen left on_comma right on_rparen on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl # Handle operation on collections
left on_op UNK on_lparen left on_comma left_o on_comma scope on_rparen on_nl right on_op UNK on_lparen right on_comma bin_expr on_period right_expr # Handle operation on numeric
fail on_lparen on_const on_op on_const on_comma left_o on_comma on_lbrace on_symbeg operator on_op operator on_comma on_symbeg left_value on_op left on_rbrace on_rparen # Deny users the fun of seeing severe rounding errors and confusing results
x on_op left on_nl left on_op right on_nl right on_op x on_nl elsif operator on_op on_tstring_beg on_tstring_content on_tstring_end on_op right # Switch places. Let the TimeData do the arithmetic
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl UNK on_op UNK on_lparen o on_comma scope on_rparen on_nl on_cvar on_period evaluate # Evaluates Puppet DSL ->, ~>, <-, and <~
UNK on_op UNK on_lparen o on_comma scope on_rparen on_nl on_cvar on_period evaluate on_lparen UNK on_comma o on_comma scope on_rparen on_nl # First level evaluation, reduction to basic data types or puppet types, the relationship operator then translates this # to the final set of references (turning strings into references, which can not naturally be done by the main evaluator since # all strings should not be turned into references. #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl left on_op evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_nl keys # Evaluates x[key, key, ...] #
keys on_op keys on_period map on_lbrace on_op key on_op key on_period is_a? on_lparen on_const on_op on_const on_rparen on_op on_const on_op # Evaluate qualified references without errors no undefined types
return keys on_lbracket on_int on_rbracket if on_const on_op on_const on_op on_const on_op left on_op keys on_period UNK on_op on_int on_op # Resource[File] becomes File
def UNK o on_comma scope on_nl left on_op evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_nl right on_op evaluate # Evaluates <, <=, >, >=, and == #
if left on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl case o on_period operator on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl # Left is a type
on_cvar on_period UNK on_lparen right on_comma left on_rparen on_op on_op on_cvar on_period equals on_lparen left on_comma right on_rparen on_nl when # left can be assigned to right, but they are not equal
on_cvar on_period UNK on_lparen right on_comma left on_rparen on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl on_cvar on_period UNK on_lparen left on_comma # left can be assigned to right
on_cvar on_period UNK on_lparen left on_comma right on_rparen on_op on_op on_cvar on_period equals on_lparen left on_comma right on_rparen on_nl when # right can be assigned to left, but they are not equal
on_cvar on_period UNK on_lparen left on_comma right on_rparen on_nl else on_ignored_nl fail on_lparen on_const on_op on_const on_comma o on_comma on_lbrace # right can be assigned to left
def UNK o on_comma scope on_nl left on_op evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_nl pattern on_op evaluate # Evaluates matching expressions with type, string or regexp rhs expression. # If RHS is a type, the =~ matches compatible (instance? of) type. # # @example # x =~ /abc.*/ # @example # x =~ "abc.*/" # @example # y = "abc" # x =~ "${y}.*" # @example # [1,2,3] =~ Array[Integer[1,10]] # # Note that a string is not instance? of Regexp, only Regular expressions are. # The Pattern type should instead be used as it is specified as subtype of String. # # @return [Boolean] if a match was made or not. Also sets $0..$n to matchdata in current scope. #
if pattern on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl matched on_op pattern on_period UNK on_lparen left on_rparen on_nl return # matches RHS types as instance of for all types except a parameterized Regexp[R]
matched on_op pattern on_period UNK on_lparen left on_rparen on_nl return o on_period operator on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_op on_op # evaluate as instance? of type check
return o on_period operator on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_op on_op matched on_op on_op matched on_nl end on_nl on_ignored_nl if # convert match result to Boolean true, or false
matched on_op on_const on_op on_const on_period UNK on_lparen pattern on_comma left on_rparen on_nl return o on_period operator on_op on_tstring_beg on_tstring_content # evaluate if range includes version
UNK on_lparen matched on_comma scope on_rparen on_ignored_nl o on_period operator on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_op on_op matched on_op on_op # nil, or MatchData
on_ignored_nl o on_period operator on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_op on_op matched on_op on_op matched on_nl end on_nl on_ignored_nl def # creates ephemeral
o on_period operator on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_op on_op matched on_op on_op matched on_nl end on_nl on_ignored_nl def UNK # convert match result to Boolean true, or false
def UNK o on_comma scope on_nl left on_op evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_nl right on_op evaluate # Evaluates Puppet DSL `in` expression #
def UNK o on_comma scope on_nl is_true? on_lparen evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_comma o on_period left_expr # @example # $a and $b # b is only evaluated if a is true #
def UNK o on_comma scope on_nl is_true? on_lparen evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_comma o on_period left_expr # @example # a or b # b is only evaluated if a is false #
def UNK o on_comma scope on_nl unfold on_lparen on_lbracket on_rbracket on_comma o on_period values on_comma scope on_rparen on_nl end on_nl # Evaluates each entry of the literal list and creates a new Array # Supports unfolding of entries # @return [Array] with the evaluated content #
def UNK o on_comma scope on_nl o on_period UNK on_period UNK on_lparen on_lbrace on_rbrace on_rparen on_lbrace on_op UNK on_comma UNK # Evaluates each entry of the literal hash and creates a new Hash. # @return [Hash] with the evaluated content #
o on_period UNK on_period UNK on_lparen on_lbrace on_rbrace on_rparen on_lbrace on_op UNK on_comma UNK on_op UNK on_lbracket evaluate on_lparen UNK # optimized
def UNK o on_comma scope on_nl o on_period UNK on_period UNK on_lparen nil on_rparen on_lbrace on_op UNK on_comma s on_op # Evaluates all statements and produces the last evaluated value #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl scope on_period UNK do on_ignored_nl test on_op evaluate on_lparen o on_period test # Performs optimized search over case option values, lazily evaluating each # until there is a match. If no match is found, the case expression's default expression # is evaluated (it may be nil or Nop if there is no default, thus producing nil). # If an option matches, the result of evaluating that option is returned. # @return [Object, nil] what a matched option returns, or nil if nothing matched. #
scope on_period UNK do on_ignored_nl test on_op evaluate on_lparen o on_period test on_comma scope on_rparen on_nl on_ignored_nl result on_op nil # memo scope level before evaluating test - don't want a match in the case test to leak $n match vars # to expressions after the case expression. #
if co on_period values on_period UNK do on_op c on_op on_ignored_nl c on_op unwind_parentheses on_lparen c on_rparen on_nl case c # the first case option that matches
evaluate on_lparen c on_comma scope on_rparen on_period UNK on_lbrace on_op v on_op UNK on_lparen test on_comma v on_comma c on_comma # not ideal for error reporting, since it is not known which unfolded result # that caused an error - the entire unfold expression is blamed (i.e. the var c, passed to is_match?)
end on_nl end on_nl result else on_ignored_nl evaluate on_lparen the_default on_comma scope on_rparen end on_nl end on_nl end on_nl on_ignored_nl # the option was picked
else on_ignored_nl evaluate on_lparen the_default on_comma scope on_rparen end on_nl end on_nl end on_nl on_ignored_nl def UNK o on_comma scope # an option was picked, and produced a result
end on_nl end on_nl end on_nl on_ignored_nl def UNK o on_comma scope on_nl if o on_period UNK on_period is_a? on_lparen # evaluate the default (should be a nop/nil) if there is no default).
def UNK o on_comma scope on_nl if o on_period UNK on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl UNK on_lparen # Evaluates a CollectExpression by creating a collector transformer. The transformer # will evaluate the collection, create the appropriate collector, and hand it off # to the compiler to collect the resources specified by the query. #
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl nil on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen # This evaluates classes, nodes and resource type definitions to nil, since 3x: # instantiates them, and evaluates their parameters and body. This is achieved by # providing bridge AST classes in Puppet::Parser::AST::PopsBridge that bridges a # Pops Program and a Pops Expression. # # Since all Definitions are handled "out of band", they are treated as a no-op when # evaluated. #
return on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_comma UNK on_comma self on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_lbracket # Add stack frame for "top scope" logic. See Puppet::Pops::PuppetStack
rescue on_const on_op on_const on_op on_const on_op on_const on_op UNK on_nl raise on_const on_op on_const on_period new on_lparen _ on_lparen #evaluate(o.body, scope)
raise on_const on_op on_const on_period new on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_comma UNK on_period UNK on_comma UNK on_period # breaking out of a file level program is not allowed #TRANSLATOR break() is a method that should not be translated
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl UNK on_op o on_period UNK on_nl UNK on_op o on_period UNK on_nl # Produces Array[PAnyType], an array of resource references #
type_name on_op on_ignored_nl if on_lparen UNK on_op o on_period type_name on_rparen on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl UNK # Get the type name
else on_ignored_nl UNK on_op on_ignored_nl case o on_period type_name on_nl when on_const on_op on_const on_nl UNK on_nl when on_const on_op # already validated as a name
case evaluated_name on_nl when on_const on_op on_const on_nl unless evaluated_name on_period UNK on_period nil? on_nl fail on_lparen on_const on_op on_const # must be a CatalogEntry subtype
on_ignored_nl when on_const on_op on_const on_nl fail on_lparen on_const on_op on_const on_comma o on_period UNK on_comma on_lbrace on_symbeg type_name on_op # assume validated
if on_lparen o on_period UNK on_rparen on_nl UNK on_lparen on_const on_op on_const on_comma o on_rparen UNK on_ignored_nl end on_nl on_ignored_nl # This is a runtime check - the model is valid, but will have runtime issues when evaluated # and storeconfigs is not set.
o on_period UNK on_period map do on_op body on_op on_ignored_nl titles on_op evaluate on_lparen body on_period title on_comma scope on_rparen # titles are evaluated before attribute operations
if titles on_period nil? on_nl fail on_lparen on_const on_op on_const on_comma body on_period title on_rparen on_nl end on_nl titles on_op # Title may not be nil # Titles may be given as an array, it is ok if it is empty, but not if it contains nil entries # Titles may not be an empty String # Titles must be unique in the same resource expression # There may be a :default entry, its entries apply with lower precedence #
titles on_period UNK do on_op title on_comma index on_op on_ignored_nl if title on_period nil? on_nl fail on_lparen on_const on_op on_const # Check types of evaluated titles and duplicate entries
titles on_period UNK on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl UNK on_lbracket body on_rbracket on_op titles on_nl on_ignored_nl UNK on_lbracket body # Do not create a real instance from the :default case
UNK on_lbracket body on_rbracket on_op body on_period UNK on_period UNK on_lparen on_lbrace on_rbrace on_rparen do on_op UNK on_comma op on_op # Store evaluated parameters in a hash associated with the body, but do not yet create resource # since the entry containing :defaults may appear later
UNK on_op UNK on_lbracket UNK on_lbracket on_symbeg UNK on_rbracket on_rbracket on_op on_lbrace on_rbrace on_nl o on_period UNK on_period map do # Titles and Operations have now been evaluated and resources can be created # Each production is a PResource, and an array of all is produced as the result of # evaluating the ResourceExpression. #
body on_op if o on_period body on_period UNK on_period UNK on_op on_int on_nl on_const on_op on_const on_period UNK on_lparen o # All expressions are wrapped in an ApplyBlockExpression so we can identify the contents of # that block. However we don't want to serialize the block expression, so unwrap here.
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl UNK on_lparen o on_comma scope on_comma o on_period UNK on_comma evaluate on_lparen # Produces 3x parameter
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl type on_op evaluate on_lparen o on_period UNK on_comma scope on_rparen on_nl type_name # Sets default parameter values for a type, produces the type #
else on_ignored_nl actual on_op type_calculator on_period UNK on_lparen type_calculator on_period infer on_lparen type on_rparen on_rparen on_nl fail on_lparen on_const on_op # assume it is a valid name
type on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen on_ignored_nl functor on_op o on_period functor_expr on_nl if # Produce the type
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl functor on_op o on_period functor_expr on_nl if functor on_period is_a? on_lparen on_const # Evaluates function call by name. #
functor on_op o on_period functor_expr on_nl if functor on_period is_a? on_lparen on_const on_op on_const on_rparen on_op on_ignored_nl functor on_period is_a? # If LHS is a type (i.e. Integer, or Integer[...] # the call is taken as an instantiation of the given type #
type on_op evaluate on_lparen functor on_comma scope on_rparen on_nl return UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma unfold on_lparen on_lbracket type # instantiation
case functor on_nl when on_const on_op on_const on_nl when on_const on_op on_const on_nl fail on_lparen on_const on_op on_const on_comma o # The functor expression is not evaluated, it is not possible to select the function to call # via an expression like $a()
when on_const on_op on_const on_nl fail on_lparen on_const on_op on_const on_comma o on_rparen on_nl else on_ignored_nl fail on_lparen on_const on_op # ok
fail on_lparen on_const on_op on_const on_comma o on_rparen on_nl else on_ignored_nl fail on_lparen on_const on_op on_const on_comma o on_period functor_expr # helpful to point out this easy to make Epp error
def UNK on_lparen o on_comma scope on_rparen on_ignored_nl unless o on_period functor_expr on_period is_a? on_const on_op on_const on_nl fail on_lparen # Evaluation of CallMethodExpression handles a NamedAccessExpression functor (receiver.function_name) #
on_ignored_nl UNK on_op UNK on_lbracket on_int on_rbracket on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen on_nl if # the string function name
def UNK o on_comma scope on_nl scope on_period UNK do on_ignored_nl test on_op evaluate on_lparen o on_period left_expr on_comma scope # @example # $x ? { 10 => true, 20 => false, default => 0 } #
scope on_period UNK do on_ignored_nl test on_op evaluate on_lparen o on_period left_expr on_comma scope on_rparen on_nl on_ignored_nl the_default on_op nil # memo scope level before evaluating test - don't want a match in the case test to leak $n match vars # to expressions after the selector expression. #
evaluate on_lparen me on_comma scope on_rparen on_period UNK on_lbrace on_op v on_op UNK on_lparen test on_comma v on_comma me on_comma # not ideal for error reporting, since it is not known which unfolded result # that caused an error - the entire unfold expression is blamed (i.e. the var c, passed to is_match?)
def UNK o on_comma scope on_nl evaluate on_lparen o on_period expr on_comma scope on_rparen on_nl end on_nl on_ignored_nl def UNK # SubLocatable is simply an expression that holds location information
def UNK o on_comma scope on_nl expr on_op o on_period UNK on_nl result on_op evaluate on_lparen o on_period UNK on_comma # Evaluates Puppet DSL Heredoc
UNK on_lparen scope on_comma result on_comma o on_period UNK on_comma o on_period UNK on_rparen on_nl end on_nl result on_nl end # When expr is a LiteralString, validation has already validated this
def UNK o on_comma scope on_nl scope on_period UNK do on_ignored_nl if is_true? on_lparen evaluate on_lparen o on_period test on_comma # Evaluates Puppet DSL `if`
def UNK o on_comma scope on_nl scope on_period UNK do on_ignored_nl unless is_true? on_lparen evaluate on_lparen o on_period test on_comma # Evaluates Puppet DSL `unless`
def UNK o on_comma scope on_nl name on_op evaluate on_lparen o on_period expr on_comma scope on_rparen on_nl on_ignored_nl case name # Evaluates a variable (getting its value) # The evaluator is lenient; any expression producing a String is used as a name # of a variable. #
name on_op evaluate on_lparen o on_period expr on_comma scope on_rparen on_nl on_ignored_nl case name on_nl when on_const on_nl when on_const # Evaluator is not too fussy about what constitutes a name as long as the result # is a String and a valid variable name #
case name on_nl when on_const on_nl when on_const on_nl else on_ignored_nl fail on_lparen on_const on_op on_const on_comma o on_period expr # Should be caught by validation, but make this explicit here as well, or mysterious evaluation issues # may occur for some evaluation use cases.
def UNK o on_comma scope on_nl o on_period UNK on_period UNK on_lbrace on_op expr on_op string on_lparen evaluate on_lparen expr # Evaluates double quoted strings that may contain interpolation #
def UNK o on_comma scope on_nl if o on_period expr on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl string on_lparen # If the wrapped expression is a QualifiedName, it is taken as the name of a variable in scope. # Note that this is different from the 3.x implementation, where an initial qualified name # is accepted. (e.g. `"---${var + 1}---"` is legal. This implementation requires such concrete # syntax to be expressed in a model as `(TextExpression (+ (Variable var) 1)` - i.e. moving the decision to # the parser. # # Semantics; the result of an expression is turned into a string, nil is silently transformed to empty # string. # @return [String] the interpolated result #
on_const on_nl else on_ignored_nl o on_period to_s on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_rparen # optimized comparison 1.44 vs 1.95
def UNK on_lparen x on_comma y on_rparen on_ignored_nl case x on_nl when on_const on_nl y on_op case y on_nl when # Produces concatenation / merge of x and y. # # When x is an Array, y of type produces: # # * Array => concatenation `[1,2], [3,4] => [1,2,3,4]` # * Hash => concatenation of hash as array `[key, value, key, value, ...]` # * any other => concatenation of single value # # When x is a Hash, y of type produces: # # * Array => merge of array interpreted as `[key, value, key, value,...]` # * Hash => a merge, where entries in `y` overrides # * any other => error # # When x is a URI, y of type produces: # # * String => merge of URI interpreted x + URI(y) using URI merge semantics # * URI => merge of URI interpreted x + y using URI merge semantics # * any other => error # # When x is nil, an empty array is used instead. # # @note to concatenate an Array, nest the array - i.e. `[1,2], [[2,3]]` # # @overload concatenate(obj_x, obj_y) # @param obj_x [Object] object to wrap in an array and concatenate to; see other overloaded methods for return type # @param ary_y [Object] array to concatenate at end of `ary_x` # @return [Object] wraps obj_x in array before using other overloaded option based on type of obj_y # @overload concatenate(ary_x, ary_y) # @param ary_x [Array] array to concatenate to # @param ary_y [Array] array to concatenate at end of `ary_x` # @return [Array] new array with `ary_x` + `ary_y` # @overload concatenate(ary_x, hsh_y) # @param ary_x [Array] array to concatenate to # @param hsh_y [Hash] converted to array form, and concatenated to array # @return [Array] new array with `ary_x` + `hsh_y` converted to array # @overload concatenate (ary_x, obj_y) # @param ary_x [Array] array to concatenate to # @param obj_y [Object] non array or hash object to add to array # @return [Array] new array with `ary_x` + `obj_y` added as last entry # @overload concatenate(hsh_x, ary_y) # @param hsh_x [Hash] the hash to merge with # @param ary_y [Array] array interpreted as even numbered sequence of key, value merged with `hsh_x` # @return [Hash] new hash with `hsh_x` merged with `ary_y` interpreted as hash in array form # @overload concatenate(hsh_x, hsh_y) # @param hsh_x [Hash] the hash to merge to # @param hsh_y [Hash] hash merged with `hsh_x` # @return [Hash] new hash with `hsh_x` merged with `hsh_y` # @overload concatenate(uri_x, uri_y) # @param uri_x [URI] the uri to merge to # @param uri_y [URI] uri to merged with `uri_x` # @return [URI] new uri with `uri_x` merged with `uri_y` # @overload concatenate(uri_x, string_y) # @param uri_x [URI] the uri to merge to # @param string_y [String] string to merge with `uri_x` # @return [URI] new uri with `uri_x` merged with `string_y` # @raise [ArgumentError] when `xxx_x` is neither an Array nor a Hash # @raise [ArgumentError] when `xxx_x` is a Hash, and `xxx_y` is neither Array nor Hash. #
when on_const on_nl y on_op case y on_nl when on_const then y on_nl when on_const on_nl UNK on_op on_cvar on_period # new array with concatenation
UNK on_op on_cvar on_period infer on_lparen y on_rparen on_nl if UNK on_period UNK on_period is_a? on_const on_op on_const on_nl on_const # Hash[[a, 1, b, 2]] => {} # Hash[a,1,b,2] => {a => 1, b => 2} # Hash[[a,1], [b,2]] => {[a,1] => [b,2]} # Hash[[[a,1], [b,2]]] => {a => 1, b => 2} # Use type calculator to determine if array is Array[Array[?]], and if so use second form # of call
when on_const on_nl raise on_const on_period new on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen unless y on_period is_a? on_lparen # new hash with overwrite
def UNK on_lparen x on_comma y on_rparen on_ignored_nl result on_op x on_period UNK on_nl case x on_nl when on_const on_nl # Produces the result x \ y (set difference) # When `x` is an Array, `y` is transformed to an array and then all matching elements removed from x. # When `x` is a Hash, all contained keys are removed from x as listed in `y` if it is an Array, or all its keys if it is a Hash. # The difference is returned. The given `x` and `y` are not modified by this operation. # @raise [ArgumentError] when `x` is neither an Array nor a Hash #
def UNK on_lparen left on_comma right on_comma o on_comma UNK on_comma scope on_rparen on_ignored_nl on_cvar on_period UNK on_lparen left on_comma # Implementation of case option matching. # # This is the type of matching performed in a case option, using == for every type # of value except regular expression where a match is performed. #
def unfold on_lparen result on_comma UNK on_comma scope on_rparen on_ignored_nl UNK on_period UNK do on_op x on_op on_ignored_nl x on_op # Maps the expression in the given array to their product except for UnfoldExpressions which are first unfolded. # The result is added to the given result Array. # @param result [Array] Where to add the result (may contain information to add to) # @param array [Array[Model::Expression] the expressions to map # @param scope [Puppet::Parser::Scope] the scope to evaluate in # @return [Array] the given result array with content added from the operation #
