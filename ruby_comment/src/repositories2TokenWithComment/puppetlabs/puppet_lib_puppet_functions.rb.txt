UNK on_const on_op on_const on_nl def self on_period UNK on_lparen func_name on_comma function_base on_op on_const on_comma on_op block on_rparen on_ignored_nl # Functions in the puppet language can be written in Ruby and distributed in # puppet modules. The function is written by creating a file in the module's # `lib/puppet/functions/<modulename>` directory, where `<modulename>` is # replaced with the module's name. The file should have the name of the function. # For example, to create a function named `min` in a module named `math` create # a file named `lib/puppet/functions/math/min.rb` in the module. # # A function is implemented by calling {Puppet::Functions.create_function}, and # passing it a block that defines the implementation of the function. # # Functions are namespaced inside the module that contains them. The name of # the function is prefixed with the name of the module. For example, # `math::min`. # # @example A simple function # Puppet::Functions.create_function('math::min') do # def min(a, b) # a <= b ? a : b # end # end # # Anatomy of a function # --- # # Functions are composed of four parts: the name, the implementation methods, # the signatures, and the dispatches. # # The name is the string given to the {Puppet::Functions.create_function} # method. It specifies the name to use when calling the function in the puppet # language, or from other functions. # # The implementation methods are ruby methods (there can be one or more) that # provide that actual implementation of the function's behavior. In the # simplest case the name of the function (excluding any namespace) and the name # of the method are the same. When that is done no other parts (signatures and # dispatches) need to be used. # # Signatures are a way of specifying the types of the function's parameters. # The types of any arguments will be checked against the types declared in the # signature and an error will be produced if they don't match. The types are # defined by using the same syntax for types as in the puppet language. # # Dispatches are how signatures and implementation methods are tied together. # When the function is called, puppet searches the signatures for one that # matches the supplied arguments. Each signature is part of a dispatch, which # specifies the method that should be called for that signature. When a # matching signature is found, the corresponding method is called. # # Special dispatches designed to create error messages for an argument mismatch # can be added using the keyword `argument_mismatch` instead of `dispatch`. The # method appointed by an `argument_mismatch` will be called with arguments # just like a normal `dispatch` would, but the method must produce a string. # The string is then used as the message in the `ArgumentError` that is raised # when the method returns. A block parameter can be given, but it is not # propagated in the method call. # # Documentation for the function should be placed as comments to the # implementation method(s). # # @todo Documentation for individual instances of these new functions is not # yet tied into the puppet doc system. # # @example Dispatching to different methods by type # Puppet::Functions.create_function('math::min') do # dispatch :numeric_min do # param 'Numeric', :a # param 'Numeric', :b # end # # dispatch :string_min do # param 'String', :a # param 'String', :b # end # # def numeric_min(a, b) # a <= b ? a : b # end # # def string_min(a, b) # a.downcase <= b.downcase ? a : b # end # end # # @example Using an argument mismatch handler # Puppet::Functions.create_function('math::min') do # dispatch :numeric_min do # param 'Numeric', :a # param 'Numeric', :b # end # # argument_mismatch :on_error do # param 'Any', :a # param 'Any', :b # end # # def numeric_min(a, b) # a <= b ? a : b # end # # def on_error(a, b) # 'both arguments must be of type Numeric' # end # end # # Specifying Signatures # --- # # If nothing is specified, the number of arguments given to the function must # be the same as the number of parameters, and all of the parameters are of # type 'Any'. # # The following methods can be used to define a parameter # # - _param_ - the argument must be given in the call. # - _optional_param_ - the argument may be missing in the call. May not be followed by a required parameter # - _repeated_param_ - the type specifies a repeating type that occurs 0 to "infinite" number of times. It may only appear last or just before a block parameter. # - _block_param_ - a block must be given in the call. May only appear last. # - _optional_block_param_ - a block may be given in the call. May only appear last. # # The method name _required_param_ is an alias for _param_ and _required_block_param_ is an alias for _block_param_ # # A parameter definition takes 2 arguments: # - _type_ A string that must conform to a type in the puppet language # - _name_ A symbol denoting the parameter name # # Both arguments are optional when defining a block parameter. The _type_ defaults to "Callable" # and the _name_ to :block. # # Note that the dispatch definition is used to match arguments given in a call to the function with the defined # parameters. It then dispatches the call to the implementation method simply passing the given arguments on to # that method without any further processing and it is the responsibility of that method's implementor to ensure # that it can handle those arguments. # # @example Variable number of arguments # Puppet::Functions.create_function('foo') do # dispatch :foo do # param 'Numeric', :first # repeated_param 'Numeric', :values # end # # def foo(first, *values) # # do something # end # end # # There is no requirement for direct mapping between parameter definitions and the parameters in the # receiving implementation method so the following example is also legal. Here the dispatch will ensure # that `*values` in the receiver will be an array with at least one entry of type String and that any # remaining entries are of type Numeric: # # @example Inexact mapping or parameters # Puppet::Functions.create_function('foo') do # dispatch :foo do # param 'String', :first # repeated_param 'Numeric', :values # end # # def foo(*values) # # do something # end # end # # Access to Scope # --- # In general, functions should not need access to scope; they should be # written to act on their given input only. If they absolutely must look up # variable values, they should do so via the closure scope (the scope where # they are defined) - this is done by calling `closure_scope()`. # # Calling other Functions # --- # Calling other functions by name is directly supported via # {Puppet::Pops::Functions::Function#call_function}. This allows a function to # call other functions visible from its loader. # # @api public
def self on_period UNK on_lparen func_name on_comma function_base on_op on_const on_comma on_op block on_rparen on_ignored_nl begin on_ignored_nl loader on_op block # @param func_name [String, Symbol] a simple or qualified function name # @param block [Proc] the block that defines the methods and dispatch of the # Function to create # @return [Class<Function>] the newly created Function class # # @api public
begin on_ignored_nl loader on_op block on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_lparen func_name on_comma loader # Ruby < 2.1.0 does not have method on Binding, can only do eval # and it will fail unless protected with an if defined? if the local # variable does not exist in the block's binder. #
def self on_period UNK on_lparen func_name on_comma loader on_comma function_base on_op on_const on_comma on_op block on_rparen on_ignored_nl if function_base on_period # Creates a function in, or in a local loader under the given loader. # This method should only be used when manually creating functions # for the sake of testing. Functions that are autoloaded should # always use the `create_function` method and the autoloader will supply # the correct loader. # # @param func_name [String, Symbol] a simple or qualified function name # @param loader [Puppet::Pops::Loaders::Loader] the loader loading the function # @param block [Proc] the block that defines the methods and dispatch of the # Function to create # @return [Class<Function>] the newly created Function class # # @api public
the_class on_op on_const on_period new on_lparen function_base on_rparen on_nl on_ignored_nl unless loader on_period nil? on_nl the_class on_period UNK on_lparen on_symbeg # Creates an anonymous class to represent the function # The idea being that it is garbage collected when there are no more # references to it. # # (Do not give the class the block here, as instance variables should be set first)
the_class on_period instance_eval do on_ignored_nl on_ivar on_op func_name on_nl on_ignored_nl def name on_nl on_ivar on_nl end on_nl on_ignored_nl def loader # Make the anonymous class appear to have the class-name <func_name> # Even if this class is not bound to such a symbol in a global ruby scope and # must be resolved via the loader. # This also overrides any attempt to define a name method in the given block # (Since it redefines it) # # TODO, enforce name in lower case (to further make it stand out since Ruby # class names are upper case) #
the_class on_period UNK on_lparen on_op block on_rparen on_nl on_ignored_nl if the_class on_period dispatcher on_period UNK on_nl UNK on_op func_name on_period # The given block can now be evaluated and have access to name and loader #
if the_class on_period dispatcher on_period UNK on_nl UNK on_op func_name on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_lbracket on_op on_int # Automatically create an object dispatcher based on introspection if the # loaded user code did not define any dispatchers. Fail if function name # does not match a given method name in user code. #
the_class on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen the_class on_comma func_name on_rparen on_ignored_nl unless the_class on_period UNK on_lparen # The function class is returned as the result of the create function method
def self on_period UNK on_lparen the_class on_comma func_name on_rparen on_ignored_nl unless the_class on_period UNK on_lparen func_name on_rparen on_nl raise on_const # Creates a default dispatcher configured from a method with the same name as the function # # @api private
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl result on_op on_lbrace on_symbeg UNK on_op on_int on_comma on_symbeg UNK on_op on_int # @api private
names on_op UNK on_period UNK on_period UNK on_lbrace on_op UNK on_op result on_lbracket UNK on_lbracket on_int on_rbracket on_rbracket on_op on_int # count per parameter kind, and get array of names
def self on_period UNK on_lparen from on_comma to on_comma names on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_op on_const on_op # Construct a signature consisting of Object type, with min, and max, and given names. # (there is only one type entry). # # @api private
UNK on_op on_const on_op on_const on_op on_const on_op on_const on_period new on_lparen on_lbracket on_const on_op on_const on_op on_const on_op on_const # Construct the type for the signature # Tuple[Object, from, to]
class on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl def self on_period UNK on_nl on_const on_period new # Function # === # This class is the base class for all Puppet 4x Function API functions. A # specialized class is created for each puppet function. # # @api public
def self on_period UNK on_nl on_const on_period new on_lparen dispatcher on_comma on_const on_op on_const on_op on_const on_op on_const on_op on_const # @api private
def self on_period UNK on_lparen meth_name on_comma on_op block on_rparen on_ignored_nl UNK on_lparen on_rparen on_period instance_eval do on_ignored_nl UNK on_lparen # Dispatch any calls that match the signature to the provided method name. # # @param meth_name [Symbol] The name of the implementation method to call # when the signature defined in the block matches the arguments to a call # to the function. # @return [Void] # # @api public
def self on_period UNK on_lparen meth_name on_comma on_op block on_rparen on_ignored_nl UNK on_lparen on_rparen on_period instance_eval do on_ignored_nl UNK on_lparen # Like `dispatch` but used for a specific type of argument mismatch. Will not be include in the list of valid # parameter overloads for the function. # # @param meth_name [Symbol] The name of the implementation method to call # when the signature defined in the block matches the arguments to a call # to the function. # @return [Void] # # @api public
def self on_period UNK on_lparen on_op block on_rparen on_ignored_nl if loader on_period nil? on_nl raise on_const on_comma _ on_lparen on_tstring_beg # Allows types local to the function to be defined to ease the use of complex types # in a 4.x function. Within the given block, calls to `type` can be made with a string # 'AliasType = ExistingType` can be made to define aliases. The defined aliases are # available for further aliases, and in all dispatchers. # # @since 4.5.0 # @api public #
UNK on_period UNK on_period UNK do on_op UNK on_op on_ignored_nl t on_op on_const on_op on_const on_op on_const on_op on_const on_period # Add the loaded types to the builder
t on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_comma UNK on_period loader on_rparen on_nl on_ignored_nl # Bind the type alias to the local_loader using the alias
UNK on_lparen on_tstring_beg on_tstring_content UNK t on_period name UNK on_tstring_end on_rparen on_lbrace t on_rbrace on_nl end on_nl on_ivar on_op UNK # Also define a method for convenient access to the defined type alias. # Since initial capital letter in Ruby means a Constant these names use a prefix of # `type`. As an example, the type 'MyType' is accessed by calling `type_MyType`.
on_ivar on_op UNK on_period loader on_nl end on_nl on_ignored_nl def self on_period new on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK # Store the loader in the class
def self on_period new on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_lparen UNK on_comma on_ivar on_op UNK on_rparen on_nl end # Creates a new function instance in the given closure scope (visibility to variables), and a loader # (visibility to other definitions). The created function will either use the `given_loader` or # (if it has local type aliases) a loader that was constructed from the loader used when loading # the function's class. # # TODO: It would be of value to get rid of the second parameter here, but that would break API. #
class on_const on_op on_const on_nl def self on_period UNK on_lparen UNK on_rparen on_ignored_nl dispatcher on_period UNK on_lparen UNK on_rparen on_nl # Base class for all functions implemented in the puppet language
dispatcher on_period UNK on_lparen UNK on_rparen on_nl end on_nl end on_nl on_ignored_nl on_ignored_nl class on_const on_nl UNK on_symbeg loader on_nl # A closure is compatible with a dispatcher - they are both callable signatures
class on_const on_nl UNK on_symbeg loader on_nl on_ignored_nl def UNK on_lparen dispatcher on_comma UNK on_comma loader on_rparen on_ignored_nl on_ivar on_op # Public api methods of the DispatcherBuilder are available within dispatch() # blocks declared in a Puppet::Function.create_function() call. # # @api public
def UNK on_lparen dispatcher on_comma UNK on_comma loader on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op dispatcher on_nl on_ivar on_op # @api private
def UNK on_lparen type on_comma name on_rparen on_ignored_nl UNK on_lparen type on_comma name on_rparen on_nl raise on_const on_comma _ on_lparen # Defines a required positional parameter with _type_ and _name_. # # @param type [String] The type specification for the parameter. # @param name [Symbol] The name of the parameter. This is primarily used # for error message output and does not have to match an implementation # method parameter. # @return [Void] # # @api public
def UNK on_lparen type on_comma name on_rparen on_ignored_nl UNK on_lparen type on_comma name on_rparen on_nl on_ivar on_op on_int on_nl end # Defines an optional positional parameter with _type_ and _name_. # May not be followed by a required parameter. # # @param type [String] The type specification for the parameter. # @param name [Symbol] The name of the parameter. This is primarily used # for error message output and does not have to match an implementation # method parameter. # @return [Void] # # @api public
def UNK on_lparen type on_comma name on_rparen on_ignored_nl UNK on_lparen type on_comma name on_comma UNK on_rparen on_nl on_ivar on_op on_symbeg # Defines a repeated positional parameter with _type_ and _name_ that may occur 0 to "infinite" number of times. # It may only appear last or just before a block parameter. # # @param type [String] The type specification for the parameter. # @param name [Symbol] The name of the parameter. This is primarily used # for error message output and does not have to match an implementation # method parameter. # @return [Void] # # @api public
def UNK on_lparen type on_comma name on_rparen on_ignored_nl UNK on_lparen type on_comma name on_comma UNK on_rparen on_nl raise on_const on_comma # Defines a repeated positional parameter with _type_ and _name_ that may occur 1 to "infinite" number of times. # It may only appear last or just before a block parameter. # # @param type [String] The type specification for the parameter. # @param name [Symbol] The name of the parameter. This is primarily used # for error message output and does not have to match an implementation # method parameter. # @return [Void] # # @api public
def UNK on_lparen on_op type_and_name on_rparen on_ignored_nl UNK type_and_name on_period UNK on_nl UNK on_int on_nl type on_op on_ivar on_nl name # Defines one required block parameter that may appear last. If type and name is missing the # default type is "Callable", and the name is "block". If only one # parameter is given, then that is the name and the type is "Callable". # # @api public
def UNK on_lparen on_op type_and_name on_rparen on_ignored_nl UNK on_lparen on_op type_and_name on_rparen on_nl on_ivar on_op on_const on_op on_const on_op on_const # Defines one optional block parameter that may appear last. If type or name is missing the # defaults are "any callable", and the name is "block". The implementor of the dispatch target # must use block = nil when it is optional (or an error is raised when the call is made). # # @api public
UNK on_lparen on_op type_and_name on_rparen on_nl on_ivar on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_rparen # same as required, only wrap the result in an optional type
def return_type on_lparen type on_rparen on_ignored_nl unless type on_period is_a? on_lparen on_const on_rparen on_op type on_period is_a? on_lparen on_const on_op # Defines the return type. Defaults to 'Any' # @param [String] type a reference to a Puppet Data Type # # @api public
def UNK on_lparen type on_comma name on_comma UNK on_op UNK on_rparen on_ignored_nl raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end # @api private
if UNK on_nl on_ivar on_op on_op on_ivar on_period UNK on_lparen on_rparen on_nl UNK on_ignored_nl on_ivar on_op on_ivar on_period UNK on_lparen # mark what should be picked for this position when dispatching
def UNK on_lparen meth_name on_comma UNK on_comma on_op block on_rparen on_ignored_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op on_lbracket on_rbracket # @api private
on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op on_lbracket on_rbracket on_nl # an array of either an index into names/types, or an array with # injection information [type, name, injection_name] used when the call # is being made to weave injections into the given arguments. #
def UNK on_lparen UNK on_comma UNK on_comma return_type on_comma from on_comma to on_rparen on_ignored_nl UNK on_op UNK on_period UNK do # Handles creation of a callable type from strings specifications of puppet # types and allows the min/max occurs of the given types to be given as one # or two integer values at the end. The given block_type should be # Optional[Callable], Callable, or nil. # # @api private
class on_const on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg loader on_nl on_ignored_nl def UNK on_lparen loader on_comma name # The LocalTypeAliasBuilder is used by the 'local_types' method to collect the individual # type aliases given by the function's author. #
on_ivar on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen on_rparen on_nl end on_nl on_ignored_nl def type on_lparen # get the shared parser used by puppet's compiler
def type on_lparen UNK on_rparen on_ignored_nl rb_location on_op UNK on_lparen on_int on_comma on_int on_rparen on_period UNK on_nl begin on_ignored_nl result # Defines a local type alias, the given string should be a Puppet Language type alias expression # in string form without the leading 'type' keyword. # Calls to local_type must be made before the first parameter definition or an error will # be raised. # # @param assignment_string [String] a string on the form 'AliasType = ExistingType' # @api public #
rb_location on_op UNK on_lparen on_int on_comma on_int on_rparen on_period UNK on_nl begin on_ignored_nl result on_op UNK on_period UNK on_lparen on_tstring_beg # Get location to use in case of error - this produces ruby filename and where call to 'type' occurred # but strips off the rest of the internal "where" as it is not meaningful to user. #
raise on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_ignored_nl on_label UNK on_comma # Create a meaningful location for parse errors - show both what went wrong with the parsing # and in which ruby file it was found.
class on_const on_op on_const on_nl def self on_period UNK on_nl on_const on_period new on_lparen dispatcher on_comma on_const on_op on_const on_op # @note WARNING: This style of creating functions is not public. It is a system # under development that will be used for creating "system" functions. # # This is a private, internal, system for creating functions. It supports # everything that the public function definition system supports as well as a # few extra features such as injection of well known parameters. # # @api private
def self on_period UNK on_nl on_const on_period new on_lparen dispatcher on_comma on_const on_op on_const on_op on_const on_op on_const on_op on_const # @api private
def UNK on_lparen scope on_comma UNK on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl UNK on_lparen scope on_comma UNK on_comma # Allows the implementation of a function to call other functions by name and pass the caller # scope. The callable functions are those visible to the same loader that loaded this function # (the calling function). # # @param scope [Puppet::Parser::Scope] The caller scope # @param function_name [String] The name of the function # @param *args [Object] splat of arguments # @return [Object] The result returned by the called function # # @api public
on_const on_op on_lbracket on_ignored_nl on_lbracket on_rbracket on_comma on_ignored_nl on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_rbracket on_period freeze on_comma on_ignored_nl on_lbracket # Table of optimized parameter names - 0 to 5 parameters
def self on_period UNK on_lparen func_name on_comma UNK on_comma loader on_rparen on_ignored_nl func_name on_op func_name on_period UNK on_nl on_ignored_nl the_class # Creates an anonymous Function3x class that wraps a 3x function # # @api private
the_class on_op on_const on_period new on_lparen on_const on_rparen on_nl on_ignored_nl unless loader on_period nil? on_nl the_class on_period UNK on_lparen on_symbeg # Creates an anonymous class to represent the function # The idea being that it is garbage collected when there are no more # references to it. # # (Do not give the class the block here, as instance variables should be set first)
the_class on_period instance_eval do on_ignored_nl def name on_nl on_ivar on_nl end on_nl on_ignored_nl def loader on_nl on_ivar on_nl end on_nl # Make the anonymous class appear to have the class-name <func_name> # Even if this class is not bound to such a symbol in a global ruby scope and # must be resolved via the loader. # This also overrides any attempt to define a name method in the given block # (Since it redefines it) #
the_class on_period UNK do on_ignored_nl on_ignored_nl def UNK on_lparen scope on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl begin on_ignored_nl # Add the method that is called - it simply delegates to # the 3.x function by calling it via the calling scope using the @method3x symbol # :"function_#{name}". # # When function is not an rvalue function, make sure it produces nil #
def UNK on_lparen scope on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl begin on_ignored_nl result on_op UNK on_lparen on_symbeg UNK # Bypasses making the call via the dispatcher to make sure errors # are reported exactly the same way as in 3x. The dispatcher is still needed as it is # used to support other features than calling. #
UNK scope on_period UNK on_lparen self on_period class on_period UNK on_comma UNK on_rparen on_nl end on_nl UNK result on_period UNK # this is the scope.function_xxx(...) call
type on_comma names on_op on_const on_op on_const on_period UNK on_lparen on_op UNK on_lparen UNK on_rparen on_rparen on_nl UNK on_op on_lparen # Create a dispatcher based on func_info
the_class on_period dispatcher on_period UNK on_lparen on_const on_op on_const on_op on_const on_op on_const on_period new on_lparen type on_comma on_tstring_beg on_tstring_content # The method '3x_function' here is a dummy as the dispatcher is not used for calling, only for information.
the_class on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_rparen on_ignored_nl arity on_op UNK on_lbracket on_symbeg arity on_rbracket # The function class is returned as the result of the create function method
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl arity on_op UNK on_lbracket on_symbeg arity on_rbracket on_nl if arity on_period nil? # Compute min and max number of arguments and a list of constructed # parameter names p0 - pn (since there are no parameter names in 3x functions). # # @api private
to on_op on_symbeg default UNK on_op on_op arity UNK on_ignored_nl UNK on_op from on_op to on_op arity on_nl end on_nl # arity -1 is 0 min param, -2 is min 1 param
UNK on_op on_op arity UNK on_ignored_nl UNK on_op from on_op to on_op arity on_nl end on_nl names on_op UNK on_op # infinite range
UNK on_ignored_nl UNK on_op from on_op to on_op arity on_nl end on_nl names on_op UNK on_op on_int on_op on_const on_lbracket # the number of named parameters
names on_op UNK on_op on_int on_op on_const on_lbracket UNK on_rbracket on_op on_lparen on_int on_op UNK on_op on_int on_rparen on_period UNK # Names of parameters, up to 5 are optimized and use frozen version # Note that (0..count-1) produces expected empty array for count == 0, 0-n for count >= 1
class on_const on_op on_const on_nl def UNK on_nl inject on_lparen on_symbeg scope on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # Injection and Weaving of parameters # --- # It is possible to inject and weave a set of well known parameters into a call. # These extra parameters are not part of the parameters passed from the Puppet # logic, and they can not be overridden by parameters given as arguments in the # call. They are invisible to the Puppet Language. # # @example using injected parameters # Puppet::Functions.create_function('test') do # dispatch :test do # param 'Scalar', 'a' # param 'Scalar', 'b' # scope_param # end # def test(a, b, scope) # a > b ? scope['a'] : scope['b'] # end # end # # The function in the example above is called like this: # # test(10, 20) # # @api private
def UNK on_nl inject on_lparen on_symbeg scope on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl inject on_lparen on_symbeg UNK on_rparen # Inject parameter for `Puppet::Parser::Scope`
def UNK on_nl inject on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl inject on_lparen on_symbeg UNK on_rparen # Inject parameter for `Puppet::Pal::ScriptCompiler`
def UNK on_nl inject on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl inject on_lparen on_symbeg UNK on_rparen # Inject a parameter getting a cached hash for this function
def UNK on_nl inject on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl inject on_lparen on_symbeg UNK on_rparen # Inject parameter for `Puppet::Pal::CatalogCompiler`
def UNK on_nl inject on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def inject on_lparen UNK on_rparen # Inject parameter for either `Puppet::Pal::CatalogCompiler` or `Puppet::Pal::ScriptCompiler`
on_ivar on_op on_lbracket on_ivar on_period UNK on_lparen on_rparen on_op on_int on_rbracket on_nl end on_nl end on_nl end on_nl EMP EMP # mark what should be picked for this position when dispatching
