class on_const on_op on_const on_op on_const on_nl class on_const on_nl UNK on_symbeg ssl_context on_nl on_ignored_nl def initialize on_lparen machine on_comma # This class implements a state machine for bootstrapping a host's CA and CRL # bundles, private key and signed client certificate. Each state has a frozen # SSLContext that it uses to make network connections. If a state makes progress # bootstrapping the host, then the state will generate a new frozen SSLContext # and pass that to the next state. For example, the NeedCACerts state will load # or download a CA bundle, and generate a new SSLContext containing those CA # certs. This way we're sure about which SSLContext is being used during any # phase of the bootstrapping process. # # @private
class on_const on_op on_const on_nl def initialize on_lparen machine on_rparen on_ignored_nl UNK on_lparen machine on_comma nil on_rparen on_nl on_ivar on_op # Load existing CA certs or download them. Transition to NeedCRLs. #
next_ctx on_op on_ivar on_period UNK on_lparen on_label cacerts on_comma on_label UNK on_rparen on_nl on_ivar on_period UNK on_lparen cacerts on_rparen on_nl # verify cacerts before saving
class on_const on_op on_const on_nl def next_state on_nl on_const on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK on_const # If revocation is enabled, load CRLs or download them, using the CA bundle # from the previous state. Transition to NeedKey. Even if Puppet[:certificate_revocation] # is leaf or chain, disable revocation when downloading the CRL, since 1) we may # not have one yet or 2) the connection will fail if NeedCACerts downloaded a new CA # for which we don't have a CRL #
on_ivar on_period UNK on_op now on_nl next_ctx on_op UNK on_lparen next_ctx on_comma last_update on_rparen on_nl end on_nl end on_nl else # set last updated time first, then make a best effort to refresh
UNK on_lparen ssl_ctx on_comma last_update on_rparen on_nl rescue on_const on_op on_const on_op on_const on_op e on_nl if e on_period response # return the next_ctx containing the updated crl
ssl_ctx on_nl rescue on_const on_op on_const on_op on_const on_op e on_nl on_const on_period UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end # return the original ssl_ctx
ssl_ctx on_nl end on_nl on_ignored_nl def UNK on_lparen ssl_ctx on_comma last_update on_rparen on_ignored_nl route on_op on_ivar on_period session on_period UNK # return the original ssl_ctx
next_ctx on_op on_ivar on_period UNK on_lparen on_label ssl_ctx on_lbracket on_symbeg cacerts on_rbracket on_comma on_label crls on_rparen on_nl on_ivar on_period UNK # verify crls before saving
class on_const on_op on_const on_nl def next_state on_nl on_const on_period debug on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl # Load or generate a private key. If the key exists, try to load the client cert # and transition to Done. If the cert is mismatched or otherwise fails valiation, # raise an error. If the key doesn't exist yet, generate one, and save it. If the # cert doesn't exist yet, transition to NeedSubmitCSR. #
class on_const on_op on_const on_nl UNK on_symbeg UNK on_nl on_ignored_nl def initialize on_lparen machine on_comma ssl_context on_comma UNK on_rparen on_ignored_nl # Base class for states with a private key. #
class on_const on_op on_const on_nl def next_state on_nl on_const on_period debug on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl # Generate and submit a CSR using the CA cert bundle and optional CRL bundle # from earlier states. If the request is submitted, proceed to NeedCert, # otherwise Wait. This could be due to the server already having a CSR # for this host (either the same or different CSR content), having a # signed certificate, or a revoked certificate. #
class on_const on_op on_const on_nl def next_state on_nl on_const on_period debug on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl # Attempt to load or retrieve our signed cert. #
next_ctx on_op on_ivar on_period UNK on_lparen on_ignored_nl on_label on_ivar on_period cacerts on_comma on_label on_ivar on_period crls on_comma on_label on_ivar on_comma # verify client cert before saving
class on_const on_op on_const on_nl def initialize on_lparen machine on_rparen on_ignored_nl UNK on_lparen machine on_comma nil on_rparen on_nl end on_nl # We cannot make progress, so wait if allowed to do so, or exit. #
on_const on_period UNK on_lbracket on_symbeg UNK on_rbracket on_period UNK on_nl on_ivar on_period session on_op on_const on_period UNK on_lbracket on_symbeg UNK # close persistent connections and session state before sleeping
class on_const on_op on_const on_nl def initialize on_lparen machine on_rparen on_ignored_nl UNK on_lparen machine on_comma nil on_rparen on_nl end on_nl # Acquire the ssl lock or return LockFailure causing us to exit. #
on_const on_period new on_lparen on_ivar on_rparen on_nl else on_ignored_nl on_const on_period new on_lparen on_ivar on_comma nil on_rparen on_nl end on_nl # our ssl directory may have been cleaned while we were # sleeping, start over from the top
class on_const on_op on_const UNK end on_nl on_ignored_nl class on_const on_op on_const on_nl UNK on_symbeg message on_comma on_symbeg UNK on_nl # We failed to acquire the lock, so exit #
class on_const on_op on_const on_nl UNK on_symbeg message on_comma on_symbeg UNK on_nl on_ignored_nl def initialize on_lparen machine on_comma message on_comma # We cannot make progress due to an error. #
class on_const on_op on_const UNK end on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK # We have a CA bundle, optional CRL bundle, a private key and matching cert # that chains to one of the root certs in our bundle. #
def initialize on_lparen on_label on_const on_lbracket on_symbeg UNK on_rbracket on_comma on_ignored_nl on_label on_const on_lbracket on_symbeg UNK on_rbracket on_comma on_ignored_nl on_label # Construct a state machine to manage the SSL initialization process. By # default, if the state machine encounters an exception, it will log the # exception and wait for `waitforcert` seconds and retry, restarting from the # beginning of the state machine. # # However, if `onetime` is true, then the state machine will raise the first # error it encounters, instead of waiting. Otherwise, if `waitforcert` is 0, # then then state machine will exit instead of wait. # # @param waitforcert [Integer] how many seconds to wait between attempts # @param maxwiatforcert [Integer] maximum amount of second # @param onetime [Boolean] whether to run onetime # @param lockfile [Puppet::Util::Pidlock] lockfile to protect against # concurrent modification by multiple processes # @param cert_provider [Puppet::X509::CertProvider] cert provider to use # to load and save X509 objects. # @param ssl_provider [Puppet::SSL::SSLProvider] ssl provider to use # to construct ssl contexts. # @param digest [String] digest algorithm to use for certificate fingerprinting # @param ca_fingerprint [String] optional fingerprint to verify the # downloaded CA bundle
def UNK on_nl UNK on_op UNK on_lparen on_const on_period new on_lparen UNK on_rparen on_comma on_const on_rparen on_nl UNK on_period ssl_context # Run the state machine for CA certs and CRLs. # # @return [Puppet::SSL::SSLContext] initialized SSLContext # @raise [Puppet::Error] If we fail to generate an SSLContext
def UNK on_nl UNK on_op UNK on_lparen on_const on_period new on_lparen UNK on_rparen on_comma on_const on_rparen on_nl ssl_context on_op UNK # Run the state machine for CA certs and CRLs. # # @return [Puppet::SSL::SSLContext] initialized SSLContext # @raise [Puppet::Error] If we fail to generate an SSLContext
UNK on_period UNK on_period UNK UNK on_op cert on_comma UNK on_op on_ignored_nl digest on_op on_const on_op on_const on_op on_const on_period # print from root to client
end on_nl end on_nl on_ignored_nl state on_nl UNK on_ignored_nl on_ivar on_period UNK if on_ivar on_period UNK on_nl end on_nl on_ignored_nl # fall through
