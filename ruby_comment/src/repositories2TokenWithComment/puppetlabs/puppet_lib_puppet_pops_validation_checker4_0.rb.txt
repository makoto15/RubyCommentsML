UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg acceptor # A Validator validates a model. # # Validation is performed on each model element in isolation. Each method should validate the model element's state # but not validate its referenced/contained elements except to check their validity in their respective role. # The intent is to drive the validation with a tree iterator that visits all elements in a model. # # # TODO: Add validation of multiplicities - this is a general validation that can be checked for all # Model objects via their metamodel. (I.e an extra call to multiplicity check in polymorph check). # This is however mostly valuable when validating model to model transformations, and is therefore T.B.D #
on_ivar on_op on_const on_period new on_lparen nil on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_int on_comma on_int on_rparen on_nl end on_nl on_ignored_nl # Class instance variable rather than Class variable because methods visited # may be overridden in subclass
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen on_rparen on_nl on_cvar on_op on_const on_period new on_lparen nil on_comma on_tstring_beg on_tstring_content # Initializes the validator with a diagnostics producer. This object must respond to # `:will_accept?` and `:accept`. #
on_ivar on_op on_lparen on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_lbrace on_const on_op on_const on_period new on_lparen on_rparen on_rbrace on_rparen # Use null migration checker unless given in context
def UNK on_lparen model on_rparen on_ignored_nl on_ivar on_op on_lbracket on_rbracket on_nl UNK on_lparen model on_rparen on_nl UNK on_lparen model on_rparen # Validates the entire model by visiting each model element and calling `check`. # The result is collected (or acted on immediately) by the configured diagnostic provider/acceptor # given when creating this Checker. #
on_ivar on_op on_lbracket on_rbracket on_nl UNK on_lparen model on_rparen on_nl UNK on_lparen model on_rparen on_nl model on_period UNK on_lparen on_ivar # tree iterate the model, and call check for each element
def UNK on_lparen o on_rparen on_ignored_nl on_ivar on_period UNK on_lparen self on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK # Performs regular validity check
def UNK on_lparen o on_comma semantic on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_comma semantic on_rparen on_nl end # Performs check if this is a vaid hostname expression # @param single_feature_name [String, nil] the name of a single valued hostname feature of the value's container. e.g. 'parent'
def UNK on_lparen o on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK # Performs check if this is valid as a query
def UNK on_lparen o on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_rparen on_nl end on_nl on_ignored_nl def rvalue # Performs check if this is valid as a relationship side
def rvalue on_lparen o on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_rparen on_nl end on_nl on_ignored_nl def top # Performs check if this is valid as a rvalue
def top on_lparen definition on_comma UNK on_op on_op on_int on_rparen on_ignored_nl o on_op container on_lparen UNK on_rparen on_nl UNK on_op #---TOP CHECK # Performs check if this is valid as a container of a definition (class, define, node)
when on_const on_op on_const on_nl UNK on_op container on_lparen UNK on_rparen on_nl if on_op UNK on_period is_a? on_lparen on_const on_op # ok, stop scanning parents
acceptor on_period accept on_lparen on_const on_op on_const on_comma definition on_rparen on_nl else on_ignored_nl top on_lparen definition on_comma UNK on_rparen on_nl # not ok. These can never be nested in a block
top on_lparen definition on_comma UNK on_rparen on_nl end on_nl when on_const on_op on_const on_nl acceptor on_period accept on_lparen on_const on_op # ok, if this is a block representing the body of a class, or is top level
acceptor on_period accept on_lparen on_const on_op on_const on_comma definition on_rparen on_nl else on_ignored_nl acceptor on_period accept on_lparen on_const on_op on_const # A LambdaExpression is a BlockExpression, and this check is needed to prevent the polymorph method for BlockExpression # to accept a lambda. # A lambda can not iteratively create classes, nodes or defines as the lambda does not have a closure.
acceptor on_period accept on_lparen on_const on_op on_const on_comma definition on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen o # fail, reached a container that is not top level
def UNK on_lparen o on_comma via_index on_op false on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_comma via_index on_rparen # Checks the LHS of an assignment (is it assignable?). # If args[0] is true, assignment via index is checked. #
def idem on_lparen o on_rparen on_ignored_nl on_cvar on_period UNK on_lparen self on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK # Checks if the expression has side effect ('idem' is latin for 'the same', here meaning that the evaluation state # is known to be unchanged after the expression has been evaluated). The result is not 100% authoritative for # negative answers since analysis of function behavior is not possible. # @return [Boolean] true if expression is known to have no effect on evaluation state #
def UNK on_lparen o on_rparen on_ignored_nl if o on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl UNK on_op o on_period # Returns the last expression in a block, or the expression, if that expression is idem
on_ignored_nl def UNK on_lparen o on_comma via_index on_rparen on_ignored_nl UNK on_op UNK on_lparen o on_period expr on_rparen on_nl if UNK #---ASSIGNMENT CHECKS
if acceptor on_period UNK on_const on_op on_const on_nl if UNK on_op UNK on_tstring_content UNK on_nl acceptor on_period accept on_lparen on_const # Can not assign to something in another namespace (i.e. a '::' in the name is not legal)
end on_nl on_ignored_nl def UNK on_lparen o on_comma via_index on_rparen on_ignored_nl if acceptor on_period UNK on_const on_op on_const on_nl acceptor # TODO: Could scan for reassignment of the same variable if done earlier in the same container # Or if assigning to a parameter (more work).
if acceptor on_period UNK on_const on_op on_const on_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl else # Are indexed assignments allowed at all ? $x[x] = '...'
UNK on_lparen o on_period left_expr on_comma true on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma via_index # Then the left expression must be assignable-via-index
acceptor on_period accept on_lparen via_index on_op on_const on_op on_const on_op on_const on_op on_const on_comma o on_rparen on_nl end on_nl on_ignored_nl # Can not assign to anything else (differentiate if this is via index or not) # i.e. 10 = 'hello' vs. 10['x'] = 'hello' (the root is reported as being in error in both cases) #
on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl UNK on_lparen o on_period #---CHECKS
if o on_period keys on_period size on_op on_int on_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl # Only min range is checked, all other checks are RT checks as they depend on the resulting type # of the LHS.
def UNK on_lparen o on_rparen on_ignored_nl if o on_period operator on_op on_tstring_beg on_tstring_content on_tstring_end on_nl p on_op container on_nl unless # Checks that operation with :+> is contained in a ResourceOverride or Collector. # # Parent of an AttributeOperation can be one of: # * CollectExpression # * ResourceOverride # * ResourceBody (ILLEGAL this is a regular resource expression) # * ResourceDefaults (ILLEGAL) #
p on_op container on_nl unless p on_period is_a? on_lparen on_const on_op on_const on_rparen on_op p on_period is_a? on_lparen on_const on_op # Append operator use is constrained
p on_op container on_nl case p on_nl when on_const on_op on_const on_nl when on_const on_op on_const on_nl when on_const on_op # Append operator use is constrained
UNK on_op p on_period nil? on_op o on_op container on_lparen on_op on_int on_rparen on_nl unless UNK on_period is_a? on_lparen on_const # protect against just testing a snippet that has no parent, error message will be a bit strange # but it is not for a real program.
end on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl UNK on_op o on_period UNK # only flag the first
return nil on_nl end on_nl case UNK on_nl when on_const on_op on_const on_nl nil on_nl when on_const on_op on_const on_nl # ok (a call to a type)
nil on_nl when on_const on_op on_const on_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl else on_ignored_nl # ok
acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl else on_ignored_nl acceptor on_period accept on_lparen on_const on_op on_const # helpful to point out this easy to make Epp error
expr on_op o on_period UNK on_nl if expr on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl UNK on_lparen nil on_comma # Only syntax check static text in heredoc during validation - dynamic text is validated by the evaluator.
UNK on_op false on_nl o on_period UNK on_period each do on_op UNK on_op on_ignored_nl UNK on_period values on_period each do # There can only be one LiteralDefault case option value
acceptor on_period accept on_lparen on_const on_op on_const on_comma value on_comma on_symbeg container on_op o on_rparen if UNK on_nl UNK on_op # Flag the second default as 'unreachable'
def UNK on_lparen o on_rparen on_ignored_nl name on_op o on_period UNK on_nl unless name on_period is_a? on_const on_op on_const on_nl # Only used for function names, grammar should not be able to produce something faulty, but # check anyway if model is created programmatically (it will fail in transformation to AST for sure).
def UNK on_lparen o on_rparen on_ignored_nl top on_lparen o on_rparen on_nl if o on_period name on_op on_const on_op on_const on_nl # for 'class', 'define', and function
if UNK on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl UNK on_op UNK on_period left_expr on_nl if UNK on_period is_a? # Not Runtime
keys on_op UNK on_period keys on_nl on_ignored_nl lhs_type on_op on_int if keys on_period size on_op on_int on_op UNK on_lparen keys # Runtime
lhs_type on_op on_int if keys on_period size on_op on_int on_op UNK on_lparen keys on_lbracket on_int on_rbracket on_rparen on_nl end on_nl # Must be a literal string or pattern replacement
acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl else on_ignored_nl UNK on_op o on_period UNK on_nl if # This is not a TypeMapping. Something other than Runtime[] on LHS
acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl # TODO: Check TypeDefinition body. For now, just error out
on_ignored_nl file_namespace on_op UNK on_lparen file on_rparen on_nl return if file_namespace on_op on_const on_nl on_ignored_nl if file_namespace on_op on_const on_op #e.g. puppet apply -e '...'
if file_namespace on_op on_const on_op on_op o on_period name on_period UNK on_period UNK on_lparen file_namespace on_rparen on_nl acceptor on_period accept # Downcasing here because check is case-insensitive
file on_op prog on_period UNK on_period file on_nl return if file on_period nil? on_nl return if UNK on_lparen file on_rparen #Check that this is a module autoloaded file
on_ignored_nl if on_lparen body on_period is_a? on_lparen on_const on_op on_const on_rparen on_rparen on_nl body on_period statements on_period each on_lbrace on_op #Ignore empty or comment-only files
UNK on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_symbeg file_to_namespace on_nl end # @api private
on_ignored_nl path on_op on_const on_period new on_lparen file on_rparen on_nl on_ignored_nl return adapter on_period file_to_namespace on_lbracket file on_rbracket on_op on_const # No cache entry, so we do the calculation
UNK on_op UNK on_lparen path on_comma UNK on_period UNK on_rparen on_nl on_ignored_nl return adapter on_period file_to_namespace on_lbracket file on_rbracket on_op #All auto-loaded files from modules come from a module search path dir
names on_op UNK on_lparen UNK on_rparen on_nl on_ignored_nl return adapter on_period file_to_namespace on_lbracket file on_rbracket on_op on_lparen names on_op on_const #If a file comes from a module, but isn't in the right place, always error
path_components on_op UNK on_period to_s on_period UNK on_period UNK on_lparen on_const on_op on_const on_rparen on_nl on_ignored_nl UNK on_op path_components on_lbracket # Downcasing here because check is case-insensitive
UNK on_op path_components on_lbracket on_int on_rbracket on_nl on_ignored_nl return on_const unless UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_op on_tstring_beg # Example definition dir: manifests in this path: # <module name>/manifests/<module subdir>/<classfile>.pp
return on_const unless UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_op on_tstring_beg on_tstring_content on_tstring_end # How can we get this result? # If it is not an initial manifest, it must come from a module, # and from the manifests dir there. This may never get used...
names on_period UNK on_lparen path_components on_lbracket on_int on_rbracket on_rparen on_ignored_nl UNK on_op path_components on_lbracket on_op on_int on_rbracket on_nl if on_op # Directories inside module
on_ignored_nl UNK on_op path_components on_lbracket on_op on_int on_rbracket on_nl if on_op on_lparen path_components on_period UNK on_op on_int on_op UNK on_op # Name of the module itself
UNK on_op path_components on_lbracket on_op on_int on_rbracket on_nl if on_op on_lparen path_components on_period UNK on_op on_int on_op UNK on_op on_tstring_beg # Do not include name of module init file at top level of module # e.g. <module name>/manifests/init.pp
end on_nl on_ignored_nl names on_nl end on_nl on_ignored_nl on_const on_op on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op true on_comma on_ignored_nl on_tstring_beg # Remove .pp from filename
end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl UNK on_lparen o on_rparen on_nl UNK on_lparen o on_rparen on_nl end # In case there are additional things to forbid than non-rvalues # acceptor.accept(Issues::ILLEGAL_EXPRESSION, o.key, :feature => 'hash key', :container => container)
UNK on_op on_const on_period new on_nl o on_period UNK on_period each do on_op UNK on_op on_ignored_nl UNK on_lparen on_symbeg UNK # the keys of a literal hash may be non-literal expressions. They cannot be checked.
UNK on_lparen o on_period UNK on_comma o on_rparen on_nl top on_lparen o on_rparen on_nl violator on_op UNK on_lparen o on_period # Check that hostnames are valid hostnames (or regular expressions)
def UNK on_lparen o on_rparen on_ignored_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl if o on_period UNK on_op # No checking takes place - all expressions using a QualifiedName need to check. This because the # rules are slightly different depending on the container (A variable allows a numeric start, but not # other names). This means that (if the lexer/parser so chooses) a QualifiedName # can be anything when it represents a Bare Word and evaluates to a String. #
def UNK on_lparen o on_rparen on_ignored_nl if o on_period UNK on_op on_const on_op on_const on_nl acceptor on_period accept on_lparen on_const # Checks that the value is a valid UpperCaseWord (a CLASSREF), and optionally if it contains a hypen. # DOH: QualifiedReferences are created with LOWER CASE NAMES at parse time
if o on_period UNK on_op on_const on_op on_const on_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_comma on_lbrace # Is this a valid qualified name?
end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl rvalue on_lparen o on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # is optional
o on_period UNK on_lbrace on_op model on_op UNK on_lparen model on_rparen on_rbrace unless o on_period is_a? on_lparen on_const on_op on_const # recursively check all contents unless it's a lambda expression. A lambda may contain # local assignments
on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl UNK on_lparen o on_period left_expr on_rparen on_nl UNK on_lparen o on_period UNK on_rparen #relationship_side: resource # | resourceref # | collection # | variable # | quotedtext # | selector # | casestatement # | hasharrayaccesses
UNK on_op o on_period UNK on_nl if o on_period UNK on_op o on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_op UNK # The expression for type name cannot be statically checked - this is instead done at runtime # to enable better error message of the result of the expression rather than the static instruction. # (This can be revised as there are static constructs that are illegal, but require updating many # tests that expect the detailed reporting).
UNK on_op o on_period UNK on_period UNK on_lbrace on_op v on_op v on_period UNK on_period is_a? on_lparen on_const on_op on_const # There can only be one LiteralDefault case option value
acceptor on_period accept on_lparen on_const on_op on_const on_comma UNK on_lbracket on_int on_rbracket on_period UNK on_comma on_symbeg container on_op o on_rparen # Flag the second default as 'unreachable'
end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl UNK on_op o on_period expr on_nl return if UNK on_period is_a? # TODO: Unless may not have an else part that is an IfExpression (grammar denies this though)
def UNK on_lparen o on_rparen on_ignored_nl UNK on_op o on_period expr on_nl return if UNK on_period is_a? on_lparen on_const on_op # Checks that variable is either strictly 0, or a non 0 starting decimal number, or a valid VAR_NAME
UNK on_op o on_period expr on_nl return if UNK on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl if on_op UNK # The expression must be a qualified name or an integer
name on_op o on_period expr on_period value on_nl if name on_lbracket on_int on_comma on_int on_rbracket on_op UNK on_tstring_content UNK on_nl # name must be either a decimal string value, or a valid NAME
on_ignored_nl def UNK on_lparen o on_comma semantic on_rparen on_ignored_nl o on_period each on_lbrace on_op UNK on_op UNK on_lparen UNK on_comma #--- HOSTNAME CHECKS
def UNK on_lparen o on_comma semantic on_rparen on_ignored_nl o on_period each on_lbrace on_op UNK on_op UNK on_lparen UNK on_comma semantic # Transforms Array of host matching expressions into a (Ruby) array of AST::HostName
if o on_op on_const on_op on_const on_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma semantic on_comma on_symbeg UNK on_op # The 3.x checker only checks for illegal characters - if matching /[^-\w.]/ the name is invalid, # but this allows pathological names like "a..b......c", "----" # TODO: Investigate if more illegal hostnames should be flagged. #
UNK on_op o on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period is_a? on_lparen on_const on_op on_const on_rparen on_rbrace # Puppet 3.1. only accepts a concatenated string without interpolated expressions
acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl else on_ignored_nl UNK on_lparen o on_period UNK on_lbracket on_int # corner case, bad model, concatenation of several plain strings
UNK on_lparen o on_period UNK on_lbracket on_int on_rbracket on_comma o on_period UNK on_lbracket on_int on_rbracket on_rparen on_nl end on_nl end # corner case, may be ok, but lexer may have replaced with plain string, this is # here if it does not
end on_nl on_ignored_nl def UNK on_lparen o on_comma semantic on_rparen on_ignored_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma semantic # always ok
end on_nl on_ignored_nl def UNK on_lparen o on_comma semantic on_rparen on_ignored_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma semantic # always ok
end on_nl on_ignored_nl def UNK on_lparen o on_comma semantic on_rparen on_ignored_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o # always ok
on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl end on_nl #---QUERY CHECKS
def UNK on_lparen o on_rparen on_ignored_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen on_nl end on_nl on_ignored_nl # Anything not explicitly allowed is flagged as error.
def UNK on_lparen o on_rparen on_ignored_nl acceptor on_period accept on_lparen on_const on_op on_const on_comma o on_rparen unless on_lbracket on_tstring_beg on_tstring_content # Puppet AST only allows == and != #
def UNK on_lparen o on_rparen on_ignored_nl UNK o on_period left_expr on_nl UNK o on_period UNK on_nl end on_nl on_ignored_nl def # Allows AND, OR, and checks if left/right are allowed in query.
on_ignored_nl def UNK on_lparen o on_rparen on_semicolon end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl acceptor on_period accept on_lparen #---RVALUE CHECKS
def UNK on_lparen o on_rparen on_semicolon end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl acceptor on_period accept on_lparen on_const # By default, all expressions are reported as being rvalues # Implement specific rvalue checks for those that are not. #
def UNK on_lparen o on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl true on_nl end #--IDEM CHECK
end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl # can have side effect of setting $n match variables
false on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def UNK on_lparen o # Always side effect
false on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl true on_nl end on_nl on_ignored_nl def UNK on_lparen o # Always side effect
def UNK on_lparen o on_rparen on_ignored_nl true on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl idem on_lparen o # Handles UnaryMinusExpression, NotExpression, VariableExpression
def UNK on_lparen o on_rparen on_ignored_nl idem on_lparen o on_period expr on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o # Allow (no-effect parentheses) to be used around a productive expression
on_op o on_period statements on_period UNK on_lbrace on_op expr on_op on_op idem on_lparen expr on_rparen on_rbrace on_nl end on_nl on_ignored_nl # productive if there is at least one productive expression
def UNK on_lparen o on_rparen on_ignored_nl true on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl true on_nl end # Returns true even though there may be interpolated expressions that have side effect. # Report as idem anyway, as it is very bad design to evaluate an interpolated string for its # side effect only.
def UNK on_lparen o on_rparen on_ignored_nl true on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl true on_nl end # Heredoc is just a string, but may contain interpolated string (which may have side effects). # This is still bad design and should be reported as idem.
def UNK on_lparen o on_rparen on_ignored_nl true on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl false on_nl end # May technically have side effects inside the Selector, but this is bad design - treat as idem
def UNK on_lparen o on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl on_lbracket o on_period # An apply expression exists purely for the side effect of applying a # catalog somewhere, so it always has side effects
def UNK on_lparen o on_rparen on_ignored_nl return false if on_op idem on_lparen o on_period UNK on_rparen on_nl on_op o on_period # Case expression is idem, if test, and all options are idem
def UNK on_lparen o on_rparen on_ignored_nl return false if o on_period values on_period UNK on_lbrace on_op value on_op on_op idem # An option is idem if values and the then_expression are idem
on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl case o on_nl when on_const on_op on_const on_nl o on_period value on_nl when #--- NON POLYMORPH, NON CHECKING CODE
def UNK on_lparen o on_rparen on_ignored_nl case o on_nl when on_const on_op on_const on_nl o on_period value on_nl when on_const # Produces string part of something named, or nil if not a QualifiedName or QualifiedReference #
