UNK on_const on_op on_const on_nl def self on_period UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_lparen UNK on_comma UNK # @api public
def really_instance? on_lparen o on_comma guard on_op UNK on_rparen on_ignored_nl if on_ivar on_period nil? on_nl on_const on_period UNK on_period really_instance? # @api private
if on_ivar on_period UNK on_lparen value on_rparen on_op on_lparen on_ivar on_op on_op on_ivar on_period UNK on_lparen value on_rparen on_op on_ivar # If there is a single argument that matches the array, then that gets priority over # expanding the array into all arguments
if on_ivar on_period UNK on_lparen on_const on_rparen on_op on_ivar on_period UNK on_lparen on_const on_rparen on_op on_ivar on_period UNK on_lparen on_const # Filter out types that will provide a new_function but are unsuitable to be contained in Init # # Calling Init#new would cause endless recursion # The Optional is the same as Variant[T,Undef]. # The NotUndef is not meaningful to create instances of
UNK on_op on_lbracket on_ivar on_rbracket on_nl on_ignored_nl if on_ivar on_period UNK on_nl UNK on_comma UNK on_op param_tuples on_period UNK on_lbrace # An instance of the contained type is always a match to this type.
UNK on_comma UNK on_op param_tuples on_period UNK on_lbrace on_op tuple on_op on_const on_op tuple on_period UNK on_rbrace on_nl UNK on_period # A value that is assignable to the type of a single parameter is also a match
param_tuples on_op param_tuples on_period UNK do on_op tuple on_op on_ignored_nl UNK on_comma UNK on_op tuple on_period UNK on_nl if UNK # disqualify all parameter tuples that doesn't allow one value (type unknown at ths stage) + init args.
tuple on_period assignable? on_lparen on_const on_period new on_lparen tuple on_period UNK on_lbracket on_int on_op on_int on_rbracket on_period UNK on_lparen UNK # Aside from the first parameter, does the other parameters match?
