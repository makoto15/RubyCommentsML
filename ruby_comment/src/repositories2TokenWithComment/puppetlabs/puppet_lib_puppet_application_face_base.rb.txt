UNK on_const on_op on_const on_lbracket on_symbeg help on_comma on_symbeg UNK on_rbracket on_period help on_lparen face on_period name on_comma action on_period # Only invoke help on the action if it was specified, not if # it was the default action.
if UNK on_period UNK on_op on_int on_nl result on_op UNK on_period UNK on_lparen result on_comma on_op UNK on_rparen on_nl else # when defining when_rendering on your action you can optionally # include arguments and options
on_ignored_nl on_ivar on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_period UNK on_period name on_period UNK on_period sub # We need to parse enough of the command line out early, to identify what # the action is, so that we can obtain the full set of options to parse.
on_ivar on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_period UNK on_period name on_period UNK on_period sub on_lparen # REVISIT: These should be configurable versions, through a global # '--version' option, but we don't implement that yet... --daniel 2011-03-29
action_name on_op UNK on_nl index on_op on_op on_int on_nl UNK action_name UNK on_lparen index on_op on_int on_rparen on_op UNK on_period # Now, walk the command line and identify the action. We skip over # arguments based on introspecting the action and all, and find the first # non-option word to use as the action.
if option on_period UNK UNK on_op item on_period index on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl index on_op on_int unless on_ignored_nl # If we have an inline argument, just carry on. We don't need to # care about optional vs mandatory in that case because we do a real # parse later, and that will totally take care of raising the error # when we get there. --daniel 2011-04-04
index on_op on_int unless item on_op on_regexp_beg on_tstring_content UNK option on_period name UNK on_tstring_content on_regexp_end on_nl end on_nl else on_ignored_nl # As far as I can tell, we treat non-bool options as always having # a mandatory argument. --daniel 2011-04-05 # ... But, the mandatory argument will not be the next item if an = is # employed in the long form of the option. --jeffmccune 2012-09-18
action_name on_op item on_period UNK on_nl on_ivar on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_period name on_comma action_name on_rparen # Stash away the requested action name for later, and try to fetch the # action object it represents; if this is an invalid action name that # will be nil, and handled later.
UNK on_ignored_nl UNK on_nl UNK on_const on_op on_const on_nl end on_nl on_ignored_nl face on_op on_ivar on_period name on_nl action on_op # First try to handle global command line options # But ignoring invalid options as this is a invalid action, and # we want the error message for that instead.
on_ivar on_period UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op on_ivar on_period UNK on_lparen UNK on_rparen UNK on_period # Now we can interact with the default option code to build behaviour # around the full set of options we now know we support.
UNK on_period UNK on_period option on_lparen on_op UNK on_period UNK on_rparen end on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl def # make it the object.
end on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen item on_rparen on_ignored_nl on_const on_period UNK on_period UNK do # ...and make the CLI parse it.
UNK on_nl end on_nl on_ignored_nl def UNK on_lparen item on_rparen on_ignored_nl on_const on_period UNK on_period UNK do on_op name on_comma # ...and invoke our parent to parse all the command line options.
UNK on_op on_regexp_beg on_tstring_content UNK UNK on_period sub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen on_period sub on_lparen on_regexp_beg # sadly, we have to emulate some of optparse here...
end on_nl on_ignored_nl def UNK on_lparen item on_rparen on_ignored_nl UNK on_period UNK on_period UNK on_period UNK do on_op UNK on_comma # nothing found.
end on_nl on_ignored_nl def UNK on_nl on_const on_op on_const on_op on_const on_period UNK on_symbeg UNK on_nl on_ignored_nl on_ivar on_op UNK # not found
on_ivar on_period UNK on_lparen on_int on_rparen unless on_ivar on_nl on_ignored_nl on_ivar on_op UNK on_nl on_ignored_nl UNK on_period render_as on_op on_lparen # Note: because of our definition of where the action is set, we end up # with it *always* being the first word of the remaining set of command # line arguments. So, strip that off when we construct the arguments to # pass down to the face action. --daniel 2011-04-04 # Of course, now that we have default actions, we should leave the # "action" name on if we didn't actually consume it when we found our # action.
on_ivar on_op UNK on_nl on_ignored_nl UNK on_period render_as on_op on_lparen on_ivar on_period render_as on_op on_symbeg UNK on_rparen on_nl end on_nl # We copy all of the app options to the end of the call; This allows each # action to read in the options. This replaces the older model where we # would invoke the action with options set as global state in the # interface object. --daniel 2011-03-28
UNK on_period render_as on_op on_lparen on_ivar on_period render_as on_op on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl on_ignored_nl def UNK on_nl # If we don't have a rendering format, set one early.
unless on_ivar on_nl UNK on_const on_op on_const on_lbracket on_symbeg help on_comma on_symbeg UNK on_rbracket on_period help on_lparen on_ivar on_period name # Call the method associated with the provided action (e.g., 'find').
if on_lparen UNK on_op on_ivar on_period UNK on_rparen on_op on_int on_nl unless on_lparen UNK on_op UNK on_period UNK on_rparen on_op # We need to do arity checking here because this is generic code # calling generic methods â€“ that have argument defaulting. We need to # make sure we don't accidentally pass the options as the first # argument to a method that takes one argument. eg: # # puppet facts find # => options => {} # @arguments => [{}] # => @face.send :bar, {} # # def face.bar(argument, options = {}) # => bar({}, {}) # oops! we thought the options were the # # positional argument!! # # We could also fix this by making it mandatory to pass the options on # every call, but that would make the Ruby API much more annoying to # work with; having the defaulting is a much nicer convention to have. # # We could also pass the arguments implicitly, by having a magic # 'options' method that was visible in the scope of the action, which # returned the right stuff. # # That sounds attractive, but adds complications to all sorts of # things, especially when you think about how to pass options when you # are writing Ruby code that calls multiple faces. Especially if # faces are involved in that. ;) # # --daniel 2011-04-27
UNK on_const on_op UNK on_nl UNK on_op UNK on_period UNK on_nl on_ignored_nl UNK on_op UNK on_nl on_const on_period UNK on_lparen # We need an easy way for the action to set a specific exit code, so we # rescue SystemExit here; This allows each action to set the desired exit # code by simply calling Kernel::exit. eg: # # exit(2) # # --kelsey 2012-02-14
