on_ignored_nl on_const on_period UNK on_period UNK on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl # Provides utility functions to help interface Puppet to SELinux. # # This requires the very new SELinux Ruby bindings. These bindings closely # mirror the SELinux C library interface. # # Support for the command line tools is not provided because the performance # was abysmal. At this time (2008-11-02) the only distribution providing # these Ruby SELinux bindings which I am aware of is Fedora (in libselinux-ruby).
on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl def UNK on_period selinux_support? on_nl # check, but continue even if it's not
def UNK on_lparen file on_rparen on_ignored_nl return nil unless selinux_support? on_nl retval on_op on_const on_period UNK on_lparen file on_rparen on_nl # Retrieve and return the full context of the file. If we don't have # SELinux support or if the SELinux call fails then return nil.
def UNK on_lparen file on_rparen on_ignored_nl return nil unless selinux_support? on_nl return nil unless UNK on_lparen file on_rparen on_nl UNK # Retrieve and return the default context of the file. If we don't have # SELinux support or if the SELinux call fails to file a default then return nil.
return nil unless UNK on_lparen file on_rparen on_nl UNK on_ignored_nl UNK on_op UNK on_lparen file on_rparen on_nl UNK on_op UNK # If the filesystem has no support for SELinux labels, return a default of nil # instead of what matchpathcon would return
UNK on_ignored_nl UNK on_op UNK on_lparen file on_rparen on_nl UNK on_op UNK on_period UNK on_nl UNK on_const on_op on_const on_comma # If the file exists we should pass the mode to matchpathcon for the most specific # matching. If not, we can pass a mode of 0.
def UNK on_lparen UNK on_comma context on_rparen on_ignored_nl if context on_period UNK UNK context on_op on_tstring_beg on_tstring_content on_tstring_end on_nl return # Take the full SELinux context returned from the tools and parse it # out to the three (or four) component parts. Supports :seluser, :selrole, # :seltype, and on systems with range support, :selrange.
def UNK on_lparen file on_comma value on_comma UNK on_op UNK on_rparen on_ignored_nl return nil unless selinux_support? on_op UNK on_lparen file # This updates the actual SELinux label on the file. You can update # only a single component or update the entire context. # The caveat is that since setting a partial context makes no sense the # file has to already exist. Puppet (via the File resource) will always # just try to set components, even if all values are specified by the manifest. # I believe that the OS should always provide at least a fall-through context # though on any well-running system.
context on_op on_const on_period UNK on_lparen file on_rparen on_lbracket on_int on_rbracket on_nl if context on_op on_op on_int on_nl on_const on_period # Must first get existing context to replace a single component
on_const on_period UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl return nil on_nl end on_nl context on_op context on_period UNK # We can't set partial context components when no context exists # unless/until we can find a way to make Puppet call this method # once for all selinux file label attributes.
def UNK on_lparen file on_rparen on_ignored_nl UNK on_op UNK on_lparen file on_rparen on_nl return nil unless UNK on_nl UNK on_op # Since this call relies on get_selinux_default_context it also needs a # full non-relative path to the file. Fortunately, that seems to be all # Puppet uses. This will set the file's SELinux context to the policy's # default context (if any) if it differs from the context currently on # the file.
def UNK on_lparen UNK on_rparen on_ignored_nl on_ignored_nl path on_op on_const on_period UNK on_nl UNK on_ignored_nl on_const on_period UNK on_lparen path ## # selinux_category_to_label is an internal method that converts all # selinux categories to their internal representation, avoiding # potential issues when mcstransd is not functional. # # It is not marked private because it is needed by File's # selcontext.rb, but it is not intended for use outside of Puppet's # code. # # @param category [String] An selinux category, such as "s0" or "SystemLow" # # @return [String] the numeric category name, such as "s0"
on_ignored_nl path on_op on_const on_period UNK on_nl UNK on_ignored_nl on_const on_period UNK on_lparen path on_rparen on_period UNK UNK on_op line # We don't cache this, but there's already a ton of duplicate work # in the selinux handling code.
line on_period UNK on_lparen UNK on_tstring_content UNK on_comma on_tstring_beg on_tstring_end on_rparen on_nl UNK on_op line on_period UNK on_lparen on_tstring_beg on_tstring_content # skip comments
UNK on_nl on_ignored_nl def UNK on_lparen file on_rparen on_ignored_nl UNK on_op UNK on_lparen file on_rparen on_nl return UNK if UNK ######################################################################## # Internal helper methods from here on in, kids. Don't fiddle.
def UNK on_lparen file on_rparen on_ignored_nl UNK on_op UNK on_lparen file on_rparen on_nl return UNK if UNK on_period UNK on_nl # Check filesystem a path resides on for SELinux support against # whitelist of known-good filesystems. # Returns true if the filesystem can support SELinux labels and # false if not.
def UNK on_nl mounts on_op on_tstring_beg on_tstring_end on_nl UNK on_ignored_nl if on_const on_period UNK on_tstring_beg on_tstring_content on_tstring_end on_nl mountfh on_op # Internal helper function to read and parse /proc/mounts
mountfh on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK UNK on_ignored_nl mounts on_op mountfh on_period UNK on_lparen # If possible we use read_nonblock in a loop rather than read to work- # a linux kernel bug. See ticket #1963 for details.
mountfh on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl mounts on_op mountfh on_period UNK on_nl end on_nl UNK # Otherwise we shell out and let cat do it for us
UNK on_nl return nil on_nl UNK on_ignored_nl mountfh on_period UNK if mountfh on_nl end on_nl on_ignored_nl UNK on_op UNK UNK # that's expected
mounts on_period UNK UNK on_op line on_op on_ignored_nl UNK on_op line on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK # Read all entries in /proc/mounts. The second column is the # mountpoint and the third column is the filesystem type. # We skip rootfs because it is always mounted at /
def UNK on_lparen path on_rparen on_ignored_nl mounts on_op UNK on_nl return nil unless mounts on_nl on_ignored_nl path on_op on_const on_lparen # Internal helper function to return which type of filesystem a given file # path resides on
path on_op on_const on_lparen path on_rparen on_period UNK on_nl unless path on_period UNK on_nl UNK on_const on_op on_const on_comma _ # cleanpath eliminates useless parts of the path (like '.', or '..', or # multiple slashes), without touching the filesystem, and without # following symbolic links. This gives the right (logical) tree to follow # while we try and figure out what file-system the target lives on.
path on_period UNK UNK on_op UNK on_op on_ignored_nl return mounts on_lbracket UNK on_period UNK on_rbracket if mounts on_period UNK on_lparen # Now, walk up the tree until we find a match for that path in the hash.
return mounts on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl end on_nl on_ignored_nl def UNK on_lparen path on_rparen on_ignored_nl on_const on_op on_const # Should never be reached...
def UNK on_lparen path on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_lparen path on_rparen on_nl end on_nl UNK on_symbeg UNK ## # file_lstat is an internal, private method to allow precise stubbing and # mocking without affecting the rest of the system. # # @return [File::Stat] File.lstat result
