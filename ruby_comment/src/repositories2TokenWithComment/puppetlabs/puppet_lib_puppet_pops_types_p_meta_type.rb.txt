UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op UNK UNK UNK on_period UNK on_nl on_const on_op UNK # @abstract base class for PObjectType and other types that implements lazy evaluation of content # @api private
end on_nl on_ignored_nl def UNK on_lparen UNK on_comma guard on_rparen on_ignored_nl UNK on_lparen UNK on_comma guard on_rparen on_nl UNK on_nl # Abstract type. It doesn't register anything
def UNK on_lparen loader on_rparen on_ignored_nl UNK on_ivar on_period UNK on_nl on_ivar on_op loader on_nl on_ivar on_op UNK on_ignored_nl init_hash_expression # Called from the TypeParser once it has found a type using the Loader. The TypeParser will # interpret the contained expression and the resolved type is remembered. This method also # checks and remembers if the resolve type contains self recursion. # # @param type_parser [TypeParser] type parser that will interpret the type expression # @param loader [Loader::Loader] loader to use when loading type aliases # @return [PTypeAliasType] the receiver of the call, i.e. `self` # @api private
on_ignored_nl init_hash_expression on_op on_ivar on_nl on_ivar on_op UNK on_nl UNK init_hash_expression on_period UNK on_lparen on_const on_op on_const on_rparen on_nl UNK # assumed while it being found out below
guard on_op on_const on_period UNK on_nl UNK on_lparen on_const on_op on_const on_comma guard on_rparen on_nl on_ivar on_op guard on_period UNK # Find out if this type is recursive. A recursive type has performance implications # on several methods and this knowledge is used to avoid that for non-recursive # types.
def UNK on_nl on_const on_period UNK on_period UNK on_lparen UNK on_rparen on_nl end on_nl end on_nl end on_nl end on_nl # Returns the expanded string the form of the alias, e.g. <alias name> = <resolved type> # # @return [String] the expanded form of this alias # @api public
