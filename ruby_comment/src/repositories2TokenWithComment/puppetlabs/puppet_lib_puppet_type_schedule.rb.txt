UNK do on_op values on_op on_ignored_nl values on_op on_lbracket values on_rbracket unless values on_period is_a? on_lparen on_const on_rparen on_nl values # This is lame; properties all use arrays as values, but parameters don't. # That's going to hurt eventually.
value on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_period each on_lbrace on_op UNK on_op on_ignored_nl range on_op UNK on_period UNK # Split each range value into a hour, minute, second triad
range on_op UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_lbrace on_op n on_op n on_period UNK on_rbrace # Add the values as an array.
range on_period each do on_op UNK on_op on_ignored_nl on_lparen on_int on_op UNK on_period UNK on_rparen on_period UNK on_lbrace on_op _ # Fill out 0s for unspecified minutes and seconds
on_lbracket range on_lbracket on_int on_rbracket on_lbracket on_int on_rbracket on_comma range on_lbracket on_int on_rbracket on_lbracket on_int on_rbracket on_rbracket on_period each do # Make sure the hours are valid
ret on_nl end on_nl on_ignored_nl def UNK on_lparen day on_rparen on_ignored_nl if on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_lbracket # Now our array of arrays
on_ivar on_op on_lbracket on_ivar on_rbracket unless on_ivar on_lbracket on_int on_rbracket on_lbracket on_int on_rbracket on_period is_a? on_lparen on_const on_rparen on_nl on_ivar # The lowest-level array is of the hour, minute, second triad # then it's an array of two of those, to present the limits # then it's an array of those ranges
now on_period UNK on_lparen UNK on_comma UNK on_rparen on_op UNK on_lparen now on_period wday on_rparen on_nl else on_ignored_nl UNK on_op # The whole range is in one day, simple case
UNK on_op on_const on_period UNK on_lparen now on_period UNK on_comma now on_period month on_comma now on_period day on_rparen on_nl UNK # The range spans days. We have to test against a range starting # today, and a range that started yesterday.
if now on_period UNK on_lparen UNK on_comma on_const on_period UNK on_lparen UNK on_period UNK on_comma UNK on_period month on_comma UNK # First check a range starting today
now on_period UNK on_lparen on_const on_period UNK on_lparen UNK on_period UNK on_comma UNK on_period month on_comma UNK on_period day on_comma # Then check a range starting yesterday
UNK on_period wday on_op now on_period wday UNK on_lparen now on_op UNK on_rparen on_op on_lparen on_int on_op on_int on_op on_int # Run the resource if the previous day was after this weekday (e.g., prev is wed, current is tue) # or if it's been more than a week since we ran
return now on_period UNK on_lparen UNK on_rparen on_op previous on_period UNK on_lparen UNK on_rparen on_nl end on_nl UNK on_symbeg UNK # We negate it, because if they're equal we don't run
return on_lparen now on_period UNK on_op previous on_period UNK on_rparen on_op on_lparen UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_rparen # If the number of seconds between the two times is greater # than the unit of time, we match. We divide the scale # by the repeat, so that we'll repeat that often within # the scale.
return unless on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl if value on_op on_int UNK on_ivar on_lbracket on_symbeg UNK on_rbracket on_op # This implicitly assumes that 'periodmatch' is distance -- that # is, if there's no value, we assume it's a valid value.
return true if on_ivar on_lbracket on_symbeg range on_rbracket on_nl on_ignored_nl return true if value on_period UNK on_lparen now on_period wday # Special case weekday matching with ranges to a no-op here. # If the ranges span days then we can't simply match the current # weekday, as we want to match the weekday as it was when the range # started. As a result, all of that logic is in range, not here.
on_ivar on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_op on_symbeg UNK on_rbrace on_period UNK on_period values on_period each # And then one for every period
previous on_op on_const on_period UNK on_lparen previous on_rparen on_nl on_ignored_nl now on_op on_const on_period now on_nl on_ignored_nl self on_period UNK # If we've got a value, then convert it to a Time instance
self on_period UNK on_period UNK on_period each on_lbrace on_op UNK on_op on_ignored_nl if on_ivar on_period UNK on_lparen UNK on_rparen UNK # Pull them in order
true on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # If we haven't returned false, then return true; in other words, # any provided schedules need to all match
