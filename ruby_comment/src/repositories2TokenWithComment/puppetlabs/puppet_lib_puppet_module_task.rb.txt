def self on_period UNK on_lparen path on_rparen on_ignored_nl UNK on_op on_const on_period basename on_lparen path on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Determine whether a file has a legal name for either a task's executable or metadata file.
name on_op on_tstring_beg UNK UNK on_period name UNK UNK path on_period UNK on_lparen UNK on_period path on_rparen on_period UNK UNK # This gets the path from the starting point onward # For files this should be the file subpath from the metadata # For directories it should be the directory subpath plus whatever we globbed # Partition matches on the first instance it finds of the parameter
def self on_period UNK on_lparen metadata on_comma UNK on_op UNK on_rparen on_ignored_nl return on_lbracket on_rbracket if metadata on_period UNK on_nl # Find task's required lib files and retrieve paths for both 'files' and 'implementation:files' metadata keys
UNK on_op on_tstring_beg on_tstring_end on_nl on_ignored_nl pup_module on_op on_const on_op on_const on_period UNK on_lparen UNK on_comma UNK on_rparen on_nl if # If there's a mount directory with no trailing slash this will be nil # We want it to be empty to construct a path
def self on_period UNK on_lparen name on_comma UNK on_comma metadata on_comma executables on_rparen on_ignored_nl basename on_op name on_period UNK on_lparen # Executables list should contain the full path of all possible implementation files
metadata on_op on_lbrace on_rbrace on_nl if metadata on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl unless metadata on_lbracket on_tstring_beg on_tstring_content # If 'implementations' is defined, it needs to mention at least one # implementation, and everything it mentions must exist.
implementations on_op executables on_period UNK on_lbrace on_op impl on_op on_const on_period basename on_lparen impl on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op # If implementations isn't defined, then we use executables matching the # task name, and only one may exist.
UNK on_lparen name on_comma UNK on_comma metadata on_comma executables on_rparen on_op UNK on_lparen metadata on_comma UNK on_rparen on_nl end on_nl # PXP agent relies on 'impls' (which is the task file) being first if there is no metadata
def UNK on_lparen pup_module on_comma task_name on_comma module_executables on_comma UNK on_op UNK on_rparen on_ignored_nl if on_op on_const on_op on_const on_op # file paths must be relative to the modules task directory
def self on_period UNK on_lparen path on_rparen on_ignored_nl return on_const on_period basename on_lparen path on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Abstracted here so we can add support for subdirectories later
