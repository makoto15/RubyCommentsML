class on_op self on_nl UNK on_symbeg UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content # JJM: Dive into the singleton_class
UNK on_symbeg UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_symbeg # JJM: This allows us to pass information when calling # Puppet::Type.type # e.g. Puppet::Type.type(:user).provide :directoryservice, :ds_path => "Users" # This is referenced in the get_ds_path class method
def self on_period UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def ds_to_ns_attribute_map UNK self on_period class on_period ds_to_ns_attribute_map # There is no generalized mechanism for provider cache management, but we can # use post_resource_eval, which will be run for each suitable provider at the # end of each transaction. Use this to clear @all_present after each run.
def ds_to_ns_attribute_map UNK self on_period class on_period ds_to_ns_attribute_map UNK end on_nl def self on_period ds_to_ns_attribute_map on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content # JJM 2007-07-25: This map is used to map NameService attributes to their # corresponding DirectoryService attribute names. # See: http://images.apple.com/server/docs.Open_Directory_v10.4.pdf # JJM: Note, this is de-coupled from the Puppet::Type, and must # be actively maintained. There may also be collisions with different # types (Users, Groups, Mounts, Hosts, etc...)
def ns_to_ds_attribute_map UNK self on_period class on_period ns_to_ds_attribute_map end on_nl def self on_period ns_to_ds_attribute_map on_nl on_ivar on_op ds_to_ns_attribute_map on_period UNK # JJM The same table as above, inverted.
UNK on_op on_lbracket on_symbeg name on_rbracket on_op on_ivar on_period UNK on_nl on_ignored_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl # JJM Class method that provides an array of instance objects of this # type. # JJM: Properties are dependent on the Puppet::Type we're managing.
UNK on_period UNK do on_op UNK on_op on_ignored_nl self on_period UNK on_lparen UNK on_lparen UNK on_comma on_op UNK on_rparen on_rparen # Create a new instance of this Puppet::Type for each object present # on the system.
UNK on_ivar if UNK on_lparen on_ivar on_rparen on_nl on_ivar on_period name on_period UNK on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl # JJM: 2007-07-24 This method dynamically returns the DS path we're concerned with. # For example, if we're working with an user type, this will be /Users # with a group type, this will be /Groups. # @ds_path is an attribute of the class itself.
on_ivar on_period name on_period UNK on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def self on_period UNK on_nl # JJM: "Users" or "Groups" etc ... (Based on the Puppet::Type) # Remember this is a class method, so self.class is Class # Also, @resource_type seems to be the reference to the # Puppet::Type this class object is providing for.
begin on_ignored_nl dscl_output on_op execute on_lparen get_exec_preamble on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl rescue on_const on_op on_const on_nl fail # JJM: List all objects of this Puppet::Type already present on the system.
UNK on_symbeg UNK on_comma on_symbeg UNK on_nl begin on_ignored_nl ds_value on_op on_const on_lparen ds_value on_lbracket on_int on_rbracket on_rparen on_nl rescue # only members uses arrays so far
begin on_ignored_nl ds_value on_op on_const on_lparen ds_value on_lbracket on_int on_rbracket on_rparen on_nl rescue on_const on_nl ds_value on_op ds_value on_lbracket on_int # OS X stores objects like uid/gid as strings. # Try casting to an integer for these cases to be # consistent with the other providers and the group type # validation
attribute_hash on_lbracket on_symbeg UNK on_rbracket on_op self on_period UNK on_lparen attribute_hash on_lbracket on_symbeg guid on_rbracket on_comma attribute_hash on_lbracket on_symbeg name # NBK: need to read the existing password here as it's not actually # stored in the user record. It is stored at a path that involves the # UUID of the user record for non-Mobile local accounts. # Mobile Accounts are out of scope for this provider for now
on_ignored_nl UNK on_op UNK on_nl on_ignored_nl UNK UNK UNK UNK on_period include? resource_name on_nl on_ignored_nl UNK on_op get_exec_preamble on_lparen on_tstring_beg # JJM 2007-07-24: # Given a the name of an object and a list of properties of that # object, return all property values in a hash. # # This class method returns nil if the object doesn't exist # Otherwise, it returns a hash of the object properties.
UNK UNK UNK UNK on_period include? resource_name on_nl on_ignored_nl UNK on_op get_exec_preamble on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma resource_name on_rparen on_nl # NBK: shortcut the process if the resource is missing
on_ignored_nl UNK on_op on_lbracket UNK on_lparen on_symbeg UNK on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ignored_nl # JJM 2007-07-24 # DSCL commands are often repetitive and contain the same positional # arguments over and over. See https://developer.apple.com/documentation/Porting/Conceptual/PortingUnix/additionalfeatures/chapter_10_section_9.html # for an example of what I mean. # This method spits out proper DSCL commands for us. # We EXPECT name to be @resource[:name] when called from an instance object.
UNK on_op UNK on_nl if resource_name on_nl UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg resource_name on_embexpr_end on_tstring_end on_nl # JJM: The actual action to perform. See "man dscl". # Common actions: -create, -delete, -merge, -append, -passwd
if resource_name on_nl UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg resource_name on_embexpr_end on_tstring_end on_nl else on_ignored_nl UNK on_op # JJM: get_ds_path will spit back "Users" or "Groups", # etc... Depending on the Puppet::Type of our self.
UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen resource_name on_comma guid on_comma password_hash on_rparen on_ignored_nl if password_hash on_period # JJM: This returns most of the preamble of the command. # e.g. 'dscl / -create /Users/mccune'
if password_hash on_period UNK on_op on_int on_nl fail on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end # 10.7 uses salted SHA512 password hashes which are 128 characters plus # an 8 character salt. Previous versions used a SHA1 hash padded with # zeroes. If someone attempts to use a password hash that worked with # a previous version of OS X, we will fail early and warn them.
fail on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen #TRANSLATORS 'OS X 10.7' is an operating system and should not be translated, 'Salted SHA512' is the name of a hashing algorithm
users_plist on_op on_const on_op on_const on_op on_const on_period UNK on_lparen plist_file on_rparen on_nl on_ignored_nl if users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end # If a plist already exists in /var/db/dslocal/nodes/Default/users, then # we will need to extract the binary plist from the 'ShadowHashData' # key, log the new password into the resultant plist's 'SALTED-SHA512' # key, and then save the entire structure back.
if users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_op users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_int on_rbracket on_nl # users_plist['ShadowHashData'][0] is actually a binary plist # that's nested INSIDE the user's plist (which itself is a binary # plist). If we encounter a user plist that DOESN'T have a # ShadowHashData field, create one.
converted_hash_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op password_hash on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen password_hash on_period UNK on_op # converted_hash_plist['SALTED-SHA512'] expects a Base64 encoded # string. The password_hash provided as a resource attribute is a # hex value. We need to convert the provided hex value to a Base64 # encoded string to nest it in the converted hash plist.
UNK on_op UNK on_lparen converted_hash_plist on_rparen on_nl users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_int on_rbracket on_op UNK on_nl on_const # Finally, we can convert the nested plist back to binary, embed it # into the user's plist, and convert the resultant plist back to # a binary plist.
users_plist on_op on_const on_op on_const on_op on_const on_period UNK on_lparen plist_file on_rparen on_nl on_ignored_nl if users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end # If a plist exists in /var/db/dslocal/nodes/Default/users, we will # extract the binary plist from the 'ShadowHashData' key, decode the # salted-SHA512 password hash, and then return it.
UNK on_op users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_lbracket on_int on_rbracket on_nl converted_hash_plist on_op UNK on_lparen UNK on_rparen on_nl on_ignored_nl # users_plist['ShadowHashData'][0] is actually a binary plist # that's nested INSIDE the user's plist (which itself is a binary # plist).
password_hash on_op converted_hash_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbracket on_int on_rbracket on_nl password_hash # converted_hash_plist['SALTED-SHA512'] is a Base64 encoded # string. The password_hash provided as a resource attribute is a # hex value. We need to convert the Base64 encoded string to a # hex value and provide it back to Puppet.
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_const on_op on_const # This method will accept a hash and convert it to a binary plist (string value).
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_const on_op on_const # This method will accept a binary plist (as a string) and convert it to a hash.
def self on_period UNK on_lparen UNK on_comma UNK on_op on_int on_rparen on_ignored_nl UNK on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Unlike most other *nixes, OS X doesn't provide built in functionality # for automatically assigning uids and gids to accounts, so we set up these # methods for consumption by functionality like --mkusers # By default we restrict to a reasonably sane range for system accounts
UNK on_op UNK on_period UNK on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK if UNK on_op UNK # We're ok with throwing away negative uids here.
UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op UNK on_lbracket UNK on_rbracket on_op on_int on_nl UNK UNK if # We're just looking for an unused id in our sorted array.
if UNK on_op on_symbeg UNK on_nl on_ivar on_period class on_period UNK on_period UNK do on_op name on_op on_ignored_nl UNK if # We need to loop over all valid properties for the type we're # managing and call the method which sets that property value # dscl can't create everything at once unfortunately.
if on_ivar on_period UNK on_lparen name on_rparen on_nl on_ivar on_period property on_lparen name on_rparen on_period UNK on_nl else on_ignored_nl value # LAK: We use property.sync here rather than directly calling # the settor method because the properties might do some kind # of conversion. In particular, the user gid property might # have a string and need to convert it to a number
guid on_op UNK on_lbracket on_tstring_beg on_tstring_content on_embexpr_beg ns_to_ds_attribute_map on_lbracket on_symbeg guid on_rbracket on_embexpr_end on_tstring_end on_rbracket on_lbracket on_int on_rbracket on_nl self # Although GeneratedUID like all DirectoryService values can be multi-valued # according to the schema, in practice user accounts cannot have multiple UUIDs # otherwise Bad Things Happen, so we just deal with the first value.
on_ignored_nl def UNK on_lparen param on_comma value on_rparen on_ignored_nl self on_period class on_period UNK on_lparen param on_comma value on_rparen on_nl # NBK: we override @parent.set as we need to execute a series of commands # to deal with array values, rather than the single command nameservice.rb # expects to be returned by modifycmd. Thus we don't bother defining modifycmd.
UNK on_lparen current_members on_comma value on_rparen if on_ivar on_lbracket on_symbeg UNK on_rbracket and UNK current_members on_period UNK on_nl on_ignored_nl UNK # If we are meant to be authoritative for the group membership # then remove all existing members who haven't been specified # in the manifest.
UNK on_lparen current_members on_comma value on_rparen on_nl else on_ignored_nl exec_arg_vector on_op self on_period class on_period get_exec_preamble on_lparen on_tstring_beg on_tstring_content on_tstring_end # if they're not a member, make them one.
exec_arg_vector on_op ns_to_ds_attribute_map on_lbracket param on_period UNK on_rbracket on_nl exec_arg_vector on_op value on_period UNK on_nl begin on_ignored_nl execute on_lparen exec_arg_vector # JJM: The following line just maps the NS name to the DS name # e.g. { :uid => 'UniqueID' }
exec_arg_vector on_op value on_period UNK on_nl begin on_ignored_nl execute on_lparen exec_arg_vector on_rparen on_nl rescue on_const on_op on_const on_op detail on_nl # JJM: The following line sends the actual value to set the property to
def UNK on_nl if UNK on_nl UNK _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK UNK on_nl end on_nl on_ignored_nl # NBK: we override @parent.create as we need to execute a series of commands # to create objects with dscl, rather than the single command nameservice.rb # expects to be returned by addcmd. Thus we don't bother defining addcmd.
guid on_op UNK on_tstring_content on_tstring_end on_period UNK on_nl on_ignored_nl exec_arg_vector on_op self on_period class on_period get_exec_preamble on_lparen on_tstring_beg on_tstring_content on_tstring_end # NBK: First we create the object with a known guid so we can set the contents # of the password hash if required # Shelling out sucks, but for a single use case it doesn't seem worth # requiring people install a UUID library that doesn't come with the system. # This should be revisited if Puppet starts managing UUIDs for other platform # user records.
on_const on_op on_const on_period UNK on_lparen on_ivar on_period class on_period name on_rparen on_period UNK on_period UNK do on_op property on_op # Now we create all the standard properties
exec_arg_vector on_op value on_period UNK on_nl begin on_ignored_nl execute on_lparen exec_arg_vector on_rparen on_nl rescue on_const on_op on_const on_op detail on_nl # skip setting the password here
cmd on_op on_lbracket on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period name # TODO: We're falling back to removing the member using dscl due to rdar://8481241 # This bug causes dseditgroup to fail to remove a member if that member doesn't exist
self on_period class on_period get_exec_preamble on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_lbracket on_symbeg name on_rbracket on_rparen on_nl end on_nl on_ignored_nl # JJM: Like addcmd, only called when deleting the object itself # Note, this isn't used to delete properties of the object, # at least that's how I understand it...
if UNK UNK on_lparen on_op UNK on_lparen on_ivar on_rparen UNK on_op on_ivar on_rparen on_nl type_properties on_op on_lbracket on_symbeg name on_rbracket # JJM 2007-07-24: # Override the getinfo method, which is also defined in nameservice.rb # This method returns and sets @infohash # I'm not re-factoring the name "getinfo" because this method will be # most likely called by nameservice.rb, which I didn't write.
type_properties on_op on_lbracket on_symbeg name on_rbracket on_op self on_period class on_period UNK on_period UNK on_nl type_properties on_period UNK on_lparen on_symbeg # JJM 2007-07-24: OK, there's a bit of magic that's about to # happen... Let's see how strong my grip has become... =) # # self is a provider instance of some Puppet::Type, like # Puppet::Type::User::ProviderDirectoryservice for the case of the # user type and this provider. # # self.class looks like "user provider directoryservice", if that # helps you ... # # self.class.resource_type is a reference to the Puppet::Type class, # probably Puppet::Type::User or Puppet::Type::Group, etc... # # self.class.resource_type.validproperties is a class method, # returning an Array of the valid properties of that specific # Puppet::Type. # # So... something like [:comment, :home, :password, :shell, :uid, # :groups, :ensure, :gid] # # Ultimately, we add :name to the list, delete :ensure from the # list, then report on the remaining list. Pretty whacky, ehh?
on_ivar on_op self on_period class on_period UNK on_lparen on_ivar on_lbracket on_symbeg name on_rbracket on_comma on_op type_properties on_rparen on_nl on_lbracket on_symbeg # append GeneratedUID so we just get the report here
