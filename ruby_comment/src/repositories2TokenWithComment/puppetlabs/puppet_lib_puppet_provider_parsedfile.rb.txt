class on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl class # This provider can be used as the parent class for a provider that # parses and generates files. Its content must be loaded via the # 'prefetch' method, and the file will be written when 'flush' is called # on the provider instance. At this point, the file is written once # for every provider instance. # # Once the provider prefetches the data, it's the resource's job to copy # that data over to the @is variables. # # NOTE: The prefetch method swallows FileReadErrors by treating the # corresponding target as an empty file. If you would like to turn this # behavior off, then set the raise_prefetch_errors class variable to # true. Doing so will error all resources associated with the failed # target.
def self on_period UNK on_lparen record on_rparen on_ignored_nl unless record on_lbracket on_symbeg UNK on_rbracket on_nl record on_lbracket on_symbeg UNK on_rbracket # Flush all of the targets for which there are modified records. The only # reason we pass a record here is so that we can add it to the stack if # necessary -- it's passed from the instance calling 'flush'.
unless record on_lbracket on_symbeg UNK on_rbracket on_nl record on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl on_ivar on_op record on_nl on_ignored_nl # Make sure this record is on the list to be flushed.
UNK on_lparen record on_lbracket on_symbeg target on_rbracket on_op UNK on_rparen on_nl end on_nl on_ignored_nl return unless UNK on_lparen on_ivar on_rparen # If we've just added the record, then make sure our # target will get flushed.
def self on_period UNK on_lparen target on_rparen on_ignored_nl return nil unless UNK on_lparen target on_rparen on_period UNK on_lparen on_symbeg UNK # Make sure our file is backed up, but only back it up once per transaction. # We cheat and rely on the fact that @records is created on each prefetch.
def self on_period UNK on_lparen target on_rparen on_ignored_nl if on_ivar on_op on_ivar on_period UNK on_lparen target on_rparen on_nl raise on_const # Flush all of the records relating to a specific target.
def self on_period UNK on_nl on_tstring_beg on_tstring_content UNK on_const on_period UNK UNK on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def self # Return the header placed at the top of each generated file, warning # users that modifying this file manually is probably a bad idea.
def self on_period UNK on_nl nil on_nl end on_nl on_ignored_nl def self on_period UNK on_nl UNK on_nl end on_nl on_ignored_nl # An optional regular expression matched by third party headers. # # For example, this can be used to filter the vixie cron headers as # erroneously exported by older cron versions. # # @api private # @abstract Providers based on ParsedFile may implement this to make it # possible to identify a header maintained by a third party tool. # The provider can then allow that header to remain near the top of the # written file, or remove it after composing the file content. # If implemented, the function must return a Regexp object. # The expression must be tailored to match exactly one third party header. # @see drop_native_header # @note When specifying regular expressions in multiline mode, avoid # greedy repetitions such as '.*' (use .*? instead). Otherwise, the # provider may drop file content between sparse headers.
def self on_period UNK on_nl UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_ivar on_op on_lbracket on_rbracket on_nl # How to handle third party headers. # @api private # @abstract Providers based on ParsedFile that make use of the support for # third party headers may override this method to return +true+. # When this is done, headers that are matched by the native_header_regex # are not written back to disk. # @see native_header_regex
def self on_period UNK on_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ignored_nl on_ivar on_op on_lbrace on_rbrace # Add another type var.
on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_op UNK on_nl on_ignored_nl on_ivar on_op nil on_nl on_ignored_nl on_ivar on_op on_const on_op on_const # Hash of <target> => <failure reason>.
on_ivar on_op on_const on_op on_const on_op on_const on_period filetype on_lparen on_symbeg UNK on_rparen on_nl UNK on_nl end on_nl on_ignored_nl def # Default to flat files
def self on_period UNK on_nl targets on_period UNK do on_op target on_op on_ignored_nl UNK on_lparen target on_rparen on_nl end on_period # Return a list of all of the records we can find.
def self on_period UNK on_nl on_lbracket UNK on_period UNK on_comma UNK on_period UNK on_rbracket on_period UNK on_period each do on_op # Override the default method with a lot more functionality.
if on_ivar on_lbracket attr on_rbracket UNK self on_period class on_period UNK on_lparen self on_period class on_period name on_comma attr on_rparen # If it's not a valid field for this record type (which can happen # when different platforms support different fields), then just # return the should value, so the resource shuts up.
def self on_period UNK on_lparen resource on_rparen on_ignored_nl UNK on_nl UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen # Always make the resource methods.
def self on_period UNK on_lparen target on_rparen on_ignored_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op target unless on_ivar on_period UNK # Mark a target as modified so we know to flush it. This only gets # used within the attr= methods.
def self on_period UNK on_lparen resources on_op nil on_rparen on_ignored_nl on_ivar on_op UNK on_lparen resources on_rparen on_nl on_ignored_nl UNK on_lparen # Retrieve all of the data from disk. There are three ways to know # which files to retrieve: We might have a list of file objects already # set up, there might be instances of our associated resource and they # will have a path parameter set, and we will have a default path # set. We need to turn those three locations into a list of files, # prefetch each one, and make sure they're associated with each appropriate # resource instance.
on_ivar on_op UNK on_lparen resources on_rparen on_nl on_ignored_nl UNK on_lparen resources on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK # Reset the record list.
def self on_period UNK on_lparen resources on_rparen on_ignored_nl return unless resources on_nl UNK on_op resources on_period UNK on_nl on_ivar on_period # Match a list of catalog resources with provider instances # # @api private # # @param [Array<Puppet::Resource>] resources A list of resources using this class as a provider
UNK if UNK on_lparen record on_rparen on_nl on_ignored_nl if on_lparen resource on_op UNK on_lparen record on_comma resources on_rparen on_rparen on_nl # Skip things like comments and blank lines
def self on_period UNK on_lparen record on_comma resources on_rparen on_ignored_nl name on_op record on_lbracket on_symbeg name on_rbracket on_nl if name # Look up a resource based on a parsed file record # # @api private # # @param [Hash<Symbol, Object>] record # @param [Array<Puppet::Resource>] resources # # @return [Puppet::Resource, nil] The resource if found, else nil
def self on_period UNK on_lparen target on_rparen on_ignored_nl UNK on_ignored_nl target_records on_op UNK on_lparen target on_rparen on_nl UNK on_const on_op # Prefetch an individual target.
on_ivar on_lbracket target on_rbracket on_op detail on_period UNK on_nl else on_ignored_nl UNK detail on_period UNK if on_const on_lbracket on_symbeg UNK # We will raise an error later in flush_target. This way, # only the resources linked to our target will fail # evaluation.
def self on_period UNK on_lparen name on_rparen on_ignored_nl return nil unless on_ivar on_nl on_ivar on_period UNK on_lbrace on_op r on_op # Is there an existing record with this name?
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl text on_op UNK on_lparen UNK on_rparen on_period UNK on_nl if text on_period # Retrieve the text for the file. Returns nil in the unlikely # event that it doesn't exist.
text on_op UNK on_lparen UNK on_rparen on_period UNK on_nl if text on_period UNK UNK text on_op on_tstring_beg on_tstring_end on_nl return # XXX We need to be doing something special here in case of failure.
return on_lbracket on_rbracket on_nl else on_ignored_nl UNK on_op on_ivar on_nl UNK on_ignored_nl on_ivar on_op UNK on_nl return self on_period UNK # there is no file
UNK on_op on_ivar on_nl UNK on_ignored_nl on_ivar on_op UNK on_nl return self on_period UNK on_lparen text on_rparen on_nl UNK on_const # Set the target, for logging.
def self on_period UNK on_lparen record on_rparen on_ignored_nl record_type on_lparen record on_lbracket on_symbeg record_type on_rbracket on_rparen on_period UNK on_nl end # Should we skip the record? Basically, we skip text records. # This is only here so subclasses can override it.
def self on_period UNK on_nl nil on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen target on_rparen on_ignored_nl if UNK # The mode for generated files if they are newly created. # No mode will be set on existing files. # # @abstract Providers inheriting parsedfile can override this method # to provide a mode. The value should be suitable for File.chmod
def self on_period UNK on_lparen target on_rparen on_ignored_nl if UNK on_nl on_ivar on_lbracket target on_rbracket on_op filetype on_period UNK on_lparen # Initialize the object if necessary.
if UNK on_nl on_ivar on_lbracket target on_rbracket on_op filetype on_period UNK on_lparen target on_comma UNK on_rparen on_nl else on_ignored_nl on_ivar # only send the default mode if the actual provider defined it, # because certain filetypes (e.g. the crontab variants) do not # expect it in their initialize method
def self on_period target_records on_lparen target on_rparen on_ignored_nl on_ivar on_period UNK on_lbrace on_op r on_op r on_lbracket on_symbeg target on_rbracket # Find all of the records for a given target
def self on_period targets on_lparen resources on_op nil on_rparen on_ignored_nl targets on_op on_lbracket on_rbracket on_nl raise on_const on_op on_const on_comma # Find a list of all of the targets that we should be reading. This is # used to figure out what targets we need to prefetch.
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless self on_period UNK on_nl targets on_op self on_period # First get the default target
targets on_op on_ivar on_period UNK on_nl on_ignored_nl if resources on_nl resources on_period each do on_op name on_comma resource on_op on_ignored_nl # Then get each of the file objects
if resources on_nl resources on_period each do on_op name on_comma resource on_op on_ignored_nl value on_op resource on_period UNK on_lparen on_symbeg # Lastly, check the file from any resource instances
def self on_period UNK on_lparen records on_rparen on_ignored_nl text on_op UNK on_nl if UNK UNK on_lparen match on_op text on_period # Compose file contents from the set of records. # # If self.native_header_regex is not nil, possible vendor headers are # identified by matching the return value against the expression. # If one (or several consecutive) such headers, are found, they are # either moved in front of the self.header if self.drop_native_header # is false (this is the default), or removed from the return value otherwise. # # @api private
text on_op match on_period UNK on_op match on_period UNK on_nl else on_ignored_nl UNK on_op match on_lbracket UNK on_rbracket on_nl return # concatenate the text in front of and after the native header
self on_period ensure on_op on_symbeg absent on_nl on_lparen on_ivar on_period class on_period name on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen # We use the method here so it marks the target as modified.
def UNK on_nl on_ignored_nl unless on_ivar on_lbracket on_symbeg target on_rbracket on_nl on_ivar on_lbracket on_symbeg target on_rbracket on_op on_ivar on_period UNK # Write our data to disk.
on_ignored_nl unless on_ivar on_lbracket on_symbeg target on_rbracket on_nl on_ivar on_lbracket on_symbeg target on_rbracket on_op on_ivar on_period UNK on_lparen on_symbeg target # Make sure we've got a target and name set.
unless on_ivar on_lbracket on_symbeg target on_rbracket on_nl on_ivar on_lbracket on_symbeg target on_rbracket on_op on_ivar on_period UNK on_lparen on_symbeg target on_rparen # If the target isn't set, then this is our first modification, so # mark it for flushing.
on_ivar on_op self on_period class on_period UNK on_lparen resource on_lbracket on_symbeg name on_rbracket on_rparen on_op on_lbrace on_symbeg record_type on_op self # The 'record' could be a resource or a record, depending on how the provider # is initialized. If we got an empty property hash (probably because the resource # is just being initialized), then we want to set up some defaults.
def UNK on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless on_ivar on_nl self on_period class # Retrieve the current state from disk.
def UNK on_nl UNK on_op on_ivar on_period UNK on_lparen on_symbeg target on_rparen if UNK on_lparen on_ivar on_rparen on_nl if UNK # Mark both the resource and provider target as modified.
