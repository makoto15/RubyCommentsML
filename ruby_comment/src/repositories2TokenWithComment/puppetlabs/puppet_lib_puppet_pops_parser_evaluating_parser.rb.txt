UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen on_rparen # Does not support "import" and parsing ruby files #
UNK on_ignored_nl UNK on_lparen UNK on_period UNK on_lparen UNK on_comma file_source on_rparen on_comma file_source on_rparen on_period model on_nl UNK on_const # Handling of syntax error can be much improved (in general), now it bails out of the parser # and does not have as rich information (when parsing a string), need to update it with the file source # (ideally, a syntax error should be entered as an issue, and not just thrown - but that is a general problem # and an improvement that can be made in the eparser (rather than here). # Also a possible improvement (if the YAML parser returns positions) is to provide correct output of position. #
e on_period file on_op file_source UNK e on_period file on_period UNK on_lparen on_const on_rparen on_op on_op e on_period file on_period # TODO: This is not quite right, why does not the exception have the correct file?
def UNK on_lparen model on_comma scope on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_period new on_lparen UNK on_comma model on_comma # Create a closure that can be called in the given scope
def UNK on_lparen scope on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen scope on_comma UNK on_comma UNK on_rparen # Evaluates the given expression in a local scope with the given variable bindings # set in this local scope, returns what the expression returns. #
UNK on_lparen on_const on_period UNK on_lparen UNK UNK on_rparen UNK nil UNK on_rparen on_nl UNK on_const on_op on_const on_period new # Do not use the cached evaluator if this is a migration run
def UNK on_period UNK on_lparen UNK on_rparen on_ignored_nl escaped on_op on_tstring_beg on_tstring_content on_tstring_end on_nl p on_op nil on_nl UNK on_period # Translates an already parsed string that contains control characters, quotes # and backslashes into a quoted string where all such constructs have been escaped. # Parsing the return value of this method using the puppet parser should yield # exactly the same string as the argument passed to this method # # The method makes an exception for the two character sequences \$ and \s. They # will not be escaped since they have a special meaning in puppet syntax. # # TODO: Handle \uXXXX characters ?? # # @param x [String] The string to quote and "unparse" # @return [String] The quoted string #
when on_tstring_beg on_tstring_content on_tstring_end on_nl escaped on_op on_tstring_beg on_tstring_content on_tstring_end on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl escaped on_op on_tstring_beg on_tstring_content # do nothing
when on_tstring_beg on_tstring_content on_tstring_end on_nl escaped on_op on_tstring_beg on_tstring_content on_tstring_end on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl escaped on_op UNK UNK # TODO: \cx is a range of characters - skip for now # when "\c" # escaped << '\\c'
UNK on_ignored_nl escaped on_op p on_nl end on_nl p on_op UNK on_nl end on_nl escaped on_op p UNK p on_period # don't escape \ when followed by s or $
