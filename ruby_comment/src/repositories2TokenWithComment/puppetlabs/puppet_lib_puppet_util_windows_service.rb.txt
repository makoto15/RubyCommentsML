UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl UNK on_const # coding: utf-8
UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op # This module is designed to provide an API between the windows system and puppet for # service management. # # for an overview of the service state transitions see: https://docs.microsoft.com/en-us/windows/desktop/Services/service-status-transitions
on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op # integer value of the floor for timeouts when waiting for service pending states. # puppet will wait the length of dwWaitHint if it is longer than this value, but # no shorter
on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int # Service error codes # https://docs.microsoft.com/en-us/windows/desktop/debug/system-error-codes--1000-1299-
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Service control codes # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-controlserviceexw
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Service start type codes # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfigw
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Service type codes # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-changeserviceconfigw
on_const on_op on_int on_nl on_const on_op on_ignored_nl on_const on_op on_ignored_nl on_const on_op on_ignored_nl on_const on_op on_ignored_nl on_const on_nl on_ignored_nl on_const # Available only if service is also SERVICE_WIN32_OWN_PROCESS or SERVICE_WIN32_SHARE_PROCESS
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Current state codes # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-_service_status_process
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Service accepts control codes # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-_service_status_process
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Service manager access codes # https://docs.microsoft.com/en-us/windows/desktop/Services/service-security-and-access-rights
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Service access codes # https://docs.microsoft.com/en-us/windows/desktop/Services/service-security-and-access-rights
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # Service config codes # From the windows 10 SDK: # // # // Value to indicate no change to an optional parameter # // # #define SERVICE_NO_CHANGE 0xffffffff # https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-changeserviceconfig2w
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_ignored_nl on_const on_op on_ignored_nl on_const on_nl on_ignored_nl on_const on_op on_int # Service enum codes # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-enumservicesstatusexa
on_const on_op on_int on_nl on_ignored_nl class on_const on_op on_const on_op on_const on_nl UNK on_lparen on_ignored_nl on_symbeg UNK on_comma on_symbeg dword # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-_enum_service_status_processw
class on_const on_op on_const on_op on_const on_nl UNK on_lparen on_ignored_nl on_symbeg UNK on_comma on_symbeg dword on_comma on_ignored_nl on_symbeg dwcurrentstate on_comma # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-_service_status_process # typedef struct _SERVICE_STATUS_PROCESS { # DWORD dwServiceType; # DWORD dwCurrentState; # DWORD dwControlsAccepted; # DWORD dwWin32ExitCode; # DWORD dwServiceSpecificExitCode; # DWORD dwCheckPoint; # DWORD dwWaitHint; # DWORD dwProcessId; # DWORD dwServiceFlags; # } SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;
class on_const on_op on_const on_op on_const on_nl UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_rparen on_nl UNK UNK on_op on_nl # https://docs.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_delayed_auto_start_info # typedef struct _SERVICE_DELAYED_AUTO_START_INFO { # BOOL fDelayedAutostart; # } SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;
def on_op on_lparen UNK on_comma UNK on_rparen on_ignored_nl on_lbracket on_int on_comma UNK on_rbracket on_period UNK on_lparen UNK on_rparen on_op UNK # Intercept the accessor so that we can handle either true/false or 1/0. # Since there is only one member, thereâ€™s no need to check the key name.
class on_const on_op on_const on_op on_const on_nl UNK on_lparen on_ignored_nl on_symbeg UNK on_comma on_symbeg pointer on_comma on_ignored_nl on_symbeg UNK on_comma # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/ns-winsvc-_enum_service_status_processw # typedef struct _ENUM_SERVICE_STATUS_PROCESSW { # LPWSTR lpServiceName; # LPWSTR lpDisplayName; # SERVICE_STATUS_PROCESS ServiceStatusProcess; # } ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;
class on_const on_op on_const on_op on_const on_nl UNK on_lparen on_ignored_nl on_symbeg UNK on_comma on_symbeg dword on_comma on_ignored_nl on_symbeg dwcurrentstate on_comma # typedef struct _SERVICE_STATUS { # DWORD dwServiceType; # DWORD dwCurrentState; # DWORD dwControlsAccepted; # DWORD dwWin32ExitCode; # DWORD dwServiceSpecificExitCode; # DWORD dwCheckPoint; # DWORD dwWaitHint; # } SERVICE_STATUS, *LPSERVICE_STATUS;
class on_const on_op on_const on_op on_const on_nl UNK on_lparen on_ignored_nl on_symbeg UNK on_comma on_symbeg dword on_comma on_ignored_nl on_symbeg UNK on_comma # typedef struct _QUERY_SERVICE_CONFIGW { # DWORD dwServiceType; # DWORD dwStartType; # DWORD dwErrorControl; # LPWSTR lpBinaryPathName; # LPWSTR lpLoadOrderGroup; # DWORD dwTagId; # LPWSTR lpDependencies; # LPWSTR lpServiceStartName; # LPWSTR lpDisplayName; # } QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;
def UNK on_lparen service_name on_rparen on_ignored_nl open_service on_lparen service_name on_comma on_const on_comma on_const on_rparen do on_op _ on_op on_ignored_nl UNK # Returns true if the service exists, false otherwise. # # @param [String] service_name name of the service
def UNK on_lparen service_name on_comma on_label on_const on_rparen on_ignored_nl on_const on_period debug _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace # Start a windows service # # @param [String] service_name name of the service to start # @param optional [Integer] timeout the minumum number of seconds to wait before timing out
def UNK on_lparen service_name on_comma on_label on_const on_rparen on_ignored_nl on_const on_period debug _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace # Stop a windows service # # @param [String] service_name name of the service to stop # @param optional [Integer] timeout the minumum number of seconds to wait before timing out
def UNK on_lparen service_name on_comma on_label on_const on_rparen on_ignored_nl on_const on_period debug _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace # Resume a paused windows service # # @param [String] service_name name of the service to resume # @param optional [Integer] :timeout the minumum number of seconds to wait before timing out
wait_on_pending_state on_lparen service on_comma on_const on_comma timeout on_rparen on_nl on_ignored_nl UNK on_lparen service on_comma on_const on_rparen on_nl end on_nl on_ignored_nl # The SERVICE_CONTROL_CONTINUE signal can only be sent when # the service is in the SERVICE_PAUSED state
def UNK on_lparen service_name on_rparen on_ignored_nl state on_op nil on_nl open_service on_lparen service_name on_comma on_const on_comma on_const on_rparen do on_op # Query the state of a service using QueryServiceStatusEx # # @param [string] service_name name of the service to query # @return [string] the status of the service
def UNK on_lparen service_name on_rparen on_ignored_nl start_type on_op nil on_nl open_service on_lparen service_name on_comma on_const on_comma on_const on_rparen do on_op # Query the configuration of a service using QueryServiceConfigW # or QueryServiceConfig2W # # @param [String] service_name name of the service to query # @return [QUERY_SERVICE_CONFIGW.struct] the configuration of the service
if start_type on_op on_symbeg on_const on_nl open_service on_lparen service_name on_comma on_const on_comma on_const on_rparen do on_op service on_op on_ignored_nl UNK # if the service has type AUTO_START, check if it's a delayed service
def UNK on_lparen service_name on_comma UNK on_comma UNK on_op UNK on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen # Change the startup mode of a windows service # # @param [String] service_name the name of the service to modify # @param [Integer] startup_type a code corresponding to a start type for # windows service, see the "Service start type codes" section in the # Puppet::Util::Windows::Service file for the list of available codes # @param [Bool] delayed whether the service should be started with a delay
success on_op on_const on_lparen on_ignored_nl service on_comma on_ignored_nl on_const on_comma UNK on_comma on_const on_comma on_const on_op on_const on_op on_const on_comma # Currently the only thing puppet's API can really manage # in this list is dwStartType (the third param). Thus no # generic function was written to make use of all the params # since the API as-is couldn't use them anyway
UNK on_comma on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op # dwServiceType
on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma # dwStartType
on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op # dwErrorControl
on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op # lpBinaryPathName
on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op # lpLoadOrderGroup
on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op # lpdwTagId
on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_rparen on_nl if # lpDependencies
on_const on_op on_const on_op on_const on_comma on_const on_op on_const on_op on_const on_rparen on_nl if success on_op on_const on_op on_const on_nl # lpServiceStartName
on_const on_op on_const on_op on_const on_rparen on_nl if success on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const # lpPassword
on_rparen on_nl if success on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const on_op on_const on_period new on_lparen # lpDisplayName
def UNK on_nl UNK on_op on_lbrace on_rbrace on_nl UNK on_lparen on_const on_rparen do on_op scm on_op on_ignored_nl size_required on_op on_int # enumerate over all services in all states and return them as a hash # # @return [Hash] a hash containing services: # { 'service name' => { # 'display_name' => 'display name', # 'service_status_process' => SERVICE_STATUS_PROCESS struct # } # }
on_const on_lparen on_ignored_nl scm on_comma on_ignored_nl on_symbeg on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_op on_const on_op # Fetch the bytes of memory required to be allocated # for QueryServiceConfigW to return succesfully. This # is done by sending NULL and 0 for the pointer and size # respectively, letting the command fail, then reading the # value of pcbBytesNeeded # # return value will be false from this call, since it's designed # to fail. Just ignore it
UNK on_op UNK on_period UNK on_nl UNK on_op on_const on_op on_const on_period new on_lparen on_const on_comma UNK on_rparen on_nl on_int # Now that the buffer is populated with services # we pull the data from memory using pointer arithmetic: # the number of services returned by the function is # available to be read from svcs_ret_ptr, and we iterate # that many times moving the cursor pointer the length of # ENUM_SERVICE_STATUS_PROCESSW.size. This should iterate # over the buffer and extract each struct.
end end end end UNK on_nl end on_nl module_function on_symbeg UNK on_nl on_ignored_nl class on_op UNK on_nl def open_service on_lparen # buffer_ptr
end end end UNK on_nl end on_nl module_function on_symbeg UNK on_nl on_ignored_nl class on_op UNK on_nl def open_service on_lparen service_name # resume_ptr
end end UNK on_nl end on_nl module_function on_symbeg UNK on_nl on_ignored_nl class on_op UNK on_nl def open_service on_lparen service_name on_comma # scvs_ret_ptr
end UNK on_nl end on_nl module_function on_symbeg UNK on_nl on_ignored_nl class on_op UNK on_nl def open_service on_lparen service_name on_comma UNK # bytes_ptr
UNK on_nl end on_nl module_function on_symbeg UNK on_nl on_ignored_nl class on_op UNK on_nl def open_service on_lparen service_name on_comma UNK on_comma # open_scm
def open_service on_lparen service_name on_comma UNK on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl service on_op on_const on_op on_const on_op on_const # @api private # Opens a connection to the SCManager on windows then uses that # handle to create a handle to a specific service in windows # corresponding to service_name # # this function takes a block that executes within the context of # the open service handler, and will close the service and SCManager # handles once the block finishes # # @param [string] service_name the name of the service to open # @param [Integer] scm_access code corresponding to the access type requested for the scm # @param [Integer] service_access code corresponding to the access type requested for the service # @yieldparam [:handle] service the windows native handle used to access # the service # @return the result of the block
def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl scm on_op on_const on_lparen on_const on_op on_const on_op on_const on_comma on_const # @api private # # Opens a handle to the service control manager # # @param [Integer] scm_access code corresponding to the access type requested for the scm
def UNK on_lparen service_name on_comma valid_initial_states on_comma final_state on_comma timeout on_comma on_op UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const # @api private # Transition the service to the specified state. The block should perform # the actual transition. # # @param [String] service_name the name of the service to transition # @param [[Integer]] valid_initial_states an array of valid states that the service can transition from # @param [Integer] final_state the state that the service will transition to # @param [Integer] timeout the minumum number of seconds to wait before timing out
if initial_state on_op final_state on_nl on_const on_period debug _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label on_const on_lbracket final_state # If the service is already in the final_state, then # no further work needs to be done
UNK valid_initial_states on_period UNK on_lparen initial_state on_rparen on_nl UNK on_op valid_initial_states on_period UNK do on_op state on_op on_ignored_nl on_const on_lbracket # Check that initial_state corresponds to a valid # initial state
UNK on_op on_const on_period UNK on_period UNK do on_op pending_state on_op on_ignored_nl on_const on_lbracket pending_state on_rbracket on_op final_state on_nl end # Check if there's a pending transition to the final_state. If so, then wait for # that transition to finish.
on_const on_lbracket pending_state on_rbracket on_op final_state on_nl end on_nl if UNK on_period UNK on_lparen initial_state on_rparen on_nl on_const on_period debug # SERVICE_RUNNING has two pending states, SERVICE_START_PENDING and # SERVICE_CONTINUE_PENDING. That is why we need the #select here
if on_const on_period UNK on_lparen initial_state on_rparen on_nl on_const on_period debug _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label # If we are in an unsafe pending state like SERVICE_START_PENDING # or SERVICE_STOP_PENDING, then we want to wait for that pending # transition to finish before transitioning the service state. # The reason we do this is because SERVICE_START_PENDING is when # the service thread is being created and initialized, while # SERVICE_STOP_PENDING is when the service thread is being cleaned # up and destroyed. Thus there is a chance that when the service is # in either of these states, its service thread may not yet be ready # to perform the state transition (it may not even exist).
def query_status on_lparen service on_rparen on_ignored_nl size_required on_op nil on_nl status on_op nil on_nl on_const on_op on_const on_period new on_lparen # @api private # perform QueryServiceStatusEx on a windows service and return the # result # # @param [:handle] service handle of the service to query # @return [SERVICE_STATUS_PROCESS struct] the result of the query
on_const on_op on_const on_period new on_lparen on_symbeg UNK on_rparen do on_op bytes_pointer on_op on_ignored_nl on_const on_lparen on_ignored_nl service on_comma on_ignored_nl # Fetch the bytes of memory required to be allocated # for QueryServiceConfigW to return succesfully. This # is done by sending NULL and 0 for the pointer and size # respectively, letting the command fail, then reading the # value of pcbBytesNeeded
on_const on_lparen on_ignored_nl service on_comma on_ignored_nl on_symbeg on_const on_comma on_ignored_nl on_const on_op on_const on_op on_const on_comma on_ignored_nl on_int on_comma on_ignored_nl # return value will be false from this call, since it's designed # to fail. Just ignore it
def UNK on_lparen service on_comma on_op UNK on_rparen on_ignored_nl config on_op nil on_nl size_required on_op nil on_nl on_const on_op on_const # @api private # perform QueryServiceConfigW on a windows service and return the # result # # @param [:handle] service handle of the service to query # @return [QUERY_SERVICE_CONFIGW struct] the result of the query
on_const on_op on_const on_period new on_lparen on_symbeg UNK on_rparen do on_op bytes_pointer on_op on_ignored_nl on_const on_lparen service on_comma on_const on_op # Fetch the bytes of memory required to be allocated # for QueryServiceConfigW to return succesfully. This # is done by sending NULL and 0 for the pointer and size # respectively, letting the command fail, then reading the # value of pcbBytesNeeded
on_const on_lparen service on_comma on_const on_op on_const on_op on_const on_comma on_int on_comma bytes_pointer on_rparen on_nl size_required on_op bytes_pointer on_period UNK # return value will be false from this call, since it's designed # to fail. Just ignore it
def UNK on_lparen service on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl config on_op nil on_nl size_required on_op nil on_nl on_const # @api private # perform QueryServiceConfig2W on a windows service and return the # result # # @param [:handle] service handle of the service to query # @param [Integer] info_level the configuration information to be queried # @return [QUERY_SERVICE_CONFIG2W struct] the result of the query
on_const on_op on_const on_period new on_lparen on_symbeg UNK on_rparen do on_op bytes_pointer on_op on_ignored_nl on_const on_lparen service on_comma UNK on_comma # Fetch the bytes of memory required to be allocated # for QueryServiceConfig2W to return succesfully. This # is done by sending NULL and 0 for the pointer and size # respectively, letting the command fail, then reading the # value of pcbBytesNeeded
on_const on_lparen service on_comma UNK on_comma on_const on_op on_const on_op on_const on_comma on_int on_comma bytes_pointer on_rparen on_nl size_required on_op bytes_pointer # return value will be false from this call, since it's designed # to fail. Just ignore it
UNK UNK on_nl UNK on_const on_nl config on_op on_const on_period new on_lparen ssp_ptr on_rparen on_nl end on_nl success on_op on_const # We need to supply the appropriate struct to be created based on # the info_level
def UNK on_lparen service_name on_comma UNK on_comma UNK on_rparen on_ignored_nl open_service on_lparen service_name on_comma on_const on_comma on_const on_rparen do on_op # @api private # Sets an optional parameter on a service by calling # ChangeServiceConfig2W # # @param [String] service_name name of service # @param [Integer] change parameter to change # @param [struct] value appropriate struct based on the parameter to change
UNK on_comma on_rparen on_nl if success on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op UNK on_op on_const on_period # dwInfoLevel
on_rparen on_nl if success on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op UNK on_op on_const on_period new on_lparen # lpInfo
def UNK on_lparen service_name on_comma UNK on_rparen on_ignored_nl UNK on_op on_const on_period new on_nl UNK on_lbracket on_symbeg UNK on_rbracket on_op # @api private # Controls the delayed auto-start setting of a service # # @param [String] service_name name of service # @param [Bool] delayed whether the service should be started with a delay or not
def UNK on_lparen service on_comma UNK on_rparen on_ignored_nl on_const on_op on_const on_period new on_lparen on_const on_period UNK on_rparen do on_op # @api private # Sends a service control signal to a service # # @param [:handle] service handle to the service # @param [Integer] signal the service control signal to send
def UNK on_lparen service on_comma initial_state on_comma final_state on_comma timeout on_rparen on_ignored_nl if final_state on_op on_const on_nl pending_state on_op on_const # @api private # Waits for a service to transition from one state to # another state. # # @param [:handle] service handle to the service to wait on # @param [Integer] initial_state the state that the service is transitioning from. # @param [Integer] final_state the state that the service is transitioning to # @param [Integer] timeout the minumum number of seconds to wait before timing out
if final_state on_op on_const on_nl pending_state on_op on_const on_period UNK on_lparen final_state on_rparen on_nl UNK initial_state on_op on_const on_nl pending_state # Get the pending state for this transition. Note that SERVICE_RUNNING # has two possible pending states, which is why we need this logic.
pending_state on_op on_const on_nl UNK on_ignored_nl pending_state on_op on_const on_nl end on_nl on_ignored_nl state on_op nil on_nl elapsed_time on_op on_int # SERVICE_STOPPED => SERVICE_RUNNING
pending_state on_op on_const on_nl end on_nl on_ignored_nl state on_op nil on_nl elapsed_time on_op on_int on_nl UNK elapsed_time on_op timeout on_nl # SERVICE_PAUSED => SERVICE_RUNNING
state on_op nil on_nl elapsed_time on_op on_int on_nl UNK elapsed_time on_op timeout on_nl on_ignored_nl query_status on_lparen service on_rparen do on_op # Wait for the transition to finish
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label on_const on_lbracket initial_state on_rbracket on_comma on_label # Timed out while waiting for the transition to finish. Raise an error # We can still use the state variable read from the FFI struct because # FFI creates new Integer objects during an assignment of an integer value # stored in an FFI struct. We verified that the '=' operater is safe # from the freed memory since the new ruby object created during the # assignment will remain in ruby memory and remain immutable and constant.
def wait_on_pending_state on_lparen service on_comma pending_state on_comma timeout on_rparen on_ignored_nl final_state on_op on_const on_lbracket pending_state on_rbracket on_nl on_ignored_nl on_const on_period # @api private # Waits for a service to finish transitioning from # a pending state. The service must be in the pending state # before invoking this routine. # # @param [:handle] service handle to the service to wait on # @param [Integer] pending_state the pending state # @param [Integer] timeout the minumum number of seconds to wait before timing out
UNK if state on_op final_state on_nl UNK state on_op pending_state on_nl raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content # Check if our service has finished transitioning to # the final_state OR if an unexpected transition # has occurred
if UNK on_op UNK on_nl elapsed_time on_op on_int on_nl UNK on_op UNK on_nl UNK on_ignored_nl wait_hint on_op UNK on_lparen status # Check if any progress has been made since our last sleep # using the dwCheckPoint. If no progress has been made then # check if we've timed out, and raise an error if so
UNK on_lparen wait_time on_rparen on_nl elapsed_time on_op wait_time on_nl end on_nl end on_nl end on_nl private on_symbeg wait_on_pending_state on_nl on_ignored_nl # Wait a bit before rechecking the service's state
def UNK on_lparen wait_hint on_rparen on_ignored_nl wait_time on_op UNK on_lparen wait_hint on_rparen on_op on_int UNK on_ignored_nl wait_time on_op on_int if # @api private # # create a usable wait time to wait between querying the service. # # @param [Integer] wait_hint the wait hint of a service in milliseconds # @return [Integer] the time to wait in seconds between querying the service
wait_time on_op UNK on_lparen wait_hint on_rparen on_op on_int UNK on_ignored_nl wait_time on_op on_int if wait_time on_op on_int on_nl wait_time on_op # Wait 1/10th the wait_hint, but no less than 1 and # no more than 10 seconds
def UNK on_lparen wait_hint on_rparen on_ignored_nl wait_hint on_op on_int UNK on_ignored_nl end on_nl private on_symbeg UNK on_nl end on_nl on_ignored_nl # @api private # # process the wait hint listed by a service to something # usable by ruby sleep # # @param [Integer] wait_hint the wait hint of a service in milliseconds # @return [Integer] wait_hint in seconds
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg lpcwstr on_comma on_symbeg lpcwstr on_comma on_symbeg dword on_rbracket on_comma # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-openscmanagerw # SC_HANDLE OpenSCManagerW( # LPCWSTR lpMachineName, # LPCWSTR lpDatabaseName, # DWORD dwDesiredAccess # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_symbeg lpcwstr on_comma on_symbeg dword on_rbracket on_comma # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-openservicew # SC_HANDLE OpenServiceW( # SC_HANDLE hSCManager, # LPCWSTR lpServiceName, # DWORD dwDesiredAccess # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_rbracket on_comma on_symbeg win32_bool on_nl on_ignored_nl on_const on_op # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-closeservicehandle # BOOL CloseServiceHandle( # SC_HANDLE hSCObject # );
on_const on_op UNK on_lparen on_ignored_nl on_symbeg on_const on_comma on_int on_comma on_ignored_nl on_rparen on_nl ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-queryservicestatusex # BOOL QueryServiceStatusEx( # SC_HANDLE hService, # SC_STATUS_TYPE InfoLevel, # LPBYTE lpBuffer, # DWORD cbBufSize, # LPDWORD pcbBytesNeeded # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_symbeg UNK on_comma on_symbeg dword on_comma on_symbeg # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-queryserviceconfigw # BOOL QueryServiceConfigW( # SC_HANDLE hService, # LPQUERY_SERVICE_CONFIGW lpServiceConfig, # DWORD cbBufSize, # LPDWORD pcbBytesNeeded # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_symbeg dword on_comma on_symbeg UNK on_comma on_symbeg # https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-queryserviceconfig2w # BOOL QueryServiceConfig2W( # SC_HANDLE hService, # DWORD dwInfoLevel, # LPBYTE lpBuffer, # DWORD cbBufSize, # LPDWORD pcbBytesNeeded # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_symbeg dword on_comma on_symbeg pointer on_rbracket on_comma # https://docs.microsoft.com/en-us/windows/desktop/api/Winsvc/nf-winsvc-startservicew # BOOL StartServiceW( # SC_HANDLE hService, # DWORD dwNumServiceArgs, # LPCWSTR *lpServiceArgVectors # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_symbeg dword on_comma on_symbeg pointer on_rbracket on_comma # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-controlservice # BOOL ControlService( # SC_HANDLE hService, # DWORD dwControl, # LPSERVICE_STATUS lpServiceStatus # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_ignored_nl on_symbeg handle on_comma on_ignored_nl on_symbeg dword on_comma on_ignored_nl on_symbeg # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-changeserviceconfigw # BOOL ChangeServiceConfigW( # SC_HANDLE hService, # DWORD dwServiceType, # DWORD dwStartType, # DWORD dwErrorControl, # LPCWSTR lpBinaryPathName, # LPCWSTR lpLoadOrderGroup, # LPDWORD lpdwTagId, # LPCWSTR lpDependencies, # LPCWSTR lpServiceStartName, # LPCWSTR lpPassword, # LPCWSTR lpDisplayName # );
ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const on_comma on_ignored_nl on_lbracket on_symbeg handle on_comma on_symbeg dword on_comma on_symbeg UNK on_rbracket on_comma # https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-changeserviceconfig2w # BOOL ChangeServiceConfig2W( # SC_HANDLE hService, # DWORD dwInfoLevel, # LPVOID lpInfo # );
on_const on_op UNK on_lparen on_ignored_nl on_symbeg on_const on_comma on_int on_comma on_ignored_nl on_rparen on_nl ffi_lib on_symbeg advapi32 on_nl attach_function_private on_symbeg on_const # https://docs.microsoft.com/en-us/windows/desktop/api/winsvc/nf-winsvc-enumservicesstatusexw # BOOL EnumServicesStatusExW( # SC_HANDLE hSCManager, # SC_ENUM_TYPE InfoLevel, # DWORD dwServiceType, # DWORD dwServiceState, # LPBYTE lpServices, # DWORD cbBufSize, # LPDWORD pcbBytesNeeded, # LPDWORD lpServicesReturned, # LPDWORD lpResumeHandle, # LPCWSTR pszGroupName # );
