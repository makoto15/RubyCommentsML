let on_symbeg UNK do on_ignored_nl on_lbracket on_ignored_nl on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # These are values getpwent might give you
let on_symbeg UNK do on_ignored_nl on_lbracket on_ignored_nl on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # These are values getgrent might give you
let on_symbeg UNK do on_ignored_nl on_const on_period new on_lparen on_symbeg foo on_comma on_symbeg bar on_rparen on_nl end on_nl on_ignored_nl let # A fake struct besides Struct::Group and Struct::Passwd
let on_symbeg UNK do on_ignored_nl UNK on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # A fake value get<foo>ent might return
let on_symbeg UNK do on_ignored_nl on_const on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen do on_ignored_nl UNK on_lparen on_symbeg name # The provider sometimes relies on @resource for valid properties so let's # create a fake type with properties that match our fake struct.
let on_lparen on_symbeg utf_8_jose on_rparen on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_rbrace on_nl let on_lparen on_symbeg UNK on_rparen on_lbrace utf_8_jose on_period UNK # These values simulate what Ruby Etc would return from a host with the "same" # user represented in different encodings on disk.
on_const on_op on_const on_period new on_lparen invalid_utf_8_jose on_comma invalid_utf_8_jose on_comma on_int on_comma on_int on_rparen on_comma on_ignored_nl nil on_nl on_rbracket on_nl # UTF-8 character # In a UTF-8 environment, ruby will return strings labeled as UTF-8 even if they're not valid in UTF-8
on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_period force_encoding on_lparen on_const on_op on_const on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end # In a LATIN-1 environment, ruby will return *all* strings labeled as LATIN-1
nil on_nl on_rbracket on_nl on_rbrace on_nl on_ignored_nl describe on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl described_class # UTF-8 character
it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl described_class on_period resource_type on_op on_const on_op on_const on_period type on_lparen on_symbeg UNK on_rparen on_nl # the return values are hard coded so I am using types that actually make # use of the nameservice provider
it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl allow on_lparen on_const on_rparen on_period to receive on_lparen on_symbeg getpwent on_rparen on_period and_return on_lparen # These two tests simulate an environment where there are two users with # the same name on disk, but each name is stored on disk in a different # encoding
allow on_lparen on_const on_rparen on_period to receive on_lparen on_symbeg getpwent on_rparen on_period and_return on_lparen on_op UNK on_rparen on_nl result on_op # These two tests simulate an environment where there are two users with # the same name on disk, but each name is stored on disk in a different # encoding
on_tstring_beg on_tstring_content on_tstring_end on_period force_encoding on_lparen on_const on_op on_const on_rparen on_comma utf_8_jose on_comma UNK on_rbracket on_nl on_rparen on_nl end on_nl # started as UTF-8 on disk, returned unaltered as UTF-8
utf_8_jose on_comma UNK on_rbracket on_nl on_rparen on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl allow on_lparen on_const on_rparen # started as UTF-8 on disk, returned unaltered as UTF-8
UNK on_rbracket on_nl on_rparen on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl allow on_lparen on_const on_rparen on_period to # started as UTF-8 on disk, returned unaltered as UTF-8
on_rbracket on_nl on_rparen on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl allow on_lparen on_const on_rparen on_period to receive # started as LATIN-1 on disk, but Etc returned as UTF-8 and we escaped invalid chars
on_tstring_beg on_tstring_content on_tstring_end on_period force_encoding on_lparen on_const on_op on_const on_rparen on_comma utf_8_jose on_comma valid_latin1_jose on_rbracket on_nl on_rparen on_nl end on_nl # started as LATIN-1 on disk, we overrode to UTF-8
utf_8_jose on_comma valid_latin1_jose on_rbracket on_nl on_rparen on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_op on_lbracket on_const # started as LATIN-1 on disk, we overrode to UTF-8
valid_latin1_jose on_rbracket on_nl on_rparen on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_op on_lbracket on_const on_op on_const # started as UTF-8 on disk, returned by Etc as LATIN-1, and we overrode to UTF-8
on_rbracket on_nl on_rparen on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_op on_lbracket on_const on_op on_const on_period # started as LATIN-1 on disk, returned by Etc as valid LATIN-1, and we leave as LATIN-1
allow on_lparen described_class on_rparen on_period to receive on_lparen on_symbeg UNK on_rparen on_period and_return on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl resource # with section=foo we'll call Etc.getfoonam instead of getpwnam or getgrnam
end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl expect on_lparen on_const on_op on_const on_rparen on_period to receive on_lparen on_symbeg # initialize the resource so our provider has a @resource instance variable
it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_op described_class on_period new on_lparen on_symbeg name on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_symbeg # Nameservice instances track the original resource name on disk, before # overriding to UTF-8, in @canonical_name for querying that state on disk # again if needed
expect on_lparen provider on_rparen on_period to receive on_lparen on_symbeg UNK on_rparen on_period with on_lparen on_symbeg foo on_rparen on_period and_return on_lparen # we have to have an implementation of posixmethod which has to # convert a propertyname (e.g. comment) into a fieldname of our # Struct (e.g. gecos). I do not want to test posixmethod here so # let's fake an implementation which does not do any translation. We # expect two method invocations because info2hash calls the method # twice if the Struct responds to the propertyname (our fake Struct # provides values for :foo and :bar) TODO: Fix that
described_class on_period UNK on_lparen on_symbeg foo on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace on_op val on_op val on_op on_int on_rbrace on_nl # initialize resource so our provider has a @resource object
UNK on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op # comments_insync? overrides Puppet::Property#insync? and will act on an # array containing a should value (the expected value of Puppet::Property # @should)
