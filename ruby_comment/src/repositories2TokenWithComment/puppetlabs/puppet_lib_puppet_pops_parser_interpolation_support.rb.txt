UNK on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op UNK on_tstring_content UNK on_nl on_ignored_nl def UNK on_nl # This module is an integral part of the Lexer. # It defines interpolation support # PERFORMANCE NOTE: There are 4 very similar methods in this module that are designed to be as # performant as possible. While it is possible to parameterize them into one common method, the overhead # of passing parameters and evaluating conditional logic has a negative impact on performance. #
def UNK on_nl scn on_op on_ivar on_nl ctx on_op on_ivar on_nl before on_op scn on_period pos on_nl scn on_period UNK # This is the starting point for a double quoted string with possible interpolation # The structure mimics that of the grammar. # The logic is explicit (where the former implementation used parameters/structures) given to a # generic handler. # (This is both easier to understand and faster). #
scn on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_nl value on_comma terminator on_op UNK on_lparen on_rparen on_nl text on_op value # skip the leading " by doing a scan since the slurp_dqstring uses last matched when there is an error
UNK UNK on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl when # simple case, there was no interpolation, return directly
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl UNK count # The ${ terminator is counted towards the string part
UNK count on_nl break on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl varname on_op scn on_period UNK on_lparen on_const on_rparen on_nl if # Lex expression tokens until a closing (balanced) brace count is reached
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma after on_op before on_op on_int on_rbracket on_comma before on_rparen on_nl enqueue_completed on_lparen # The $ is counted towards the variable
text on_op terminator on_nl value on_comma terminator on_op UNK on_lparen on_rparen on_nl text on_op value on_nl after on_op scn on_period # false $ variable start
on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl scn on_op on_ivar on_nl ctx on_op on_ivar on_nl before on_op # return the first enqueued token and shift the queue
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl UNK on_nl # simple case, there was no further interpolation, return directly
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl UNK count # The ${ terminator is counted towards the string part
UNK count on_nl break on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl varname on_op scn on_period UNK on_lparen on_const on_rparen on_nl if # Lex expression tokens until a closing (balanced) brace count is reached
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma after on_op before on_op on_int on_rbracket on_comma before on_rparen on_nl enqueue_completed on_lparen # The $ is counted towards the variable
text on_op terminator on_nl value on_comma terminator on_op UNK on_nl text on_op value on_nl after on_op scn on_period pos on_nl # false $ variable start
def UNK on_nl scn on_op on_ivar on_nl ctx on_op on_ivar on_nl before on_op scn on_period pos on_nl value on_comma terminator # This is the starting point for a un-quoted string with possible interpolation # The logic is explicit (where the former implementation used parameters/strucures) given to a # generic handler. # (This is both easier to understand and faster). #
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl UNK on_nl # simple case, there was no interpolation, return directly
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl UNK count # The ${ terminator is counted towards the string part
UNK count on_nl break on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl varname on_op scn on_period UNK on_lparen on_const on_rparen on_nl if # Lex expression tokens until a closing (balanced) brace count is reached
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma after on_op before on_op on_int on_rbracket on_comma before on_rparen on_nl enqueue_completed on_lparen # The $ is counted towards the variable
text on_op terminator on_nl value on_comma terminator on_op UNK on_lparen on_rparen on_nl text on_op value on_nl after on_op scn on_period # false $ variable start
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl UNK on_nl # simple case, there was no further interpolation, return directly
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl UNK count # The ${ terminator is counted towards the string part
UNK count on_nl break on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl varname on_op scn on_period UNK on_lparen on_const on_rparen on_nl if # Lex expression tokens until a closing (balanced) brace count is reached
enqueue_completed on_lparen on_lbracket on_symbeg on_const on_comma text on_comma after on_op before on_op on_int on_rbracket on_comma before on_rparen on_nl enqueue_completed on_lparen # The $ is counted towards the variable
text on_op terminator on_nl value on_comma terminator on_op UNK on_nl text on_op value on_nl after on_op scn on_period pos on_nl # false $ variable start
def UNK brace_count on_nl scn on_op on_ivar on_nl ctx on_op on_ivar on_nl queue on_op on_ivar on_nl UNK on_op on_ivar on_lbracket # Enqueues lexed tokens until either end of input, or the given brace_count is reached #
queue on_period UNK on_lparen on_int on_comma token on_rparen on_nl UNK end on_nl token_name on_op token on_lbracket on_int on_rbracket on_nl ctx # A nested #interpolate_dq call shifted the queue_base token from the @token_queue. It must # be put back since it is intended for the top level #interpolate_dq call only.
end on_nl token_name on_op token on_lbracket on_int on_rbracket on_nl ctx on_lbracket on_symbeg after on_rbracket on_op token_name on_nl if token_name on_op # all relevant tokens are already on the queue
queue on_lbracket on_op on_int on_rbracket on_op UNK on_lparen queue on_lbracket on_op on_int on_rbracket on_rparen on_nl UNK UNK on_op on_int on_op # Single token is subject to replacement
queue on_lbracket UNK on_rbracket on_op UNK on_lparen queue on_lbracket UNK on_rbracket on_rparen on_nl end on_nl UNK on_nl end on_nl queue # A first word, number of name token followed by '[' or '.' is subject to replacement # But not for other operators such as ?, +, - etc. where user must use a $ before the name # to get a variable
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_nl queue on_op on_ivar on_nl UNK queue on_period UNK do on_ignored_nl UNK on_period # Interpolates unquoted string and transfers the result to the given lexer # (This is used when a second lexer instance is used to lex a substring) #
