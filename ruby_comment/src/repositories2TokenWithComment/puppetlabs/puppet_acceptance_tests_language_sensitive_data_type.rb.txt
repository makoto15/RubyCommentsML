on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_ignored_nl UNK on_op UNK on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl tmp_environment # Tests that sensitive data is retains integrity # between server and agent transport/application. # Leaving at acceptance layer due to validate # written logs.
UNK agent on_period UNK on_op UNK on_tstring_content UNK on_nl UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg tmp_environment on_embexpr_end on_tstring_content on_tstring_end on_nl UNK # ugh... this won't work with more than two agents of two types
notify_redacted on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op on_lbracket on_ignored_nl on_lbrace on_symbeg type on_op # first attempts at a reasonable table driven test. needs API work # FIXME: # expand this to other resource types, make parameters arbitrary, make assertions arbitrary # FIXME: add context messaging to each instance
on_lbrace on_symbeg type on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_symbeg parameters on_op on_lbrace on_symbeg namevar on_op on_tstring_beg on_tstring_content on_tstring_end on_rbrace on_comma # unwrap(), these should be en-clair
on_lbrace on_symbeg type on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_symbeg parameters on_op on_lbrace on_symbeg namevar on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_symbeg # for --show_diff
on_ignored_nl UNK on_op UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op UNK on_period UNK on_nl UNK on_lbracket on_symbeg # Make a copy of the full set of 'test_resources' but filtered down to include # only the assertions of type ':refute_match'. So for example, where the # 'test_resources' array might have an entry like this... # # {:type => 'notify', ... # :assertions => [{:refute_match => 'sekrit1'}, # {:assert_match => "1:#{notify_redacted}"}]} # # ... the ':assert_match' entry would be filtered out in the new # 'refutation_resources' array, producing: # # {:type => 'notify', ... # :assertions => [{:refute_match => 'sekrit1'}]} # # This is done so that when validating the log output, we can refute the # existence of any of the sensitive info in the log without having to # assert that redacted info is in the log. The redacted info appears in # the console output from the Puppet agent run - by virtue of including a # '--debug' flag on the agent command line - whereas the redacted info is not # expected to be piped into the log.
UNK on_lparen agent on_comma UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg tmp_environment on_embexpr_end on_tstring_end on_rparen on_comma on_symbeg UNK on_op UNK on_rparen do # redirect logging to a temp location to avoid platform specific syslogs
UNK on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_lparen agent on_comma on_tstring_beg on_tstring_content on_embexpr_beg agent on_period UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end # don't do this before the agent log scanning, above. it will skew the results
UNK on_lparen agent on_comma on_tstring_beg on_tstring_content on_embexpr_beg agent on_period UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_embexpr_end on_tstring_content on_tstring_end on_comma on_symbeg # no recursive grep in solaris :facepalm:
UNK on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl refute_match on_lparen UNK on_tstring_content UNK on_comma result on_period UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen #TODO: if/when this is fixed, we should just be able to eval(assertion_code_ in this result block also!
