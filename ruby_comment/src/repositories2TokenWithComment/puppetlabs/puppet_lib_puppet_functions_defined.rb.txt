on_const on_op on_const on_period UNK on_lparen UNK on_tstring_content on_tstring_end on_comma on_const on_op on_const on_op on_const on_rparen UNK on_ignored_nl on_ignored_nl UNK # Determines whether a given class or resource type is defined and returns a Boolean # value. You can also use `defined` to determine whether a specific resource is defined, # or whether a variable has a value (including `undef`, as opposed to the variable never # being declared or assigned). # # This function takes at least one string argument, which can be a class name, type name, # resource reference, or variable reference of the form `'$name'`. (Note that the `$` sign # is included in the string which must be in single quotes to prevent the `$` character # to be interpreted as interpolation. # # The `defined` function checks both native and defined types, including types # provided by modules. Types and classes are matched by their names. The function matches # resource declarations by using resource references. # # @example Different types of `defined` function matches # # ```puppet # # Matching resource types # defined("file") # defined("customtype") # # # Matching defines and classes # defined("foo") # defined("foo::bar") # # # Matching variables (note the single quotes) # defined('$name') # # # Matching declared resources # defined(File['/tmp/file']) # ``` # # Puppet depends on the configuration's evaluation order when checking whether a resource # is declared. # # @example Importance of evaluation order when using `defined` # # ```puppet # # Assign values to $is_defined_before and $is_defined_after using identical `defined` # # functions. # # $is_defined_before = defined(File['/tmp/file']) # # file { "/tmp/file": # ensure => present, # } # # $is_defined_after = defined(File['/tmp/file']) # # # $is_defined_before returns false, but $is_defined_after returns true. # ``` # # This order requirement only refers to evaluation order. The order of resources in the # configuration graph (e.g. with `before` or `require`) does not affect the `defined` # function's behavior. # # > **Warning:** Avoid relying on the result of the `defined` function in modules, as you # > might not be able to guarantee the evaluation order well enough to produce consistent # > results. This can cause other code that relies on the function's result to behave # > inconsistently or fail. # # If you pass more than one argument to `defined`, the function returns `true` if _any_ # of the arguments are defined. You can also match resources by type, allowing you to # match conditions of different levels of specificity, such as whether a specific resource # is of a specific data type. # # @example Matching multiple resources and resources by different types with `defined` # # ```puppet # file { "/tmp/file1": # ensure => file, # } # # $tmp_file = file { "/tmp/file2": # ensure => file, # } # # # Each of these statements return `true` ... # defined(File['/tmp/file1']) # defined(File['/tmp/file1'],File['/tmp/file2']) # defined(File['/tmp/file1'],File['/tmp/file2'],File['/tmp/file3']) # # ... but this returns `false`. # defined(File['/tmp/file3']) # # # Each of these statements returns `true` ... # defined(Type[Resource['file','/tmp/file2']]) # defined(Resource['file','/tmp/file2']) # defined(File['/tmp/file2']) # defined('$tmp_file') # # ... but each of these returns `false`. # defined(Type[Resource['exec','/tmp/file2']]) # defined(Resource['exec','/tmp/file2']) # defined(File['/tmp/file3']) # defined('$tmp_file2') # ``` # # @since 2.7.0 # @since 3.6.0 variable reference and future parser types # @since 3.8.1 type specific requests with future parser # @since 4.0.0 #
on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen scope on_rparen on_nl UNK on_ignored_nl on_const on_op on_const on_op on_const # Find the main class (known as ''), it does not have to be in the catalog
on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen scope on_comma val on_rparen on_nl end on_nl end on_nl when # Find a resource type, definition or class definition
scope on_period UNK on_period UNK on_lparen val on_period UNK on_comma val on_period UNK on_rparen on_nl on_ignored_nl when on_const on_op on_const # Find instance of given resource type and title that is in the catalog
UNK on_lparen scope on_comma val on_period type on_rparen on_nl on_ignored_nl when on_const on_op on_const on_op on_const on_op on_const on_nl UNK # It is most reasonable to take Type[File] and Type[File[foo]] to mean the same as if not wrapped in a Type # Since the difference between File and File[foo] already captures the distinction of type vs instance.
UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK val on_period type on_period UNK on_period UNK on_nl on_const on_op # Interpreted as asking if a class (and nothing else) is defined without having to be included in the catalog # (this is the same as asking for just the class' name, but with the added certainty that it cannot be a defined type. #
