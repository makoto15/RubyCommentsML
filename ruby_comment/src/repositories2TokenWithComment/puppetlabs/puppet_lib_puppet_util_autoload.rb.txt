class on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK UNK UNK on_nl end # An adapter that ties the module_directories cache to the environment where the modules are parsed. This # adapter ensures that the life-cycle of this cache doesn't exceed the life-cycle of the environment. # # @api private
class on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_op on_const # Autoload paths, either based on names or all at once.
def UNK on_lparen path on_rparen on_ignored_nl path on_op UNK on_lparen path on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Has a given path been loaded? This is used for testing whether a # changed file should be loaded or just ignored. This is only # used in network/client/master, when downloading plugins, to # see if a given plugin is currently loaded and thus should be # reloaded.
def UNK on_lparen name on_comma file on_rparen on_ignored_nl name on_op UNK on_lparen name on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # Save the fact that a given path has been loaded. This is so # we can load downloaded plugins if they've already been loaded # into memory. # @api private
def UNK on_lparen name on_comma env on_rparen on_ignored_nl name on_op UNK on_lparen name on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # @api private
def UNK on_lparen name on_comma env on_rparen on_ignored_nl file on_op UNK on_lparen name on_period UNK on_comma env on_rparen on_nl UNK # Load a single plugin by name. We use 'load' here so we can reload a # given plugin.
UNK on_lparen path on_comma env on_rparen on_period UNK do on_op file on_op on_ignored_nl name on_op file on_period UNK on_lparen on_tstring_beg # Load every instance of everything we can find.
def UNK on_lparen name on_comma env on_rparen on_ignored_nl name on_op name on_op on_tstring_beg on_tstring_content on_tstring_end unless name on_op UNK on_tstring_content # Get the correct file to load for a given path # returns nil if no file is found # @api private
def UNK on_lparen dir on_comma path on_rparen on_ignored_nl dir on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen dir on_rparen # @api private
def UNK on_lparen env on_rparen on_ignored_nl UNK on_const on_comma on_tstring_beg on_tstring_content on_tstring_end unless env on_nl on_ignored_nl on_const on_op on_const on_op # @api private
def UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen env on_rparen on_ignored_nl UNK on_const on_period UNK # @api private
def UNK on_lparen env on_rparen on_ignored_nl UNK on_const on_period UNK on_period UNK on_nl UNK on_op UNK on_lparen env on_rparen on_op # @api private
UNK on_const on_period UNK on_period UNK on_nl UNK on_op UNK on_lparen env on_rparen on_op UNK on_nl UNK on_ignored_nl UNK on_op # This is a little bit of a hack. Basically, the autoloader is being # called indirectly during application bootstrapping when we do things # such as check "features". However, during bootstrapping, we haven't # yet parsed all of the command line parameters nor the config files, # and thus we don't yet know with certainty what the module path is. # This should be irrelevant during bootstrapping, because anything that # we are attempting to load during bootstrapping should be something # that we ship with puppet, and thus the module path is irrelevant. # # In the long term, I think the way that we want to handle this is to # have the autoloader ignore the module path in all cases where it is # not specifically requested (e.g., by a constructor param or # something)... because there are very few cases where we should # actually be loading code from the module path. However, until that # happens, we at least need a way to prevent the autoloader from # attempting to access the module path before it is initialized. For # now we are accomplishing that by calling the # "app_defaults_initialized?" method on the main puppet Settings object. # --cprice 2012-03-16
def UNK on_lparen path on_rparen on_ignored_nl UNK on_const on_op on_const on_period UNK on_lparen path on_rparen on_nl on_const on_period UNK on_lparen # Normalize a path. This converts ALT_SEPARATOR to SEPARATOR on Windows # and eliminates unnecessary parts of a path.
UNK on_const on_op on_const on_period UNK on_lparen path on_rparen on_nl on_const on_period UNK on_lparen path on_rparen on_nl UNK on_ignored_nl on_const # There are two cases here because cleanpath does not handle absolute # paths correctly on windows (c:\ and c:/ are treated as distinct) but # we don't want to convert relative paths to absolute
def UNK on_lparen env on_rparen on_ignored_nl self on_period class on_period UNK on_lparen on_ivar on_comma env on_rparen on_nl end on_nl on_ignored_nl # Load all instances from a path of Autoload.search_directories matching the # relative path this Autoloader was initialized with. For example, if we # have created a Puppet::Util::Autoload for Puppet::Type::User with a path of # 'puppet/provider/user', the search_directories path will be searched for # all ruby files matching puppet/provider/user/*.rb and they will then be # loaded from the first directory in the search path providing them. So # earlier entries in the search path may shadow later entries. # # This uses require, rather than load, so that already-loaded files don't get # reloaded unnecessarily.
def UNK on_lparen name on_comma env on_rparen on_ignored_nl self on_period class on_period UNK on_lparen UNK on_lparen name on_rparen on_comma env # @api private
