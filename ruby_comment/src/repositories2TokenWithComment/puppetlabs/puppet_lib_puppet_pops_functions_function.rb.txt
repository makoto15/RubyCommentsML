UNK on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_symbeg closure_scope on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def # @note WARNING: This new function API is still under development and may change at # any time # # A function in the puppet evaluator. # # Functions are normally defined by another system, which produces subclasses # of this class as well as constructing delegations to call the appropriate methods. # # This class should rarely be used directly. Instead functions should be # constructed using {Puppet::Functions.create_function}. # # @api public
UNK on_symbeg closure_scope on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen closure_scope on_comma UNK on_rparen on_ignored_nl UNK on_op # The scope where the function was defined
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen closure_scope on_comma UNK on_rparen on_ignored_nl UNK on_op closure_scope on_nl UNK on_op UNK # The loader that loaded this function. # Should be used if function wants to load other things. #
def UNK on_lparen UNK on_comma on_op args on_comma on_op block on_rparen on_ignored_nl UNK on_ignored_nl UNK on_op UNK on_lparen on_symbeg UNK # Invokes the function via the dispatching logic that performs type check and weaving. # A specialized function may override this method to do its own dispatching and checking of # the raw arguments. A specialized implementation can rearrange arguments, add or remove # arguments and then delegate to the dispatching logic by calling: # # @example Delegating to the dispatcher # def call(scope, *args) # manipulated_args = args + ['easter_egg'] # self.class.dispatcher.dispatch(self, scope, manipulated_args) # end # # System functions that must have access to the calling scope can use this technique. Functions # in general should not need the calling scope. (The closure scope; what is visible where the function # is defined) is available via the method `closure_scope`). # # @api public
def UNK on_lparen function_name on_comma on_op args on_comma on_op block on_rparen on_ignored_nl UNK on_lparen closure_scope on_comma function_name on_comma args on_comma # Allows the implementation of a function to call other functions by name. The callable functions # are those visible to the same loader that loaded this function (the calling function). The # referenced function is called with the calling functions closure scope as the caller's scope. # # @param function_name [String] The name of the function # @param *args [Object] splat of arguments # @return [Object] The result returned by the called function # # @api public
UNK on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen UNK UNK UNK UNK on_nl end on_nl on_ignored_nl def self on_period # If closure scope is explicitly set to not nil, if there is a global scope, otherwise an empty hash
def self on_period UNK on_nl UNK on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_nl end on_nl on_ignored_nl # The dispatcher for the function # # @api private
def self on_period UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen UNK on_comma # Produces information about parameters in a way that is compatible with Closure # # @api private
def UNK on_lparen UNK on_comma function_name on_comma args on_comma on_op block on_rparen on_ignored_nl on_ignored_nl UNK on_op UNK on_nl UNK UNK # Allows the implementation of a function to call other functions by name and pass the caller # scope. The callable functions are those visible to the same loader that loaded this function # (the calling function). # # @param scope [Puppet::Parser::Scope] The caller scope # @param function_name [String] The name of the function # @param args [Array] array of arguments # @return [Object] The result returned by the called function # # @api public
UNK on_op closure_scope on_nl UNK on_op on_const on_op on_const on_op on_const on_period UNK on_lparen function_name on_comma UNK on_period UNK on_rparen # Check if a 3x function is present. Raise a generic error if it's not to allow upper layers to fill in the details # about where in a puppet manifest this error originates. (Such information is not available here).
UNK on_op UNK on_period UNK on_lparen UNK on_comma on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen args on_comma # Call via 3x API # Arguments must be mapped since functions are unaware of the new and magical creatures in 4x. # NOTE: Passing an empty string last converts nil/:undef to empty string
on_const on_op on_const on_op on_const on_period UNK on_lparen function_name on_rparen on_op UNK on_op UNK on_nl end on_nl on_ignored_nl end on_nl # Prevent non r-value functions from leaking their result (they are not written to care about this)
