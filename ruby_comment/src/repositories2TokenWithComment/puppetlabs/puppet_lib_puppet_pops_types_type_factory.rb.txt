UNK on_const on_nl on_ivar on_op on_const on_period singleton on_nl on_ignored_nl def self on_period UNK on_nl on_ivar on_op nil on_nl on_ivar # Helper module that makes creation of type objects simpler. # @api public #
def self on_period UNK on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil # Clears caches - used when testing
on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl # these types are cached and needs to be nulled as the representation may change if loaders are cleared
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen from on_comma to # Produces the Integer type # @api public #
def self on_period UNK on_lparen from on_comma to on_rparen on_ignored_nl from on_op on_symbeg default on_op from if from on_op on_tstring_beg # Produces an Integer range type # @api public #
from on_op on_symbeg default on_op from if from on_op on_tstring_beg on_tstring_content on_tstring_end on_nl to on_op on_symbeg default if to on_op # optimize eq with symbol (faster when it is left)
def self on_period UNK on_lparen from on_comma to on_rparen on_ignored_nl from on_op on_const on_lparen from on_rparen unless on_symbeg default on_op # Produces a Float range type # @api public #
from on_op on_const on_lparen from on_rparen unless on_symbeg default on_op from on_op from on_period nil? on_nl to on_op on_const on_lparen # optimize eq with symbol (faster when it is left)
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen type on_op nil # Produces the Float type # @api public #
def self on_period UNK on_lparen type on_op nil on_rparen on_ignored_nl on_const on_period new on_lparen type on_rparen on_nl end on_nl on_ignored_nl # Produces the Sensitive type # @api public #
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen on_op args on_rparen # Produces the Numeric type # @api public #
def self on_period UNK on_lparen on_op args on_rparen on_ignored_nl case args on_period size on_nl when on_int on_nl on_const on_op on_const # Produces the Init type # @api public
def self on_period UNK on_lparen elem_type on_op nil on_rparen on_ignored_nl elem_type on_period nil? on_op on_const on_op on_const on_op on_const on_period # Produces the Iterable type # @api public #
def self on_period UNK on_lparen elem_type on_op nil on_rparen on_ignored_nl elem_type on_period nil? on_op on_const on_op on_const on_op on_const on_period # Produces the Iterator type # @api public #
def self on_period UNK on_lparen t on_rparen on_ignored_nl on_ivar on_period string on_lparen t on_rparen on_nl end on_nl on_ignored_nl def self # Produces a string representation of the type # @api public #
def self on_period string on_lparen UNK on_op nil on_comma on_op UNK on_rparen on_ignored_nl if UNK on_period empty? on_nl UNK on_period # Produces the String type based on nothing, a string value that becomes an exact match constraint, or a parameterized # Integer type that constraints the size. # # @api public #
UNK on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end #TRANSLATORS 'TypeFactory#string' is a class and method name and should not be translated
def self on_period UNK on_lparen optional_type on_op nil on_rparen on_ignored_nl if optional_type on_period nil? on_nl on_const on_op on_const on_nl else # Produces the Optional type, i.e. a short hand for Variant[T, Undef] # If the given 'optional_type' argument is a String, then it will be # converted into a String type that represents that string. # # @param optional_type [String,PAnyType,nil] the optional type # @return [POptionalType] the created type # # @api public #
def self on_period UNK on_lparen on_op values on_rparen on_ignored_nl last on_op values on_period last on_nl UNK on_op UNK on_nl if # Produces the Enum type, optionally with specific string values # @api public #
def self on_period UNK on_lparen on_op types on_rparen on_ignored_nl on_const on_period UNK on_lparen types on_period UNK UNK on_op UNK on_op # Produces the Variant type, optionally with the "one of" types # @api public #
def self on_period UNK on_lparen hash on_op UNK UNK on_rparen on_ignored_nl UNK on_op on_ivar on_nl UNK on_op hash on_period UNK # Produces the Struct type, either a non parameterized instance representing # all structs (i.e. all hashes) or a hash with entries where the key is # either a literal String, an Enum with one entry, or a String representing exactly one value. # The key type may also be wrapped in a NotUndef or an Optional. # # The value can be a ruby class, a String (interpreted as the name of a ruby class) or # a Type. # # @param hash [{String,PAnyType=>PAnyType}] key => value hash # @return [PStructType] the created Struct type #
if key_type on_period is_a? on_lparen on_const on_rparen on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end if key_type on_period empty? on_nl key_type # TODO: Should have stricter name rule
key_type on_op UNK on_lparen key_type on_rparen if UNK on_period UNK on_lparen value_type on_comma on_const on_op on_const on_rparen on_nl else on_ignored_nl # Must make key optional if the value can be Undef
case key_type on_nl when on_const on_nl key_type on_op key_type on_period type on_nl s on_op key_type on_nl when on_const on_nl s # assert that the key type is one of String[1], NotUndef[String[1]] and Optional[String[1]]
key_type on_op key_type on_period type on_nl s on_op key_type on_nl when on_const on_nl s on_op key_type on_period optional_type on_nl when # We can loose the NotUndef wrapper here since String[1] isn't optional anyway
def self on_period UNK on_lparen hash on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl hash on_period nil? on_op hash on_period # Produces an `Object` type from the given _hash_ that represents the features of the object # # @param hash [{String=>Object}] the hash of feature groups # @return [PObjectType] the created type #
def self on_period UNK on_lparen value on_op nil on_rparen on_ignored_nl value on_period nil? on_op on_const on_op on_const on_op on_lparen value # Produces the Boolean type # @api public #
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_op nil # Produces the Any type # @api public #
def self on_period UNK on_lparen UNK on_op nil on_rparen on_ignored_nl UNK on_op on_const on_period new on_lparen UNK on_rparen on_op on_const # Produces the Regexp type # @param pattern [Regexp, String, nil] (nil) The regular expression object or # a regexp source string, or nil for bare type # @api public #
UNK on_nl on_ignored_nl when on_const on_nl on_const on_period new on_lparen re on_rparen on_nl on_ignored_nl when on_const on_nl re on_nl on_ignored_nl # compile it to catch errors
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_const on_op on_const # Produces the Scalar type # @api public #
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_nl UNK on_const on_op # Produces the ScalarData type # @api public #
def self on_period UNK on_nl UNK on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen on_op params # Produces a CallableType matching all callables # @api public #
def self on_period UNK on_lparen on_op params on_rparen on_ignored_nl if params on_period size on_op on_int on_op params on_lbracket on_int on_rbracket # Produces a Callable type with one signature without support for a block # Use #with_block, or #with_optional_block to add a block to the callable # If no parameters are given, the Callable will describe a signature # that does not accept parameters. To create a Callable that matches all callables # use {#all_callables}. # # The params is a list of types, where the three last entries may be # optionally followed by min, max count, and a Callable which is taken as the # block_type. # If neither min or max are specified the parameters must match exactly. # A min < params.size means that the difference are optional. # If max > params.size means that the last type repeats. # if max is :default, the max value is unbound (infinity). # # Params are given as a sequence of arguments to {#type_of}. #
if UNK on_lparen params on_lbracket on_op on_int on_rbracket on_rparen on_op UNK on_lparen params on_lbracket on_op on_int on_rbracket on_rparen on_nl size_type # compute a size_type for the signature based on the two last parameters
if types on_period empty? on_op on_op size_type on_period nil? on_op size_type on_period UNK on_lbracket on_int on_rbracket on_op on_int on_nl types # If the specification requires types, and none were given, a Unit type is used
UNK on_op UNK on_lparen types on_comma size_type on_rparen on_nl on_const on_period new on_lparen UNK on_comma UNK on_comma UNK on_rparen on_nl # create a signature
def self on_period UNK on_lparen size_type on_op nil on_rparen on_ignored_nl size_type on_period nil? on_op on_const on_op on_const on_op on_const on_period # Produces the abstract type Collection # @api public #
def self on_period UNK on_nl on_ivar on_op on_const on_period singleton on_period parse on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_const on_period UNK # Produces the Data type # @api public #
def self on_period UNK on_nl on_ivar on_op on_const on_period singleton on_period parse on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_const on_period UNK # Produces the RichData type # @api public #
def self on_period UNK on_nl on_ivar on_op on_const on_period singleton on_period parse on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_const on_period UNK # Produces the RichData type # @api public #
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period default on_nl on_const on_op on_const # Creates an instance of the Undef type # @api public
def self on_period default on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_const on_op on_const # Creates an instance of the Default type # @api public
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_const on_op on_const # Creates an instance of the Binary type # @api public
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_const on_op on_const # Produces an instance of the abstract type PCatalogEntryType
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen on_op UNK on_rparen # Produces an instance of the SemVerRange type
def self on_period UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_period empty? on_op on_const on_op on_const on_op on_const on_op new # Produces an instance of the SemVer type
def self on_period UNK on_lparen type_name on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl case type_name on_nl when on_const on_nl # Produces a PResourceType with a String type_name A PResourceType with a nil # or empty name is compatible with any other PResourceType. A PResourceType # with a given name is only compatible with a PResourceType with the same # name. (There is no resource-type subtyping in Puppet (yet)). #
def self on_period UNK on_lparen UNK on_op nil on_rparen on_ignored_nl if UNK on_period nil? on_nl on_const on_op on_const on_nl else # Produces PClassType with a string class_name. A PClassType with # nil or empty name is compatible with any other PClassType. A # PClassType with a given name is only compatible with a PClassType # with the same name. #
def self on_period UNK on_lparen o on_comma size_type on_op nil on_rparen on_ignored_nl on_const on_period new on_lparen type_of on_lparen o on_rparen # Produces a type for Array[o] where o is either a type, or an instance for # which a type is inferred. # @api public #
def self on_period UNK on_lparen value on_comma UNK on_op UNK on_comma size_type on_op nil on_rparen on_ignored_nl on_const on_period new on_lparen # Produces a type for Hash[Scalar, o] where o is either a type, or an # instance for which a type is inferred. # @api public #
def self on_period UNK on_lparen key_type on_comma value_type on_comma size_type on_op nil on_rparen on_ignored_nl on_const on_period new on_lparen key_type on_comma # Produces a type for Hash[key,value,size] # @param key_type [PAnyType] the key type # @param value_type [PAnyType] the value type # @param size_type [PIntegerType] # @return [PHashType] the created hash type # @api public #
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_ivar on_op on_const # Produces a type for Array[Any] # @api public #
def self on_period UNK on_nl on_ivar on_op on_const on_period new on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def self on_period # Produces a type for Array[Data] # @api public #
def self on_period UNK on_nl on_const on_op on_const on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_ivar on_op on_const # Produces a type for Hash[Any,Any] # @api public #
def self on_period UNK on_nl on_ivar on_op on_const on_period new on_lparen string on_comma UNK on_rparen on_nl end on_nl on_ignored_nl def # Produces a type for Hash[String,Data] # @api public #
def self on_period UNK on_lparen inst_type on_op nil on_rparen on_ignored_nl inst_type on_op string on_lparen inst_type on_rparen if inst_type on_period is_a? # Produces a type for NotUndef[T] # The given 'inst_type' can be a string in which case it will be converted into # the type String[inst_type]. # # @param inst_type [Type,String] the type to qualify # @return [PNotUndefType] the NotUndef type # # @api public #
def self on_period UNK on_lparen inst_type on_op nil on_rparen on_ignored_nl inst_type on_period nil? on_op on_const on_op on_const on_op on_const on_period # Produces a type for Type[T] # @api public #
def self on_period UNK on_nl on_ivar on_op on_const on_period singleton on_period parse on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_const on_period UNK # Produces a type for Error # @api public #
def self on_period UNK on_lparen UNK on_op nil on_rparen on_ignored_nl UNK on_period nil? on_op on_const on_op on_const on_op on_const on_period # Produces a type for URI[String or Hash] # @api public #
def self on_period type_of on_lparen o on_rparen on_ignored_nl if o on_period is_a? on_lparen on_const on_rparen on_nl on_ivar on_period type on_lparen # Produce a type corresponding to the class of given unless given is a # String, Class or a PAnyType. When a String is given this is taken as # a classname. #
def self on_period UNK on_lparen o on_rparen on_ignored_nl if o on_period is_a? on_lparen on_const on_rparen on_nl on_ivar on_period type on_lparen # Produces a type for a class or infers a type for something that is not a # class # @note # To get the type for the class' class use `TypeCalculator.infer(c)` # # @overload ruby(o) # @param o [Class] produces the type corresponding to the class (e.g. # Integer becomes PIntegerType) # @overload ruby(o) # @param o [Object] produces the type corresponding to the instance class # (e.g. 3 becomes PIntegerType) # # @api public #
def self on_period UNK on_lparen UNK on_op nil on_rparen on_ignored_nl on_const on_period new on_lparen on_symbeg UNK on_comma UNK on_rparen on_nl # Generic creator of a RuntimeType["ruby"] - allows creating the Ruby type # with nil name, or String name. Also see ruby(o) which performs inference, # or mapps a Ruby Class to its name. #
def self on_period runtime on_lparen runtime on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl runtime on_op runtime on_period UNK if # Generic creator of a RuntimeType - allows creating the type with nil or # String runtime_type_name. Also see ruby_type(o) and ruby(o). #
def self on_period UNK on_lparen name on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl name on_period nil? on_op on_const on_op # Returns the type alias for the given expression # @param name [String] the name of the unresolved type # @param expression [Model::Expression] an expression that will evaluate to a type # @return [PTypeAliasType] the type alias
def self on_period UNK on_lparen UNK on_op nil on_rparen on_ignored_nl UNK on_op nil on_op on_const on_op on_const on_op on_const on_period # Returns the type that represents a type reference with a given name and optional # parameters. # @param type_string [String] the string form of the type # @return [PTypeReferenceType] the type reference
def self on_period UNK on_lparen t on_rparen on_ignored_nl t on_period is_a? on_lparen on_const on_rparen on_op t on_op on_tstring_beg on_tstring_content on_tstring_end # Returns true if the given type t is of valid range parameter type (integer # or literal default).
