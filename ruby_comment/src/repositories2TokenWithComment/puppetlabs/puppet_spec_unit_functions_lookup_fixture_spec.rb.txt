UNK on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl include on_const on_op on_const on_nl on_ignored_nl UNK assemble_and_compile on_lparen UNK on_comma on_op UNK on_comma # Tests the lookup function using fixtures
UNK assemble_and_compile on_lparen UNK on_comma on_op UNK on_comma on_op UNK on_rparen on_ignored_nl assemble_and_compile_with_block on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma # Assembles code that includes the *abc* class and compiles it into a catalog. This class will use the global # variable $args to perform a lookup and assign the result to $abc::result. Unless the $block is set to # the string 'no_block_present', it will be passed as a lambda to the lookup. The assembled code will declare # a notify resource with a name that is formed by interpolating the result into a format string. # # The method performs the folloging steps. # # - Build the code that: # - sets the $args variable from _lookup_args_ # - sets the $block parameter to the given block or the string 'no_block_present' # - includes the abc class # - assigns the $abc::result to $r # - interpolates a string using _fmt_ (which is assumed to use $r) # - declares a notify resource from the interpolated string # - Compile the code into a catalog # - Return the name of all Notify resources in that catalog # # @param fmt [String] The puppet interpolated string used when creating the notify title # @param *args [String] splat of args that will be concatenated to form the puppet args sent to lookup # @return [Array<String>] List of names of Notify resources in the resulting catalog #
UNK on_lparen on_symbeg environmentpath on_rparen on_lbrace on_const on_period join on_lparen my_fixture_dir on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rbrace on_nl UNK on_lparen # There is a fully configured 'production' environment in fixtures at this location
on_const on_period settings on_period UNK on_nl on_ignored_nl UNK on_op on_const on_op on_const on_op on_const on_period new on_lparen environmentpath on_comma on_lbracket # Initialize settings to get a full compile as close as possible to a real # environment load
UNK on_op on_const on_op on_const on_op on_const on_period new on_lparen environmentpath on_comma on_lbracket on_rbracket on_rparen on_nl on_const on_period UNK on_lparen # Initialize loaders based on the environmentpath. It does not work to # just set the setting environmentpath for some reason - this achieves the same: # - first a loader is created, loading directory environments from the fixture (there is # one environment, 'production', which will be loaded since the node references this # environment by name). # - secondly, the created env loader is set as 'environments' in the puppet context. #
end on_nl end on_nl on_ignored_nl context on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl on_const on_lbracket on_symbeg # k2 is missing
it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl on_const on_lbracket on_symbeg code on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl expect on_lbrace compiler on_period # An empty YAML file is OK and should be treated as a file that contains no keys
it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl on_const on_lbracket on_symbeg code on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl expect on_lbrace compiler on_period # An empty JSON file is not OK. Should yield a parse error
