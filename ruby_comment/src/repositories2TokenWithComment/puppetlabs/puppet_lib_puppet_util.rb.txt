on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # A module to collect utility functions.
require on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end if on_const on_op # These are all for backward compatibility -- these are methods that used # to be in Puppet::Util but have been moved into external modules.
def get_env on_lparen name on_comma mode on_op default_env on_rparen on_ignored_nl if mode on_op on_symbeg windows on_nl on_const on_op on_const on_op # @param name [String] The name of the environment variable to retrieve # @param mode [Symbol] Which operating system mode to use e.g. :posix or :windows. Use nil to autodetect # @return [String] Value of the specified environment variable. nil if it does not exist # @api private
def UNK on_lparen mode on_op default_env on_rparen on_ignored_nl UNK mode on_nl when on_symbeg posix on_nl on_const on_period UNK on_nl when # @param mode [Symbol] Which operating system mode to use e.g. :posix or :windows. Use nil to autodetect # @return [Hash] A hashtable of all environment variables # @api private
def UNK on_lparen mode on_op default_env on_rparen on_ignored_nl UNK mode on_nl when on_symbeg posix on_nl on_const on_period UNK on_nl when # Removes all environment variables # @param mode [Symbol] Which operating system mode to use e.g. :posix or :windows. Use nil to autodetect # @api private
def UNK on_lparen name on_comma UNK on_op nil on_comma mode on_op default_env on_rparen on_ignored_nl UNK mode on_nl when on_symbeg posix # @param name [String] The name of the environment variable to set # @param value [String] The value to set the variable to. nil deletes the environment variable # @param mode [Symbol] Which operating system mode to use e.g. :posix or :windows. Use nil to autodetect # @api private
def UNK on_lparen UNK on_comma mode on_op default_env on_rparen on_ignored_nl UNK mode on_nl when on_symbeg posix on_nl UNK on_period each # @param name [Hash] Environment variables to merge into the existing environment. nil values will remove the variable # @param mode [Symbol] Which operating system mode to use e.g. :posix or :windows. Use nil to autodetect # @api private
def UNK on_lparen UNK on_comma mode on_op on_symbeg posix on_rparen on_ignored_nl UNK on_op UNK on_lparen mode on_rparen on_nl UNK on_lparen # Run some code with a specific environment. Resets the environment back to # what it was at the end of the code. # Windows can store Unicode chars in the environment as keys or values, but # Ruby's ENV tries to roundtrip them through the local codepage, which can # cause encoding problems - underlying helpers use Windows APIs on Windows # see https://bugs.ruby-lang.org/issues/8822
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl begin on_ignored_nl # Execute a given chunk of code with a new umask.
def self on_period UNK on_nl group on_op on_const on_lbracket on_symbeg group on_rbracket on_nl if group on_nl begin on_ignored_nl on_const on_op # Change the process to a different user
end on_nl end on_nl on_ignored_nl UNK on_op on_const on_lbracket on_symbeg UNK on_rbracket on_nl if UNK on_nl begin on_ignored_nl on_const on_op # Don't exit on failed group changes, since it's # not fatal #exit(74)
def self on_period UNK on_lparen UNK on_comma UNK on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_period UNK on_lbrace # Create instance methods for each of the log levels. This allows # the messages to be a little richer. Most classes will be calling this # method.
def UNK on_lparen on_op args on_rparen on_ignored_nl UNK on_op args on_period UNK on_nl level on_op args on_period UNK on_nl UNK # execute a block of work and based on the logging level provided, log the provided message with the seconds taken # The message 'msg' should include string ' in %{seconds} seconds' as part of the message and any content should escape # any percent signs '%' so that they are not interpreted as formatting commands # escaped_str = str.gsub(/%/, '%%') # # @param msg [String] the message to be formated to assigned the %{seconds} seconds take to execute, # other percent signs '%' need to be escaped # @param level [Symbol] the logging level for this message # @param object [Object] The object use for logging the message
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless level on_nl on_ignored_nl unless level on_op on_symbeg UNK #TRANSLATORS 'benchmark' is a method name and should not be translated
if level on_op on_symbeg UNK UNK on_const on_op on_const on_op on_const on_period UNK on_lparen level on_rparen on_nl UNK on_op on_const # Only benchmark if our log level is high enough
def UNK on_lparen bin on_rparen on_ignored_nl if UNK on_lparen bin on_rparen on_nl return bin if on_const on_period UNK bin UNK # Resolve a path for an executable to the absolute path. This tries to behave # in the same manner as the unix `which` command and uses the `PATH` # environment variable. # # @api public # @param bin [String] the name of the executable to find. # @return [String] the absolute path to the found executable.
if UNK on_period UNK on_op on_regexp_beg on_tstring_content on_regexp_end UNK on_lparen on_const on_op on_const on_period get_env on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # if the user's PATH contains a literal tilde (~) character and HOME is not set, we may get # an ArgumentError here. Let's check to see if that is the case; if not, re-raise whatever error # was thrown.
on_const on_op on_const on_op on_const on_period UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label UNK on_rbrace on_rparen # if we get here they have a tilde in their PATH. We'll issue a single warning about this and then # ignore this path element and carry on with our lives. #TRANSLATORS PATH and HOME are environment variables and should not be translated
on_const on_op on_const on_op on_const on_period UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label UNK on_rbrace on_rparen # ...otherwise, we just skip the non-existent entry, and do nothing. #TRANSLATORS PATH is an environment variable and should not be translated
slash on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_regexp_beg on_tstring_content on_embexpr_beg slash on_embexpr_end on_tstring_content # Determine in a platform-specific way whether a path is absolute. This # defaults to the local platform if none is specified. # # Escape once for the string literal, and once for the regex.
UNK on_op on_const on_op on_const on_op on_const on_period windows? on_op on_symbeg windows on_op on_symbeg posix on_nl UNK on_op UNK UNK # Ruby only sets File::ALT_SEPARATOR on Windows and the Ruby standard # library uses that to test what platform it's on. Normally in Puppet we # would use Puppet.features.microsoft_windows?, but this method needs to # be called during the initialization of features so it can't depend on # that. # # @deprecated Use ruby's built-in methods to determine if a path is absolute.
def UNK on_lparen path on_rparen on_ignored_nl return unless path on_nl on_ignored_nl params on_op on_lbrace on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end # Convert a path to a file URI
params on_lbracket on_symbeg path on_rbracket on_comma params on_lbracket on_symbeg UNK on_rbracket on_op UNK on_lparen path on_rparen on_period UNK on_lparen on_tstring_beg # have to split *after* any relevant escaping
def UNK on_lparen uri on_rparen on_ignored_nl return unless uri on_period UNK on_lparen on_const on_rparen on_nl on_ignored_nl path on_op on_const on_period # Get the path component of a URI
path on_op on_const on_period UNK on_lparen uri on_period path on_period UNK on_lparen on_const on_op on_const on_rparen on_rparen on_nl on_ignored_nl if # CGI.unescape doesn't handle space rules properly in uri paths # URI.unescape does, but returns strings in their original encoding
else on_ignored_nl path on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end on_rparen on_nl end on_nl end on_nl on_ignored_nl path # UNC
def UNK on_lparen UNK on_rparen on_ignored_nl return nil if UNK on_period nil? on_nl on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen # Percent-encodes a URI query parameter per RFC3986 - https://tools.ietf.org/html/rfc3986 # # The output will correctly round-trip through URI.unescape # # @param [String query_string] A URI query parameter that may contain reserved # characters that must be percent encoded for the key or value to be # properly decoded as part of a larger query string: # # query # encodes as : query # # query_with_special=chars like&and * and# plus+this # encodes as: # query_with_special%3Dchars%20like%26and%20%2A%20and%23%20plus%2Bthis # # Note: Also usable by fragments, but not suitable for paths # # @return [String] a new string containing an encoded query string per the # rules of RFC3986. # # In particular, # query will encode + as %2B and space as %20
on_const on_period UNK on_lparen UNK on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # query can encode space to %20 OR + # + MUST be encoded as %2B # in RFC3968 both query and fragment are defined as: # = *( pchar / "/" / "?" ) # CGI.escape turns space into + which is the most backward compatible # however it doesn't roundtrip through URI.unescape which prefers %20
def UNK on_lparen path on_comma UNK on_op on_lbrace on_symbeg UNK on_op UNK on_rbrace on_rparen on_ignored_nl raise on_const on_period new on_lparen # Percent-encodes a URI string per RFC3986 - https://tools.ietf.org/html/rfc3986 # # Properly handles escaping rules for paths, query strings and fragments # independently # # The output is safe to pass to URI.parse or URI::Generic.build and will # correctly round-trip through URI.unescape # # @param [String path] A URI string that may be in the form of: # # http://foo.com/bar?query # file://tmp/foo bar # //foo.com/bar?query # /bar?query # bar?query # bar # . # C:\Windows\Temp # # Note that with no specified scheme, authority or query parameter delimiter # ? that a naked string will be treated as a path. # # Note that if query parameters need to contain data such as & or = # that this method should not be used, as there is no way to differentiate # query parameter data from query delimiters when multiple parameters # are specified # # @param [Hash{Symbol=>String} opts] Options to alter encoding # @option opts [Array<Symbol>] :allow_fragment defaults to false. When false # will treat # as part of a path or query and not a fragment delimiter # # @return [String] a new string containing appropriate portions of the URI # encoded per the rules of RFC3986. # In particular, # path will not encode +, but will encode space as %20 # query will encode + as %2B and space as %20 # fragment behaves like query
encoded on_op on_tstring_beg on_tstring_end on_period UNK on_lparen on_const on_op on_const on_rparen on_nl on_ignored_nl parts on_op path on_period UNK on_lparen on_const # ensure string starts as UTF-8 for the sake of Ruby 1.9.3
parts on_op path on_period UNK on_lparen on_const on_rparen on_nl on_ignored_nl encoded on_op parts on_lbracket on_symbeg UNK on_rbracket unless parts on_lbracket # parse uri into named matches, then reassemble properly encoded
encoded on_op on_const on_period UNK on_lparen parts on_lbracket on_symbeg path on_rbracket on_rparen unless parts on_lbracket on_symbeg path on_rbracket on_period nil? # path requires space to be encoded as %20 (NEVER +) # + should be left unencoded # URI::parse and URI::Generic.build don't like paths encoded with CGI.escape # URI.escape does not change / to %2F and : to %3A like CGI.escape
if on_op parts on_lbracket on_symbeg UNK on_rbracket on_period nil? on_nl UNK on_op parts on_lbracket on_symbeg UNK on_rbracket on_period UNK on_lparen # each query parameter
UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK do on_op UNK on_op on_ignored_nl UNK on_lparen UNK on_rparen on_nl # can optionally be separated by an =
on_int on_period UNK on_lparen on_int on_rparen on_lbrace on_op UNK on_op on_const on_op new on_lparen UNK on_rparen on_period UNK rescue nil # /proc/self/fd not found
def UNK on_nl UNK on_op on_const on_period UNK on_lbrace on_ignored_nl yield on_nl on_rbrace on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl # Just benchmark, with no logging.
def self on_period UNK on_lparen UNK on_op UNK on_lparen on_int on_rparen on_comma UNK on_op on_lbracket on_rbracket on_rparen on_ignored_nl UNK on_lparen # utility method to get the current call stack and format it to a human-readable string (which some IDEs/editors # will recognize as links to the line numbers in the trace)
def self on_period UNK on_lparen UNK on_comma UNK on_op on_lbracket on_rbracket on_rparen on_ignored_nl UNK on_period UNK do on_op frame on_op # arguments may be a Ruby stack, with an optional Puppet stack argument, # or just a Puppet stack. # stacks may be an Array of Strings "/foo.rb:0 in `blah'" or # an Array of Arrays that represent a frame: ["/foo.pp", 0]
on_ignored_nl on_const on_op on_int on_nl on_const on_op nil on_nl on_ignored_nl def UNK on_lparen file on_comma UNK on_comma on_label nil on_comma # Replace a file, securely. This takes a block, and passes it the file # handle of a file open for writing. Write the replacement content inside # the block and it will safely replace the target file. # # This method will make no changes to the target file until the content is # successfully written and the block returns without raising an error. # # As far as possible the state of the existing file, such as mode, is # preserved. This works hard to avoid loss of any metadata, but will result # in an inode change for the file. # # Arguments: `filename`, `default_mode`, `staging_location` # # The filename is the file we are going to replace. # # The default_mode is the mode to use when the target file doesn't already # exist; if the file is present we copy the existing mode/owner/group values # across. The default_mode can be expressed as an octal integer, a numeric string (ie '0664') # or a symbolic file mode. # # The staging_location is a location to render the temporary file before # moving the file to it's final location.
if UNK on_nl tempfile on_op on_const on_op on_const on_op on_const on_period new on_lparen on_const on_op on_const on_period UNK on_lparen file # encoding for Uniquefile is not important here because the caller writes to it as it sees fit
on_ignored_nl if on_const on_op on_const on_period UNK on_lparen file on_rparen on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen file # Grab the current file mode, and fall back to the defaults.
yield tempfile on_nl on_ignored_nl if UNK on_nl tempfile on_period UNK on_lparen UNK on_op on_int on_rparen on_nl end on_nl on_ignored_nl tempfile # OK, now allow the caller to write the content of the file.
tempfile on_period UNK on_lparen UNK on_op on_int on_rparen on_nl end on_nl on_ignored_nl tempfile on_period UNK on_nl begin on_ignored_nl tempfile on_period # We only care about the bottom four slots, which make the real mode, # and not the rest of the platform stat call fluff and stuff.
tempfile on_period UNK on_nl begin on_ignored_nl tempfile on_period UNK on_nl rescue on_const on_nl end on_nl on_ignored_nl tempfile on_period UNK on_nl # Now, make sure the data (which includes the mode) is safe on disk.
end on_nl on_ignored_nl tempfile on_period UNK on_nl on_ignored_nl if UNK on_nl UNK on_period UNK on_lparen tempfile on_period path on_rparen on_nl # fsync may not be implemented by Ruby on all platforms, but # there is absolutely no recovery path if we detect that. So, we just # ignore the return code. # # However, don't be fooled: that is accepting that we are running in # an unsafe fashion. If you are porting to a new platform don't stub # that out.
if on_op on_const on_op on_const on_period UNK on_lparen file on_rparen on_nl on_const on_op on_const on_period UNK on_lparen file on_rparen on_nl # Windows ReplaceFile needs a file to exist, so touch handles this
on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen file on_rparen on_comma tempfile on_period path # Yes, the arguments are reversed compared to the rename in the rest # of the world.
if on_const on_op on_const on_period UNK on_lparen file on_rparen on_op on_const on_op on_const on_period UNK on_lparen file on_rparen on_nl raise # MRI Ruby checks for this and raises an error, while JRuby removes the directory # and replaces it with a file. This makes the our version of replace_file() consistent
if tempfile on_nl tempfile on_period UNK on_nl end on_nl end on_nl on_ignored_nl on_ignored_nl on_ignored_nl file on_nl end on_nl module_function on_symbeg # in case an error occurred before we renamed the temp file, make sure it # gets deleted
on_ignored_nl file on_nl end on_nl module_function on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_op on_int on_rparen on_ignored_nl # Ideally, we would now fsync the directory as well, but Ruby doesn't # have support for that, and it doesn't matter /that/ much...
file on_nl end on_nl module_function on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_op on_int on_rparen on_ignored_nl yield # Return something true, and possibly useful.
def UNK on_lparen UNK on_comma UNK on_op on_int on_rparen on_ignored_nl yield on_nl rescue on_const on_op UNK on_nl raise UNK on_nl # Executes a block of code, wrapped with some special exception handling. Causes the ruby interpreter to # exit if the block throws an exception. # # @api public # @param [String] message a message to log if the block fails # @param [Integer] code the exit code that the ruby interpreter should return if the block fails # @yield
rescue on_const on_op UNK on_nl raise UNK on_nl on_ignored_nl rescue on_const on_op UNK on_nl on_const on_period UNK on_lparen UNK on_comma # First, we need to check and see if we are catching a SystemExit error. These will be raised # when we daemonize/fork, and they do not necessarily indicate a failure case.
rescue on_const on_op UNK on_nl on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end # Now we need to catch *any* other kind of exception, because we may be calling third-party # code (e.g. webrick), and we have no idea what they might throw.
on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end on_rparen on_nl on_const on_op on_const ## NOTE: when debugging spec failures, these two lines can be very useful #puts err.inspect #puts Puppet::Util.pretty_backtrace(err.backtrace)
