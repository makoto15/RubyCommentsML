UNK UNK on_lparen key on_rparen on_ignored_nl UNK UNK key UNK UNK key on_period UNK on_lparen on_const on_rparen on_period UNK on_nl # Split key into segments. A segment may be a quoted string (both single and double quotes can # be used) and the segment separator is the '.' character. Whitespace will be trimmed off on # both sides of each segment. Whitespace within quotes are not trimmed. # # If the key cannot be parsed, this method will yield a string describing the problem to a one # parameter block. The block must return an exception instance. # # @param key [String] the string to split # @return [Array<String>] the array of segments # @yieldparam problem [String] the problem, i.e. 'Syntax error' # @yieldreturn [Exception] the exception to raise # # @api public
UNK UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK segments on_period UNK on_op on_tstring_beg on_tstring_end on_nl UNK on_op segments on_period # Only happens if the original key was an empty string
UNK UNK on_lparen key on_comma UNK on_comma segments on_comma value on_rparen on_ignored_nl lookup_invocation on_op UNK on_period UNK on_lparen on_const on_rparen # Perform a sub-lookup using the given _segments_ to access the given _value_. Each segment must be a string. A string # consisting entirely of digits will be treated as an indexed lookup which means that the value that it is applied to # must be an array. Other types of segments will expect that the given value is something other than a String that # implements the '#[]' method. # # @param key [String] the original key (only used for error messages) # @param context [Context] The current lookup context # @param segments [Array<String>] the segments to use for lookup # @param value [Object] the value to access using the segments # @return [Object] the value obtained when accessing the value # # @api public
