UNK on_const on_op on_const on_op on_const on_nl end on_nl end on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl # A command failed to execute. # @api public
UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_const on_op on_const on_nl UNK on_symbeg exitstatus on_nl on_ignored_nl def UNK # This module defines methods for execution of system commands. It is intended for inclusion # in classes that needs to execute system commands. # @api public
UNK on_const on_op on_const on_nl UNK on_symbeg exitstatus on_nl on_ignored_nl def UNK on_lparen UNK on_comma exitstatus on_rparen on_ignored_nl UNK on_lparen # This is the full output from a process. The object itself (a String) is the # stdout of the process. # # @api public
UNK on_symbeg exitstatus on_nl on_ignored_nl def UNK on_lparen UNK on_comma exitstatus on_rparen on_ignored_nl UNK on_lparen UNK on_rparen on_nl UNK on_op # @return [Integer] The exit status of the process # @api public
def UNK on_lparen UNK on_comma exitstatus on_rparen on_ignored_nl UNK on_lparen UNK on_rparen on_nl UNK on_op exitstatus on_nl end on_nl end # @api private
def self on_period UNK on_lparen command on_comma UNK on_op UNK on_rparen on_ignored_nl command_str on_op command on_period UNK on_lparen on_symbeg UNK # The command can be a simple string, which is executed as-is, or an Array, # which is treated as a set of command arguments to pass through. # # In either case, the command is passed directly to the shell, STDOUT and # STDERR are connected together, and STDOUT will be streamed to the yielded # pipe. # # @param command [String, Array<String>] the command to execute as one string, # or as parts in an array. The parts of the array are joined with one # separating space between each entry when converting to the command line # string to execute. # @param failonfail [Boolean] (true) if the execution should fail with # Exception on failure or not. # @yield [pipe] to a block executing a subprocess # @yieldparam pipe [IO] the opened pipe # @yieldreturn [String] the output to return # @raise [Puppet::ExecutionFailure] if the executed child process did not # exit with status == 0 and `failonfail` is `true`. # @return [String] a string with the output from the subprocess executed by # the given block # # @see Kernel#open for `mode` values # @api public
command_str on_op command on_period UNK on_lparen on_symbeg UNK on_rparen on_op command on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op command # Paste together an array with spaces. We used to paste directly # together, no spaces, which made for odd invocations; the user had to # include whitespace between arguments. # # Having two spaces is really not a big drama, since this passes to the # shell anyhow, while no spaces makes for a small developer cost every # time this is invoked. --daniel 2012-02-13
UNK on_op on_const on_period UNK on_period UNK on_lparen on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # force the run of the command with # the user/system locale to "C" (via environment variables LANG and LC_*) # it enables to have non localized output for some commands and therefore # a predictable output
def self on_period UNK on_lparen command on_comma UNK on_rparen on_ignored_nl UNK on_lparen command on_rparen on_nl rescue on_const on_op on_const on_op # Wraps execution of {execute} with mapping of exception to given exception (and output as argument). # @raise [exception] under same conditions as {execute}, but raises the given `exception` with the output as argument # @return (see execute) # @api public # @deprecated
on_const on_op on_lbrace on_rbrace on_nl on_ignored_nl def self on_period UNK on_lparen command on_comma options on_op on_const on_rparen on_ignored_nl UNK on_op # Default empty options for {execute}
def self on_period UNK on_lparen command on_comma options on_op on_const on_rparen on_ignored_nl UNK on_op on_lbrace on_ignored_nl on_symbeg UNK on_op on_const # Executes the desired command, and return the status and output. # def execute(command, options) # @param command [Array<String>, String] the command to execute. If it is # an Array the first element should be the executable and the rest of the # elements should be the individual arguments to that executable. # @param options [Hash] a Hash of options # @option options [String] :cwd the directory from which to run the command. Raises an error if the directory does not exist. # This option is only available on the agent. It cannot be used on the master, meaning it cannot be used in, for example, # regular functions, hiera backends, or report processors. # @option options [Boolean] :failonfail if this value is set to true, then this method will raise an error if the # command is not executed successfully. # @option options [Integer, String] :uid (nil) the user id of the user that the process should be run as. Will be ignored if the # user id matches the effective user id of the current process. # @option options [Integer, String] :gid (nil) the group id of the group that the process should be run as. Will be ignored if the # group id matches the effective group id of the current process. # @option options [Boolean] :combine sets whether or not to combine stdout/stderr in the output, if false stderr output is discarded # @option options [String] :stdinfile (nil) sets a file that can be used for stdin. Passing a string for stdin is not currently # supported. # @option options [Boolean] :squelch (false) if true, ignore stdout / stderr completely. # @option options [Boolean] :override_locale (true) by default (and if this option is set to true), we will temporarily override # the user/system locale to "C" (via environment variables LANG and LC_*) while we are executing the command. # This ensures that the output of the command will be formatted consistently, making it predictable for parsing. # Passing in a value of false for this option will allow the command to be executed using the user/system locale. # @option options [Hash<{String => String}>] :custom_environment ({}) a hash of key/value pairs to set as environment variables for the duration # of the command. # @return [Puppet::Util::Execution::ProcessOutput] output as specified by options # @raise [Puppet::ExecutionFailure] if the executed chiled process did not exit with status == 0 and `failonfail` is # `true`. # @note Unfortunately, the default behavior for failonfail and combine (since # 0.22.4 and 0.24.7, respectively) depend on whether options are specified # or not. If specified, then failonfail and combine default to false (even # when the options specified are neither failonfail nor combine). If no # options are specified, then failonfail and combine default to true. # @comment See commits efe9a833c and d32d7f30 # @api public #
UNK on_op on_lbrace on_ignored_nl on_symbeg UNK on_op on_const on_period UNK on_lparen options on_rparen on_comma on_ignored_nl on_symbeg UNK on_op nil on_comma # specifying these here rather than in the method signature to allow callers to pass in a partial # set of overrides without affecting the default values for options that they don't pass in
command_str on_op on_tstring_beg on_tstring_content on_tstring_end if options on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl user_log_s on_op on_tstring_beg on_tstring_end on_nl if options # do this after processing 'command' array or string
if options on_lbracket on_symbeg UNK on_rbracket on_nl stdout on_op on_const on_op on_const on_period UNK on_lparen UNK on_comma nil on_comma on_tstring_beg # On Windows, continue to use the file-based approach to avoid breaking people's existing # manifests. If they use a script that doesn't background cleanly, such as # `start /b ping 127.0.0.1`, we couldn't handle it with pipes as there's no non-blocking # read available.
UNK on_op on_const on_op on_const on_op on_const on_period UNK on_nl if UNK on_nl child_pid on_op UNK on_period UNK on_lparen on_op # We close stdin/stdout/stderr immediately after fork/exec as they're no longer needed by # this process. In most cases they could be closed later, but when `stdout` is the "writer" # pipe we must close it or we'll never reach eof on the `reader` pipe.
on_ignored_nl UNK UNK on_op on_const on_period UNK on_lparen child_pid on_comma on_const on_op on_const on_rparen on_ignored_nl UNK on_op on_const on_period UNK # Use non-blocking read to check for data. After each attempt, # check whether the child is done. This is done in case the child # forks and inherits stdout, as happens in `foo &`.
on_ignored_nl UNK on_op on_const on_period UNK on_lparen on_lbracket reader on_rbracket on_comma on_lbracket on_rbracket on_comma on_lbracket on_rbracket on_comma UNK on_rparen on_nl #rubocop:disable Lint/AssignmentInCondition
UNK on_op on_const on_period UNK on_lparen on_lbracket reader on_rbracket on_comma on_lbracket on_rbracket on_comma on_lbracket on_rbracket on_comma UNK on_rparen on_nl begin # If not done, wait for data to read with a timeout # This timeout is selected to keep activity low while waiting on # a long process, while not waiting too long for the pathological # case where stdout is never closed.
begin on_ignored_nl UNK do on_ignored_nl output on_op reader on_period UNK on_lparen on_int on_rparen on_nl end on_nl rescue on_const on_op on_const # Read any remaining data. Allow for but don't expect EOF.
output on_period UNK on_lparen on_const on_period UNK on_rparen on_nl exit_status on_op UNK on_period UNK on_period exitstatus on_nl end on_nl child_pid # Force to external encoding to preserve prior behavior when reading a file. # Wait until after reading all data so we don't encounter corruption when # reading part of a multi-byte unicode character if default_external is UTF-8.
UNK child_pid on_period UNK on_nl on_const on_period UNK on_lparen on_symbeg on_const on_comma child_pid on_rparen on_nl on_const on_period UNK on_lbrace on_const # NOTE: For Ruby 2.1+, an explicit Timeout::Error class has to be # passed to Timeout.timeout in order for there to be something for # this block to rescue.
on_const on_period UNK on_lbrace on_const on_period UNK on_lparen child_pid on_rparen on_rbrace on_nl end on_nl on_ignored_nl UNK UNK on_nl end on_nl # Spawn a thread to reap the process if it dies.
UNK options on_lbracket on_symbeg UNK on_rbracket on_nl output on_op UNK on_lparen stdout on_rparen on_nl on_const on_period UNK UNK on_lparen on_tstring_beg # read output in if required
on_lbracket stdin on_comma stdout on_comma stderr on_rbracket on_period each on_lbrace on_op io on_op io on_period close rescue nil on_rbrace on_nl # Make sure all handles are closed in case an exception was thrown attempting to execute.
reader on_period close if reader on_nl stdout on_period UNK if on_const on_op on_const on_op on_const on_period UNK on_nl end on_nl # if we opened a pipe, we need to clean it up.
def self on_period UNK on_lparen on_rparen on_ignored_nl on_const on_period UNK on_lparen on_const on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_comma # Returns the path to the ruby executable (available via Config object, even if # it's not in the PATH... so this is slightly safer than just using Puppet::Util.which) # @return [String] the path to the Ruby executable # @api private #
UNK on_op self on_nl UNK UNK UNK on_nl end on_nl on_ignored_nl on_ignored_nl def self on_period UNK on_lparen command on_comma options # Because some modules provide their own version of this method.
def self on_period UNK on_lparen command on_comma options on_comma stdin on_comma stdout on_comma stderr on_rparen on_ignored_nl child_pid on_op on_const on_op # This is private method. # @comment see call to private_class_method after method definition # @api private #
command on_op on_lbracket command on_rbracket on_period UNK on_nl on_const on_period UNK on_nl begin on_ignored_nl cwd on_op options on_lbracket on_symbeg cwd # We can't just call Array(command), and rely on it returning # things like ['foo'], when passed ['foo'], because # Array(command) will call command.to_a internally, which when # given a string can end up doing Very Bad Things(TM), such as # turning "/tmp/foo;\r\n /bin/echo" into ["/tmp/foo;\r\n", " /bin/echo"]
cwd on_op options on_lbracket on_symbeg cwd on_rbracket on_nl on_const on_period UNK on_lparen cwd on_rparen if cwd on_nl on_ignored_nl on_const on_op # We need to chdir to our cwd before changing privileges as there's a # chance that the user may not have permissions to access the cwd, which # would cause execute_posix to fail.
if on_lparen options on_lbracket on_symbeg UNK on_rbracket on_rparen UNK on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_period each on_lbrace # if the caller has requested that we override locale environment variables,
on_const on_op on_const on_op on_const on_op on_const on_period each on_lbrace on_op UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_rbrace # loop over them and clear them
on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content # set LANG and LC_ALL to 'C' so that the command will have consistent, predictable output # it's OK to manipulate these directly rather than, e.g., via "withenv", because we are in # a forked process.
on_const on_op on_const on_op on_const on_op on_const on_period each on_lbrace on_op UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_rbrace # unset all of the user-related environment variables so that different methods of starting puppet # (automatic start during boot, via 'service', via /etc/init.d, etc.) won't have unexpected side # effects relating to user / home dir environment vars. # it's OK to manipulate these directly rather than, e.g., via "withenv", because we are in # a forked process.
def self on_period UNK on_lparen command on_comma options on_comma stdin on_comma stdout on_comma stderr on_rparen on_ignored_nl command on_op command on_period # This is private method. # @comment see call to private_class_method after method definition # @api private #
def self on_period UNK on_lparen stdout on_rparen on_ignored_nl on_int on_period UNK do on_op UNK on_op on_ignored_nl if on_const on_op on_const # This is private method. # @comment see call to private_class_method after method definition # @api private #
on_int on_period UNK do on_op UNK on_op on_ignored_nl if on_const on_op on_const on_period UNK on_lparen stdout on_period UNK on_rparen on_nl # Make sure the file's actually been written. This is basically a race # condition, and is probably a horrible way to handle it, but, well, oh # well. # (If this method were treated as private / inaccessible from outside of this file, we shouldn't have to worry # about a race condition because all of the places that we call this from are preceded by a call to "waitpid2", # meaning that the processes responsible for writing the file have completed before we get here.)
