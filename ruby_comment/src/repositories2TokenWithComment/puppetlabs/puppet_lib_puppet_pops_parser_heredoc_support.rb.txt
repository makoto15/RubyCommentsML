on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl on_ignored_nl UNK UNK on_nl scn on_op UNK on_nl UNK on_op UNK on_nl locator # Pattern for heredoc `@(endtag[:syntax][/escapes]) # Produces groups for endtag (group 1), syntax (group 2), and escapes (group 3) #
UNK on_op scn on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_op lex_error on_lparen on_const on_op on_const on_comma on_symbeg UNK on_op # scanner is at position before @( # find end of the heredoc spec
md on_op UNK on_period UNK on_lparen on_const on_rparen on_nl lex_error on_lparen on_const on_op on_const on_rparen UNK md on_nl endtag on_op # Note: allows '+' as separator in syntax, but this needs validation as empty segments are not allowed
if endtag on_op on_regexp_beg on_tstring_content on_regexp_end on_nl UNK on_op UNK on_nl endtag on_op UNK on_period UNK on_nl end on_nl on_ignored_nl # Is this a dq string style heredoc? (endtag enclosed in "")
UNK on_lparen on_lbracket on_symbeg on_const on_comma UNK on_comma UNK on_op UNK on_rbracket on_comma UNK on_rparen on_nl on_ignored_nl on_ignored_nl if UNK # Produce a heredoc token to make the syntax available to the grammar
on_ignored_nl if UNK on_lbracket on_symbeg UNK on_rbracket on_nl scn on_period pos on_op UNK on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_ignored_nl # If this is the second or subsequent heredoc on the line, the lexing context's :newline_jump contains # the position after the \n where the next heredoc text should scan. If not set, this is the first # and it should start scanning after the first found \n (or if not found == error).
UNK on_op scn on_period pos on_nl UNK on_op locator on_period UNK on_lparen UNK on_rparen on_op on_int on_nl on_ignored_nl UNK on_op # offset 0 for the heredoc, and its line number
UNK on_op UNK on_lparen on_const on_op on_const on_rparen on_nl on_ignored_nl on_ignored_nl UNK on_op on_regexp_beg on_tstring_content UNK on_const on_period UNK on_lparen # Compute message to emit if there is no end (to make it refer to the opening heredoc position).
on_ignored_nl UNK on_op on_regexp_beg on_tstring_content UNK on_const on_period UNK on_lparen endtag on_rparen UNK on_tstring_content on_regexp_end on_nl lines on_op on_lbracket on_rbracket # Text from this position (+ lexing contexts offset for any preceding heredoc) is heredoc until a line # that terminates the heredoc is found.
UNK on_op on_regexp_beg on_tstring_content UNK on_const on_period UNK on_lparen endtag on_rparen UNK on_tstring_content on_regexp_end on_nl lines on_op on_lbracket on_rbracket on_nl # (Endline in EBNF form): WS* ('|' WS*)? ('-' WS*)? endtag WS* \r? (\n|$)
UNK on_lbracket on_symbeg UNK on_rbracket on_op scn on_period pos on_nl on_ignored_nl on_ignored_nl UNK on_comma UNK on_op UNK on_lparen lines on_comma # Record position where next heredoc (from same line as current @()) should start scanning for content
UNK on_comma UNK on_op UNK on_lparen lines on_comma UNK on_comma UNK on_comma UNK on_rparen on_nl on_ignored_nl UNK on_op UNK on_period # Process captured lines - remove leading, and trailing newline # get processed string and index of removed margin/leading size per line
UNK on_op UNK on_period UNK on_period UNK on_lparen on_rparen on_nl locator on_op on_const on_op on_const on_period UNK on_lparen locator on_comma # Use a new lexer instance configured with a sub-locator to enable correct positioning
UNK on_lparen on_lbracket on_symbeg on_const on_comma on_ignored_nl on_const on_op on_const on_period UNK on_lparen on_lbracket on_symbeg on_const on_comma on_ignored_nl lines on_comma # Emit a token that provides the grammar with location information about the lines on which the heredoc # content is based.
scn on_period pos on_op UNK on_nl UNK on_nl UNK on_ignored_nl lines on_op UNK on_nl end on_nl end on_nl UNK UNK # Continue scan after @(...)
UNK UNK on_lparen lines on_comma UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl if UNK on_op UNK on_period length on_op on_int # Produces the heredoc text string given the individual (unprocessed) lines as an array and array with margin sizes per line # @param lines [Array<String>] unprocessed lines of text in the heredoc w/o terminating line # @param leading [String] the leading text up (up to pipe or other terminating char) # @param has_margin [Boolean] if the left margin should be adjusted as indicated by `leading` # @param remove_break [Boolean] if the line break (\r?\n) at the end of the last line should be removed or not # @return [Array] - a tuple with resulting string, and an array with margin size per line #
UNK on_op lines on_period UNK UNK on_op UNK on_op UNK on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_end on_rparen UNK on_nl # TODO: This implementation is not according to the specification, but is kept to be bug compatible. # The specification says that leading space up to the margin marker should be removed, but this implementation # simply leaves lines that have text in the margin untouched. #
UNK on_op on_const on_period UNK on_lparen lines on_period length on_comma on_int on_rparen on_nl end on_nl UNK on_op lines on_period UNK # Array with a 0 per line
