class on_const on_op on_const on_nl def UNK on_lparen scope on_rparen on_ignored_nl UNK on_lparen scope on_rparen on_nl on_ivar on_op on_lbracket on_rbracket # @api private
on_ivar on_period UNK on_lbrace on_op UNK on_op UNK on_lbracket on_int on_rbracket on_rbrace on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK # Save extra checks by keeping the array unique with respect to the key (first entry)
def UNK on_lparen name on_rparen on_ignored_nl UNK on_op on_ivar on_nl on_ivar on_op on_lbracket on_rbracket on_nl UNK on_op UNK on_nl UNK # Yield invocation that remembers all but the given name
class on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_const on_op on_tstring_beg # @api private
def self on_period UNK on_lparen lookup_invocation on_comma config_path on_comma owner on_rparen on_ignored_nl if config_path on_period is_a? on_lparen on_const on_rparen on_nl # Creates a new HieraConfig from the given _config_root_. This is where the 'hiera.yaml' is expected to be found # and is also the base location used when resolving relative paths. # # @param lookup_invocation [Invocation] Invocation data containing scope, overrides, and defaults # @param config_path [Pathname] Absolute path to the configuration file # @param owner [ConfiguredDataProvider] The data provider that will own the created configuration # @return [LookupConfiguration] the configuration
if UNK on_period is_a? on_lparen on_const on_rparen on_nl UNK on_nl else on_ignored_nl on_const on_period UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content # For backward compatibility, we must treat an empty file, or a yaml that doesn't # produce a Hash as Hiera version 3 default.
def UNK on_lparen config_root on_comma config_path on_comma loaded_config on_comma owner on_rparen on_ignored_nl on_ivar on_op config_root on_nl on_ivar on_op config_path on_nl # Creates a new HieraConfig from the given _config_root_. This is where the 'lookup.yaml' is expected to be found # and is also the base location used when resolving relative paths. # # @param config_path [Pathname] Absolute path to the configuration # @param loaded_config [Hash] the loaded configuration
def UNK on_lparen lookup_invocation on_comma parent_data_provider on_comma use_default_hierarchy on_op false on_rparen on_ignored_nl unless on_ivar on_op UNK on_lparen lookup_invocation on_rparen on_nl # Returns the data providers for this config # # @param lookup_invocation [Invocation] Invocation data containing scope, overrides, and defaults # @param parent_data_provider [DataProvider] The data provider that loaded this configuration # @return [Array<DataProvider>] the data providers
if UNK on_period UNK on_op on_regexp_beg on_tstring_content on_regexp_end on_nl UNK on_op UNK on_nl fail on_lparen on_const on_op on_const on_comma on_lbrace # Raise a LookupError with a RUNTIME_ERROR issue to prevent this being translated to an evaluation error triggered in the pp file # where the lookup started
def find_line_matching on_lparen UNK on_comma UNK on_op on_int on_rparen on_ignored_nl UNK on_op on_int on_nl on_const on_period UNK on_lparen on_ivar on_rparen # Find first line in configuration that matches regexp after given line. Comments are stripped
if UNK on_op cp on_nl UNK on_op nil on_nl UNK UNK on_period nil? on_nl UNK on_op cp on_nl end on_nl # double or single quote
UNK on_nl end on_nl UNK on_op cp on_nl end on_nl UNK UNK if UNK on_op UNK on_nl end on_nl nil # unquoted hash mark
def create_configured_data_providers on_lparen lookup_invocation on_comma parent_data_provider on_comma use_default_hierarchy on_rparen on_ignored_nl self on_period class on_period UNK on_lparen self on_comma on_tstring_beg on_tstring_content # @api private
UNK on_tstring_beg on_tstring_content on_tstring_end on_nl if on_const on_op on_const on_period UNK on_lparen on_symbeg on_ivar on_rparen on_op on_lparen UNK on_op on_const # Custom backend. Hiera v3 must be installed, it's logger configured, and it must be made aware of the loaded config
class on_op on_const on_op on_const on_nl UNK on_op on_const on_period new do on_op UNK on_comma key on_comma scope on_comma UNK # Replace the class methods 'hiera_interpolate' and 'alias_interpolate' with a method that wires back and performs global # lookups using the lookup framework. This is necessary since the classic Hiera is made aware only of custom backends.
paths on_op nil if on_op paths on_period nil? on_op paths on_period UNK on_nl create_data_provider on_lparen name on_comma parent_data_provider on_comma on_const # Use a special lookup_key that delegates to the backend
class on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze # @api private
on_cvar on_op on_lbrace on_ignored_nl tf on_period optional on_lparen on_const on_rparen on_op tf on_period range on_lparen on_int on_comma on_int on_rparen on_comma # This is a hash, not a type. Contained backends are added prior to validation
tf on_op on_const on_op on_const on_nl UNK on_op on_lbrace on_rbrace on_nl UNK on_period each on_lbrace on_op backend on_op UNK on_lbracket # Create the final struct used for validation (backends are included as keys to arbitrary configs in the form of a hash)
class on_const on_op on_const on_nl def self on_period config_type on_nl UNK on_cvar if UNK on_lparen on_symbeg on_cvar on_rparen on_nl tf # @api private
class on_const on_op on_const on_nl def self on_period config_type on_nl UNK on_cvar if UNK on_lparen on_symbeg on_cvar on_rparen on_nl tf # @api private
UNK on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_op tf on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl # Validated using Ruby URI implementation
UNK on_op tf on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl on_ignored_nl UNK on_op tf on_period array_of on_lparen tf on_period # The option name must start with a letter and end with a letter or digit. May contain underscore and dash.
data_providers on_op on_lbrace on_rbrace on_nl on_ignored_nl if on_ivar on_period include? on_lparen on_const on_rparen on_nl unless parent_data_provider on_period is_a? on_lparen on_const # Hashes enumerate their values in the order that the corresponding keys were inserted so it's safe to use # a hash for the data_providers.
options on_op he on_lbracket on_const on_rbracket on_op defaults on_lbracket on_const on_rbracket on_nl options on_op options on_period nil? on_op on_const on_op # Default config and no existing paths found
else on_ignored_nl fail on_lparen on_const on_op on_const on_comma on_symbeg name on_op name on_rparen on_nl end on_nl on_ignored_nl v3_backend on_op he # OK
fail on_lparen on_const on_op on_const on_comma on_lbrace on_symbeg function_name on_op v3_backend on_rbrace on_comma on_ignored_nl find_line_matching on_lparen on_regexp_beg on_tstring_content on_embexpr_beg on_const # Disallow use of backends that have corresponding "data_hash" functions in version 5
else on_ignored_nl fail on_lparen on_const on_op on_const on_rparen on_nl end on_nl on_ignored_nl options on_op defaults on_lbracket on_const on_rbracket on_nl unless # OK
