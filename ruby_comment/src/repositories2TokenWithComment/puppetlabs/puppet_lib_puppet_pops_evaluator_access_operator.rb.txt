class on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op # AccessOperator handles operator [] # This operator is part of evaluation. #
UNK on_const on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_period new # Provides access to the Puppet 3.x runtime (scope, etc.) # This separation has been made to make it easier to later migrate the evaluator to an improved runtime. #
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_period new on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_int on_comma # Initialize with AccessExpression to enable reporting issues # @param access_expression [Model::AccessExpression] the semantic object being evaluated # @return [void] #
k1 on_op on_const on_period UNK on_lparen keys on_lbracket on_int on_rbracket on_rparen on_nl UNK on_lparen o on_comma on_int on_comma k1 on_period # Note that Ruby 1.8.7 requires a length of 1 to produce a String
if k1 on_op on_int on_nl on_const on_nl else on_ignored_nl o on_lbracket k1 on_comma k2 on_rbracket on_nl end on_nl when on_int # abs pos # if k1 is outside, a length of 1 always produces an empty string
k2 on_op k2 on_op on_int on_op o on_period UNK on_op k1 on_op k2 on_op on_int on_op k2 if k1 on_op # abs pos (negative is count from end)
if k1 on_op on_int on_nl k2 on_op k2 on_op k1 on_nl k1 on_op on_int on_nl end on_nl o on_lbracket k1 # abs length (negative k2 is length from pos to end count) # if k1 is outside, adjust to first position, and adjust length
on_lparen result on_period nil? on_op result on_period UNK on_rparen on_op on_const on_op result on_nl end on_nl on_ignored_nl def UNK on_lparen # Specified as: an index outside of range, or empty result == empty string
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl keys on_period flatten! on_nl unless keys on_period size on_op on_int # Parameterizes a PRegexp Type with a pattern string or r ruby egexp #
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl keys on_period flatten! on_nl case keys on_period size on_nl when # Evaluates <ary>[] with 1 or 2 arguments. One argument is an index lookup, two arguments is a slice from/to. #
k1 on_op UNK on_lparen keys on_lbracket on_int on_rbracket on_comma on_ivar on_period keys on_lbracket on_int on_rbracket on_comma scope on_rparen on_nl k2 # A slice [from, to] with support for -1 to mean start, or end respectively.
k1 on_op k1 on_op on_int on_op o on_period UNK on_op k1 on_op k1 k2 on_op k2 on_op on_int on_op o # Help confused Ruby do the right thing (it truncates to the right, but negative index + length can never overlap # the available range.
k2 on_op k2 on_op on_int on_op o on_period UNK on_op k1 on_op k2 on_op on_int on_op k2 if k1 on_op # abs pos (negative is count from end)
if k1 on_op on_int on_nl k2 on_op k2 on_op k1 on_nl k1 on_op on_int on_nl end on_nl result on_op o # abs length (negative k2 is length from pos to end count) # if k1 is outside, adjust to first position, and adjust length
result on_op o on_lbracket k1 on_comma k2 on_rbracket on_nl result on_period nil? on_op on_lbracket on_rbracket on_op result on_nl else on_ignored_nl # Help ruby always return empty array when asking for a sub array
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl result on_op keys on_period UNK do on_op k on_op on_ignored_nl # Evaluates <hsh>[] with support for one or more arguments. If more than one argument is used, the result # is an array with each lookup. # @note # Does not flatten its keys to enable looking up with a structure #
result on_op keys on_period UNK do on_op k on_op on_ignored_nl o on_period UNK on_lparen k on_rparen on_lbrace on_op key on_op # Look up key in hash, if key is nil, try alternate form (:undef) before giving up. # This is done because the hash may have been produced by 3x logic and may thus contain :undef.
result on_period UNK on_nl result on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_comma keys on_rparen # remove nil elements and return
def assert_keys on_lparen keys on_comma o on_comma min on_comma max on_comma on_op UNK on_rparen on_ignored_nl size on_op keys on_period size # Asserts type of each key and calls fail with BAD_TYPE_SPECIFICATION # @param keys [Array<Object>] the evaluated keys # @param o [Object] evaluated LHS reported as :base_type # @param min [Integer] the minimum number of keys (typically 1) # @param max [Numeric] the maximum number of keys (use same as min, specific number, or Float::INFINITY) # @param allowed_classes [Class] a variable number of classes that each key must be an instance of (any) # @api private #
on_const on_op on_const on_period UNK on_lparen on_op keys on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen o on_comma scope on_comma # create runtime type based on runtime and name of class, (not inference of key's type)
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl keys on_period flatten! on_nl if keys on_period size on_op on_int # A Hash can create a new Hash type, one arg sets value type, two args sets key and value type in new type. # With 3 or 4 arguments, these are used to create a size constraint. # It is not possible to create a collection of Hash types directly. #
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl keys on_period flatten! on_nl case keys on_period size on_nl when # CollectionType is parameterized with a range
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl keys on_period flatten! on_nl case keys on_period size on_nl when # An Array can create a new Array type. It is not possible to create a collection of Array types. #
def collection_size_t on_lparen UNK on_comma on_op keys on_rparen on_ignored_nl if keys on_period size on_op on_int on_op keys on_lbracket on_int on_rbracket # Produces an PIntegerType (range) given one or two keys.
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl t on_op on_const on_op on_const on_period UNK on_lparen o on_rparen # A Puppet::Resource represents either just a type (no title), or is a fully qualified type/title. #
t on_op on_const on_op on_const on_period UNK on_lparen o on_rparen on_period type on_nl t on_period title on_op nil if t # To access a Puppet::Resource as if it was a PResourceType, simply infer it, and take the type of # the parameterized meta type (i.e. Type[Resource[the_resource_type, the_resource_title]])
t on_period title on_op nil if t on_period title on_op on_const on_nl UNK on_lparen t on_comma scope on_comma on_op keys # must map "undefined title" from resource to nil
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl fail on_lparen on_const on_op on_const on_comma on_ivar on_comma on_lbrace on_symbeg # If a type reference is encountered here, it's an error
def UNK on_lparen o on_comma scope on_comma keys on_rparen on_ignored_nl blamed on_op keys on_period size on_op on_int on_op on_ivar on_op # A Resource can create a new more specific Resource type, and/or an array of resource types # If the given type has title set, it can not be specified further. # @example # Resource[File] # => File # Resource[File, 'foo'] # => File[foo] # Resource[File. 'foo', 'bar'] # => [File[foo], File[bar]] # File['foo', 'bar'] # => [File[foo], File[bar]] # File['foo']['bar'] # => Value of the 'bar' parameter in the File['foo'] resource # Resource[File]['foo', 'bar'] # => [File[Foo], File[bar]] # Resource[File, 'foo', 'bar'] # => [File[foo], File[bar]] # Resource[File, 'foo']['bar'] # => Value of the 'bar' parameter in the File['foo'] resource #
type_name on_op o on_period type_name on_op on_const on_op on_const on_period UNK on_period UNK on_lparen keys on_period UNK on_rparen on_nl type_name # Must know which concrete resource type to operate on in all cases. # It is not allowed to specify the type in an array arg - e.g. Resource[[File, 'foo']] # type_name is LHS type_name if set, else the first given arg
UNK on_op o on_period type_name on_period nil? on_op on_ivar on_period keys on_lbracket on_int on_rbracket on_op on_ivar on_period left_expr on_nl fail # blame given left expression if it defined the type, else the first given key expression
if type_name on_op on_const on_op on_const on_nl fail on_lparen on_const on_op on_const on_comma blamed on_comma on_lbrace on_symbeg name on_op type_name # type name must conform
result_type_array on_op keys on_period size on_op on_int on_op keys on_lbracket on_int on_rbracket on_period is_a? on_lparen on_const on_rparen on_nl keys_orig_size on_op # The result is an array if multiple titles are given, or if titles are specified with an array # (possibly multiple arrays, and nested arrays).
if keys on_period UNK on_op keys_orig_size on_op on_int on_nl UNK on_lparen on_const on_op on_const on_comma blamed on_rparen on_nl return result_type_array # If given keys that were just a mix of empty/nil with empty array as a result. # As opposed to calling the function the wrong way (without any arguments), (configurable issue), # Return an empty array #
resource on_op UNK on_lparen scope on_comma o on_period type_name on_comma o on_period title on_rparen on_nl unless resource on_nl fail on_lparen # lookup resource and return one or more parameter values
result on_op keys on_period each_with_index on_period UNK do on_op t on_comma i on_op on_ignored_nl unless t on_period is_a? on_lparen on_const # if there was only a type_name and it was consumed
return result_type_array on_op result on_op result on_period UNK on_nl end on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl # returns single type if request was for a single entity, else an array of types (possibly empty)
result_type_array on_op keys on_period size on_op on_int on_op keys on_lbracket on_int on_rbracket on_period is_a? on_lparen on_const on_rparen on_nl on_ignored_nl keys # The result is an array if multiple classnames are given, or if classnames are specified with an array # (possibly multiple arrays, and nested arrays).
if keys on_period UNK on_op keys_orig_size on_op on_int on_nl UNK on_lparen on_const on_op on_const on_comma blamed on_rparen on_nl return result_type_array # If given keys that were just a mix of empty/nil with empty array as a result. # As opposed to calling the function the wrong way (without any arguments), (configurable issue), # Return an empty array #
name on_op name on_lbracket on_int on_op on_op on_int on_rbracket if name on_lbracket on_int on_comma on_int on_rbracket on_op on_const on_nl on_ignored_nl # Remove leading '::' since all references are global, and 3x runtime does the wrong thing
resource on_op UNK on_lparen scope on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma o on_period UNK on_rparen on_nl if resource on_nl result on_op # lookup class resource and return one or more parameter values
return result_type_array on_op result on_op result on_period UNK on_nl end on_nl end on_nl end on_nl end on_nl EMP EMP EMP # returns single type as type, else an array of types
