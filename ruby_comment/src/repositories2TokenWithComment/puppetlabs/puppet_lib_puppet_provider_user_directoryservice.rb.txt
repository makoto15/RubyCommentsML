on_ignored_nl UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_symbeg dscl ## ## ## Provider Settings ## ## ##
UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_symbeg dscl on_op # Provider command declarations
UNK on_symbeg UNK on_op on_symbeg UNK on_nl UNK on_symbeg UNK on_op on_symbeg UNK on_nl UNK on_symbeg UNK on_op on_symbeg UNK # Provider confines and defaults
UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def # Need this to create getter/setter methods automagically # This command creates methods that return @property_hash[:value]
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def self on_period UNK # JJM: OS X can manage passwords.
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content # 10.8 Passwords use a PBKDF2 salt value
UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_symbeg name on_comma #provider can set the user's shell
on_ignored_nl def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_symbeg name on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op ## ## ## Class Methods ## ## ##
def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_symbeg name on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_symbeg # This method exists to map the dscl values to the correct Puppet # properties. This stays relatively consistent, but who knows what # Apple will do next year...
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period each do on_op UNK on_op on_ignored_nl UNK on_op UNK on_lbracket # Prefetching is necessary to use @property_hash inside any setter methods. # self.prefetch uses self.instances to gather an array of user instances # on the system, and then populates the @property_hash instance variable # with attribute data for the specific instance in question (i.e. it # gathers the 'is' values of the resource into the @property_hash instance # variable so you don't have to read from the system every time you need # to gather the 'is' values for a resource. The downside here is that # populating this instance variable for every resource on the system # takes time and front-loads your Puppet run.
def self on_period UNK on_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl self on_period UNK on_lparen UNK on_lparen UNK # This method assembles an array of provider instances containing # information about every instance of the user type on the system (i.e. # every user and its attributes). The `puppet resource` command relies # on self.instances to gather an array of user instances in order to # display its output.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period UNK on_lparen dscl on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content # Return an array of hashes containing information about every user on # the system.
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl attribute_hash on_op on_lbrace on_rbrace on_nl UNK on_period UNK do on_op UNK on_op # This method accepts an individual user plist, passed as a hash, and # strips the dsAttrTypeStandard: prefix that dscl adds for each key. # An attribute hash is assembled and returned from the properties # supported by the user type.
begin on_ignored_nl ds_value on_op on_const on_lparen ds_value on_lbracket on_int on_rbracket on_rparen on_nl rescue on_const on_nl ds_value on_op ds_value on_lbracket on_int # OS X stores objects like uid/gid as strings. # Try casting to an integer for these cases to be # consistent with the other providers and the group type # validation
UNK on_op on_lbracket on_rbracket on_nl UNK on_period each do on_op group on_op on_ignored_nl if group on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket ############## # Get Groups # ##############
if attribute_hash on_lbracket on_symbeg UNK on_rbracket on_period UNK UNK attribute_hash on_lbracket on_symbeg UNK on_rbracket on_period UNK on_nl attribute_hash on_lbracket on_symbeg ################################ # Get Password/Salt/Iterations # ################################
def self on_period UNK on_nl on_ivar on_op on_const on_op on_const on_op on_const on_period UNK on_lparen dscl on_tstring_beg on_tstring_content on_tstring_end on_comma # Use dscl to retrieve an array of hashes containing attributes about all # of the local groups on the machine.
def self on_period UNK on_lparen path on_comma username on_comma keyname on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_period UNK on_lparen # Perform a dscl lookup at the path specified for the specific keyname # value. The value returned is the first item within the array returned # from dscl
def self on_period UNK on_lparen shadow_hash_data on_rparen on_ignored_nl embedded_binary_plist on_op on_const on_lparen shadow_hash_data on_lbracket on_int on_rbracket on_period UNK on_lparen on_tstring_beg # The plist embedded in the ShadowHashData key is a binary plist. The # plist library doesn't read binary plists, so we need to # extract the binary plist, convert it to XML, and return it.
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_const on_op on_const # This method will accept a hash and convert it to a binary plist (string value).
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_const on_op on_const # This method will accept a binary plist (as a string) and convert it to a hash.
def self on_period UNK on_lparen embedded_binary_plist on_rparen on_ignored_nl embedded_binary_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # The salted-SHA512 password hash in 10.7 is stored in the 'SALTED-SHA512' # key as binary data. That data is extracted and converted to a hex string.
def self on_period UNK on_lparen field on_comma embedded_binary_plist on_rparen on_ignored_nl UNK field on_nl when on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content # This method reads the passed embedded_binary_plist hash and returns values # according to which field is passed. Arguments passed are the hash # containing the value read from the 'ShadowHashData' key in the User's # plist, and the field to be read (one of 'entropy', 'salt', or 'iterations')
def self on_period UNK on_lparen guid on_rparen on_ignored_nl UNK on_op UNK on_nl password_hash_file on_op on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg # In versions 10.5 and 10.6 of OS X, the password hash is stored in a file # in the /var/db/shadow/hash directory that matches the GUID of the user.
on_ignored_nl def UNK on_nl begin on_ignored_nl dscl on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period ## ## ## Ensurable Methods ## ## ##
def UNK on_nl UNK on_lparen on_ivar on_period name on_rparen on_nl on_ignored_nl on_ivar on_op self on_period class on_period UNK on_lparen on_tstring_beg # This method is called if ensure => present is passed and the exists? # method returns false. Dscl will directly set most values, but the # setter methods will be used for any exceptions.
on_ivar on_op self on_period class on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_period name on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Retrieve the user's GUID
UNK on_op on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_nl on_ignored_nl UNK on_period each do # Get an array of valid User type properties
UNK on_period each do on_op attribute on_op on_ignored_nl UNK if attribute on_op on_symbeg UNK on_nl value on_op on_ivar on_period UNK # Iterate through valid User type properties
if value on_period UNK on_nl value on_op UNK attribute on_nl when on_symbeg UNK on_nl on_tstring_beg on_tstring_content on_tstring_end on_nl when on_symbeg # Value defaults
value on_op on_const on_op on_const on_period UNK on_lparen value on_rparen if attribute on_op on_symbeg UNK on_nl on_ignored_nl if value on_op # Ensure group names are converted to integers.
if value on_op on_tstring_beg on_tstring_end UNK UNK value on_period UNK on_nl UNK attribute on_nl when on_symbeg password on_nl self on_period ## Set values ## # For the :password and :groups properties, call the setter methods # to enforce those values. For everything else, use dscl with the # ns_to_ds_attribute_map to set the appropriate values.
def UNK on_nl dscl on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period name on_embexpr_end on_tstring_end # This method is called when ensure => absent has been set. # Deleting a user is handled by dscl
on_ignored_nl def UNK on_lparen value on_rparen on_ignored_nl guid on_op self on_period class on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar ## ## ## Getter/Setter Methods ## ## ##
def UNK on_lparen value on_rparen on_ignored_nl guid on_op self on_period class on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_period # In the setter method we're only going to take action on groups for which # the user is not currently a member.
def UNK on_lparen value on_rparen on_ignored_nl if self on_period class on_period get_os_version on_op on_tstring_beg on_tstring_content on_tstring_end on_nl if value on_period # If you thought GETTING a password was bad, try SETTING it. This method # makes me want to cry. A thousand tears... # # I've been unsuccessful in tracking down a way to set the password for # a user using dscl that DOESN'T require passing it as plaintext. We were # also unable to get dsimport to work like this. Due to these downfalls, # the sanest method requires opening the user's plist, dropping in the # password hash, and serializing it back to disk. The problems with THIS # method revolve around dscl. Any time you directly modify a user's plist, # you need to flush the cache that dscl maintains.
UNK on_int on_nl flush_dscl_cache on_nl UNK on_lparen value on_rparen on_nl on_ignored_nl flush_dscl_cache on_nl end on_nl on_ignored_nl def UNK on_lparen value # Methods around setting the password on OS X are the ONLY methods that # cannot use dscl (because the only way to set it via dscl is by passing # a plaintext password - which is bad). Because of this, we have to change # the user's plist directly. DSCL has its own caching mechanism, which # means that every time we call dscl in this provider we're not directly # changing values on disk (instead, those calls are cached and written # to disk according to Apple's prioritization algorithms). When Puppet # needs to set the password property on OS X > 10.6, the provider has to # tell dscl to write its cache to disk before modifying the user's # plist. The 'dscacheutil -flushcache' command does this. Another issue # is how fast Puppet makes calls to dscl and how long it takes dscl to # enter those calls into its cache. We have to sleep for 2 seconds before # flushing the dscl cache to allow all dscl calls to get INTO the cache # first. This could be made faster (and avoid a sleep call) by finding # a way to enter calls into the dscl cache faster. A sleep time of 1 # second would intermittently require a second Puppet run to set # properties, so 2 seconds seems to be the minimum working value.
flush_dscl_cache on_nl end on_nl on_ignored_nl def UNK on_lparen value on_rparen on_ignored_nl if on_lparen on_const on_op on_const on_op on_const on_period UNK # Since we just modified the user's plist, we need to flush the ds cache # again so dscl can pick up on the changes we made.
def UNK on_lparen value on_rparen on_ignored_nl if on_lparen on_const on_op on_const on_op on_const on_period UNK on_lparen self on_period class on_period # The iterations and salt properties, like the password property, can only # be modified by directly changing the user's plist. Because of this fact, # we have to treat the ds cache just like you would in the password= # method.
def UNK on_lparen value on_rparen on_ignored_nl if on_lparen on_const on_op on_const on_op on_const on_period UNK on_lparen self on_period class on_period # The iterations and salt properties, like the password property, can only # be modified by directly changing the user's plist. Because of this fact, # we have to treat the ds cache just like you would in the password= # method.
on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end ##### # Dynamically create setter methods for dscl properties ##### # # Setter methods are only called when a resource currently has a value for # that property and it needs changed (true here since all of these values # have a default that is set in the create method). We don't want to merge # in additional values if an incorrect value is set, we want to CHANGE it. # When using the -change argument in dscl, the old value needs to be passed # first (followed by the new value). Because of this, we get the current # value from the @property_hash variable and then use the value passed as # the new value. Because we're prefetching instances of the provider, it's # possible that the value determined at the start of the run may be stale # (i.e. someone changed the value by hand during a Puppet run) - if that's # the case we rescue the error from dscl and alert the user. # # In the event that the user doesn't HAVE a value for the attribute, the # provider should use the -create option with dscl to add the attribute value # for the user record
on_ignored_nl def UNK on_nl UNK on_op on_lbracket on_symbeg password on_comma on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_period UNK on_lbrace on_op ## ## ## Helper Methods ## ## ##
def UNK on_lparen path on_comma username on_comma keyname on_comma value on_rparen on_ignored_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma path on_comma # This method will create a given value using dscl
def UNK on_lparen path on_comma username on_comma keyname on_comma value on_rparen on_ignored_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma path on_comma # This method will merge in a given value using dscl
def UNK on_lparen username on_rparen on_ignored_nl dscl on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_embexpr_beg username on_embexpr_end # Create the new user with dscl
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl UNK on_op dscl on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Get the next available uid on the system by getting a list of user ids, # sorting them, grabbing the last one, and adding a 1. Scientific stuff here.
UNK on_op UNK on_period UNK on_period UNK on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK if UNK on_op UNK # We're ok with throwing away negative uids here. Also, remove nil values.
UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op UNK on_lbracket UNK on_rbracket on_op on_int on_nl UNK UNK if # We're just looking for an unused id in our sorted array.
def UNK on_lparen value on_rparen on_ignored_nl users_plist on_op UNK on_lparen on_ivar on_period name on_rparen on_nl shadow_hash_data on_op UNK on_lparen users_plist # This method is only called on version 10.7 or greater. On 10.7 machines, # passwords are set using a salted-SHA512 hash, and on 10.8 machines, # passwords are set using PBKDF2. It's possible to have users on 10.8 # who have upgraded from 10.7 and thus have a salted-SHA512 password hash. # If we encounter this, do what 10.8 does - remove that key and give them # a 10.8-style PBKDF2 password.
if on_lparen shadow_hash_data on_period class on_op on_const on_rparen on_op on_lparen shadow_hash_data on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl # It's possible that a user could exist on the system and NOT have # a ShadowHashData key (especially if the system was upgraded from 10.6). # In this case, a conditional check is needed to determine if the # shadow_hash_data variable is a Hash (it would be false if the key # didn't exist for this user on the system). If the shadow_hash_data # variable IS a Hash and contains the 'SALTED-SHA512' key (indicating an # older 10.7-style password hash), it will be deleted and a newer # 10.8-style (PBKDF2) password hash will be generated.
path on_op on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg username on_embexpr_end on_tstring_content on_tstring_end on_nl on_const on_op on_const on_op on_const on_period UNK # This method will retrieve the data stored in a user's plist and # return it as a native Ruby hash.
def UNK on_lparen users_plist on_rparen on_ignored_nl if users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_op users_plist on_lbracket on_tstring_beg on_tstring_content # This method will return the binary plist that's embedded in the # ShadowHashData key of a user's plist, or false if it doesn't exist.
def UNK on_lparen users_plist on_comma binary_plist on_rparen on_ignored_nl binary_plist on_op on_const on_op on_const on_op on_const on_period UNK on_lparen binary_plist on_rparen # This method will embed the binary plist data comprising the user's # password hash (and Salt/Iterations value if the OS is 10.8 or greater) # into the ShadowHashData key of the user's plist.
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period name on_embexpr_end on_tstring_end on_comma on_symbeg # This method writes the ShadowHashData plist in a temporary file, # then imports it using dsimport. macOS versions 10.15 and newer do # not support directly managing binary plists, so we have to use an # intermediary. # dsimport is an archaic utilitary with hard-to-find documentation # # See http://web.archive.org/web/20090106120111/http://support.apple.com/kb/TA21305?viewlocale=en_US # for information regarding the dsimport syntax
dscl on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period name on_embexpr_end on_tstring_end on_comma on_tstring_beg # Delete the user's existing ShadowHashData, since dsimport appends, not replaces
def UNK on_lparen value on_rparen on_ignored_nl on_const on_period UNK on_lparen on_lbracket on_lbracket value on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # This method accepts an argument of a hex password hash, and base64 # decodes it into a format that OS X 10.7 and 10.8 will store # in the user's plist.
def UNK on_lparen users_plist on_comma shadow_hash_data on_comma value on_rparen on_ignored_nl UNK shadow_hash_data on_nl shadow_hash_data on_op on_const on_period UNK on_nl shadow_hash_data # Puppet requires a salted-sha512 password hash for 10.7 users to be passed # in Hex, but the embedded plist stores that value as a Base64 encoded # string. This method converts the string and calls the # set_shadow_hash_data method to serialize and write the plist to disk.
def UNK on_lparen users_plist on_comma shadow_hash_data on_comma field on_comma value on_rparen on_ignored_nl shadow_hash_data on_op on_const on_period UNK UNK shadow_hash_data on_nl # This method accepts a passed value and one of three fields: 'salt', # 'entropy', or 'iterations'. These fields correspond with the fields # utilized in a PBKDF2 password hashing system # (see https://en.wikipedia.org/wiki/PBKDF2 ) where 'entropy' is the # password hash, 'salt' is the password hash salt value, and 'iterations' # is an integer recommended to be > 10,000. The remaining arguments are # the user's plist itself, and the shadow_hash_data hash containing the # existing PBKDF2 values.
users_plist on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_int on_rparen on_nl on_ignored_nl binary_plist on_op self on_period # on 10.8, this field *must* contain 8 stars, or authentication will # fail.
binary_plist on_op self on_period class on_period UNK on_lparen shadow_hash_data on_rparen on_nl UNK on_lparen users_plist on_comma binary_plist on_rparen on_nl end on_nl # Convert shadow_hash_data to a binary plist, and call the # set_shadow_hash_data method to serialize and write the data # back to the user's plist.
def UNK on_lparen users_plist on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_period UNK on_lparen users_plist on_comma on_tstring_beg on_embexpr_beg UNK on_embexpr_end # This method will accept a plist in XML format, save it to disk, convert # the plist to a binary format, and flush the dscl cache.
def UNK on_lparen UNK on_comma value on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl begin on_ignored_nl on_const # This is a simple wrapper method for writing values to a file.
