class on_const on_nl attr_reader on_symbeg key on_nl on_ignored_nl def initialize on_lparen key on_rparen on_ignored_nl on_ivar on_op key on_nl end on_nl # @api private
class on_const on_op on_const on_nl def to_s on_nl key on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl # @api private
class on_const on_op on_const on_nl def to_s on_nl on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl end on_nl # @api private
class on_const on_op on_const on_nl def to_s on_nl on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl end on_nl # @api private
class on_const on_op on_const on_nl def to_s on_nl on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl end on_nl # @api private
class on_const on_op on_const on_nl def initialize on_lparen name on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen on_ignored_nl super on_lparen name on_rparen on_nl # @api private
class on_const on_op on_const on_nl def initialize on_lparen name on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen on_ignored_nl super on_lparen name on_rparen on_nl # @api private
class on_const on_op on_const on_nl def to_s on_nl on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_end on_nl end on_nl end on_nl on_ignored_nl # @api private
class on_const on_op on_const on_nl def to_s on_nl on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_end on_nl end on_nl end on_nl on_ignored_nl # @api private
class on_const on_op on_const on_nl def to_s on_nl on_tstring_beg on_embexpr_beg key on_op on_int on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl end # @api private
class on_const on_nl attr_reader on_symbeg path on_nl on_ignored_nl def initialize on_lparen path on_rparen on_ignored_nl on_ivar on_op path on_op on_const on_nl # @api private
class on_const on_op on_const on_nl attr_reader on_symbeg key on_nl on_ignored_nl def initialize on_lparen path on_comma key on_rparen on_ignored_nl super on_lparen # @abstract # @api private
class on_const on_op on_const on_nl def message on_lparen variant on_comma position on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg variant on_embexpr_end on_embexpr_beg position on_embexpr_end # @api private
class on_const on_op on_const on_nl def message on_lparen variant on_comma position on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg variant on_embexpr_end on_embexpr_beg position on_embexpr_end # @api private
class on_const on_op on_const on_nl def message on_lparen variant on_comma position on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg variant on_embexpr_end on_embexpr_beg position on_embexpr_end # @api private
class on_const on_op on_const on_nl def message on_lparen variant on_comma position on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg variant on_embexpr_end on_embexpr_beg position on_embexpr_end # @api private
class on_const on_op on_const on_nl def message on_lparen variant on_comma position on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg variant on_embexpr_end on_embexpr_beg position on_embexpr_end # @api private
class on_const on_op on_const on_nl def message on_lparen variant on_comma position on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg variant on_embexpr_end on_embexpr_beg position on_embexpr_end # @api private
class on_const on_op on_const on_nl attr_reader on_symbeg unresolved on_nl on_ignored_nl def initialize on_lparen path on_comma unresolved on_rparen on_ignored_nl super on_lparen # @api private
class on_const on_op on_const on_nl attr_reader on_symbeg expected on_comma on_symbeg actual on_nl on_ignored_nl def initialize on_lparen path on_comma expected on_comma # @api private
class on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_lparen path on_comma o on_rparen on_ignored_nl self on_period class # @api private
def UNK on_lparen path on_comma o on_rparen on_ignored_nl self on_period class on_period new on_lparen path on_comma on_lbracket expected on_comma o # @return A new instance with the least restrictive respective boundaries
if t on_period is_a? on_lparen on_const on_rparen on_op on_op on_lparen t on_period type on_period nil? on_op t on_period type on_period # Ensure that Optional, NotUndef, Sensitive, and Type are reported with included # type parameter.
def UNK on_lparen e on_comma a on_rparen on_ignored_nl case e on_nl when on_const on_nl a on_period is_a? on_lparen on_const on_rparen # Answers the question if `e` is a specialized type of `a` # @param e [PAnyType] the expected type # @param a [PAnyType] the actual type # @return [Boolean] `true` when the _e_ is a specialization of _a_ #
def UNK on_lparen e on_comma a on_rparen on_ignored_nl if e on_period is_a? on_lparen on_const on_rparen on_nl e on_period UNK on_lbrace # Decides whether or not the report must be fully detailed, or if generalization can be permitted # in the mismatch report. All comparisons are made using resolved aliases rather than the alias # itself. # # @param e [PAnyType,Array[PAnyType]] the expected type or array of expected types # @param a [PAnyType] the actual type # @return [Boolean] `true` when the class of _a_ equals the class _e_ or, # in case _e_ is an `Array`, the class of at least one element of _e_
def UNK on_lparen e on_comma a on_rparen on_ignored_nl e on_period is_a? on_lparen on_const on_rparen on_op e on_period UNK on_lbrace on_op # @param e [PAnyType,Array[PAnyType]] the expected type or array of expected types # @param a [PAnyType] the actual type # @return [Boolean] `true` when _a_ is assignable to _e_ or, in case _e_ is an `Array`, # to at least one element of _e_
def UNK on_lparen e on_comma a on_rparen on_ignored_nl if e on_period is_a? on_lparen on_const on_rparen on_nl e on_period UNK on_lbrace # @param e [PAnyType,Array[PAnyType]] the expected type or array of expected types # @param a [PAnyType] the actual type # @return [Boolean] `true` when _a_ is assignable to the default generalization of _e_ or, # in case _e_ is an `Array`, to the default generalization of at least one element of _e_
def UNK on_lparen e on_comma a on_rparen on_ignored_nl UNK on_lparen e on_comma a on_rparen on_op UNK on_lparen e on_comma a # @param e [PAnyType,Array[PAnyType]] the expected type or array of expected types # @param a [PAnyType] the actual type # @return [Boolean] `true` when either #always_fully_detailed or #assignable_to_default returns `true`
def UNK on_lparen e on_rparen on_ignored_nl if e on_period is_a? on_lparen on_const on_rparen on_nl e on_period map on_lbrace on_op t # Returns its argument with all type aliases resolved # @param e [PAnyType,Array[PAnyType]] the expected type or array of expected types # @return [PAnyType,Array[PAnyType]] the resolved result
def UNK on_lparen e on_comma a on_rparen on_ignored_nl e on_op UNK on_lparen e on_rparen on_nl if UNK on_lparen e on_comma # Returns a string that either represents the generalized type _a_ or the type _a_ verbatim. The latter # form is used when at least one of the following conditions are met: # # - #always_fully_detailed returns `true` for the resolved type of _e_ and _a_ # - #any_assignable? returns `true` for the resolved type of _e_ and the generalized type of _a_. # # @param e [PAnyType,Array[PAnyType]] the expected type or array of expected types # @param a [PAnyType] the actual type # @return [String] The string representation of the type _a_ or generalized type _a_
class on_const on_op on_const on_nl def message on_lparen variant on_comma position on_rparen on_ignored_nl e on_op expected on_nl UNK on_op on_tstring_beg # @api private
class on_const on_op on_const on_nl def from on_nl on_ivar on_period from on_op on_int on_nl end on_nl on_ignored_nl def to on_nl # @api private
def UNK on_lparen path on_comma o on_rparen on_ignored_nl range on_op on_const on_period new on_lparen from on_op o on_period from on_op # @return A new instance with the least restrictive respective boundaries
class on_const on_op on_const on_nl def initialize on_lparen path on_comma expected on_comma actual on_rparen on_ignored_nl super on_lparen path on_comma expected # @api private
class on_const on_nl def self on_period UNK on_lparen subject on_comma params_struct on_comma UNK on_comma missing_ok on_op UNK on_rparen on_ignored_nl singleton # @api private
message on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl message on_op on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end #TRANSLATORS TypeMismatchDescriber is a class name and 'tense' is a method name and should not be translated
def UNK on_lparen subject on_comma params_struct on_comma UNK on_comma missing_ok on_op UNK on_comma tense on_op on_symbeg ignored on_rparen on_ignored_nl UNK # Validates that all entries in the give_hash exists in the given param_struct, that their type conforms # with the corresponding param_struct element and that all required values are provided. # # @param subject [String] string to be prepended to the exception message # @param params_struct [PStructType] Struct to use for validation # @param given_hash [Hash<String,Object>] the parameters to validate # @param missing_ok [Boolean] Do not generate errors on missing parameters # @param tense [Symbol] deprecated and ignored #
def UNK on_lparen name on_comma expected on_comma actual on_comma tense on_op on_symbeg ignored on_rparen on_ignored_nl UNK unless tense on_op on_symbeg # Describe a confirmed mismatch using present tense # # @param name [String] name of mismatch # @param expected [PAnyType] expected type # @param actual [PAnyType] actual type # @param tense [Symbol] deprecated and ignored #
def UNK on_lparen subject on_comma UNK on_comma UNK on_comma value on_comma tense on_op on_symbeg ignored on_rparen on_ignored_nl UNK unless tense # @param subject [String] string to be prepended to the exception message # @param param_name [String] parameter name # @param param_type [PAnyType] parameter type # @param value [Object] value to be validated against the given type # @param tense [Symbol] deprecated and ignored #
def UNK on_lparen params_struct on_comma UNK on_comma missing_ok on_op UNK on_rparen on_ignored_nl UNK on_op params_struct on_period UNK on_nl result on_op # Validates that all entries in the _param_hash_ exists in the given param_struct, that their type conforms # with the corresponding param_struct element and that all required values are provided. # An error message is created for each problem found. # # @param params_struct [PStructType] Struct to use for validation # @param param_hash [Hash<String,Object>] The parameters to validate # @param missing_ok [Boolean] Do not generate errors on missing parameters # @return [Array<Mismatch>] An array of found errors. An empty array indicates no errors.
unless error_arrays on_period UNK on_lbrace on_op a on_op on_op a on_period empty? on_rbrace on_nl block_arrays on_op on_lbracket on_rbracket on_nl signatures # Skip block checks if all signatures have argument errors
error_arrays on_op block_arrays on_nl elsif UNK on_op on_int on_nl error_arrays on_period each_with_index on_lbrace on_op a on_comma index on_op error_arrays on_lbracket # Skip argument errors when all alternatives have block errors
error_arrays on_period each_with_index on_lbrace on_op a on_comma index on_op error_arrays on_lbracket index on_rbracket on_op block_arrays on_lbracket index on_rbracket if a # Merge errors giving argument errors precedence over block errors
arg_count on_op arg_types on_period size on_op on_int on_nl UNK on_lparen signature on_comma arg_types on_comma path on_comma UNK on_comma on_const on_period # Check other arguments
if UNK on_period nil? on_nl on_lbracket on_const on_period new on_lparen path on_rparen on_rbracket on_nl else on_ignored_nl describe on_lparen UNK on_comma # Can't pass a block to a callable that doesn't accept one
describe on_lparen UNK on_comma UNK on_comma path on_op on_lbracket on_const on_period new on_rbracket on_rparen on_nl end on_nl else on_ignored_nl if # Check that the block is of the right type
if UNK on_period nil? on_op UNK on_period assignable? on_lparen on_const on_op on_const on_rparen on_nl on_const on_nl else on_ignored_nl on_lbracket on_const # Check that the block is optional
if expected_size on_period assignable? on_lparen actual_size on_rparen on_nl etypes on_op signature on_period type on_period param_types on_period types on_nl UNK on_op # not assignable if the number of types in actual is outside number of types in expected
on_lbracket on_const on_period new on_lparen path on_comma original on_comma actual on_rparen on_rbracket on_nl else on_ignored_nl descriptions on_nl end on_nl end # All variants failed in this alias so we report it as a mismatch on the alias # rather than reporting individual failures of the variants
UNK on_op UNK on_period UNK do on_op UNK on_comma UNK on_op on_ignored_nl UNK nil unless UNK on_period canonical_path on_op UNK # If they all have the same canonical path, then we can compact this into one
descriptions on_op on_lbracket UNK on_rbracket on_nl UNK on_nl end on_nl end on_nl end on_nl descriptions on_op descriptions on_period UNK on_nl # Report the generic mismatch and skip the rest
if expected_size on_period assignable? on_lparen actual_size on_rparen on_nl etypes on_op expected on_period types on_nl descriptions on_op on_lbracket on_rbracket on_nl unless # not assignable if the number of types in actual is outside number of types in expected
on_lbracket on_const on_period new on_lparen path on_comma original on_comma actual on_rparen on_rbracket on_nl else on_ignored_nl expected_size on_op expected on_period size_type # Array of anything can not be assigned (unless tuple is tuple of anything) - this case # was handled at the top of this method. #
if expected on_period param_types on_period nil? on_op expected on_period UNK on_period nil? on_nl on_const on_nl else on_ignored_nl UNK on_op UNK # nil param_types means, any other Callable is assignable
UNK on_op UNK on_lparen expected on_period param_types on_comma actual on_period param_types on_comma path on_rparen on_nl if UNK on_period empty? on_nl # NOTE: these tests are made in reverse as it is calling the callable that is constrained # (it's lower bound), not its upper bound
UNK on_op expected on_period block_type on_op on_const on_op on_const on_nl UNK on_op actual on_period block_type on_op on_const on_op on_const on_nl # names are ignored, they are just information # Blocks must be compatible
def UNK on_lparen signature on_rparen on_ignored_nl param_types on_op signature on_period type on_period param_types on_nl param_names on_op signature on_period UNK on_nl # Produces a string for the signature(s) # # @api private
return on_tstring_beg on_tstring_end on_nl end on_nl on_ignored_nl UNK on_op from on_nl types on_op on_ignored_nl case param_types on_nl when on_const on_nl # No parameters function
param_names on_op on_const on_period new on_lparen types on_period size on_comma on_tstring_beg on_tstring_end on_rparen if param_names on_period empty? on_nl UNK on_op # join type with names (types are always present, names are optional) # separate entries with comma #
UNK on_op from on_op param_names on_period size on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_nl elsif UNK on_lparen index # Last is a repeated_param.
case signature on_period type on_period block_type on_nl when on_const on_nl result on_op on_tstring_beg on_tstring_content on_tstring_end unless result on_op on_tstring_beg on_tstring_end # If there is a block, include it
end on_nl result on_nl end on_nl on_ignored_nl def max on_lparen a on_comma UNK on_rparen on_ignored_nl a on_op UNK on_op a # nothing
def max on_lparen a on_comma UNK on_rparen on_ignored_nl a on_op UNK on_op a on_op UNK on_nl end on_nl on_ignored_nl def # Why oh why Ruby do you not have a standard Math.max ? # @api private
def UNK on_lparen index on_comma UNK on_rparen on_ignored_nl UNK on_op index on_op on_int on_nl UNK on_op UNK on_nl end on_nl # @api private
