UNK on_const on_nl on_const on_op UNK UNK UNK on_period UNK on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_comma UNK # @api private
on_ignored_nl if type_name on_period UNK on_lparen on_const on_rparen on_op type_name on_period UNK on_lparen on_const on_rparen on_op UNK on_nl UNK on_op # loader = Adapters::LoaderAdapter.loader_for_model_object(o, scope)
UNK on_op UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_op UNK on_period UNK on_period UNK on_lparen UNK on_rparen # Resolve a 'class' and its titles
UNK on_op on_const on_nl UNK on_ignored_nl UNK on_op UNK on_lparen scope on_comma type_name on_rparen on_nl end on_nl on_ignored_nl UNK UNK # resolved type is just the string CLASS
UNK on_op UNK on_lparen scope on_comma type_name on_rparen on_nl end on_nl on_ignored_nl UNK UNK on_nl UNK on_const on_comma UNK on_lparen # resolve a resource type - pcore based, ruby impl, user defined, or application
UNK UNK on_nl UNK on_const on_comma UNK on_lparen UNK UNK UNK on_rparen on_op UNK UNK type_name UNK on_nl end on_nl # TODO: Unknown resource causes creation of Resource to fail with ArgumentError, should give # a proper Issue. Now the result is "Error while evaluating a Resource Statement" with the message # from the raised exception. (It may be good enough).
UNK on_const on_comma UNK on_lparen UNK UNK UNK on_rparen on_op UNK UNK type_name UNK on_nl end on_nl on_ignored_nl UNK on_period # TODO: do this the right way
UNK on_period UNK UNK on_op UNK on_op on_ignored_nl resource on_op on_const on_op on_const on_op on_const on_period UNK on_lparen on_ignored_nl UNK # Build a resource for each title - use the resolved *type* as opposed to a reference # as this makes the created resource retain the type instance. #
on_symbeg UNK on_op scope on_period UNK on_comma on_ignored_nl on_symbeg scope on_op scope on_comma on_ignored_nl on_symbeg UNK on_op UNK on_nl on_rparen # WTF is this? Which source is this? The file? The name of the context ?
if resource on_period UNK on_period UNK on_const on_op on_const on_op on_const on_nl resource on_period UNK on_period UNK on_lparen scope on_comma # If this resource type supports inheritance (e.g. 'class') the parent chain must be walked # This impl delegates to the resource type to figure out what is needed. #
scope on_period UNK on_period UNK on_lparen UNK UNK UNK on_comma scope on_comma UNK on_rparen if UNK on_op on_const on_nl on_ignored_nl # Classes are evaluated immediately
UNK on_lparen resource on_rparen on_nl end on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen scope on_comma type_name on_rparen on_ignored_nl # Turn the resource into a PTypeType (a reference to a resource type) # weed out nil's
on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen on_rparen on_period UNK on_lparen resource on_rparen on_period UNK on_nl end # inference returns the meta type since the 3x Resource is an alternate way to describe a type
scope on_period UNK on_period UNK on_period UNK on_lparen UNK UNK on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen # Find the main class (known as ''), it does not have to be in the catalog
UNK UNK on_nl end on_nl on_ignored_nl UNK on_op scope on_period UNK on_period UNK on_period UNK on_nl UNK on_op UNK on_period # Skip the search for built in types as they are always in global namespace # (At least for now).
on_const on_op on_const on_period UNK on_lparen type_name on_rparen on_nl end on_nl UNK on_symbeg UNK on_nl on_ignored_nl def self on_period UNK # horrible - should be loaded by a "last loader" in 4.x loaders instead.
