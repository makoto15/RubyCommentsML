UNK on_const on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_op on_const on_op on_const # The AST::Bridge contains classes that bridges between the new Pops based model # and the 3.x AST. This is required to be able to reuse the Puppet::Resource::Type which is # fundamental for the rest of the logic. #
UNK on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl def UNK on_nl on_const on_op on_const on_op on_const on_op # Bridges to one Pops Model Expression # The @value is the expression # This is used to represent the body of a class, definition, or node, and for each parameter's default value # expression. #
def UNK on_nl UNK UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK value on_period UNK on_nl # Adapts to 3x where top level constructs needs to have each to iterate over children. Short circuit this # by yielding self. By adding this there is no need to wrap a pops expression inside an AST::BlockExpression #
UNK on_nl UNK on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl on_lbracket on_rbracket on_nl # This happens when testing and not having a complete setup
UNK on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl on_lbracket on_rbracket on_nl end on_nl end on_nl # When does this happen ? Ever ?
end on_nl end on_nl on_ignored_nl def UNK on_nl on_lbracket on_rbracket on_nl end on_nl end on_nl on_ignored_nl UNK on_const on_op on_const # What should be done if the above happens (We don't want this to happen). # Puppet::Parser::AST::BlockExpression.new(:children => [self] + other.children)
def UNK on_nl on_lbracket on_rbracket on_nl end on_nl end on_nl on_ignored_nl UNK on_const on_op on_const on_nl def UNK args on_nl # The 3x requires code plugged in to an AST to have this in certain positions in the tree. The purpose # is to either print the content, or to look for things that needs to be defined. This implementation # cheats by always returning an empty array. (This allows simple files to not require a "Program" at the top. #
UNK on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def # Bridges the top level "Program" produced by the pops parser. # Its main purpose is to give one point where all definitions are instantiated (actually defined since the # Puppet 3x terminology is somewhat misleading - the definitions are instantiated, but instances of the created types # are not created, that happens when classes are included / required, nodes are matched and when resources are instantiated # by a resource expression (which is also used to instantiate a host class). #
def UNK on_lparen modname on_rparen on_ignored_nl on_ignored_nl on_ivar on_period UNK on_period UNK do on_op d on_op on_ignored_nl UNK d on_nl # This is the 3x API, the 3x AST searches through all code to find the instructions that can be instantiated. # This Pops-model based instantiation relies on the parser to build this list while parsing (which is more # efficient as it avoids one full scan of all logic via recursive enumeration/yield) #
UNK on_nl end on_nl end on_period UNK on_lparen on_rparen on_period UNK on_lparen on_rparen end on_nl on_ignored_nl def evaluate on_lparen scope # The 3x logic calling this will not know what to do with the result, it is compacted away at the end
end on_nl on_ignored_nl def evaluate on_lparen scope on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_period UNK on_period evaluate # flatten since node definition may have returned an array # Compact since 4x definitions are not understood by compiler
def UNK on_nl UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl # Adapts to 3x where top level constructs needs to have each to iterate over children. Short circuit this # by yielding self. This means that the HostClass container will call this bridge instance with `instantiate`. #
def UNK on_nl UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen o on_rparen on_ignored_nl # Returns true if this Program only contains definitions
UNK o on_period value on_nl on_lbracket o on_period name on_comma on_const on_period new on_lparen on_symbeg value on_op o on_period value # 3x needs parameters as an array of `[name]` or `[name, value_expr]`
return UNK UNK UNK on_period UNK on_period UNK on_op UNK on_nl on_ignored_nl UNK on_op UNK on_period UNK on_period UNK on_lbrace # No need to do anything if there are no parameters
UNK on_op UNK on_period UNK on_period UNK on_lbrace on_op p on_op p on_period UNK on_rbrace on_nl return UNK UNK UNK # No need to do anything if there are no typed parameters
scope on_op UNK on_nl UNK scope on_nl UNK on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_nl UNK # If there are typed parameters, they need to be evaluated to produce the corresponding type # instances. This evaluation requires a scope. A scope is not available when doing deserialization # (there is also no initialized evaluator). When running apply and test however, the environment is # reused and we may reenter without a scope (which is fine). A debug message is then output in case # there is the need to track down the odd corner case. See {#obtain_scope}. #
def UNK on_nl scope on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen do on_ignored_nl on_const on_period UNK on_lbrace UNK on_lparen # Obtains the scope or issues a warning if :global_scope is not bound
on_const on_period UNK on_lbrace UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rbrace on_nl UNK on_nl end on_nl scope on_nl end on_nl # This occurs when testing and when applying a catalog (there is no scope available then), and # when running tests that run a partial setup. # This is bad if the logic is trying to compile, but a warning can not be issues since it is a normal # use case that there is no scope when requesting the type in order to just get the parameters.
def UNK on_lparen o on_comma modname on_comma UNK on_op on_const on_rparen on_ignored_nl args on_op on_lbrace on_ignored_nl on_symbeg UNK on_op o # Produces a hash with data for Definition and HostClass
on_const on_op on_const on_op on_const on_period new on_lparen on_symbeg UNK on_comma on_tstring_beg UNK o on_period UNK UNK on_tstring_content UNK o # Use an intermediate 'capability_mapping' type to pass this info to the compiler where the # actual mapping takes place
