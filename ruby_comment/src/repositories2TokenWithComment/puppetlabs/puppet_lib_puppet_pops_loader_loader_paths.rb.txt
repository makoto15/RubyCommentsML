UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_period UNK on_lparen type on_comma loader # LoaderPaths # === # The central loader knowledge about paths, what they represent and how to instantiate from them. # Contains helpers (*smart paths*) to deal with lazy resolution of paths. # # TODO: Currently only supports loading of functions (2 kinds) #
def UNK on_period UNK on_lparen type on_comma loader on_rparen on_ignored_nl result on_op on_lbracket on_rbracket on_nl UNK type on_nl UNK on_symbeg # Returns an array of SmartPath, each instantiated with a reference to the given loader (for root path resolution # and existence checks). The smart paths in the array appear in precedence order. The returned array may be # mutated. #
if loader on_period loadables on_period include? on_lparen on_symbeg UNK on_rparen on_nl result on_op on_const on_period new on_lparen loader on_rparen on_nl # Only include support for the loadable items the loader states it can contain
on_lbracket on_rbracket on_nl end on_nl result on_nl end on_nl on_ignored_nl on_ignored_nl class on_const on_nl UNK on_symbeg generic_path on_nl on_ignored_nl def # unknown types, simply produce an empty result; no paths to check, nothing to find... move along...
on_ignored_nl class on_const on_nl UNK on_symbeg generic_path on_nl on_ignored_nl def UNK on_lparen loader on_rparen on_ignored_nl on_ivar on_op loader on_nl end # # DO NOT REMOVE YET. needed later? when there is the need to decamel a classname # def de_camel(fq_name) # fq_name.to_s.gsub(/::/, '/'). # gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2'). # gsub(/([a-z\d])([A-Z])/,'\1_\2'). # tr("-", "_"). # downcase # end
UNK on_symbeg generic_path on_nl on_ignored_nl def UNK on_lparen loader on_rparen on_ignored_nl on_ivar on_op loader on_nl end on_nl on_ignored_nl def generic_path # Generic path, in the sense of "if there are any entities of this kind to load, where are they?"
def UNK on_lparen loader on_rparen on_ignored_nl on_ivar on_op loader on_nl end on_nl on_ignored_nl def generic_path on_nl UNK on_ivar unless on_ivar # Creates SmartPath for the given loader (loader knows how to check for existence etc.)
on_ivar on_op on_lparen UNK on_period nil? on_op relative_path on_op on_const on_period join on_lparen UNK on_comma relative_path on_rparen on_rparen on_nl end # @loader.path
def UNK on_lparen typed_name on_comma start_index_in_name on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg on_const on_period join on_lparen generic_path on_comma typed_name on_period name_parts on_rparen # Effective path is the generic path + the name part(s) + extension. #
n on_op on_tstring_beg on_tstring_end on_nl unless extension on_period UNK on_nl relative_path on_op relative_path on_lbracket on_int on_op on_op on_lparen extension on_period # Module name is assumed to be included in the path and therefore not added here
relative_path on_op relative_path on_lbracket on_int on_op on_op on_lparen extension on_period UNK on_op on_int on_rparen on_rbracket on_nl end on_nl relative_path on_period # Remove extension
def UNK on_lparen typed_name on_comma start_index_in_name on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg on_const on_period join on_lparen generic_path on_comma typed_name on_period name_parts on_rparen # Duplication of extension information, but avoids one call
class on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_nl on_ignored_nl def extension on_nl on_const on_nl end # A PuppetSmartPath is rooted at the loader's directory one level up from what the loader specifies as it # path (which is a reference to its 'lib' directory. #
def UNK on_lparen typed_name on_comma start_index_in_name on_rparen on_ignored_nl parts on_op typed_name on_period name_parts on_nl if start_index_in_name on_op on_int on_nl UNK # Duplication of extension information, but avoids one call
parts on_op typed_name on_period name_parts on_nl if start_index_in_name on_op on_int on_nl UNK UNK if start_index_in_name on_op parts on_period size on_nl # Puppet name to path always skips the name-space as that is part of the generic path # i.e. <module>/mymodule/functions/foo.pp is the function mymodule::foo
relative_path on_op relative_path on_lbracket on_int on_op on_op on_lparen extension on_period UNK on_op on_int on_rparen on_rbracket on_nl end on_nl relative_path on_period # Remove extension
class on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period freeze on_nl on_const on_op UNK on_tstring_content UNK on_tstring_content on_tstring_end # TaskPath is like PuppetSmartPath but it does not use an extension and may # match more than one path with one name
relative_path on_op relative_path on_period UNK on_lparen UNK on_tstring_content UNK on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_ignored_nl if relative_path on_op on_tstring_beg on_tstring_content # Remove the file extension, defined as everything after the *last* dot.
typed_name on_period name_parts on_period size on_op on_int on_nl end on_nl on_ignored_nl def UNK on_lparen path on_rparen on_ignored_nl path on_period UNK # TODO: Remove when PE has proper namespace handling
def UNK on_lparen typed_name on_comma start_index_in_name on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg on_const on_period join on_lparen generic_path on_comma typed_name on_period name_parts on_rparen # The effect paths for resource type impl is the full name # since resource types are not name spaced. # This overrides the default PuppetSmartPath. #
on_tstring_beg on_embexpr_beg on_const on_period join on_lparen generic_path on_comma typed_name on_period name_parts on_rparen on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl end on_nl # Resource type to name does not skip the name-space # i.e. <module>/mymodule/resource_types/foo.pp is the resource type foo
parts on_op typed_name on_period name_parts on_nl if start_index_in_name on_op on_int on_nl UNK UNK if start_index_in_name on_op parts on_period size on_nl # Puppet name to path always skips the name-space as that is part of the generic path # i.e. <module>/mymodule/functions/foo.pp is the function mymodule::foo
class on_const on_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op on_lbrace on_rbrace on_nl end on_nl # SmartPaths # === # Holds effective SmartPath instances per type #
def UNK on_lparen type on_rparen on_ignored_nl UNK on_op on_ivar on_nl loader on_op on_ivar on_nl UNK on_op UNK on_lbracket type on_rbracket # Ensures that the paths for the type have been probed and pruned to what is existing relative to # the given root. # # @param type [Symbol] the entity type to load # @return [Array<SmartPath>] array of effective paths for type (may be empty) #
UNK on_op on_const on_period UNK on_lparen type on_comma loader on_rparen on_nl UNK on_op UNK on_lbracket type on_rbracket on_op UNK on_period # type not yet processed, does the various directories for the type exist ? # Get the relative dirs for the type
UNK on_op UNK on_lbracket type on_rbracket on_op UNK on_period UNK on_lbrace on_op UNK on_op loader on_period UNK on_lparen UNK on_rparen # Check which directories exist in the loader's content/index
