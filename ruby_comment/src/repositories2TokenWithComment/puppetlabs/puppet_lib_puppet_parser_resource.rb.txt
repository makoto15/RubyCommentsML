UNK on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end # The primary difference between this class and its # parent is that this class has rules on who can set # parameters
def self on_period UNK on_lparen name on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period UNK on_period UNK on_lbrace on_op UNK # Determine whether the provided parameter name is a relationship parameter.
def UNK on_semicolon on_op on_op on_ivar on_semicolon end on_nl def UNK on_semicolon on_op on_op on_ivar on_semicolon end on_nl def UNK # Set up some boolean test methods
def UNK on_nl return unless self on_period UNK on_nl on_ignored_nl stage on_op UNK on_period resource on_lparen on_symbeg stage on_comma self # Process the stage metaparameter for a class. A containment edge # is drawn from the class to the stage. The stage for containment # defaults to main, if none is specified.
def UNK on_nl return if UNK on_nl on_const on_op on_const on_op on_const on_period UNK on_lparen _ on_lparen on_tstring_beg on_tstring_content on_tstring_end # Retrieve the associated definition and evaluate it.
resource_type on_period UNK on_lparen self on_rparen on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen value on_rparen on_ignored_nl # do not finish completely (as that destroys Sensitive data)
def UNK on_lparen value on_rparen on_ignored_nl if value on_nl on_ivar on_op true on_nl on_ivar on_op value on_nl else on_ignored_nl on_ivar # Mark this resource as both exported and virtual, # or remove the exported mark.
def UNK on_nl return if on_ivar on_nl UNK on_nl on_ivar on_op true on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # Finish the evaluation by assigning defaults and scope tags # @api private #
def UNK on_lparen UNK on_op true on_rparen on_ignored_nl return if UNK on_nl on_ivar on_op true on_nl UNK on_nl UNK on_nl # Do any finishing work on this object, called before # storage/translation. The method does nothing the second time # it is called on the same resource. # # @param do_validate [Boolean] true if validation should be performed # # @api private
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_lparen type on_comma title on_comma UNK on_comma UNK on_op true # Has this resource already been finished?
def UNK on_nl if UNK on_nl return resource_type on_period UNK on_nl else on_ignored_nl return true on_nl end on_nl end on_nl # Is this resource modeling an isomorphic resource type?
UNK on_lparen on_symbeg on_ivar on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op true on_nl end on_nl on_ignored_nl def # We don't declare a new variable here just to test. Saves memory
def UNK on_lparen resource on_rparen on_ignored_nl unless self on_period source on_period UNK on_op resource on_period source on_period UNK on_op resource # Merge an override resource in. This will throw exceptions if # any overrides aren't allowed.
unless self on_period source on_period UNK on_op resource on_period source on_period UNK on_op resource on_period source on_period UNK on_lparen self # Test the resource scope, to make sure the resource is even allowed # to override.
resource on_period UNK on_period each do on_op name on_comma param on_op on_ignored_nl UNK on_lparen param on_rparen on_nl end on_nl end # Some of these might fail, but they'll fail in the way we want.
UNK UNK to_s on_nl on_ignored_nl def UNK on_lparen param on_comma value on_op UNK on_rparen on_ignored_nl if on_op param on_period is_a? # A temporary occasion, until I get paths in the scopes figured out.
def UNK on_lparen param on_comma value on_op UNK on_rparen on_ignored_nl if on_op param on_period is_a? on_lparen on_const on_op on_const on_op # Define a parameter in our resource. # if we ever receive a parameter named 'tag', set # the resource tags with its value.
on_ivar on_lbracket param on_period name on_rbracket on_op param on_nl end on_nl UNK on_op UNK on_nl on_ignored_nl def UNK on_nl UNK # And store it in our parameter hash.
def UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_lparen on_lparen # Convert this resource to a RAL resource.
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_lparen on_lparen scope_resource on_op scope on_period resource on_rparen on_op on_op scope_resource on_period # Answers if this resource is tagged with at least one of the tags given in downcased string form. # # The method is a faster variant of the tagged? method that does no conversion of its # arguments. # # The match takes into account the tags that a resource will inherit from its container # but have not been set yet. # It does *not* take tags set via resource defaults as these will *never* be set on # the resource itself since all resources always have tags that are automatically # assigned. # # @param tag_array [Array[String]] list tags to look for # @return [Boolean] true if this instance is tagged with at least one of the provided tags #
def UNK on_nl return if self on_lbracket on_symbeg UNK on_rbracket on_period nil? on_nl on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl on_lbracket # Fills resource params from a capability # # This backs 'consumes => Sql[one]' # @api private
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label self on_period ref on_comma on_label ref # Assert that the ref really is a resource reference
t on_op ref on_period type on_nl t on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen scope on_comma # Resolve references
raise on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label ref on_comma on_label UNK on_rbrace unless # Ensure that the found resource is a capability resource
UNK on_op resource_type on_period UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_lbracket on_symbeg UNK on_rbracket on_op cns on_period # Establish mappings
raise _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label self on_comma on_label cns on_comma on_label self on_period resource_type on_comma # @todo lutter 2015-08-03: catch this earlier, can we do this during # static analysis ?
scope on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op UNK on_period UNK on_lparen on_symbeg source on_op self on_comma on_symbeg # setup scope that has, for each attr of cns, a binding to cns[attr]
resource_type on_period UNK on_period UNK on_period each do on_op name on_op on_ignored_nl UNK on_op UNK on_lbracket on_symbeg UNK on_rbracket on_lbracket # evaluate mappings in that scope
value on_op UNK on_period UNK on_lparen UNK on_rparen on_nl else on_ignored_nl value on_op cns on_lbracket name on_rbracket on_nl end on_nl # Explicit mapping
raise _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label name on_comma on_label self on_rbrace if UNK on_lbracket name on_rbracket # @todo lutter 2015-07-01: this should be caught by the checker # much earlier. We consume several capres, at least two of which # want to map to the same parameter (PUP-5080)
def UNK on_lparen param on_rparen on_ignored_nl current on_op on_ivar on_lbracket param on_period name on_rbracket on_nl on_lparen UNK on_lparen param on_rparen # Accept a parameter from an override.
current on_op on_ivar on_lbracket param on_period name on_rbracket on_nl on_lparen UNK on_lparen param on_rparen UNK return on_rparen unless current on_nl # This can happen if the override is defining a new parameter, rather # than replacing an existing one.
return if scope on_period UNK on_lparen type on_comma param on_period name on_comma param on_period value on_rparen on_nl on_ignored_nl unless param # Parameter is already set - if overriding with a default - simply ignore the setting of the default value
unless param on_period source on_period UNK on_lparen current on_period source on_rparen on_op param on_period source on_period UNK on_lparen current on_period # The parameter is already set. Fail if they're not allowed to override it.
on_ignored_nl if param on_period UNK on_nl param on_op param on_period UNK on_nl param on_period value on_op on_lbracket current on_period value # If we've gotten this far, we're allowed to override.
if param on_period UNK on_nl param on_op param on_period UNK on_nl param on_period value on_op on_lbracket current on_period value on_comma # Merge with previous value, if the parameter was generated with the +> # syntax. It's important that we use a copy of the new param instance # here, not the old one, and not the original new one, so that the source # is registered correctly for later overrides but the values aren't # implicitly shared when multiple resources are overridden at once (see # ticket #3556).
def UNK on_nl if UNK on_nl UNK on_ignored_nl on_ivar on_period each on_lbrace on_op name on_comma value on_op UNK on_lparen name # Make sure the resource's parameters are all valid for the type.
self on_period UNK on_const on_op on_const on_comma _ on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label param on_period name on_comma # Don't set the same parameter twice
