UNK on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl UNK UNK on_lparen UNK on_comma # # @api private # # Resolve a service using SRV #
UNK UNK on_lparen UNK on_comma on_label on_comma on_label on_const on_op on_const UNK UNK on_rparen UNK on_ivar on_op UNK on_nl on_ivar # # @api private # # @param [Puppet::HTTP::Client] client # @param [String] domain srv domain # @param [Resolv::DNS] dns #
UNK UNK on_lparen UNK on_comma UNK on_comma on_label UNK on_comma on_label UNK on_rparen UNK on_ivar UNK UNK on_lparen on_ivar on_comma # # @api private # # Walk the available srv records and return the first that successfully connects # # @param [Puppet::HTTP::Session] session # @param [Symbol] name the service being resolved # @param [Puppet::SSL::SSLContext] ssl_context # @param [Proc] error_handler (nil) optional callback for each error # encountered while resolving a route. # # @return [Puppet::HTTP::Service] if an available service is found, return # it. Return nil otherwise. #
on_ivar UNK UNK on_lparen on_ivar on_comma UNK on_rparen UNK on_op UNK on_comma UNK on_op UNK UNK on_op on_const on_op on_const # Here we pass our HTTP service name as the DNS SRV service name # This is fine for :ca, but note that :puppet and :file are handled # specially in `each_srv_record`.
