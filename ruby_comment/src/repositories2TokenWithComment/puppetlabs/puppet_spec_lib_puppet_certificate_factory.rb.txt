UNK on_const on_op on_const on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_comma csr on_comma issuer on_comma UNK on_comma UNK # This class encapsulates the logic of creating and adding extensions to X509 # certificates. # # @api private
def self on_period UNK on_lparen UNK on_comma csr on_comma issuer on_comma UNK on_comma UNK on_op UNK on_rparen on_ignored_nl UNK on_op # Create a new X509 certificate and add any needed extensions to the cert. # # @param cert_type [Symbol] The certificate type to create, which specifies # what extensions are added to the certificate. # One of (:ca, :terminalsubca, :server, :ocsp, :client) # @param csr [Puppet::SSL::CertificateRequest] The signing request associated with # the certificate being created. # @param issuer [OpenSSL::X509::Certificate, OpenSSL::X509::Request] An X509 CSR # if this is a self signed certificate, or the X509 certificate of the CA if # this is a CA signed certificate. # @param serial [Integer] The serial number for the given certificate, which # MUST be unique for the given CA. # @param ttl [String] The duration of the validity for the given certificate. # # @api public # # @return [OpenSSL::X509::Certificate]
UNK on_op on_tstring_beg on_tstring_content UNK UNK UNK on_tstring_content on_tstring_end on_nl UNK on_lparen UNK on_rparen UNK on_ignored_nl UNK on_const on_comma UNK # Work out if we can even build the requested type of certificate.
cert on_op on_const on_op on_const on_op on_const on_period UNK on_nl on_ignored_nl cert on_period UNK on_op UNK cert on_period UNK on_op # set up the certificate, and start building the content.
cert on_period UNK on_op csr on_period UNK on_period UNK on_nl cert on_period issuer on_op issuer on_period UNK on_nl cert on_period # X509v3
cert on_period UNK on_op on_const on_period UNK on_op on_lparen UNK on_op UNK on_op UNK on_rparen on_nl cert on_period UNK on_op # Make the certificate valid as of yesterday, because so many people's # clocks are out of sync. This gives one more day of validity than people # might expect, but is better than making every person who has a messed up # clock fail, and better than having every cert we generate expire a day # before the user expected it to when they asked for "one year".
def self on_period UNK on_lparen cert on_comma csr on_comma issuer on_comma UNK on_rparen on_ignored_nl ef on_op on_const on_op on_const on_op # Add X509v3 extensions to the given certificate. # # @param cert [OpenSSL::X509::Certificate] The certificate to add the # extensions to. # @param csr [OpenSSL::X509::Request] The CSR associated with the given # certificate, which may specify requested extensions for the given cert. # See https://tools.ietf.org/html/rfc2985 Section 5.4.2 Extension request # @param issuer [OpenSSL::X509::Certificate, OpenSSL::X509::Request] An X509 CSR # if this is a self signed certificate, or the X509 certificate of the CA if # this is a CA signed certificate. # @param extensions [Hash<String, Array<String> | String>] The extensions to # add to the certificate, based on the certificate type being created (CA, # server, client, etc) # # @api private # # @return [void]
UNK on_op csr on_period UNK on_period UNK on_lparen on_lbrace on_rbrace on_rparen UNK on_op UNK on_comma UNK on_op on_ignored_nl UNK on_lbracket # Extract the requested extensions from the CSR.
UNK on_op on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_rbrace on_nl on_ignored_nl UNK on_op on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end # Produce our final set of extensions. We deliberately order these to # build the way we want: # 1. "safe" default values, like the comment, that no one cares about. # 2. request extensions, from the CSR # 3. extensions based on the type we are generating # 4. overrides, which we always want to have in their form # # This ordering *is* security-critical, but we want to allow the user # enough rope to shoot themselves in the foot, if they want to ignore our # advice and externally approve a CSR that sets the basicConstraints. # # Swapping the order of 2 and 3 would ensure that you couldn't slip a # certificate through where the CA constraint was true, though, if # something went wrong up there. --daniel 2011-10-11
UNK on_op on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end # See https://www.openssl.org/docs/apps/x509v3_config.html # for information about the special meanings of 'hash', 'keyid', 'issuer'
def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_tstring_end on_comma true on_rbracket # Woot! We're a CA.
on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_tstring_end on_comma true on_rbracket on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket # This was accidentally omitted in the previous version of this code: an # effort was made to add it last, but that actually managed to avoid # adding it to the certificate at all. # # We have some sort of bug, which means that when we add it we get a # complaint that the issuer keyid can't be fetched, which breaks all # sorts of things in our test suite and, e.g., bootstrapping the CA. # # https://tools.ietf.org/html/rfc5280#section-4.2.1.1 says that, to be a # conforming CA we MAY omit the field if we are self-signed, which I # think gives us a pass in the specific case. # # It also notes that we MAY derive the ID from the subject and serial # number of the issuer, or from the key ID, and we definitely have the # former data, should we want to restore this... # # Anyway, preserving this bug means we don't risk breaking anything in # the field, even though it would be nice to have. --daniel 2011-10-11 # # "authorityKeyIdentifier" => "keyid:always,issuer:always",
def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_tstring_end on_comma true on_rbracket # We're a terminal CA, probably not self-signed.
def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_tstring_end on_comma true on_rbracket # We're a normal server.
def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_tstring_end on_comma true on_rbracket # Um, no idea.
def self on_period UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_tstring_end on_comma # Normal client.
on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_tstring_end on_comma true on_rbracket on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_lbracket # We don't seem to use this, but that seems much more reasonable here...
def self on_period UNK on_lparen ef on_comma oid on_comma val on_comma UNK on_op UNK on_rparen on_ignored_nl on_ignored_nl val on_op val # Generate an extension with the given OID, value, and critical state # # @param oid [String] The numeric value or short name of a given OID. X509v3 # extensions must be passed by short name or long name, while custom # extensions may be passed by short name, long name, oid numeric OID. # @param ef [OpenSSL::X509::ExtensionFactory] The extension factory to use # when generating the extension. # @param val [String, Array<String>] The extension value. # @param crit [true, false] Whether the given extension is critical, defaults # to false. # # @return [OpenSSL::X509::Extension] # # @api private
UNK on_op UNK UNK oid on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_period UNK on_lparen # Enforce the X509v3 rules about subjectAltName being critical: # specifically, it SHOULD NOT be critical if we have a subject, which we # always do. --daniel 2011-10-18
ef on_period UNK on_lparen oid on_comma val on_comma UNK on_rparen on_nl UNK on_ignored_nl on_const on_op on_const on_op on_const on_period UNK # Attempt to create a X509v3 certificate extension. Standard certificate # extensions may need access to the associated subject certificate and # issuing certificate, so must be created by the OpenSSL::X509::ExtensionFactory # which provides that context.
on_const on_op on_const on_op on_const on_period UNK on_lparen oid on_comma on_const on_op on_const on_op on_const on_period UNK on_lparen val on_rparen # This is not an X509v3 extension which means that the extension # factory cannot generate it. We need to generate the extension # manually.
