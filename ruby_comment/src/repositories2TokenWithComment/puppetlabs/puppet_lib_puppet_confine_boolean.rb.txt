UNK UNK on_op UNK on_nl UNK UNK on_nl UNK UNK on_nl UNK UNK UNK UNK UNK UNK on_op UNK UNK # Common module for the Boolean confines. It currently # contains just enough code to implement PUP-9336.
UNK UNK on_nl UNK UNK UNK UNK UNK UNK on_op UNK UNK UNK on_period UNK on_period UNK UNK on_nl end # Returns the passing value for the Boolean confine.
UNK UNK on_nl UNK on_ivar on_period UNK on_op UNK on_op on_ivar on_period UNK on_period UNK UNK UNK UNK UNK on_nl # The Boolean confines 'true' and 'false' let the user specify # two types of values: # * A lambda for lazy evaluation. This would be something like # confine :true => lambda { true } # # * A single Boolean value, or an array of Boolean values. This would # be something like # confine :true => true OR confine :true => [true, false, false, true] # # This override distinguishes between the two cases.
UNK on_ivar on_period UNK on_op UNK on_op on_ivar on_period UNK on_period UNK UNK UNK UNK UNK on_nl UNK on_ivar on_nl # Note that Puppet::Confine's constructor ensures that @values # will always be an array, even if a lambda's passed in. This is # why we have the length == 1 check.
on_ignored_nl UNK on_ivar UNK on_ivar on_period UNK on_nl on_ignored_nl UNK on_op on_op on_op on_ivar on_period UNK on_period UNK on_nl UNK # We have a lambda. Here, we want to enforce "cache positive" # behavior, which is to cache the result _if_ it evaluates to # the passing value (i.e. the class name).
UNK on_op on_op on_op on_ivar on_period UNK on_period UNK on_nl UNK UNK on_op UNK on_nl on_ivar on_op UNK UNK UNK # Double negate to coerce the value into a Boolean
