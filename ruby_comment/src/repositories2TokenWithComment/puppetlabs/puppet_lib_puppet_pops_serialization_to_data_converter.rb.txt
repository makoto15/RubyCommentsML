UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl def UNK on_period UNK on_lparen value on_comma options on_op on_const on_rparen # Class that can process an arbitrary object into a value that is assignable to `Data`. # # @api public
def UNK on_period UNK on_lparen value on_comma options on_op on_const on_rparen on_ignored_nl UNK on_lparen options on_rparen on_period UNK on_lparen value # Convert the given _value_ according to the given _options_ and return the result of the conversion # # @param value [Object] the value to convert # @param options {Symbol => <Boolean,String>} options hash # @option options [Boolean] :rich_data `true` if rich data is enabled # @option options [Boolean] :local_reference use local references instead of duplicating complex entries # @option options [Boolean] :type_by_reference `true` if Object types are converted to references rather than embedded. # @option options [Boolean] :symbol_as_string `true` if Symbols should be converted to strings (with type loss) # @option options [String] :message_prefix String to prepend to in warnings and errors # @return [Data] the processed result. An object assignable to `Data`. # # @api public
def UNK on_lparen options on_op on_const on_rparen on_ignored_nl on_ivar on_op options on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_op UNK if # Create a new instance of the processor # # @param options {Symbol => Object} options hash # @option options [Boolean] :rich_data `true` if rich data is enabled # @option options [Boolean] :local_references use local references instead of duplicating complex entries # @option options [Boolean] :type_by_reference `true` if Object types are converted to references rather than embedded. # @option options [Boolean] :symbol_as_string `true` if Symbols should be converted to strings (with type loss) # @option options [String] :message_prefix String to prepend to path in warnings and errors # @option semantic [Object] :semantic object to pass to the issue reporter
def UNK on_lparen value on_rparen on_ignored_nl on_ivar on_op on_lbracket on_rbracket on_nl on_ivar on_op on_lbrace on_rbrace on_nl to_data on_lparen value on_rparen # Convert the given _value_ # # @param value [Object] the value to convert # @return [Data] the processed result. An object assignable to `Data`. # # @api public
on_lbrace on_ignored_nl on_const on_op on_const on_comma on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK # Transform the binary string to rich Binary
def process on_lparen value on_comma on_op UNK on_rparen on_ignored_nl if on_ivar on_nl id on_op value on_period UNK on_nl UNK on_op # If `:local_references` is enabled, then the `object_id` will be associated with the current _path_ of # the context the first time this method is called. The method then returns the result of yielding to # the given block. Subsequent calls with a value that has the same `object_id` will instead return a # reference based on the given path. # # If `:local_references` is disabled, then this method performs a check for endless recursion before # it yields to the given block. The result of yielding is returned. # # @param value [Object] the value # @yield The block that will produce the data for the value # @return [Data] the result of yielding to the given block, or a hash denoting a reference # # @api private
UNK on_lparen value on_comma on_op UNK on_rparen on_nl else on_ignored_nl on_ivar on_lbracket id on_rbracket on_op on_lbrace on_const on_op on_const on_comma # Complex key and hence no way to reference the prior value. The value must therefore be # duplicated which in turn introduces a risk for endless recursion in case of self # referencing structures
def with on_lparen key on_rparen on_ignored_nl on_ivar on_period UNK on_lparen key on_rparen on_nl value on_op UNK on_nl on_ivar on_period UNK # Pushes `key` to the end of the path and yields to the given block. The # `key` is popped when the yield returns. # @param key [Object] the key to push on the current path # @yield The block that will produce the returned value # @return [Object] the result of yielding to the given block # # @api private
def UNK on_lparen value on_rparen on_ignored_nl id on_op value on_period UNK on_nl if on_ivar on_nl if on_ivar on_period UNK on_lparen # @param value [Object] the value to use when checking endless recursion # @yield The block that will produce the data # @return [Data] the result of yielding to the given block
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_lbracket on_rbracket on_nl UNK on_period UNK do on_op key on_comma value on_op # A Key extended hash is a hash whose keys are not entirely strings. Such a hash # cannot be safely represented as JSON or YAML # # @param hash {Object => Object} the hash to process # @return [String => Data] the representation of the extended hash
on_const on_op on_const on_op on_const on_period UNK on_period UNK on_lparen value on_rparen on_nl on_rbrace on_nl elsif pcore_type on_period UNK on_period # Scalar values are stored using their default string representation
UNK args on_period UNK on_op UNK on_nl UNK UNK pcore_type on_lbracket UNK on_lbracket args on_period UNK on_op UNK on_rbracket on_rbracket # Pop optional arguments that are default
