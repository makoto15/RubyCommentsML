UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_const on_op on_const on_op on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period # The RubyLegacyFunctionInstantiator instantiates a Puppet::Functions::Function given the ruby source # that calls Puppet::Functions.create_function. #
def self on_period UNK on_lparen UNK on_comma UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_const on_lbracket on_symbeg UNK on_rbracket # Produces an instance of the Function class with the given typed_name, or fails with an error if the # given ruby source does not produce this instance when evaluated. # # @param loader [Puppet::Pops::Loader::Loader] The loader the function is associated with # @param typed_name [Puppet::Pops::Loader::TypedName] the type / name of the function to load # @param source_ref [URI, String] a reference to the source / origin of the ruby code to evaluate # @param ruby_code_string [String] ruby code in a string # # @return [Puppet::Pops::Functions.Function] - an instantiated function with global scope closure associated with the given loader #
UNK on_const on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_op on_lbracket on_rbracket on_nl UNK UNK on_lparen UNK on_comma UNK on_rparen on_nl # When func3x turned on, assert content by parsing, when turned off continue with (legacy) undefined behavior
UNK on_op UNK on_period UNK on_nl UNK on_op UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK on_op on_const on_period UNK on_lparen # make the private loader available in a binding to allow it to be passed on
UNK on_op on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_nl func_info on_op on_const on_op on_const on_op on_const on_period UNK on_lparen # Avoid reloading the function if already loaded via one of the APIs that trigger 3x function loading # Check if function is already loaded the 3x way (and obviously not the 4x way since we would not be here in the # first place.
func_info on_op UNK on_lparen UNK on_comma UNK on_comma UNK on_comma on_int on_rparen on_nl on_ignored_nl UNK func_info on_period is_a? on_lparen on_const # This will do the 3x loading and define the "function_<name>" and "real_function_<name>" methods # in the anonymous module used to hold function definitions. #
UNK func_info on_period is_a? on_lparen on_const on_rparen on_nl UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label # Validate what was loaded
UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_lbrace on_label UNK on_comma on_label func_info on_period UNK on_rbrace on_nl # TRANSLATORS - the word 'newfunction' should not be translated as it is a method name.
on_ignored_nl UNK on_period UNK on_lparen UNK on_comma UNK on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_rparen # create the function instance - it needs closure (scope), and loader (i.e. where it should start searching for things # when calling functions etc. # It should be bound to global scope
UNK on_period UNK on_lparen UNK on_comma UNK on_rparen on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_rparen on_ignored_nl # Sets closure scope to nil, to let it be picked up at runtime from Puppet.lookup(:global_scope) # If function definition used the loader from the binding to create a new loader, that loader wins
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_nl end on_nl UNK on_symbeg UNK on_nl on_ignored_nl def self on_period # Produces a binding where the given loader is bound as a local variable (loader_injected_arg). This variable can be used in loaded # ruby code - e.g. to call Puppet::Function.create_loaded_function(:name, loader,...) #
UNK on_period UNK on_lbrace on_op x on_op UNK on_lparen x on_comma UNK on_rparen on_rbrace on_nl UNK on_nl end on_nl UNK # Let the next real parse crash and tell where and what is wrong
UNK on_op UNK on_lparen x on_rparen on_nl UNK on_op on_symbeg UNK UNK UNK on_period is_a? on_lparen on_const on_rparen on_op UNK # Ripper returns a :fcall for a function call in a module (want to know there is a call to newfunction()). # And it returns :call for a qualified named call
UNK on_comma UNK on_op UNK on_lparen UNK on_lparen x on_rparen on_rparen on_nl UNK on_const on_comma UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # There should not be any calls to def in a 3x function
def self on_period UNK on_lparen x on_rparen on_ignored_nl on_lparen x on_period is_a? on_lparen on_const on_rparen on_op on_lbracket x on_lbracket on_int # Extracts the method name and line number from the Ripper Rast for an id entry. # The expected input (a result from Ripper :@ident entry) is an array with: # [0] == :def (or :defs for self.def) # [1] == method name # [2] == [ <filename>, <linenumber> ] # # Returns an Array; a tuple with method name and line number or "<unknown>" if either is missing, or format is not the expected #
