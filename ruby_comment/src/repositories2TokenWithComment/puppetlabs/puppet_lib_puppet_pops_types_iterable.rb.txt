UNK on_const on_nl def UNK on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl on_ignored_nl UNK on_const # Implemented by classes that can produce an iterator to iterate over their contents
UNK on_const on_nl def self on_period UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op self on_period UNK on_lparen UNK # The runtime Iterable type for an Iterable
def self on_period UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op self on_period UNK on_lparen UNK on_rparen on_nl raise # Produces an `Iterable` for one of the following types with the following characterstics: # # `String` - yields each character in the string # `Array` - yields each element in the array # `Hash` - yields each key/value pair as a two element array # `Integer` - when positive, yields each value from zero to the given number # `PIntegerType` - yields each element from min to max (inclusive) provided min < max and neither is unbounded. # `PEnumtype` - yields each possible value of the enum. # `Range` - yields an iterator for all elements in the range provided that the range start and end # are both integers or both strings and start is less than end using natural ordering. # `Dir` - yields each name in the directory # # An `ArgumentError` is raised for all other objects. # # @param o [Object] The object to produce an `Iterable` for # @return [Iterable,nil] The produced `Iterable` # @raise [ArgumentError] In case an `Iterable` cannot be produced # @api public
def self on_period UNK on_lparen o on_comma element_type on_op UNK on_rparen on_ignored_nl UNK o on_nl when on_const on_nl o on_period # Produces an `Iterable` for one of the following types with the following characteristics: # # `String` - yields each character in the string # `Array` - yields each element in the array # `Hash` - yields each key/value pair as a two element array # `Integer` - when positive, yields each value from zero to the given number # `PIntegerType` - yields each element from min to max (inclusive) provided min < max and neither is unbounded. # `PEnumtype` - yields each possible value of the enum. # `Range` - yields an iterator for all elements in the range provided that the range start and end # are both integers or both strings and start is less than end using natural ordering. # `Dir` - yields each name in the directory # # The value `nil` is returned for all other objects. # # @param o [Object] The object to produce an `Iterable` for # @param element_type [PAnyType] the element type for the iterator. Optional (inferred if not provided) # @return [Iterable,nil] The produced `Iterable` or `nil` if it couldn't be produced # # @api public
if o on_period UNK on_nl on_const on_period new on_lparen on_const on_op on_const on_comma o on_period each on_rparen on_nl else on_ignored_nl # Each element is a two element [key, value] tuple.
o on_period UNK on_op on_const on_period new on_lparen o on_rparen on_op UNK on_nl when on_const on_nl on_const on_period new on_lparen # a finite range will always produce at least one element since it's inclusive
if min on_period UNK on_op max on_period UNK on_nl UNK on_op min on_nl UNK on_op max on_nl else on_ignored_nl UNK # A generalized element type where only the size is inferred is used here since inferring the full # range might waste a lot of memory.
UNK on_nl end on_nl else on_ignored_nl UNK on_nl end on_nl end on_nl on_ignored_nl def self on_period unbounded? on_lparen UNK on_rparen # Unsupported range. It's either descending or nonsensical for other reasons (float, mixed types, etc.)
UNK on_nl end on_nl end on_nl on_ignored_nl def self on_period unbounded? on_lparen UNK on_rparen on_ignored_nl UNK UNK on_nl when on_const # Not supported. We cannot determine the element type
def self on_period unbounded? on_lparen UNK on_rparen on_ignored_nl UNK UNK on_nl when on_const on_nl UNK on_period unbounded? on_nl when on_const # Answers the question if there is an end to the iteration. Puppet does not currently provide any unbounded # iterables. # # @return [Boolean] `true` if the iteration is unbounded
raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def step on_lparen step on_comma on_op block on_rparen on_ignored_nl raise # Default implementation cannot propagate reverse_each to a new enumerator so chained # calls must put reverse_each last.
raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_nl raise on_const on_op on_const on_comma on_tstring_beg on_tstring_content # Default implementation cannot propagate step to a new enumerator so chained # calls must put stepping last.
class on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_lparen element_type on_comma UNK on_rparen on_ignored_nl on_ivar on_op element_type on_nl on_ivar # @api private
UNK on_const on_nl on_ignored_nl def UNK on_lparen element_type on_comma UNK on_rparen on_ignored_nl on_ivar on_op element_type on_nl on_ivar on_op UNK on_nl # Note! We do not include Enumerable module here since that would make this class respond # in a bad way to all enumerable methods. We want to delegate all those calls directly to # the contained @enumeration
class on_const on_op on_const on_nl def UNK on_nl UNK on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl # Special iterator used when iterating over hashes. Returns `true` for `#hash_style?` so that # it is possible to differentiate between two element arrays and key => value associations
class on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_lparen element_type on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK # @api private
class on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_lparen range on_comma step on_op on_int on_rparen on_ignored_nl raise # @api private
range on_op on_ivar on_nl step on_op on_ivar on_op step on_nl UNK on_op on_lparen range on_period to on_op range on_period from # The step iterator must use a range that has its logical end truncated at an even step boundary. This will # fulfil two objectives: # 1. The element_type method should not report excessive integers as possible numbers # 2. A reversed iterator must start at the correct number #
