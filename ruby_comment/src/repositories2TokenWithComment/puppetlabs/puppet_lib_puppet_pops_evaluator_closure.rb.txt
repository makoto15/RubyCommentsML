class on_const on_op on_const on_nl attr_reader on_symbeg evaluator on_nl attr_reader on_symbeg model on_nl attr_reader on_symbeg enclosing_scope on_nl on_ignored_nl def initialize # A Closure represents logic bound to a particular scope. # As long as the runtime (basically the scope implementation) has the behavior of Puppet 3x it is not # safe to return and later use this closure. # # The 3x scope is essentially a named scope with an additional internal local/ephemeral nested scope state. # In 3x there is no way to directly refer to the nested scopes, instead, the named scope must be in a particular # state. Specifically, closures that require a local/ephemeral scope to exist at a later point will fail. # It is safe to call a closure (even with 3x scope) from the very same place it was defined, but not # returning it and expecting the closure to reference the scope's state at the point it was created. # # Note that this class is a CallableSignature, and the methods defined there should be used # as the API for obtaining information in a callable-implementation agnostic way. #
def UNK on_lparen on_op args on_rparen on_ignored_nl UNK on_lparen enclosing_scope on_comma args on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Evaluates a closure in its enclosing scope after having matched given arguments with parameters (from left to right) # @api public
def UNK on_lparen UNK on_comma UNK on_comma args on_comma on_op UNK on_rparen on_ignored_nl enclosing_scope on_period UNK do on_op UNK on_op # This method makes a Closure compatible with a Dispatch. This is used when the closure is wrapped in a Function # and the function is called. (Saves an extra Dispatch that just delegates to a Closure and avoids having two # checks of the argument type/arity validity). # @api private
def UNK on_lparen closure_scope on_comma args_hash on_comma enforce_parameters on_rparen on_ignored_nl if enforce_parameters on_nl closure_scope on_period UNK on_lparen closure_name on_comma UNK # Call closure with argument assignment by name
closure_scope on_period UNK on_lparen closure_name on_comma UNK on_rparen do on_op param_scope on_op on_ignored_nl args_hash on_period UNK on_lbrace on_op UNK on_comma # Push a temporary parameter scope used while resolving the parameter defaults
args_hash on_period UNK on_lbrace on_op UNK on_comma UNK on_op param_scope on_lbracket UNK on_rbracket on_op UNK UNK UNK on_period UNK on_rbrace # Assign all non-nil values, even those that represent non-existent parameters.
if UNK on_period value on_period UNK on_nl param_scope on_lbracket name on_rbracket on_op UNK if args_hash on_period UNK on_lparen name on_rparen # Arg either wasn't given, or it was undef
param_scope on_lbracket name on_rbracket on_op UNK if args_hash on_period UNK on_lparen name on_rparen on_nl else on_ignored_nl param_scope on_lbracket name on_rbracket # No default. Assign nil if the args_hash included it
def UNK on_nl on_ivar on_period parameters on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period parameters on_period UNK # Returns the number of parameters (required and optional) # @return [Integer] the total number of accepted parameters
on_ivar on_period parameters on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period parameters on_period UNK on_lparen on_op on_symbeg # yes, this is duplication of code, but it saves a method call
def UNK on_nl on_ivar on_period parameters on_period UNK on_lparen on_op on_symbeg name on_rparen on_nl end on_nl on_ignored_nl def return_type on_nl # @api public
def type on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl # @api public
def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_ivar on_period parameters on_lbracket on_op # @api public
def UNK on_nl UNK on_op on_ivar on_period parameters on_lbracket on_op on_int on_rbracket on_nl UNK on_op UNK on_period UNK on_nl end # @api public
def UNK on_nl UNK UNK UNK on_nl end on_nl on_ignored_nl on_const on_op UNK UNK UNK on_period UNK on_nl on_ignored_nl def # @api public
UNK UNK UNK on_nl end on_nl on_ignored_nl on_const on_op UNK UNK UNK on_period UNK on_nl on_ignored_nl def closure_name on_lparen on_rparen # TODO: Lambda's does not support blocks yet. This is a placeholder
def closure_name on_lparen on_rparen on_ignored_nl on_const on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl def initialize on_lparen evaluator on_comma # @api public
UNK on_op UNK on_lparen on_symbeg UNK on_rparen do on_ignored_nl UNK UNK on_lparen enclosing_scope on_comma args on_rparen on_nl end on_nl UNK # A return from an unnamed closure is treated as a return from the context evaluating # calling this closure - that is, as if it was the return call itself. #
def enclosing_scope on_nl on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_lbrace on_lbrace on_rbrace on_rbrace on_nl end on_nl end on_nl on_ignored_nl # The assigned enclosing scope, or global scope if enclosing scope was initialized to nil #
on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_lbrace on_lbrace on_rbrace on_rbrace on_nl end on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl # Named closures are typically used for puppet functions and they cannot be defined # in an enclosing scope as they are cashed and reused. They need to bind to the # global scope at time of use rather at time of definition. # Unnamed closures are always a runtime construct, they are never bound by a loader # and are thus garbage collected at end of a compilation. #
value on_op param_scope on_period UNK on_lparen parameter on_period name on_comma UNK on_comma scope on_comma on_ivar on_rparen on_nl on_ignored_nl if UNK # not given, has default
value on_op on_lbracket value on_rbracket on_nl end on_nl else on_ignored_nl if UNK on_nl value on_op on_lbracket on_rbracket on_nl else on_ignored_nl # correct non array default value
if UNK on_nl value on_op on_lbracket on_rbracket on_nl else on_ignored_nl on_ivar on_period UNK on_lparen on_const on_op on_const on_comma parameter on_comma # not given, does not have default
value on_op on_lbracket on_rbracket on_nl else on_ignored_nl on_ivar on_period UNK on_lparen on_const on_op on_const on_comma parameter on_comma on_lbrace on_symbeg UNK # default for captures rest is an empty array
value on_op args on_lbracket on_lparen UNK on_op on_int on_rparen on_op on_op on_int on_rbracket on_nl if value on_period UNK on_op on_int # get excess arguments
if value on_period UNK on_op on_int on_op on_lparen UNK on_period UNK on_op UNK on_op on_symbeg UNK on_rparen on_op UNK on_nl # If the input was a single nil, or undef, and there is a default, use the default # This supports :undef in case it was used in a 3x data structure and it is passed as an arg #
value on_op on_lbracket value on_rbracket UNK value on_period UNK on_lparen on_const on_rparen on_nl end on_nl else on_ignored_nl value on_op UNK # and ensure it is an array
param_range on_op type on_period UNK on_nl type on_op type on_period UNK on_nl UNK param on_period UNK on_op on_op type on_period # An array on a slurp parameter is how a size range is defined for a # slurp (Array[Integer, 1, 3] *$param). However, the callable that is # created can't have the array in that position or else type checking # will require the parameters to be arrays, which isn't what is # intended. The array type contains the intended information and needs # to be unpacked.
def UNK on_nl on_lbracket UNK on_rbracket on_nl end on_nl on_ignored_nl on_const on_op on_lbracket on_int on_comma on_const on_op on_const on_rbracket on_nl # Produces information about parameters compatible with a 4x Function (which can have multiple signatures)
