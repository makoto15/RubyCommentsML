UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_lbracket on_symbeg on_const on_comma nil on_comma on_int on_rbracket on_nl # This module is an integral part of the Lexer. # It handles scanning of EPP (Embedded Puppet), a form of string/expression interpolation similar to ERB. #
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl UNK UNK on_op token on_comma UNK on_op UNK on_period UNK on_lparen on_lbracket # Scans all of the content and returns it in an array # Note that the terminating [false, false] token is included in the result. #
def UNK on_nl scn on_op on_ivar on_nl ctx on_op on_ivar on_nl UNK on_op on_ivar on_nl on_ignored_nl UNK on_lparen on_const on_op # A block must be passed to scan. It will be called with two arguments, a symbol for the token, # and an instance of LexerSupport::TokenValue # PERFORMANCE NOTE: The TokenValue is designed to reduce the amount of garbage / temporary data # and to only convert the lexer's internal tokens on demand. It is slightly more costly to create an # instance of a class defined in Ruby than an Array or Hash, but the gain is much bigger since transformation # logic is avoided for many of its members (most are never used (e.g. line/pos information which is only of # value in general for error messages, and for some expressions (which the lexer does not know about). #
scn on_op on_ivar on_nl ctx on_op on_ivar on_nl UNK on_op on_ivar on_nl on_ignored_nl UNK on_lparen on_const on_op on_const on_comma on_symbeg # PERFORMANCE note: it is faster to access local variables than instance variables. # This makes a small but notable difference since instance member access is avoided for # every token in the lexed content. #
UNK UNK on_period UNK on_op scn on_period UNK UNK on_ignored_nl token on_op UNK on_period UNK on_op UNK on_nl if token # This is the lexer's main loop
UNK on_lbracket UNK on_comma UNK on_rbracket on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl scn on_op # Signals end of input
UNK on_ivar on_period UNK on_nl UNK on_lparen on_const on_op on_const on_comma on_symbeg error on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end # Should be at end of scan, or something is terribly wrong
UNK on_lparen on_lbracket on_symbeg on_const on_comma s on_comma scn on_period pos on_op before on_rbracket on_comma before on_rparen on_nl end on_nl # s may be nil if scanned text ends with an epp tag (i.e. no trailing text).
on_ignored_nl when on_symbeg error on_nl UNK on_lparen UNK on_period UNK on_rparen on_nl on_ignored_nl when on_symbeg UNK on_nl if s on_op # do nothing else, scanner is at the end
if s on_op s on_period UNK on_op on_int on_nl UNK on_lparen on_lbracket on_symbeg on_const on_comma s on_comma scn on_period pos # It is meaningless to render empty string segments, and it is harmful to do this at # the start of the scan as it prevents specification of parameters with <%- ($x, $y) -%> #
ctx on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_nl ctx on_lbracket on_symbeg UNK on_rbracket on_op scn on_period pos on_nl on_ignored_nl # switch epp_mode to general (embedded) pp logic (non rendered result)
if s on_op s on_period UNK on_op on_int on_nl UNK on_lparen on_lbracket on_symbeg on_const on_comma s on_comma scn on_period pos # It is meaningless to render an empty string segment
ctx on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_nl ctx on_lbracket on_symbeg UNK on_rbracket on_op scn on_period pos on_nl UNK # switch mode to "epp expr interpolation"
UNK on_const on_nl UNK on_symbeg scanner on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg # A scanner specialized in processing text with embedded EPP (Embedded Puppet) tags. # The scanner is initialized with a StringScanner which it mutates as scanning takes place. # The intent is to use one instance of EppScanner per wanted scan, and this instance represents # the state after the scan. # # @example Sample usage # a = "some text <% pp code %> some more text" # scan = StringScanner.new(a) # eppscan = EppScanner.new(scan) # str = eppscan.scan # eppscan.mode # => :epp # eppscan.lines # => 0 # eppscan # # The scanner supports # * scanning text until <%, <%-, <%= # * while scanning text: # * tokens <%% and %%> are translated to <% and %>, respectively, and is returned as text. # * tokens <%# and %> (or ending with -%>) and the enclosed text is a comment and is not included in the returned text # * text following a comment that ends with -%> gets trailing whitespace (up to and including a line break) trimmed # and this whitespace is not included in the returned text. # * The continuation {#mode} is set to one of: # * `:epp` - for a <% token # * `:expr` - for a <%= token # * `:text` - when there was no continuation mode (e.g. when input ends with text) # * ':error` - if the tokens are unbalanced (reaching the end without a closing matching token). An error message # is then also available via the method {#message}. # # Note that the intent is to use this specialized scanner to scan the text parts, when continuation mode is `:epp` or `:expr` # the pp lexer should advance scanning (using the string scanner) until it reaches and consumes a `-%>` or '%>Â´ token. If it # finds a `-%> token it should pass this on as a `skip_leading` parameter when it performs the next {#scan}. #
UNK on_symbeg scanner on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl # The original scanner used by the lexer/container using EppScanner
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen scanner on_rparen # The resulting mode after the scan. # The mode is one of `:text` (the initial mode), `:epp` embedded code (no output), `:expr` (embedded # expression), or `:error` #
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen scanner on_rparen on_ignored_nl on_ivar on_op scanner on_nl # An error issue if `mode == :error`, `nil` otherwise.
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen scanner on_rparen on_ignored_nl on_ivar on_op scanner on_nl end on_nl on_ignored_nl def UNK # If the first scan should skip leading whitespace (typically detected by the pp lexer when the # pp mode end-token is found (i.e. `-%>`) and then passed on to the scanner. #
def UNK on_lparen scanner on_rparen on_ignored_nl on_ivar on_op scanner on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK on_op # Creates an EppScanner based on a StringScanner that represents the state where EppScanner should start scanning. # The given scanner will be mutated (i.e. position moved) to reflect the EppScanner's end state after a scan. #
def UNK on_nl on_ivar on_period UNK on_op nil on_op on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # Here for backwards compatibility. # @deprecated Use issue instead # @return [String] the issue message
def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl on_ivar on_op on_symbeg UNK on_nl on_ivar on_op UNK on_nl on_ignored_nl return nil # Scans from the current position in the configured scanner, advances this scanner's position until the end # of the input, or to the first position after a mode switching token (`<%`, `<%-` or `<%=`). Number of processed # lines and continuation mode can be obtained via {#lines}, and {#mode}. # # @return [String, nil] the scanned and processed text, or nil if at the end of the input. #
part on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl s on_op part on_nl UNK on_ivar on_period # The spec for %%> is to transform it into a literal %>. This is done here, as %%> otherwise would go # undetected in text mode. (i.e. it is not really necessary to escape %> with %%> in text mode unless # adding checks stating that a literal %> is illegal in text (unbalanced). #
if s on_period UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_op on_symbeg error on_nl on_ivar on_op on_const on_op on_const on_nl end # at the end # if s ends with <% then this is an error (unbalanced <% %>)
on_ivar on_period UNK s on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_ivar on_op on_symbeg UNK on_nl # trim trailing whitespace on same line from accumulated s # return text and signal switch to pp mode
s on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_ivar on_op on_symbeg UNK on_nl return s on_nl # drop the -
on_ivar on_period UNK on_ignored_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_period UNK s on_period UNK on_lparen on_op on_int on_op on_op # verbatim text # keep the scanned <%, and continue scanning after skipping one % # (i.e. do nothing here)
on_ignored_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_period UNK s on_period UNK on_lparen on_op on_int on_op on_op on_int on_rparen on_nl # drop the % to get a literal <% in the output
on_ivar on_period UNK s on_period UNK on_lparen on_op on_int on_op on_op on_int on_rparen on_nl on_ivar on_op on_symbeg UNK on_nl return # expression # return text and signal switch to expression mode # drop the scanned <%, and skip past -%>, or %>, but also skip %%>
s on_period UNK on_lparen on_op on_int on_op on_op on_int on_rparen on_nl on_ivar on_op on_symbeg UNK on_nl return s on_nl on_ignored_nl # drop the =
on_ignored_nl s on_period UNK on_lparen on_op on_int on_op on_op on_int on_rparen on_nl on_ignored_nl part on_op scanner on_period UNK on_lparen on_regexp_beg # template comment
s on_period UNK on_lparen on_op on_int on_op on_op on_int on_rparen on_nl on_ignored_nl part on_op scanner on_period UNK on_lparen on_regexp_beg on_tstring_content # drop the scanned <%, and skip past -%>, or %>, but also skip %%>
part on_op scanner on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl UNK part on_nl on_ivar on_op on_const on_op on_const on_nl # unless there is an immediate termination i.e. <%#%> scan for the next %> that is not # preceded by a % (i.e. skip %%>)
if part on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl s on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end # Trim leading whitespace on the same line when start was <%#-
on_ignored_nl UNK on_ignored_nl s on_period UNK on_lparen on_op on_int on_op on_op on_int on_rparen on_nl on_ivar on_op on_symbeg UNK on_nl return # Continue scanning for more text
s on_period UNK on_lparen on_op on_int on_op on_op on_int on_rparen on_nl on_ivar on_op on_symbeg UNK on_nl return s on_nl end # Switch to pp after having removed the <%
