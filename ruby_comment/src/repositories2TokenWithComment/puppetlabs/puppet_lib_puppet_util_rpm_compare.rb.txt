UNK UNK on_lparen str1 on_comma str2 on_rparen on_ignored_nl return on_int if str1 on_op str2 on_nl on_ignored_nl UNK on_op on_regexp_beg on_tstring_content # This is an attempt at implementing RPM's # lib/rpmvercmp.c rpmvercmp(a, b) in Ruby. # # Some of the things in here look REALLY # UGLY and/or arbitrary. Our goal is to # match how RPM compares versions, quirks # and all. # # I've kept a lot of C-like string processing # in an effort to keep this as identical to RPM # as possible. # # returns 1 if str1 is newer than str2, # 0 if they are identical # -1 if str1 is older than str2
str1 on_op str1 on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_end on_rparen on_nl str2 on_op str2 on_period UNK on_lparen UNK on_comma # trim anything that's in front_strip_re and != '~' off the beginning of each string
if str1 on_op on_regexp_beg on_tstring_content on_regexp_end on_op str2 on_op on_regexp_beg on_tstring_content on_regexp_end on_nl str1 on_op str1 on_lbracket on_int on_op on_op # "handle the tilde separator, it sorts before everything else"
str1 on_op str1 on_lbracket on_int on_op on_op on_int on_rbracket on_nl str2 on_op str2 on_lbracket on_int on_op on_op on_int on_rbracket on_nl # if they both have ~, strip it
UNK on_op UNK on_nl if str1 on_op on_regexp_beg on_tstring_content on_regexp_end on_nl if str1 on_op on_regexp_beg on_tstring_content on_regexp_end on_nl segment1 on_op # "grab first completely alpha or completely numeric segment"
if str1 on_op on_regexp_beg on_tstring_content on_regexp_end on_nl if str1 on_op on_regexp_beg on_tstring_content on_regexp_end on_nl segment1 on_op on_gvar on_period UNK on_nl # if the first char of str1 is a digit, grab the chunk of continuous digits from each string
else on_ignored_nl if str1 on_op on_regexp_beg on_tstring_content on_regexp_end on_nl segment1 on_op on_gvar on_period UNK on_nl str1 on_op on_gvar on_period UNK # else grab the chunk of continuous alphas from each string (which may be '')
if segment2 on_period length on_op on_int on_nl return on_int if UNK on_nl return on_op on_int on_nl end on_nl on_ignored_nl if # if the segments we just grabbed from the strings are different types (i.e. one numeric one alpha), # where alpha also includes ''; "numeric segments are always newer than alpha segments"
segment1 on_op segment1 on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end on_rparen on_nl segment2 on_op segment2 on_period UNK on_lparen # "throw away any leading zeros - it's a number, right?"
return on_int if segment1 on_period length on_op segment2 on_period length on_nl return on_op on_int if segment1 on_period length on_op segment2 # "whichever number has more digits wins"
rc on_op segment1 on_op segment2 on_nl return rc if rc on_op on_int on_nl end on_ignored_nl return on_int if str1 on_period # "strcmp will return which one is greater - even if the two segments are alpha # or if they are numeric. don't return if they are equal because there might # be more segments to compare"
on_ignored_nl return on_int if str1 on_period length on_op str2 on_period length on_nl return on_op on_int if str1 on_period length on_op #end while loop
return on_int if str1 on_period length on_op str2 on_period length on_nl return on_op on_int if str1 on_period length on_op str2 # if we haven't returned anything yet, "whichever version still has characters left over wins"
UNK UNK on_lparen full_version on_rparen on_ignored_nl UNK on_op full_version on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if UNK on_nl # parse a rpm "version" specification # this re-implements rpm's # rpmUtils.miscutils.stringToVersion() in ruby
epoch on_op UNK on_nl end on_nl UNK on_op full_version on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if UNK on_nl # If there are non-digits in the epoch field, default to nil
UNK UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl return on_int if UNK on_period nil? on_op UNK on_period nil? on_nl return # this method is a native implementation of the # compare_values function in rpm's python bindings, # found in python/header-py.c, as used by rpm.
UNK UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl should_hash on_op UNK on_lparen UNK on_rparen on_nl UNK on_op UNK on_lparen UNK # how rpm compares two package versions: # rpmUtils.miscutils.compareEVR(), which massages data types and then calls # rpm.labelCompare(), found in rpm.git/python/header-py.c, which # sets epoch to 0 if null, then compares epoch, then ver, then rel # using compare_values() and returns the first non-0 result, else 0. # This function combines the logic of compareEVR() and labelCompare(). # # "version_should" can be v, v-r, or e:v-r. # "version_is" will always be at least v-r, can be e:v-r # # return 1: a is newer than b # 0: a and b are the same version # -1: b is newer than a
should_hash on_op UNK on_lparen UNK on_rparen on_nl UNK on_op UNK on_lparen UNK on_rparen on_nl on_ignored_nl if on_op should_hash on_lbracket on_symbeg # pass on to rpm labelCompare
return on_int if should_hash on_lbracket on_symbeg release on_rbracket on_period nil? on_nl on_ignored_nl rc on_op UNK on_lparen should_hash on_lbracket on_symbeg release # here is our special case, PUP-1244. # if should_hash[:release] is nil (not specified by the user), # and comparisons up to here are equal, return equal. We need to # evaluate to whatever level of detail the user specified, so we # don't end up upgrading or *downgrading* when not intended. # # This should NOT be triggered if we're trying to ensure latest.
