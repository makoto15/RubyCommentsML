UNK on_const on_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg config on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg # This represents a machine that Vagrant manages. This provides a singular # API for querying the state and making state changes to the machine, which # is backed by any sort of provider (VirtualBox, VMware, etc.).
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg config on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The box that is backing this machine. # # @return [Box]
UNK on_symbeg config on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg id on_nl on_ignored_nl # Configuration for the machine. # # @return [Object]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg id on_nl on_ignored_nl attr_reader on_symbeg name on_nl on_ignored_nl # Directory where machine-specific data can be stored. # # @return [Pathname]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg id on_nl on_ignored_nl attr_reader on_symbeg name on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The environment that this machine is a part of. # # @return [Environment]
attr_reader on_symbeg id on_nl on_ignored_nl attr_reader on_symbeg name on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl # ID of the machine. This ID comes from the provider and is not # guaranteed to be of any particular format except that it is # a string. # # @return [String]
attr_reader on_symbeg name on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # Name of the machine. This is assigned by the Vagrantfile. # # @return [Symbol]
attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The provider backing this machine. # # @return [Object]
UNK on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The provider-specific configuration for this machine. # # @return [Object]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg ui on_nl on_ignored_nl # The name of the provider. # # @return [Symbol]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg ui on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The options given to the provider when registering the plugin. # # @return [Hash]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg ui on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen name on_comma # The triggers with machine specific configuration applied # # @return [Vagrant::Plugin::V2::Trigger]
attr_reader on_symbeg ui on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen name on_comma UNK on_comma UNK on_comma UNK # The UI for outputting in the scope of this machine. # # @return [UI]
attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen name on_comma UNK on_comma UNK on_comma UNK on_comma UNK on_comma config on_comma # The Vagrantfile that this machine is attached to. # # @return [Vagrantfile]
def UNK on_lparen name on_comma UNK on_comma UNK on_comma UNK on_comma UNK on_comma config on_comma UNK on_comma UNK on_comma UNK # Initialize a new machine. # # @param [String] name Name of the virtual machine. # @param [Class] provider The provider backing this machine. This is # currently expected to be a V1 `provider` plugin. # @param [Object] provider_config The provider-specific configuration for # this machine. # @param [Hash] provider_options The provider-specific options from the # plugin definition. # @param [Object] config The configuration for this machine. # @param [Pathname] data_dir The directory where machine-specific data # can be stored. This directory is ensured to exist. # @param [Box] box The box that is backing this virtual machine. # @param [Environment] env The environment that this machine is a # part of.
on_ivar on_op nil on_nl on_ignored_nl if UNK on_nl on_ivar on_op name on_nl on_ignored_nl on_ivar on_period ssh on_period UNK on_op UNK # Read the ID, which is usually in local storage
if UNK on_nl on_ivar on_op name on_nl on_ignored_nl on_ivar on_period ssh on_period UNK on_op UNK on_nl UNK on_ignored_nl UNK on_nl # XXX: This is temporary. This will be removed very soon.
on_ivar on_period ssh on_period UNK on_op UNK on_nl UNK on_ignored_nl UNK on_nl end on_nl on_ignored_nl on_ivar on_op nil on_nl on_ivar # For base setups, we don't want to insert the key
on_ivar on_op nil on_nl on_ivar on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen if on_ivar on_nl on_ignored_nl on_ivar on_op # Keep track of where our UUID should be placed
on_ivar on_op UNK on_period new on_lparen self on_rparen on_nl on_ivar on_period UNK on_lparen on_ivar on_comma self on_rparen on_nl on_ignored_nl if # Initializes the provider last so that it has access to all the # state we setup on this machine.
if on_ivar on_period UNK on_period UNK on_op on_symbeg UNK on_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK # If we're using WinRM, we eager load the plugin because of # GH-3390
if UNK on_period id on_op on_const on_op on_const on_nl self on_period id on_op nil on_nl end on_nl on_ignored_nl on_ivar on_period # If the ID is the special not created ID, then set our ID to # nil so that we destroy all our data.
on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Output a bunch of information about this machine in # machine-readable format in case someone is listening.
def UNK on_lparen name on_comma UNK on_op nil on_rparen on_ignored_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_content # This calls an action on the provider. The provider may or may not # actually implement the action. # # @param [Symbol] name Name of the action to run. # @param [Hash] extra_env This data will be passed into the action runner # as extra data set on the environment hash for the middleware # runner.
lock on_op UNK on_nl lock on_op UNK on_period UNK on_lparen on_symbeg lock on_rparen if UNK on_period UNK on_lparen on_symbeg lock # Determine whether we lock or not
UNK on_op UNK on_period UNK on_nl UNK on_lbracket on_symbeg UNK on_rbracket on_op on_ivar on_nl on_ignored_nl UNK on_ignored_nl UNK on_op nil # Extra env keys are the remaining opts
UNK on_lbracket on_symbeg UNK on_rbracket on_op on_ivar on_nl on_ignored_nl UNK on_ignored_nl UNK on_op nil on_nl UNK on_op on_ivar on_period UNK # An environment is required for triggers to function properly. This is # passed in specifically for the `#Action::Warden` class triggers. We call it # `:trigger_env` instead of `env` in case it collides with an existing environment
on_ignored_nl UNK on_op nil on_nl UNK on_op on_ivar on_period UNK on_lbracket UNK on_rbracket if on_ivar on_period UNK on_nl id on_op # Warns the UI if the machine was last used on a different dir
UNK on_op nil on_nl UNK on_op on_ivar on_period UNK on_lbracket UNK on_rbracket if on_ivar on_period UNK on_nl id on_op on_const # Create a deterministic ID for this machine
UNK on_op on_const on_period new UNK on_op on_op UNK on_comma on_op UNK on_op UNK on_period UNK UNK on_nl UNK on_op # We only lock if we're not executing an SSH action. In the future # we will want to do more fine-grained unlocking in actions themselves # but for a 1.6.2 release this will work.
UNK on_op UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg id on_embexpr_end on_tstring_end on_rparen do on_ignored_nl UNK on_op on_ivar on_period UNK # Lock this machine for the duration of this action
UNK on_op on_ivar on_period UNK on_lparen name on_rparen on_nl on_ignored_nl if UNK on_period UNK on_nl UNK on_const on_op on_const on_comma # Get the callable from the provider.
if UNK on_period UNK on_nl UNK on_const on_op on_const on_comma on_ignored_nl on_label name on_comma on_ignored_nl on_label on_ivar on_period to_s on_nl # If this action doesn't exist on the provider, then an exception # must be raised.
ui on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma name on_period to_s on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op UNK # Call the action
return UNK on_nl UNK on_const on_op on_const on_nl UNK on_const on_op on_const on_comma on_ignored_nl on_label name on_comma on_ignored_nl on_label on_ivar # preserve returning environment after machine action runs
def UNK on_lparen name on_comma UNK on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_op UNK on_ignored_nl on_label name on_comma on_ignored_nl # This calls a raw callable in the proper context of the machine using # the middleware stack. # # @param [Symbol] name Name of the action # @param [Proc] callable # @param [Hash] extra_env Extra env for the action env. # @return [Hash] The resulting env
UNK on_op UNK on_ignored_nl on_label name on_comma on_ignored_nl on_label on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end on_period UNK on_comma on_ignored_nl on_label # Run the action with the action runner on the environment
def UNK on_nl if on_op on_ivar on_nl UNK on_op on_ivar on_period UNK on_period UNK on_nl UNK on_op on_symbeg ssh on_nl # Returns a communication object for executing commands on the remote # machine. Note that the _exact_ semantics of this are up to the # communication provider itself. Despite this, the semantics are expected # to be consistent across operating systems. For example, all linux-based # systems should have similar communication (usually a shell). All # Windows systems should have similar communication as well. Therefore, # prior to communicating with the machine, users of this method are # expected to check the guest OS to determine their behavior. # # This method will _always_ return some valid communication object. # The `ready?` API can be used on the object to check if communication # is actually ready. # # @return [Object]
def UNK on_nl UNK on_const on_op on_const if on_op UNK on_period UNK on_nl on_ivar on_period UNK if on_op on_ivar on_period # Returns a guest implementation for this machine. The guest implementation # knows how to do guest-OS specific tasks, such as configuring networks, # mounting folders, etc. # # @return [Guest]
def UNK on_lparen value on_rparen on_ignored_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg value on_period UNK on_embexpr_end on_tstring_end on_rparen on_nl # This sets the unique ID associated with this machine. This will # persist this ID so that in the future Vagrant will be able to find # this machine again. The unique ID must be absolutely unique to the # virtual machine, and can be used by providers for finding the # actual machine associated with this instance. # # **WARNING:** Only providers should ever use this method. # # @param [String] value The ID.
id_file on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl if value on_nl if id_file on_nl # The file that will store the id if we have one. This allows the # ID to persist across Vagrant runs. Also, store the UUID for the # machine index.
id_file on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op f on_op on_ignored_nl f on_period UNK on_lparen value on_rparen on_nl # Write the "id" file with the id given.
uid_file on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op f on_op on_ignored_nl f on_period UNK on_lparen on_const on_period UNK # Write the user id that created this machine
if UNK on_period UNK on_nl entry on_op on_const on_op on_const on_period new on_nl entry on_period UNK on_op on_ivar on_period UNK # If we don't have a UUID, then create one
entry on_op on_const on_op on_const on_period new on_nl entry on_period UNK on_op on_ivar on_period UNK on_nl entry on_period name on_op # Create the index entry and save it
if on_ivar on_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op f on_op on_ignored_nl f on_period UNK on_lparen # Store our UUID so we can access it later
id_file on_period UNK if id_file on_op id_file on_period file? on_nl uid_file on_period UNK if uid_file on_op uid_file on_period file? on_nl # Delete the file, since the machine is now destroyed
uuid on_op UNK on_nl if uuid on_nl entry on_op on_ivar on_period machine_index on_period UNK on_lparen uuid on_rparen on_nl on_ivar on_period # If we have a UUID associated with the index, remove it
on_ivar on_period UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_ignored_nl UNK on_period UNK on_nl UNK on_const on_op on_const # Delete the entire data directory contents since all state # associated with the VM is now gone.
on_ivar on_op value on_period UNK on_op nil on_op value on_period to_s on_nl on_ignored_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl # Store the ID locally
on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl return nil if on_op on_ivar on_nl return on_ivar on_period UNK # Notify the provider that the ID changed in case it needs to do # any accounting from it.
def UNK on_nl return nil if on_op on_ivar on_nl return on_ivar on_period UNK on_period UNK if on_ivar on_period file? on_nl # Returns the UUID associated with this machine in the machine # index. We only have a UUID if an ID has been set. # # @return [String] UUID or nil if we don't have one yet.
def UNK on_nl on_tstring_beg on_tstring_content on_embexpr_beg self on_period UNK on_embexpr_end on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_embexpr_beg on_ivar on_period UNK on_embexpr_end # This returns a clean inspect value so that printing the value via # a pretty print (`p`) results in a readable value. # # @return [String]
def UNK on_nl UNK on_op on_ivar on_nl on_ivar on_op nil on_nl on_ignored_nl if on_ivar on_nl id_file on_op on_ivar on_period join # This reloads the ID of the underlying machine.
id_file on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op id_file on_period UNK on_period UNK if id_file # Read the id file from the data directory if it exists as the # ID for the pre-existing physical representation of this machine.
on_ivar on_period UNK on_nl end on_nl on_ignored_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl info on_op on_ivar on_period UNK # It changed, notify the provider
def UNK on_nl info on_op on_ivar on_period UNK on_nl return nil if info on_period UNK on_nl on_ignored_nl info on_period UNK # This returns the SSH info for accessing this machine. This SSH info # is queried from the underlying provider. This method returns `nil` if # the machine is not ready for SSH communication. # # The structure of the resulting hash is guaranteed to contain the # following structure, although it may return other keys as well # not documented here: # # { # host: "1.2.3.4", # port: "22", # username: "mitchellh", # private_key_path: "/path/to/my/key" # } # # Note that Vagrant makes no guarantee that this info works or is # correct. This is simply the data that the provider gives us or that # is configured via a Vagrantfile. It is still possible after this # point when attempting to connect via SSH to get authentication # errors. # # @return [Hash] SSH information.
info on_op on_ivar on_period UNK on_nl return nil if info on_period UNK on_nl on_ignored_nl info on_period UNK on_period UNK do # First, ask the provider for their information. If the provider # returns nil, then the machine is simply not ready for SSH, and # we return nil as well.
info on_period UNK on_period UNK do on_op UNK on_comma value on_op on_ignored_nl info on_period UNK on_lparen UNK on_rparen if value # Delete out the nil entries.
info on_lbracket on_symbeg UNK on_rbracket on_op on_ivar on_period ssh on_period default on_period UNK on_nl info on_lbracket on_symbeg UNK on_rbracket on_op # We set the defaults
info on_lbracket on_symbeg UNK on_rbracket on_op on_ivar on_period ssh on_period UNK if on_ivar on_period ssh on_period UNK on_nl info on_lbracket # We set overrides if they are set. These take precedence over # provider-returned data.
info on_lbracket on_symbeg UNK on_rbracket on_op on_ivar on_period ssh on_period UNK on_nl info on_lbracket on_symbeg UNK on_rbracket on_op on_ivar on_period # We also set some fields that are purely controlled by Vagrant
info on_lbracket on_symbeg UNK on_rbracket on_op on_ivar on_period ssh on_period UNK if on_ivar on_period ssh on_period UNK on_nl on_ignored_nl if # Add in provided proxy command config
if on_op info on_lbracket on_symbeg private_key_path on_rbracket on_op on_op info on_lbracket on_symbeg UNK on_rbracket on_nl if on_ivar on_period ssh on_period # Set the private key path. If a specific private key is given in # the Vagrantfile we set that. Otherwise, we use the default (insecure) # private key, but only if the provider didn't give us one.
if on_ivar on_op on_op on_ivar on_period ssh on_period private_key_path on_nl UNK on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # If we have a private key in our data dir, then use that
info on_lbracket on_symbeg private_key_path on_rbracket on_op on_lbracket on_rbracket on_nl info on_lbracket on_symbeg private_key_path on_rbracket on_op on_const on_lparen info on_lbracket on_symbeg # Setup the keys
info on_lbracket on_symbeg private_key_path on_rbracket on_period UNK do on_op path on_op on_ignored_nl on_const on_period UNK on_lparen path on_comma on_ivar on_period # Expand the private key path relative to the root path
info on_lbracket on_symbeg private_key_path on_rbracket on_period UNK do on_op path on_op on_ignored_nl UNK on_op on_const on_period new on_lparen path on_rparen # Check that the private key permissions are valid
info on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_ivar on_period UNK on_nl UNK on_const on_op on_const if on_op # Return the final compiled SSH info data
def UNK on_nl UNK on_op on_ivar on_period UNK on_nl UNK on_const on_op on_const if on_op UNK on_period UNK on_lparen on_const # Returns the state of this machine. The state is queried from the # backing provider, so it can be any arbitrary symbol. # # @return [MachineState]
uuid on_op UNK on_nl if uuid on_nl on_ivar on_period UNK do on_ignored_nl entry on_op on_ivar on_period machine_index on_period UNK on_lparen # Update our state cache if we have a UUID and an entry in the # master index.
on_ivar on_period UNK do on_ignored_nl entry on_op on_ivar on_period machine_index on_period UNK on_lparen uuid on_rparen on_nl if entry on_nl entry # active_machines provides access to query this info on each machine # from a different thread, ensure multiple machines do not access # the locked entry simultaneously as this triggers a locked machine # exception.
def UNK on_nl path on_op uid_file on_nl return nil if on_op path on_nl return nil if on_op path on_period file? # Returns the user ID that created this machine. This is specific to # the host machine that this was created on. # # @return [String]
def UNK on_lparen ui on_rparen on_ignored_nl on_ivar on_period UNK do on_ignored_nl UNK on_ignored_nl UNK on_op on_ivar on_nl on_ivar on_op ui # Temporarily changes the machine UI. This is useful if you want # to execute an {#action} with a different UI.
def uid_file on_nl return nil if on_op on_ivar on_nl on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl # Returns the path to the file that stores the UID.
def UNK on_nl UNK on_op on_ivar on_period root_path on_period to_s on_period UNK on_nl UNK on_op on_ivar on_period join on_lparen on_tstring_beg # Checks the current directory for a given machine # and displays a warning if that machine has moved # from its previous location on disk. If the machine # has moved, it prints a warning to the user.
