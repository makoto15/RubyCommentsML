UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl UNK UNK on_lparen argv on_comma UNK on_rparen on_ignored_nl on_ivar on_op argv # This is the base class for a CLI command.
UNK UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl UNK UNK on_lparen opts on_op nil on_rparen on_ignored_nl argv on_op on_ivar # This is what is called on the class to actually execute it. Any # subclasses should implement this method and do any option parsing # and validation here.
UNK UNK on_lparen opts on_op nil on_rparen on_ignored_nl argv on_op on_ivar on_period UNK on_nl on_ignored_nl opts on_op on_const on_period UNK # Parses the options given an OptionParser instance. # # This is a convenience method that properly handles duping the # originally argv array so that it is not destroyed. # # This method will also automatically detect "-h" and "--help" # and print help. And if any invalid options are detected, the help # will be printed, as well. # # If this method returns `nil`, then you should assume that help # was printed and parsing failed.
argv on_op on_ivar on_period UNK on_nl on_ignored_nl opts on_op on_const on_period UNK on_nl on_ignored_nl opts on_period UNK on_lparen on_tstring_beg on_tstring_content # Creating a shallow copy of the arguments so the OptionParser # doesn't destroy the originals.
opts on_op on_const on_period UNK on_nl on_ignored_nl opts on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Default opts to a blank optionparser if none is given
opts on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK on_ignored_nl UNK on_lparen # Add the help option, which must be on every command.
UNK UNK on_lparen names on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_const on_op on_const if on_op on_ivar on_period # Yields a VM for each target VM for the command. # # This is a convenience method for easily implementing methods that # take a target VM (in the case of multi-VM) or every VM if no # specific VM name is specified. # # @param [String] name The name of the VM. Nil if every VM. # @param [Boolean] single_target If true, then an exception will be # raised if more than one target is found.
UNK on_const on_op on_const if on_op on_ivar on_period UNK on_nl on_ignored_nl UNK on_op UNK UNK on_nl on_ignored_nl names on_op on_lbracket # Using VMs requires a Vagrant environment to be properly setup
UNK on_op UNK UNK on_nl on_ignored_nl names on_op on_lbracket on_rbracket on_nl names on_op on_lbracket names on_rbracket if on_op names on_period # Setup the options hash
names on_op on_lbracket on_rbracket on_nl names on_op on_lbracket names on_rbracket if on_op names on_period UNK on_lparen on_const on_rparen on_nl on_ignored_nl # Require that names be an array
vms on_op on_lbracket on_rbracket on_nl if names on_period UNK on_op on_int on_nl names on_period UNK UNK on_op name on_op on_ignored_nl # First determine the proper array of VMs.
UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl on_ivar on_period vms on_period UNK UNK on_op name on_comma vm # This is a regular expression name, so we convert to a regular # expression and allow that sort of matching.
vms on_op on_ivar on_period vms on_lbracket name on_period UNK on_rbracket on_nl UNK on_const on_op on_const on_comma UNK name if on_op # String name, just look for a specific VM
if UNK on_lbracket UNK UNK on_rbracket on_op vms on_period UNK on_op on_int on_nl vm on_op on_ivar on_period UNK on_nl UNK # Make sure we're only working with one VM if single target
vms on_period UNK if UNK on_lbracket UNK UNK on_rbracket on_nl on_ignored_nl vms on_period UNK UNK on_op UNK on_op on_ignored_nl vm # If we asked for reversed ordering, then reverse it
vms on_period UNK UNK on_op UNK on_op on_ignored_nl vm on_op on_ivar on_period vms on_lbracket UNK on_period name on_rbracket on_nl UNK # Go through each VM and yield it!
vm on_op on_ivar on_period vms on_lbracket UNK on_period name on_rbracket on_nl UNK vm on_nl end on_nl end on_nl on_ignored_nl UNK # We get a new VM from the environment here to avoid potentially # stale VMs (if there was a config reload on the environment # or something).
UNK UNK on_lparen argv on_rparen on_ignored_nl UNK on_op nil on_nl UNK on_op nil on_nl UNK on_op on_lbracket on_rbracket on_nl on_ignored_nl # This method will split the argv given into three parts: the # flags to this command, the subcommand, and the flags to the # subcommand. For example: # # -v status -h -v # # The above would yield 3 parts: # # ["-v"] # "status" # ["-h", "-v"] # # These parts are useful because the first is a list of arguments # given to the current command, the second is a subcommand, and the # third are the commands given to the subcommand. # # @return [Array] The three parts.
UNK on_op nil on_nl UNK on_op nil on_nl UNK on_op on_lbracket on_rbracket on_nl on_ignored_nl argv on_period UNK UNK on_op i # Initialize return variables
argv on_period UNK UNK on_op i on_op on_ignored_nl if on_op argv on_lbracket i on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # We split the arguments into two: One set containing any # flags before a word, and then the rest. The rest are what # get actually sent on to the subcommand.
UNK on_op argv on_lbracket on_int on_comma i on_rbracket on_nl UNK on_op argv on_lbracket i on_rbracket on_nl UNK on_op argv on_lbracket # We found the beginning of the sub command. Split the # args up.
UNK on_nl end on_nl end on_nl on_ignored_nl UNK on_op argv on_period UNK if UNK on_period UNK on_nl on_ignored_nl UNK on_lbracket # Break so we don't find the next non flag and shift our # main args.
UNK on_op argv on_period UNK if UNK on_period UNK on_nl on_ignored_nl UNK on_lbracket UNK on_comma UNK on_comma UNK on_rbracket on_nl # Handle the case that argv was empty or didn't contain any subcommand
