UNK on_const on_nl UNK on_op UNK on_nl on_ignored_nl def logger on_nl if on_op defined? on_lparen on_ivar on_rparen on_nl on_ivar on_op # This class just contains some platform checking code.
if on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma # Find 'microsoft' in /proc/version indicative of WSL
def UNK on_nl return on_ivar if defined? on_lparen on_ivar on_rparen on_nl on_ignored_nl on_ivar on_op UNK UNK on_ignored_nl ps_cmd on_op on_tstring_beg # Checks if the user running Vagrant on Windows has administrative # privileges. # # From: https://support.microsoft.com/en-us/kb/243330 # SID: S-1-5-19 # # @return [Boolean]
def UNK on_nl return on_ivar if defined? on_lparen on_ivar on_rparen on_nl on_ignored_nl if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl # Checks if Hyper-V is accessible to the local user. It will check # if user is in the "Hyper-V Administrators" group, is a Domain # administrator, and finally will run a manual interaction with # Hyper-V to determine if Hyper-V is usable for the current user. # # From: https://support.microsoft.com/en-us/kb/243330 # SID: S-1-5-32-578 # Name: BUILTIN\Hyper-V Administrators # SID: S-1-5-21DOMAIN-512 # Name: Domain Admins # # @return [Boolean]
def UNK on_nl return on_ivar if defined? on_lparen on_ivar on_rparen on_nl on_ignored_nl on_ivar on_op UNK UNK on_ignored_nl on_lbracket on_tstring_beg on_tstring_content # Checks if Hyper-V is enabled on the host system and returns true # if enabled. # # @return [Boolean]
def UNK on_lparen path on_rparen on_ignored_nl begin on_ignored_nl UNK on_op on_const on_op on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content # This takes any path and converts it from a Windows path to a # Cygwin style path. # # @param [String] path # @return [String]
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl else on_ignored_nl UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # If Which can't find it, just attempt to invoke it directly
process on_op on_const on_period execute on_lparen on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end # Sometimes cygpath isn't available (msys). Instead, do what we # can with bash tricks.
def UNK on_lparen path on_rparen on_ignored_nl begin on_ignored_nl UNK on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_const on_lbracket on_tstring_beg # This takes any path and converts it from a Windows path to a # msys style path. # # @param [String] path # @return [String]
UNK on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_const on_lbracket on_tstring_beg on_tstring_content # We have to revert to the old env # path here, otherwise it looks like # msys2 ends up using the wrong cygpath # binary and ends up with a `/cygdrive` # when it doesn't exist in msys2
def UNK on_lparen path on_rparen on_ignored_nl return path if on_op UNK on_nl on_ignored_nl path on_op UNK on_lparen path on_rparen on_nl # This takes any path and converts it to a full-length Windows # path on Windows machines in Cygwin. # # @return [String]
path on_op UNK on_lparen path on_rparen on_nl on_ignored_nl process on_op on_const on_period execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content # Replace all "\" with "/", otherwise cygpath doesn't work.
process on_op on_const on_period execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content # Call out to cygpath and gather the result
def UNK on_lparen path on_rparen on_ignored_nl path on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end # This takes any path and converts Windows-style path separators # to Unix-like path separators. # @return [String]
def UNK on_nl return on_ivar if defined? on_lparen on_ivar on_rparen on_nl on_ivar on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # This checks if the filesystem is case sensitive. This is not a # 100% correct check, since it is possible that the temporary # directory runs a different filesystem than the root directory. # However, this works in many cases.
on_op on_const on_period UNK on_lparen on_const on_period join on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl end on_nl return # The filesystem is case sensitive if the lowercased version # of the filename is NOT reported as existing.
def UNK on_lparen path on_comma on_op UNK on_rparen on_ignored_nl path on_op on_const on_period new on_lparen on_const on_period UNK on_lparen path # This expands the path and ensures proper casing of each part # of the path.
if windows? on_op path on_period to_s on_op UNK on_tstring_content UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl path on_op on_const on_period # If the path contains a Windows short path, then we attempt to # expand. The require below is embedded here since it requires # windows to work.
UNK on_op on_lbracket on_rbracket on_nl UNK on_op path on_period UNK on_nl UNK on_period UNK on_lparen path on_period UNK on_period to_s # Build up all the parts of the path
UNK on_period each do on_op UNK on_op on_ignored_nl on_const on_period UNK on_lparen path on_rparen on_period each do on_op UNK on_op # Traverse each part and join it into the resulting path
end on_nl if UNK on_period downcase on_op UNK on_period downcase on_nl path on_op path on_period join on_lparen UNK on_rparen on_nl # NOTE: Depending on the Windows environment the above # encode will generate an "input string invalid" when # attempting to encode. If that happens, continue on
path on_op path on_period to_s on_nl if path on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl path on_lbracket on_int on_rbracket # Fix the drive letter to be uppercase.
def UNK on_lparen path on_rparen on_ignored_nl path on_op path on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Converts a given path to UNC format by adding a prefix and converting slashes. # @param [String] path Path to convert to UNC for Windows # @return [String]
if path on_op UNK on_tstring_content UNK on_nl path on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK path on_period start_with? on_lparen on_tstring_beg on_tstring_content # Convert to UNC path
path on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK path on_period start_with? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl path on_nl else on_ignored_nl # If the path is just a drive letter, then return that as-is
path on_nl else on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op path on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # If the path already starts with `\\` assume UNC and return as-is
def UNK on_nl return on_ivar if defined? on_lparen on_ivar on_rparen on_nl on_ivar on_op UNK UNK on_ignored_nl if windows? on_nl return # Returns a boolean noting whether the terminal supports color. # output.
def UNK on_lparen path on_rparen on_ignored_nl wsl? on_op on_op path on_period to_s on_period downcase on_period start_with? on_lparen on_tstring_beg on_tstring_content on_tstring_end # Determine if given path is within the WSL rootfs. Returns # true if within the subsystem, or false if outside the subsystem. # # @param [String] path Path to check # @return [Boolean] path is within subsystem
def UNK on_nl return on_ivar if defined? on_lparen on_ivar on_rparen on_nl on_ignored_nl if wsl? on_nl UNK on_op on_const on_period new # Compute the path to rootfs of currently active WSL. # # @return [String] A path to rootfs of a current WSL instance.
UNK on_op on_const on_period new on_lparen on_const on_period UNK on_period UNK on_period to_s on_rparen on_nl logger on_op on_const on_op on_const # Mark our filesystem with a temporary file having an unique name.
UNK on_op on_lbracket UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op on_lbracket # Check for lxrun installation first
UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg path on_lbracket on_int on_comma on_int on_rbracket on_period downcase on_embexpr_end on_embexpr_beg path on_lbracket on_int on_op on_op # Lowercase the drive letter, skip the next symbol (which is a # colon from a Windows path) and convert path to UNIX style.
end on_nl on_ignored_nl logger on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg path on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl begin on_ignored_nl on_const on_period # pass
on_const on_period UNK on_lparen UNK on_rparen do on_op UNK on_op on_ignored_nl if on_const on_period UNK on_lparen on_tstring_beg on_embexpr_beg UNK on_period # https://blogs.msdn.microsoft.com/wsl/2016/06/15/wsl-file-system-support # Current WSL instance doesn't have an access to its mount from # within itself despite all others are available. That's the # hacky way we're using to determine current instance. # For example we have three WSL instances: # A -> C:\User\USER\AppData\Local\Packages\A\LocalState\rootfs # B -> C:\User\USER\AppData\Local\Packages\B\LocalState\rootfs # C -> C:\User\USER\AppData\Local\Packages\C\LocalState\rootfs # If we're in "A" WSL at the moment, then its path will not be # accessible since it's mounted for exactly the instance we're # in. All others can be opened.
if on_const on_period UNK on_lparen on_tstring_beg on_embexpr_beg UNK on_period path on_embexpr_end on_tstring_content on_embexpr_beg UNK on_period path on_embexpr_end on_tstring_end on_rparen on_nl # A fallback for a case if our trick will stop working. For # that we've created a temporary file with an unique name in # a current WSL and now seeking it among all WSL.
UNK on_nl rescue on_const on_op on_const on_nl logger on_period warn on_lparen on_tstring_beg on_tstring_content on_embexpr_beg path on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl # You can create and simultaneously run multiple WSL instances, # comment out the "break", run this script within each one and # it'll return only single value.
logger on_period warn on_lparen on_tstring_beg on_tstring_content on_embexpr_beg path on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl on_ignored_nl UNK on_period # Warn about data discrepancy between Winreg and file system # states. For the sake of justice, it's worth mentioning that # it is possible only when someone will manually break WSL by # removing a directory of its base path (kinda "stupid WSL # uninstallation by removing hidden and system directory").
end on_nl on_ignored_nl UNK on_period UNK on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const if on_ivar on_period UNK on_nl end # All other exceptions have to be raised since they will mean # something unpredictably terrible.
if on_ivar on_op UNK on_nl on_ivar on_op on_tstring_beg on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl logger on_period UNK # Attach the rootfs leaf to the path
def UNK on_lparen path on_rparen on_ignored_nl path on_op path on_period to_s on_nl if wsl? on_op UNK on_op on_op path on_period # Convert a WSL path to the local Windows path. This is useful # for conversion when calling out to Windows executables from # the WSL # # @param [String, Pathname] path Path to convert # @return [String]
end on_nl if UNK on_lparen path on_rparen on_nl parts on_op path on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl parts # pass
if UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_op on_lparen on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # lxrun splits home separate so we need to account # for it's specialness here when we build the path
def UNK on_lparen path on_comma on_op UNK on_rparen on_ignored_nl path on_op UNK on_lparen path on_rparen if UNK on_nl path on_op # Takes a windows path and formats it to the # 'unix' style (i.e. `/cygdrive/c` or `/c/`) # # @param [Pathname, String] path Path to convert # @param [Hash] hash of arguments # @return [String]
def UNK on_lparen path on_rparen on_ignored_nl path on_op UNK on_lparen path on_rparen on_nl path on_op UNK on_lparen path on_rparen on_nl # Automatically convert a given path to a Windows path. Will only # be applied if running on a Windows host. If running on Windows # host within the WSL, the actual Windows path will be returned. # # @param [Pathname, String] path Path to convert # @return [String]
def UNK on_nl if on_op defined? on_lparen on_ivar on_rparen on_nl on_ivar on_op wsl? on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket # Allow Vagrant to access Vagrant managed machines outside the # Windows Subsystem for Linux # # @return [Boolean]
def UNK on_nl if on_op defined? on_lparen on_ivar on_rparen on_nl access_path on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl if # The allowed windows system path Vagrant can manage from the Windows # Subsystem for Linux # # @return [Pathname]
end on_nl end on_nl if access_path on_period to_s on_period UNK on_nl access_path on_op UNK on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end # pass
def UNK on_lparen path on_rparen on_ignored_nl wsl? on_op UNK on_op on_ignored_nl path on_period to_s on_period start_with? on_lparen UNK on_period to_s # Checks given path to determine if Vagrant is allowed to bypass checks # # @param [String] path Path to check # @return [Boolean] Vagrant is allowed to bypass checks
on_const on_op UNK on_tstring_content UNK on_period UNK on_nl on_ignored_nl def UNK on_nl if on_op defined? on_lparen on_ivar on_rparen on_nl on_ivar # Mount pattern for extracting local mount information
def UNK on_nl if on_op defined? on_lparen on_ivar on_rparen on_nl on_ivar on_op on_lbracket on_rbracket on_nl if wsl? on_nl result on_op # Get list of local mount paths that are DrvFs file systems # # @return [Array<String>]
def UNK on_lparen path on_rparen on_ignored_nl if wsl? on_nl UNK on_period each do on_op UNK on_op on_ignored_nl return true if # Check if given path is located on DrvFs file system # # @param [String, Pathname] path Path to check # @return [Boolean]
def UNK on_lparen UNK on_comma logger on_op UNK on_rparen on_ignored_nl if wsl? on_nl if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket # If running within the Windows Subsystem for Linux, this will provide # simple setup to allow sharing of the user's VAGRANT_HOME directory # within the subsystem # # @param [Environment] env # @param [Logger] logger Optional logger to display information
def UNK on_nl if on_op on_ivar on_nl result on_op on_const on_op on_const on_period execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Fetch the Windows username currently in use # # @return [String, Nil]
def UNK on_nl if on_op on_ivar on_nl result on_op on_const on_op on_const on_period execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Fetch the Windows user home directory # # @return [String, Nil]
def UNK on_nl if on_op on_ivar on_nl result on_op on_const on_op on_const on_period execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Fetch the Windows user local app data directory # # @return [String, Nil]
def UNK on_nl UNK on_op false on_nl if on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl result # Confirm Vagrant versions installed within the WSL and the Windows system # are the same. Raise error if they do not match.
def UNK on_nl if on_op defined? on_lparen on_ivar on_rparen on_nl if on_op windows? on_nl result on_op on_const on_op on_const on_op # systemd is in use
def UNK on_nl UNK on_period each on_lparen on_op UNK on_lparen on_symbeg UNK on_rparen on_rparen on_nl end on_nl end on_nl end # @private # Reset the cached values for platform. This is not considered a public # API and should only be used for testing.
