UNK on_const on_nl UNK on_symbeg stack on_nl on_ignored_nl def self on_period UNK on_lparen middleware on_comma on_op args on_comma on_op block # Action builder which provides a nice DSL for building up # a middleware sequence for Vagrant actions. This code is based # heavily off of `Rack::Builder` and `ActionDispatch::MiddlewareStack` # in Rack and Rails, respectively. # # Usage # # Building an action sequence is very easy: # # app = Vagrant::Action::Builder.new.tap do |b| # b.use MiddlewareA # b.use MiddlewareB # end # # Vagrant::Action.run(app) #
UNK on_symbeg stack on_nl on_ignored_nl def self on_period UNK on_lparen middleware on_comma on_op args on_comma on_op block on_rparen on_ignored_nl UNK # This is the stack of middlewares added. This should NOT be used # directly. # # @return [Array]
def self on_period UNK on_lparen middleware on_comma on_op args on_comma on_op block on_rparen on_ignored_nl UNK on_period UNK on_lparen middleware on_comma # This is a shortcut for a middleware sequence with only one item # in it. For a description of the arguments and the documentation, please # see {#use} instead. # # @return [Builder]
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_nl on_ignored_nl UNK on_op UNK on_period stack on_period UNK on_nl end on_nl on_ignored_nl # Implement a custom copy that copies the stack variable over so that # we don't clobber that.
def UNK on_nl UNK do on_op env on_op on_ignored_nl self on_period UNK on_lparen env on_rparen on_nl end on_nl end on_nl # Returns a mergeable version of the builder. If `use` is called with # the return value of this method, then the stack will merge, instead # of being treated as a separate single middleware.
def UNK on_lparen middleware on_comma on_op args on_comma on_op block on_rparen on_ignored_nl if middleware on_period UNK on_lparen on_const on_rparen on_nl # Adds a middleware class to the middleware stack. Any additional # args and a block, if given, are saved and passed to the initializer # of the middleware. # # @param [Class] middleware The middleware class
self on_period stack on_period UNK on_lparen middleware on_period stack on_rparen on_nl UNK on_ignored_nl self on_period stack on_op on_lbracket middleware on_comma # Merge in the other builder's stack into our own
def insert on_lparen index on_comma middleware on_comma on_op args on_comma on_op block on_rparen on_ignored_nl index on_op self on_period index on_lparen # Inserts a middleware at the given index or directly before the # given middleware object.
def UNK on_lparen index on_comma middleware on_comma on_op args on_comma on_op block on_rparen on_ignored_nl index on_op self on_period index on_lparen # Inserts a middleware after the given index or middleware object.
def UNK on_lparen index on_comma middleware on_comma on_op args on_comma on_op block on_rparen on_ignored_nl if index on_period UNK on_lparen on_const # Replaces the given middlware object or index with the new # middleware.
def UNK on_lparen index on_rparen on_ignored_nl index on_op self on_period index on_lparen index on_rparen UNK index on_period UNK on_lparen on_const # Deletes the given middleware object or index
def UNK on_lparen env on_rparen on_ignored_nl UNK on_lparen env on_rparen on_period UNK on_lparen env on_rparen on_nl end on_nl on_ignored_nl def # Runs the builder stack with the given environment.
def index on_lparen UNK on_rparen on_ignored_nl stack on_period UNK do on_op item on_comma UNK on_op on_ignored_nl UNK UNK if item # Returns the numeric index for the given middleware object. # # @param [Object] object The item to find the index for # @return [Integer]
def UNK on_lparen env on_rparen on_ignored_nl builder on_op self on_period UNK on_nl on_ignored_nl builder on_period UNK on_lparen env on_rparen on_nl # Converts the builder stack to a runnable action sequence. # # @param [Hash] env The action environment hash # @return [Warden] A callable object
builder on_op self on_period UNK on_nl on_ignored_nl builder on_period UNK on_lparen env on_rparen on_nl on_ignored_nl builder on_period UNK on_lparen env # Start with a duplicate of ourself which can # be modified
builder on_period UNK on_lparen env on_rparen on_nl on_ignored_nl builder on_period UNK on_lparen env on_rparen on_nl on_ignored_nl on_const on_period UNK on_lparen # Apply all dynamic modifications of the stack. This # will generate dynamic hooks for all actions within # the stack, load any triggers for action classes, and # apply them to the builder's stack
builder on_period UNK on_lparen env on_rparen on_nl on_ignored_nl on_const on_period UNK on_lparen builder on_period stack on_period UNK on_comma env on_rparen # Now that the stack is fully expanded, apply any # action hooks that may be defined so they are on # the outermost locations of the stack
on_const on_period UNK on_lparen builder on_period stack on_period UNK on_comma env on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen env # Wrap the middleware stack with the Warden to provide a consistent # and predictable behavior upon exceptions.
def UNK on_lparen env on_rparen on_ignored_nl if on_const on_op on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Find any action hooks or triggers which have been defined # for items within the stack. Update the stack with any # hooks or triggers found. # # @param [Hash] env Call environment # @return [Builder] self
machine_name on_op env on_lbracket on_symbeg UNK on_rbracket on_period name if env on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl stack on_period UNK # Use a Hook as a convenient interface for injecting # any applicable trigger actions within the stack
stack on_period UNK on_period UNK do on_op item on_op on_ignored_nl hook on_op on_const on_period UNK on_nl on_ignored_nl action on_op item # Iterate over all items in the stack and apply new items # into the hook as they are found. Must be sure to dup the # stack here since we are modifying the stack in the loop.
if triggers on_op on_op triggers on_period find on_lparen action on_comma on_symbeg before on_comma machine_name on_comma on_symbeg action on_rparen on_period empty? # Start with adding any action triggers that may be defined
if triggers on_op on_op triggers on_period find on_lparen action on_comma on_symbeg before on_comma machine_name on_comma on_symbeg hook on_rparen on_period empty? # Next look for any hook triggers that may be defined against # the dynamically generated action class hooks
on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_period UNK on_lparen action on_rparen on_period UNK do on_op UNK # Finally load any registered hooks for dynamically generated # action class based hooks
self on_nl end on_nl on_ignored_nl def UNK on_lparen env on_rparen on_ignored_nl UNK self if on_op env on_lbracket on_symbeg action_name on_rbracket # Apply the hook to ourself to update the stack
def UNK on_lparen env on_rparen on_ignored_nl UNK self if on_op env on_lbracket on_symbeg action_name on_rbracket on_nl hook on_op on_const on_period # If action hooks have not already been set, this method # will perform three tasks: # 1. Load any hook triggers defined for the action_name # 2. Load any action_hooks defined from plugins # 3. Load any action triggers based on machine action called (not action classes) # # @param [Hash] env Call environment # @return [Builder]
if on_const on_op on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op env on_lbracket on_symbeg triggers on_rbracket on_nl # Start with loading any hook triggers if applicable
UNK on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_period UNK on_lparen env on_lbracket on_symbeg action_name on_rbracket # Next we load up all the action hooks that plugins may # have defined
if env on_lbracket on_symbeg triggers on_rbracket on_nl if on_op env on_lbracket on_symbeg triggers on_rbracket on_period find on_lparen env on_lbracket on_symbeg # Finally load any action triggers defined. The action triggers # are the originally implemented trigger style. They run before # and after specific provider actions (like :up, :halt, etc) and # are different from true action triggers
builder on_op self on_period UNK on_period UNK on_lparen on_const on_op on_const on_op on_const on_op on_const on_comma on_ignored_nl env on_lbracket on_symbeg # NOTE: These after triggers need to be delayed before running to # allow the rest of the call stack to complete before being # run. The delayed action is prepended to the stack (not appended) # to ensure it is called first, which results in it properly # waiting for everything to finish before itself completing.
UNK self if hook on_period empty? on_nl on_ignored_nl UNK on_op UNK UNK on_nl on_ignored_nl if env on_lbracket on_symbeg UNK on_rbracket # If the hooks are empty, then there was nothing to apply and # we can just send ourself back
UNK on_op UNK UNK on_nl on_ignored_nl if env on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_lbracket on_symbeg UNK on_rbracket on_op UNK # These are the options to pass into hook application.
if env on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl end on_nl on_ignored_nl env on_lbracket # If we already ran through once and did append/prepends, # then don't do it again.
env on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl on_ignored_nl hook on_period UNK on_lparen self on_comma UNK on_rparen on_nl on_ignored_nl self # Specify that we already ran, so in the future we don't repeat # the prepend/append hooks.
hook on_period UNK on_lparen self on_comma UNK on_rparen on_nl on_ignored_nl self on_nl end on_nl end on_nl end on_nl end on_nl # Apply all the hooks to the new builder instance
