UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new # Include the built-in modules so we can use them as top-level things.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This action starts another container just like the real one running # but only for the purpose of running a single command rather than # to exist long-running.
b on_period use UNK on_nl end on_nl end on_nl on_ignored_nl def self on_period UNK on_nl on_const on_op on_const on_op on_const # We just call the "up" action. We create a separate action # to hold this though in case we modify it in the future, and # so that we can switch on the "machine_action" env var.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This action brings the "machine" up from nothing, including creating the # container, configuring metadata, and booting.
b on_period use on_const on_comma on_const on_comma on_symbeg not_created do on_op env on_comma b2 on_op on_ignored_nl if env on_lbracket on_symbeg # Yeah, this is supposed to be here twice (once more above). This # catches the case when the container was supposed to be created, # but the host state was unknown, and now we know its not actually # created.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This action just runs the provisioners on the machine.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This is the action that is primarily responsible for halting # the virtual machine, gracefully or by force.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This action is responsible for reloading the machine, which # brings it down, sucks in new configuration, and brings the # machine back up with the new configuration.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This is the action that is primarily responsible for completely # freeing the resources of the underlying virtual machine.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This is the action that will exec into an SSH shell.
def self on_period UNK on_nl on_const on_op on_const on_op on_const on_period new on_period tap do on_op b on_op on_ignored_nl b # This is the action that will run a single SSH command.
next if env on_lbracket on_symbeg result on_rbracket on_op env on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_nl on_ignored_nl b2 on_period # If the container is running and we're doing a run, we're done
b3 on_period use on_const on_nl else on_ignored_nl b3 on_period use on_const on_comma on_label UNK on_nl end on_nl end on_nl on_ignored_nl # First time making this thing, set to the "preparing" state
b2 on_period use on_const on_comma on_const on_comma on_symbeg UNK do on_op env2 on_comma b3 on_op on_ignored_nl if env2 on_lbracket on_symbeg # If the container is NOT created yet, then do some setup steps # necessary for creating it.
b2 on_period use on_const on_nl b2 on_period use on_const on_nl end on_nl end on_nl end on_nl end on_nl on_ignored_nl def # We're in a run command, so we do things a bit differently.
action_root on_op on_const on_period new on_lparen on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma UNK on_rparen on_rparen on_nl autoload on_symbeg # The autoload farm
