UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl def UNK on_period UNK on_nl on_tstring_beg on_tstring_end on_nl end on_nl on_ignored_nl # This is the base class for a CLI command.
def UNK on_period UNK on_nl on_tstring_beg on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_lparen argv on_comma UNK on_rparen on_ignored_nl on_ivar # This should return a brief (60 characters or less) synopsis of what # this command does. It will be used in the output of the help. # # @return [String]
def UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen opts on_op nil on_rparen on_ignored_nl on_const on_lbracket on_tstring_beg # This is what is called on the class to actually execute it. Any # subclasses should implement this method and do any option parsing # and validation here.
def UNK on_lparen opts on_op nil on_rparen on_ignored_nl on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op nil on_nl on_ignored_nl argv on_op # Parses the options given an OptionParser instance. # # This is a convenience method that properly handles duping the # originally argv array so that it is not destroyed. # # This method will also automatically detect "-h" and "--help" # and print help. And if any invalid options are detected, the help # will be printed, as well. # # If this method returns `nil`, then you should assume that help # was printed and parsing failed.
on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op nil on_nl on_ignored_nl argv on_op on_ivar on_period UNK on_nl on_ignored_nl opts on_op on_const # make sure optparse doesn't use POSIXLY_CORRECT parsing
argv on_op on_ivar on_period UNK on_nl on_ignored_nl opts on_op on_const on_op on_const on_period UNK on_nl on_ignored_nl opts on_period UNK on_lparen # Creating a shallow copy of the arguments so the OptionParser # doesn't destroy the originals.
opts on_op on_const on_op on_const on_period UNK on_nl on_ignored_nl opts on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # Default opts to a blank optionparser if none is given
opts on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_ignored_nl UNK on_lparen # Add the help option, which must be on every command.
def UNK on_lparen names on_op nil on_comma options on_op nil on_rparen on_ignored_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Yields a VM for each target VM for the command. # # This is a convenience method for easily implementing methods that # take a target VM (in the case of multi-VM) or every VM if no # specific VM name is specified. # # @param [String] name The name of the VM. Nil if every VM. # @param [Hash] options Additional tweakable settings. # @option options [Symbol] :provider The provider to back the # machines with. All machines will be backed with this # provider. If none is given, a sensible default is chosen. # @option options [Boolean] :reverse If true, the resulting order # of machines is reversed. # @option options [Boolean] :single_target If true, then an # exception will be raised if more than one target is found.
options on_op UNK UNK on_nl on_ignored_nl names on_op on_lbracket on_rbracket on_nl names on_op on_lbracket names on_rbracket if on_op names on_period # Setup the options hash
names on_op on_lbracket on_rbracket on_nl names on_op on_lbracket names on_rbracket if on_op names on_period UNK on_lparen on_const on_rparen on_nl on_ignored_nl # Require that names be an array
UNK on_op UNK on_nl UNK on_op UNK if names on_period UNK on_nl UNK on_op names on_period UNK UNK on_op UNK # Determine if we require a local Vagrant environment. There are # two cases that we require a local environment: # # * We're asking for ANY/EVERY VM (no names given). # # * We're asking for specific VMs, at least once of which # is NOT in the local machine index. #
UNK on_op on_ivar on_period UNK on_nl on_ignored_nl UNK on_op UNK do on_op name on_op on_ignored_nl provider_to_use on_op options on_lbracket UNK # Cache the active machines outside the loop
UNK on_op UNK do on_op name on_op on_ignored_nl provider_to_use on_op options on_lbracket UNK UNK on_rbracket on_nl provider_to_use on_op provider_to_use on_period # This is a helper that gets a single machine with the proper # provider. The "proper provider" in this case depends on what was # given: # # * If a provider was explicitly specified, then use that provider. # But if an active machine exists with a DIFFERENT provider, # then throw an error (for now), since we don't yet support # bringing up machines with different providers. # # * If no provider was specified, then use the active machine's # provider if it exists, otherwise use the default provider. #
provider_to_use on_op options on_lbracket UNK UNK on_rbracket on_nl provider_to_use on_op provider_to_use on_period UNK if provider_to_use on_nl on_ignored_nl entry on_op on_ivar # Check for an active machine with the same name
entry on_op on_ivar on_period UNK on_period UNK on_lparen name on_period to_s on_rparen on_nl if entry on_nl on_ivar on_period UNK on_period # If we have this machine in our index, load that.
UNK on_ignored_nl UNK on_op entry on_period UNK on_lparen on_ignored_nl on_ivar on_period UNK on_comma on_label on_ivar on_period UNK on_rparen on_nl UNK # Create an environment for this location and yield the # machine in that environment. We silence warnings here because # Vagrantfiles often have constants, so people would otherwise # constantly (heh) get "already initialized constant" warnings.
entry on_op on_ivar on_period UNK on_period UNK on_lparen name on_period to_s on_rparen on_nl on_ivar on_period UNK on_period UNK on_lparen entry # This means that this environment working directory # no longer exists, so delete this entry.
on_ignored_nl if provider_to_use on_op provider_to_use on_op UNK on_nl raise on_const on_op on_const on_comma on_ignored_nl on_label UNK on_period to_s on_comma on_ignored_nl # We found an active machine with the same name
raise on_const on_op on_const on_comma on_ignored_nl on_label UNK on_period to_s on_comma on_ignored_nl on_label UNK on_period to_s on_comma on_ignored_nl on_label provider_to_use # We found an active machine with a provider that doesn't # match the requested provider. Show an error.
on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end on_op on_ignored_nl on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end on_rparen # Use this provider and exit out of the loop. One of the # invariants [for now] is that there shouldn't be machines # with multiple providers.
provider_to_use on_op on_ivar on_period UNK on_lparen on_label name on_rparen on_nl on_ignored_nl on_ivar on_period machine on_lparen name on_comma provider_to_use on_rparen on_nl # Use the default provider if nothing else
on_ivar on_period machine on_lparen name on_comma provider_to_use on_rparen on_nl end on_nl on_ignored_nl machines on_op on_lbracket on_rbracket on_nl if names on_period # Get the right machine with the right provider
machines on_op on_lbracket on_rbracket on_nl if names on_period UNK on_op on_int on_nl names on_period UNK do on_op name on_op on_ignored_nl # First determine the proper array of VMs.
UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl on_ivar on_period UNK on_period UNK do on_op UNK on_op on_ignored_nl # This is a regular expression name, so we convert to a regular # expression and allow that sort of matching.
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end on_rparen on_nl machines on_op UNK on_period UNK on_lparen name on_period # String name, just look for a specific VM
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl machines on_op on_ivar on_period UNK on_period UNK do on_op UNK on_op # No name was given, so we return every VM in the order # configured.
if options on_lbracket UNK UNK on_rbracket on_op machines on_period UNK on_op on_int on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end # Make sure we're only working with one VM if single target
machines on_period UNK if options on_lbracket UNK UNK on_rbracket on_nl on_ignored_nl UNK on_op on_lbracket UNK UNK on_rbracket on_nl UNK on_op # If we asked for reversed ordering, then reverse it
UNK on_op on_lbracket UNK UNK on_rbracket on_nl UNK on_op on_int on_nl on_ignored_nl machines on_period UNK do on_op machine on_op on_ignored_nl # Go through each VM and yield it!
machine on_period UNK on_period opts on_lbracket UNK UNK on_rbracket on_op UNK on_lbracket UNK on_op UNK on_period UNK on_rbracket on_nl UNK # Set the machine color
UNK on_ignored_nl machine on_period UNK on_nl UNK on_const on_op on_const on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK # Call the state method so that we update our index state. Don't # worry about exceptions here, since we just care about updating # the cache.
machine on_period UNK on_nl UNK on_const on_op on_const on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen argv # Called for side effects
def UNK on_lparen argv on_rparen on_ignored_nl UNK on_op nil on_nl UNK on_op nil on_nl UNK on_op on_lbracket on_rbracket on_nl on_ignored_nl # This method will split the argv given into three parts: the # flags to this command, the subcommand, and the flags to the # subcommand. For example: # # -v status -h -v # # The above would yield 3 parts: # # ["-v"] # "status" # ["-h", "-v"] # # These parts are useful because the first is a list of arguments # given to the current command, the second is a subcommand, and the # third are the commands given to the subcommand. # # @return [Array] The three parts.
UNK on_op nil on_nl UNK on_op nil on_nl UNK on_op on_lbracket on_rbracket on_nl on_ignored_nl argv on_period UNK do on_op i # Initialize return variables
argv on_period UNK do on_op i on_op on_ignored_nl if on_op argv on_lbracket i on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # We split the arguments into two: One set containing any # flags before a word, and then the rest. The rest are what # get actually sent on to the subcommand.
UNK on_op argv on_lbracket on_int on_comma i on_rbracket on_nl UNK on_op argv on_lbracket i on_rbracket on_nl UNK on_op argv on_lbracket # We found the beginning of the sub command. Split the # args up.
UNK on_nl end on_nl end on_nl on_ignored_nl UNK on_op argv on_period UNK if UNK on_period UNK on_nl on_ignored_nl UNK on_lbracket # Break so we don't find the next non flag and shift our # main args.
UNK on_op argv on_period UNK if UNK on_period UNK on_nl on_ignored_nl UNK on_lbracket UNK on_comma UNK on_comma UNK on_rbracket on_nl # Handle the case that argv was empty or didn't contain any subcommand
