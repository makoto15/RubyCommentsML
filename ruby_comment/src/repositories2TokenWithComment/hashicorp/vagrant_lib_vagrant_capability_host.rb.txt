UNK on_const on_nl def UNK on_lparen host on_comma hosts on_comma UNK on_comma on_op args on_rparen on_ignored_nl on_ivar on_op on_const on_op # This module enables a class to host capabilities. Prior to being able # to use any capabilities, the `initialize_capabilities!` method must be # called. # # Capabilities allow small pieces of functionality to be plugged in using # the Vagrant plugin model. Capabilities even allow for a certain amount # of inheritance, where only a subset of capabilities may be implemented but # a parent implements the rest. # # Capabilities are used heavily in Vagrant for host/guest interactions. For # example, "mount_nfs_folder" is a guest-OS specific operation, so capabilities # defer these operations to the guest.
def UNK on_lparen host on_comma hosts on_comma UNK on_comma on_op args on_rparen on_ignored_nl on_ivar on_op on_const on_op on_const on_period UNK # Initializes the capability system by detecting the proper capability # host to execute on and building the chain of capabilities to execute. # # @param [Symbol] host The host to use for the capabilities, or nil if # we should auto-detect it. # @param [Hash<Symbol, Array<Class, Symbol>>] hosts Potential capability # hosts. The key is the name of the host, value[0] is a class that # implements `#detect?` and value[1] is a parent host (if any). # @param [Hash<Symbol, Hash<Symbol, Class>>] capabilities The capabilities # that are supported. The key is the host of the capability. Within that # is a hash where the key is the name of the capability and the value # is the class/module implementing it.
UNK on_tstring_beg on_tstring_content on_embexpr_beg host on_embexpr_end on_tstring_end on_nl end on_nl on_ignored_nl name on_op host on_nl host_info on_op hosts on_lbracket name # This should never happen because the autodetect above uses the # hosts hash to look up hosts. And if an explicit host is specified, # we do another check higher up.
if host_info on_lbracket on_int on_rbracket on_nl UNK on_op host_info on_lbracket on_int on_rbracket on_nl UNK on_op hosts on_lbracket UNK on_rbracket on_nl # Build the proper chain of parents if there are any. # This allows us to do "inheritance" of capabilities later
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_lparen cap_name on_rparen on_ignored_nl on_op UNK on_lparen cap_name on_period UNK # Returns the chain of hosts that will be checked for capabilities. # # @return [Array<Array<Symbol, Class>>]
def UNK on_lparen cap_name on_rparen on_ignored_nl on_op UNK on_lparen cap_name on_period UNK on_rparen on_period UNK on_nl end on_nl on_ignored_nl def # Tests whether the given capability is possible. # # @param [Symbol] cap_name Capability name # @return [Boolean]
def UNK on_lparen cap_name on_comma on_op args on_rparen on_ignored_nl UNK on_op UNK on_lparen cap_name on_period UNK on_rparen on_nl if on_op # Executes the capability with the given name, optionally passing more # arguments onwards to the capability. If the capability returns a value, # it will be returned. # # @param [Symbol] cap_name Name of the capability
UNK on_op UNK UNK on_nl hosts on_period UNK UNK on_op name on_comma UNK on_op on_ignored_nl UNK on_lbracket name on_rbracket on_op # Get the mapping of hosts with the most parents. We start searching # with the hosts with the most parents first.
UNK on_op UNK UNK on_nl UNK on_period UNK UNK on_op name on_comma UNK on_op on_ignored_nl UNK on_lbracket UNK on_rbracket on_op # Now swap around the mapping so that it is a mapping of # count to the actual list of host names
def UNK on_lparen cap_name on_rparen on_ignored_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg cap_name on_embexpr_end on_tstring_end on_rparen on_nl on_ivar on_period # Returns the registered module for a capability with the given name. # # @param [Symbol] cap_name # @return [Module]
