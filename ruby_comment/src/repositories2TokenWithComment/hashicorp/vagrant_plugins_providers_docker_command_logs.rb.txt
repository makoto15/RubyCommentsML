UNK on_op UNK on_lparen UNK on_rparen on_nl UNK if on_op UNK on_nl on_ignored_nl UNK on_op UNK on_nl on_ignored_nl UNK on_period # Parse the options
UNK on_op UNK on_nl on_ignored_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_lparen UNK on_rparen do on_op machine # This keeps track of if we ran our action on any machines...
UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_lparen UNK on_rparen do on_op machine on_op on_ignored_nl if machine on_period # Start a batch action that sends all the logs to stdout. This # will parallelize, if enabled, across all containers that are # chosen.
UNK on_op UNK on_nl on_ignored_nl UNK on_period UNK on_lparen machine on_rparen do on_op UNK on_op on_ignored_nl UNK on_lparen UNK on_comma # At least one was run!
UNK UNK on_op UNK on_op UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl UNK UNK on_lparen machine on_comma options on_rparen # If we didn't run on any machines, then exit status 1
UNK UNK on_lparen machine on_comma options on_rparen on_ignored_nl UNK on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl # Executes the "docker logs" command on a single machine and proxies # the output to our UI.
data_acc on_op UNK on_nl on_ignored_nl if data_acc on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op data_acc on_period UNK # Accumulate the data so we only output lines at a time
if data_acc on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op data_acc on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # If we have a newline, then output all the lines we have so far
machine on_period UNK on_period UNK on_lparen data_acc on_comma on_op UNK on_rparen if on_op data_acc on_period UNK on_nl end on_nl end # Output any remaining data
