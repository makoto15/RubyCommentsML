UNK on_const on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_symbeg UNK on_rparen on_nl on_const on_op on_tstring_beg on_tstring_end on_nl # This class provides communication with the VM via SSH.
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op # Marker for start of PTY enabled command output
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_lbracket on_ignored_nl on_const on_op on_const on_comma # Marker for end of PTY enabled command output
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_lbracket on_ignored_nl on_const on_op on_const on_comma on_ignored_nl on_const on_op on_const on_comma on_ignored_nl # Marker for start of regular command output
on_const on_op on_lbracket on_ignored_nl on_const on_op on_const on_comma on_ignored_nl on_const on_op on_const on_comma on_ignored_nl on_const on_op on_const on_comma on_ignored_nl on_const # These are the exceptions that we retry because they represent # errors that are generally fixed from a retry and don't # necessarily represent immediate failure cases.
true on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op on_const on_period new on_nl on_ivar on_op UNK # All machines are currently expected to have SSH.
ssh_info on_op nil on_nl UNK true on_nl ssh_info on_op on_ivar on_period ssh_info on_nl UNK if ssh_info on_nl UNK on_lparen UNK # Wait for ssh_info to be ready
if on_op on_ivar on_nl on_ivar on_period ui on_period detail on_lparen on_tstring_beg on_tstring_content on_embexpr_beg ssh_info on_lbracket on_symbeg UNK on_rbracket on_embexpr_end on_tstring_content # Got it! Let the user know what we're connecting to.
end on_nl on_ignored_nl if message on_nl UNK on_op on_const on_period UNK on_period UNK on_nl UNK on_op true on_nl if UNK # Ignore it, SSH is not ready, some other error.
if message on_nl UNK on_op on_const on_period UNK on_period UNK on_nl UNK on_op true on_nl if UNK on_lbracket message on_rbracket # If we have a message to show, then show it. We don't show # repeated messages unless they've been repeating longer than # 10 seconds.
begin on_ignored_nl UNK on_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl rescue on_const on_op on_const on_op on_const on_op # Attempt to connect. This will raise an exception if it fails.
on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg e on_period UNK on_embexpr_end on_tstring_end on_rparen on_nl return false on_nl end on_nl on_ignored_nl # We catch a `VagrantError` which would signal that something went # wrong expectedly in the `connect`, which means we didn't connect.
if execute on_lparen UNK on_period UNK on_period UNK on_lparen on_symbeg on_const on_rparen on_comma on_label false on_rparen on_op on_int on_nl raise # Verify the shell is valid
on_ivar on_period UNK do on_ignored_nl return true if on_ivar on_op on_op machine_config_ssh on_period UNK on_nl on_ivar on_op true on_nl end # If we're already attempting to switch out the SSH key, then # just return that we're ready (for Machine#guest).
ssh_info on_op on_ivar on_period ssh_info on_nl return if ssh_info on_period UNK on_nl UNK on_op ssh_info on_lbracket on_symbeg UNK on_rbracket on_op # If we used a password, then insert the insecure key
UNK on_op on_ivar on_period UNK on_period UNK on_lparen on_symbeg UNK on_rparen on_op on_ignored_nl on_ivar on_period UNK on_period UNK on_lparen on_symbeg # If we don't have the power to insert/remove keys, then its an error
on_ivar on_period UNK on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op UNK # Write out the private key in the data dir so that the # machine automatically picks it up.
if on_ivar on_period UNK on_period UNK on_period UNK on_lparen on_symbeg UNK on_rparen on_nl on_ivar on_period UNK on_period UNK on_period UNK # Adjust private key file permissions if host provides capability
on_ivar on_period ui on_period detail on_lparen on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl on_ivar on_period UNK on_period # Remove the old key if it exists
on_ivar on_period ui on_period detail on_lparen on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl on_ivar on_period UNK on_nl # Done, restart.
true on_nl end on_nl on_ignored_nl def execute on_lparen command on_comma opts on_op nil on_comma on_op UNK on_rparen on_ignored_nl opts on_op # If we reached this point then we successfully connected
stdout on_op on_tstring_beg on_tstring_end on_nl UNK on_op on_tstring_beg on_tstring_end on_nl exit_status on_op UNK do on_op connection on_op on_ignored_nl UNK on_op # Connect via SSH and execute the command in the shell.
if opts on_lbracket on_symbeg UNK on_rbracket on_op on_op opts on_lbracket on_symbeg UNK on_rbracket on_period UNK on_lparen exit_status on_rparen on_nl UNK # Check for any errors
UNK on_op opts on_period UNK on_lparen on_ignored_nl on_label opts on_lbracket on_symbeg UNK on_rbracket on_comma on_ignored_nl on_label stdout on_comma on_ignored_nl on_label # The error classes expect the translation key to be _key, # but that makes for an ugly configuration parameter, so we # set it here from `error_key`
exit_status on_nl end on_nl on_ignored_nl def sudo on_lparen command on_comma opts on_op nil on_comma on_op UNK on_rparen on_ignored_nl opts on_op # Return the exit status
opts on_op on_lbrace on_label true on_rbrace on_period UNK on_lparen opts on_op on_lbrace on_rbrace on_rparen on_nl execute on_lparen command on_comma opts # Run `execute` but with the `sudo` option.
raise if e on_period message on_op UNK on_tstring_content UNK on_nl on_ignored_nl raise on_const on_op on_const on_op on_const on_comma on_ignored_nl on_label # Net::SCP raises a runtime error for this so the only way we have # to really catch this exception is to check the message to see if # it is something we care about. If it isn't, we re-raise.
raise on_const on_op on_const on_op on_const on_comma on_ignored_nl on_label from on_period UNK on_comma on_ignored_nl on_label to on_period UNK on_nl end # Otherwise, it is a permission denied, so let's raise a proper # exception
UNK on_lparen on_int on_rparen on_nl end on_nl on_ignored_nl def generate_environment_export on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op machine_config_ssh on_period # suppress ssh info output
def UNK on_lparen on_op opts on_rparen on_ignored_nl if on_ivar on_op on_op on_ivar on_period UNK on_nl begin on_ignored_nl on_const on_period timeout # Opens an SSH connection and yields it to a block.
begin on_ignored_nl on_const on_period timeout on_lparen on_int on_rparen do on_ignored_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_end on_rparen on_nl end on_nl # There is a chance that the socket is closed despite us checking # 'closed?' above. To test this we need to send data through the # socket. # # We wrap the check itself in a 5 second timeout because there # are some cases where this will just hang.
if on_ivar on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl return yield on_ivar if UNK on_nl return on_nl # If the @connection is still around, then it is valid, # and we use it.
ssh_info on_op on_ivar on_period ssh_info on_nl raise on_const on_op on_const on_op on_const if ssh_info on_period UNK on_nl on_ignored_nl opts on_lbracket # Get the SSH info for the machine, raise an exception if the # provider is saying that SSH is not ready.
opts on_lbracket on_symbeg UNK on_rbracket on_op on_int if on_op opts on_period UNK on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl UNK on_op # Default some options
UNK on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end if ssh_info on_lbracket # Set some valid auth methods. We disable the auth methods that # we're not using if we don't have the right auth info.
UNK on_op on_lbrace on_ignored_nl on_label UNK on_comma on_ignored_nl on_label false on_comma on_ignored_nl on_label ssh_info on_lbracket on_symbeg UNK on_rbracket on_comma on_ignored_nl # Build the options we'll use to initiate the connection via Net::SSH
connection on_op nil on_nl begin on_ignored_nl timeout on_op on_int on_nl on_ignored_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # Connect to SSH, giving it a few tries
UNK on_op on_const on_period new on_nl UNK on_op on_const on_period new on_lparen UNK on_rparen on_nl on_ignored_nl connect_opts on_op UNK on_period # This logger will get the Net-SSH log data for us.
connect_opts on_op UNK on_period UNK on_nl connect_opts on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl on_ignored_nl if ssh_info on_lbracket on_symbeg private_key_path # Setup logging for connections
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ivar on_period debug on_lparen UNK on_period UNK on_rparen on_nl on_ivar on_period # Make sure we output the connection log
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_comma on_const on_op on_const on_nl raise on_const on_op on_const # This happens on connect() for unknown reasons yet...
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const # This happens if we continued to timeout when attempting to connect.
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const # This happens if authentication failed. We wrap the error in our # own exception.
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const on_nl rescue # This happens if the remote server unexpectedly closes the # connection. This is usually raised when SSH is running on the # other side but can't properly setup a connection. This is # usually a server-side issue.
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const on_nl rescue # This is raised if we failed to connect the max amount of times
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const on_nl rescue # This is raised if we failed to connect the max number of times # due to an ECONNRESET.
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_nl raise on_const on_op on_const on_op on_const on_nl rescue # This is raised if we failed to connect the max number of times # due to an ECONNABORTED
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_comma on_const on_op on_const on_nl raise on_const on_op on_const # This is raised if we get an ICMP DestinationUnknown error.
raise on_const on_op on_const on_op on_const on_nl rescue on_const on_op on_const on_op on_const on_op e on_nl raise on_const on_op on_const # This is raised if we can't work out how to route traffic.
raise on_const on_op on_const on_op on_const on_comma on_label e on_period message on_nl rescue on_const on_nl raise on_const on_op on_const on_op # This is an internal error in Net::SSH
raise on_const on_op on_const on_op on_const on_nl end on_nl on_ignored_nl on_ivar on_op connection on_nl on_ivar on_op ssh_info on_nl on_ignored_nl return # This is raised if a private key type that Net-SSH doesn't support # is used. Show a nicer error.
return yield connection if UNK on_nl end on_nl on_ignored_nl def UNK on_lparen opts on_rparen on_ignored_nl sudo on_op opts on_lbracket on_symbeg # Yield the connection that is ready to be used and # return the value of the block
def UNK on_lparen opts on_rparen on_ignored_nl sudo on_op opts on_lbracket on_symbeg sudo on_rbracket on_nl shell on_op opts on_lbracket on_symbeg shell # The shell wrapper command used in shell_execute defined by # the sudo and shell options.
UNK on_op machine_config_ssh on_period shell on_nl UNK on_op shell if shell on_nl UNK on_op machine_config_ssh on_period UNK on_period UNK on_lparen # Determine the shell to execute. Prefer the explicitly passed in shell # over the default configured shell. If we are using `sudo` then we # need to wrap the shell in a `sudo` call.
def UNK on_lparen connection on_comma command on_comma on_op opts on_rparen on_ignored_nl opts on_op on_lbrace on_ignored_nl on_label false on_comma on_ignored_nl on_label # Executes the command on an SSH connection within a login shell.
pty on_op false on_nl pty_stdout on_op on_tstring_beg on_tstring_end on_nl on_ignored_nl UNK on_op connection on_period UNK do on_op UNK on_op on_ignored_nl # These variables are used to scrub PTY output if we're in a PTY
UNK on_op connection on_period UNK do on_op UNK on_op on_ignored_nl if machine_config_ssh on_period pty on_nl UNK on_period UNK do on_op # Open the channel so we can execute or command
ch2 on_period UNK do on_op UNK on_comma data on_op on_ignored_nl data on_op UNK on_lparen data on_rparen on_nl on_ignored_nl if pty # Setup the channel callbacks so we can get data and exit status
data on_op UNK on_lparen data on_rparen on_nl on_ignored_nl if pty on_nl pty_stdout on_op data on_nl else on_ignored_nl if on_op UNK # Filter out the clear screen command
data on_op UNK on_lparen data on_rparen on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg data on_embexpr_end on_tstring_end on_rparen on_nl if # Filter out the clear screen command
UNK on_period UNK on_nl end on_nl on_ignored_nl ch2 on_period UNK on_lparen generate_environment_export on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # Close the channel, since after the exit status we're # probably done. This fixes up issues with hanging.
ch2 on_period UNK on_lparen generate_environment_export on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl on_ignored_nl if on_ivar on_lbracket # Set the terminal
if on_ivar on_lbracket on_symbeg UNK on_rbracket on_op sudo on_nl auth_socket on_op on_tstring_beg on_tstring_end on_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Set SSH_AUTH_SOCK if we are in sudo and forwarding agent. # This is to work around often misconfigured boxes where # the SSH_AUTH_SOCK env var is not preserved.
auth_socket on_op auth_socket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_period UNK on_nl end on_nl on_ignored_nl if auth_socket # Make sure we only read the last line which should be # the $SSH_AUTH_SOCK env var we printed.
if pty on_nl data on_op on_tstring_beg on_tstring_content on_tstring_end on_nl data on_op generate_environment_export on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen # Output the command. If we're using a pty we have to do # a little dance to make sure we get all the output properly # without the cruft added from pty mode.
ch2 on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl ch2 on_period UNK on_nl end on_nl end on_nl # Remember to exit or this channel will hang open
ch2 on_period UNK on_nl end on_nl end on_nl on_ignored_nl begin on_ignored_nl UNK on_op nil on_nl on_ignored_nl if machine_config_ssh on_period UNK # Send eof to let server know we're done
UNK on_op on_const on_period new do on_ignored_nl UNK do on_ignored_nl UNK on_int on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end # Begin sending keep-alive packets while we wait for the script # to complete. This avoids connections closing on long-running # scripts.
begin on_ignored_nl UNK on_period UNK on_nl rescue on_const on_op on_const on_comma on_const on_nl on_ivar on_period info on_lparen on_ignored_nl on_tstring_beg on_tstring_content # Wait for the channel to complete
UNK on_period UNK if UNK on_nl end on_nl on_ignored_nl if pty on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg pty_stdout # Kill the keep-alive thread
if pty on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg pty_stdout on_embexpr_end on_tstring_end on_rparen on_nl if on_op pty_stdout on_period UNK # If we're in a PTY, we now finally parse the output
return exit_status on_nl end on_nl on_ignored_nl def UNK on_nl UNK do on_op connection on_op on_ignored_nl scp on_op on_const on_op on_const # Return the final exit status
def UNK on_nl UNK do on_op connection on_op on_ignored_nl scp on_op on_const on_op on_const on_period new on_lparen connection on_rparen on_nl # Opens an SCP connection and yields it so that you can download # and upload files.
UNK do on_op connection on_op on_ignored_nl scp on_op on_const on_op on_const on_period new on_lparen connection on_rparen on_nl return yield scp # Connect to SCP and yield the SCP object
raise on_const on_op on_const on_op on_const if e on_period message on_op UNK on_tstring_content UNK on_nl on_ignored_nl raise on_nl end on_nl # If we get the exit code of 127, then this means SCP is unavailable.
raise on_nl end on_nl on_ignored_nl def UNK on_lparen path on_rparen on_ignored_nl return false if on_op path on_nl return false if # Otherwise, just raise the error up
def UNK on_lparen path on_rparen on_ignored_nl return false if on_op path on_nl return false if on_op on_const on_period UNK on_lparen # This will test whether path is the Vagrant insecure private key. # # @param [String] path
