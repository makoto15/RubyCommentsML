UNK on_const on_nl def UNK on_period UNK on_lparen on_op command on_comma on_op UNK on_rparen on_ignored_nl new on_lparen on_op command on_rparen # Execute a command in a subprocess, gathering the results and # exit status. # # This class also allows you to read the data as it is outputted # from the subprocess in real time, by simply passing a block to # the execute method.
def UNK on_period UNK on_lparen on_op command on_comma on_op UNK on_rparen on_ignored_nl new on_lparen on_op command on_rparen on_period UNK on_lparen # Convenience method for executing a method.
def UNK on_nl on_op on_op on_lparen on_ivar on_op on_ivar on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl if # @return [TrueClass, FalseClass] subprocess is currently running
def UNK on_nl if on_ivar on_op on_ivar on_period UNK on_nl on_ivar on_period UNK on_nl UNK on_nl UNK on_ignored_nl UNK on_nl # Stop the subprocess if running # # @return [TrueClass] FalseClass] true if process was running and stopped
def UNK on_nl UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_op # Start the process # # @return [Result]
UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_op on_const on_period UNK # Get the timeout, if we have one
UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_op on_const on_period UNK on_nl on_ignored_nl notify on_op on_ivar on_lbracket on_symbeg notify on_rbracket # Get the working directory
notify on_op on_ivar on_lbracket on_symbeg notify on_rbracket on_op on_lbracket on_rbracket on_nl notify on_op on_lbracket notify on_rbracket if on_op notify on_period # Get what we're interested in being notified about
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl raise on_const on_comma UNK on_nl end on_nl on_ignored_nl UNK on_op UNK UNK on_nl UNK # If a block is given, subscribers must be given, otherwise the # block is never called. This is usually NOT what you want, so this # is an error.
UNK on_op UNK UNK on_nl UNK on_lbracket on_symbeg stderr on_rbracket on_op notify on_period UNK on_lparen on_symbeg stderr on_rparen on_nl UNK # Let's get some more useful booleans that we access a lot so # we're not constantly calling an `include` check
on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period UNK on_embexpr_end on_tstring_end on_rparen on_nl on_ivar on_op process on_op on_const on_period # Build the ChildProcess
stdout on_comma UNK on_op on_op on_const on_period UNK on_nl stderr on_comma UNK on_op on_op on_const on_period UNK on_nl process on_period # Create the pipes so we can read the output in real time as # we execute the command.
if on_const on_period UNK on_nl UNK on_op on_const on_period UNK on_period UNK on_period UNK on_nl on_ignored_nl if on_const on_period UNK # Special installer-related things
if on_const on_period UNK on_nl if on_ivar on_lbracket on_int on_rbracket on_period UNK on_period UNK on_lparen UNK on_rparen on_nl on_ivar on_period # If we're in an installer on Mac and we're executing a command # in the installer context, then force DYLD_LIBRARY_PATH to look # at our libs first.
UNK on_op on_lbracket UNK on_comma on_const on_period UNK on_period UNK on_period UNK on_rbracket on_period on_ignored_nl UNK UNK on_op UNK on_op # If the command that is being run is not inside the installer, reset # the original environment - this is required for shelling out to # other subprocesses that depend on environment variables (like Ruby # and $GEM_PATH for example)
if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl UNK on_op on_const on_period new on_lparen on_const on_period UNK on_rparen on_period UNK # If running within an AppImage and calling external executable. When # executable is external set the LD_LIBRARY_PATH to host values.
if on_ivar on_lbracket on_symbeg env on_rbracket on_nl on_ivar on_lbracket on_symbeg env on_rbracket on_period UNK UNK on_op UNK on_comma UNK on_op # Set the environment on the process if we must
UNK on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen UNK on_ignored_nl process on_period UNK on_nl end on_nl UNK on_const on_op on_const # Start the process
raise on_const on_period new on_lparen UNK on_period UNK on_rparen on_nl end on_nl on_ignored_nl process on_period io on_period stdin on_period UNK # Raise our own version of the error so that users of the class # don't need to be aware of ChildProcess
process on_period io on_period stdin on_period UNK on_op UNK on_nl on_ignored_nl if on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_period # Make sure the stdin does not buffer
UNK on_period UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl UNK on_op UNK UNK on_tstring_beg on_tstring_end on_comma UNK on_tstring_beg # On Java, we have to close after. See down the method... # Otherwise, we close the writers right here, since we're # not on the writing side.
UNK on_op UNK UNK on_tstring_beg on_tstring_end on_comma UNK on_tstring_beg on_tstring_end UNK on_nl on_ignored_nl UNK on_op on_const on_period UNK on_period UNK # Create a dictionary to store all the output we see.
UNK on_op on_const on_period UNK on_period UNK on_nl on_ignored_nl UNK on_op on_lbracket stdout on_comma stderr on_rbracket on_nl UNK on_op UNK # Record the start time for timeout purposes
raise on_const on_comma process on_period UNK if UNK on_op on_lparen on_const on_period UNK on_period UNK on_op UNK on_rparen on_op UNK # Check if we have exceeded our timeout
if UNK on_op on_op UNK on_period UNK on_nl UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_op on_const on_period # Check the readers to see if they're ready
UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK if UNK on_period UNK on_nl on_ignored_nl io_name on_op UNK # Read from the IO object
UNK if UNK on_period UNK on_nl on_ignored_nl io_name on_op UNK on_op stdout on_op on_symbeg stdout on_op on_symbeg stderr on_nl on_ivar # We don't need to do anything if the data is empty
UNK if process on_period UNK on_nl on_ignored_nl if UNK on_op on_op UNK on_period UNK on_op UNK on_nl UNK on_symbeg stdin # Break out if the process exited. We have to do this before # attempting to write to stdin otherwise we'll get a broken pipe # error.
if UNK on_op on_op UNK on_period UNK on_op UNK on_nl UNK on_symbeg stdin on_comma process on_period io on_period stdin on_nl # Check the writers to see if they're ready, and notify any listeners
if process on_period io on_period stdin on_period UNK on_nl UNK on_op on_lbracket on_rbracket on_nl end on_nl end on_nl end on_nl # if the callback closed stdin, we should remove it, because # IO.select() will throw if called with a closed io.
UNK on_ignored_nl UNK on_op on_lparen UNK on_op on_int on_rparen on_op on_lparen on_const on_period UNK on_period UNK on_op UNK on_rparen on_nl # Wait for the process to end.
on_lbracket stdout on_comma stderr on_rbracket on_period UNK UNK on_op io on_op on_ignored_nl UNK on_op on_const on_period UNK on_lparen io on_rparen # Read the final output data, since it is possible we missed a small # amount of text between the time we last read data and when the # process exited.
UNK on_op on_const on_period UNK on_lparen io on_rparen on_nl UNK if UNK on_op on_tstring_beg on_tstring_end on_nl on_ignored_nl io_name on_op io # Read the extra data, ignoring if there isn't any
io_name on_op io on_op stdout on_op on_symbeg stdout on_op on_symbeg stderr on_nl UNK on_lbracket io_name on_rbracket on_op UNK on_nl on_ivar # Log it out and accumulate
UNK io_name on_comma UNK if UNK on_op UNK on_lbracket io_name on_rbracket on_nl end on_nl on_ignored_nl if on_const on_op on_tstring_beg on_tstring_content # Yield to any listeners any remaining data
UNK on_period UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl UNK on_const on_period new on_lparen process on_period UNK on_comma # On JRuby, we need to close the writers after the process, # for some reason. See GH-711.
UNK on_const on_period new on_lparen process on_period UNK on_comma UNK on_lbracket on_symbeg stdout on_rbracket on_comma UNK on_lbracket on_symbeg stderr on_rbracket # Return an exit status container
process on_period UNK on_lparen on_int on_rparen on_nl end on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl UNK on_const on_op on_const UNK # Make sure no matter what happens, the process exits
UNK on_const on_op on_const UNK end on_nl on_ignored_nl UNK on_const on_op on_const on_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK # An error which raises when a process fails to start
UNK on_const on_op on_const on_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen on_rparen on_nl # An error which occurs when the process doesn't end within # the given timeout.
UNK on_const on_nl UNK on_symbeg UNK on_nl UNK on_symbeg stdout on_nl UNK on_symbeg stderr on_nl on_ignored_nl def UNK on_lparen UNK # Container class to store the results of executing a subprocess.
def UNK on_lparen env on_op UNK UNK on_rparen on_ignored_nl UNK if on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # This is, quite possibly, the saddest function in all of Vagrant. # # If a user is running Vagrant via Bundler (but not via the official # installer), we want to reset to the "original" environment so that when # shelling out to other Ruby processes (specifically), the original # environment is restored. This is super important for things like # rbenv and chruby, who rely on environment variables to locate gems, but # Bundler stomps on those environment variables like an angry T-Rex after # watching Jurassic Park 2 and realizing they replaced you with CGI. # # If a user is running in Vagrant via the official installer, BUT trying # to execute a subprocess *outside* of the installer, we want to reset to # the "original" environment. In this case, the Vagrant installer actually # knows what the original environment was and replaces it completely. # # Finally, we reset any Bundler-specific environment variables, since the # subprocess being called could, itself, be Bundler. And Bundler does not # behave very nicely in these circumstances. # # This function was added in Vagrant 1.7.3, but there is a failsafe # because the author doesn't trust himself that this functionality won't # break existing assumptions, so users can specify # `VAGRANT_SKIP_SUBPROCESS_JAILBREAK` and none of the above will happen. # # This function modifies the given hash in place! # # @return [nil]
env on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ignored_nl on_const on_period UNK UNK on_op # Bundler does this, so I guess we should as well, since I think it # other subprocesses that use Bundler will reload it
on_const on_period UNK UNK on_op UNK on_comma UNK on_op on_ignored_nl env on_lbracket UNK on_rbracket on_op UNK if UNK on_lbracket on_int # Replace all current environment BUNDLE_ variables to nil
if on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl env on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_const on_lbracket on_tstring_beg # If RUBYOPT was set, unset it with Bundler
