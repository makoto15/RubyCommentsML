on_ivar on_period UNK on_period UNK on_period UNK on_op on_symbeg UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # We need to use a special communicator that proxies our # SSH requests over our host VM to the container itself.
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_tstring_beg on_tstring_content UNK UNK UNK on_tstring_end on_nl return on_const on_period UNK on_lparen # @see Vagrant::Plugin::V2::Provider#action
def UNK on_nl if on_op on_ivar on_nl if on_ivar on_period UNK on_period UNK on_nl on_ivar on_op on_const on_op on_const on_period # Returns the driver instance for this provider.
def UNK on_nl return on_ivar if on_ivar on_nl on_ignored_nl vf_path on_op on_ivar on_period UNK on_period UNK on_nl UNK on_op on_ivar # This returns the {Vagrant::Machine} that is our host machine. # It does not perform any action on the machine or verify it is # running. # # @return [Vagrant::Machine]
UNK on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma UNK on_rparen on_nl vf_path on_op on_ivar on_period env on_period UNK # We don't have a Vagrantfile path set, so we're going to use # the default but we need to copy it into the data dir so that # we don't write into our installation dir (we can't).
UNK on_nl end on_nl on_ignored_nl UNK on_op on_symbeg UNK on_nl end on_nl on_ignored_nl vf_path on_op on_const on_period UNK on_lparen vf_path # Lock contention, just retry
UNK on_op on_symbeg UNK on_nl end on_nl on_ignored_nl vf_path on_op on_const on_period UNK on_lparen vf_path on_comma on_ivar on_period env on_period # Set the machine name since we hardcode that for the default
vf_path on_op on_const on_period UNK on_lparen vf_path on_comma on_ivar on_period env on_period UNK on_rparen on_nl on_ignored_nl UNK on_op on_const on_period # Expand it so that the home directories and so on get processed # properly.
on_ivar on_op on_const on_op on_const on_op on_const on_period UNK UNK on_ignored_nl UNK on_op on_const on_op on_const on_period new on_lparen on_ignored_nl # Create the env to manage this machine
UNK on_const on_op on_const if on_op UNK on_period UNK on_nl on_ignored_nl UNK on_period UNK on_lparen on_ignored_nl UNK on_comma on_ignored_nl UNK # If there is no root path, then the Vagrantfile wasn't found # and it is an error...
def UNK on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen UNK on_period UNK on_period UNK on_rparen on_nl on_ignored_nl UNK # This acquires a lock on the host VM.
UNK on_period UNK UNK on_ignored_nl on_ivar on_period env on_period UNK on_lparen UNK on_rparen UNK on_ignored_nl return UNK on_nl end on_nl # We do a process-level mutex on the outside, since we can # wait for that a short amount of time. Then, we do a process lock # on the inside, which will raise an exception if locked.
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK on_period UNK on_nl end on_nl on_ignored_nl # This is a process-local mutex that can be used by parallel # providers to lock the host VM access.
def UNK on_nl on_ivar on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl return UNK if UNK on_period # This says whether or not Docker will be running within a VM # rather than directly on our system. Docker needs to run in a VM # when we're not on Linux, or not on a Linux that supports Docker.
def UNK on_nl return UNK if UNK on_period id on_op on_symbeg UNK on_nl on_ignored_nl UNK on_op on_tstring_beg UNK on_ivar on_period # Returns the SSH info for accessing the Container.
return UNK if UNK on_period id on_op on_symbeg UNK on_nl on_ignored_nl UNK on_op on_tstring_beg UNK on_ivar on_period UNK on_period UNK # If the container isn't running, we can't SSH into it
return UNK if port_info on_period UNK on_op port_info on_period UNK on_nl on_ignored_nl UNK on_ignored_nl on_label port_info on_lbracket on_tstring_beg on_tstring_content on_tstring_end # If we were not able to identify the container's IP, we return nil # here and we let Vagrant core deal with it ;)
state_id on_op on_symbeg UNK if on_ivar on_period id on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_op state_id on_period UNK on_period # This is a special pseudo-state so that we don't set the # NOT_CREATED_ID while we're setting up the machine. This avoids # clearing the data dir.
if state_id on_op on_symbeg UNK on_nl state_id on_op on_const on_op on_const on_op on_const on_nl end on_nl on_ignored_nl on_const on_op on_const # If we're not created, then specify the special ID flag
