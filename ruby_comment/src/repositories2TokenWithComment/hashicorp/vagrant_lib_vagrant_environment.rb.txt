UNK on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl attr_reader on_symbeg cwd # A "Vagrant environment" represents a configuration of how Vagrant # should behave: data directories, working directory, UI output, # etc. In day-to-day usage, every `vagrant` invocation typically # leads to a single Vagrant environment.
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl attr_reader on_symbeg cwd on_nl on_ignored_nl attr_reader # This is the current version that this version of Vagrant is # compatible with in the home directory. # # @return [String]
attr_reader on_symbeg cwd on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg vagrantfile_name on_nl on_ignored_nl attr_reader on_symbeg ui on_nl on_ignored_nl # The `cwd` that this environment represents
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg vagrantfile_name on_nl on_ignored_nl attr_reader on_symbeg ui on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The persistent data directory where global data can be stored. It # is up to the creator of the data in this directory to properly # remove it when it is no longer needed. # # @return [Pathname]
attr_reader on_symbeg vagrantfile_name on_nl on_ignored_nl attr_reader on_symbeg ui on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg home_path on_nl on_ignored_nl # The valid name for a Vagrantfile for this environment.
attr_reader on_symbeg ui on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg home_path on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The {UI} object to communicate with the outside world.
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg home_path on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # This is the UI class to use when creating new UIs.
attr_reader on_symbeg home_path on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The directory to the "home" folder that Vagrant will use to store # global state.
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The directory to the directory where local, environment-specific # data is stored.
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The directory where temporary files for Vagrant go.
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # File where command line aliases go.
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen opts on_op # The directory where boxes are stored.
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen opts on_op nil on_rparen on_ignored_nl opts on_op # The path where the plugins are stored (gems)
attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen opts on_op nil on_rparen on_ignored_nl opts on_op on_lbrace on_ignored_nl on_label nil on_comma # The path to the default private key
def UNK on_lparen opts on_op nil on_rparen on_ignored_nl opts on_op on_lbrace on_ignored_nl on_label nil on_comma on_ignored_nl on_label nil on_comma on_ignored_nl # Initializes a new environment with the given options. The options # is a hash where the main available key is `cwd`, which defines where # the environment represents. There are other options available but # they shouldn't be used in general. If `cwd` is nil, then it defaults # to the `Dir.pwd` (which is the cwd of the executing process).
opts on_lbracket on_symbeg cwd on_rbracket on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket if on_const on_period key? on_lparen on_tstring_beg on_tstring_content on_tstring_end # Set the default working directory to look for the vagrantfile
opts on_lbracket on_symbeg UNK on_rbracket on_op on_const on_op on_const on_nl on_ignored_nl opts on_lbracket on_symbeg vagrantfile_name on_rbracket on_op on_const on_lbracket on_tstring_beg # Set the default ui class
opts on_lbracket on_symbeg vagrantfile_name on_rbracket on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket if on_const on_period key? on_lparen on_tstring_beg on_tstring_content on_tstring_end # Set the Vagrantfile name up. We append "Vagrantfile" and "vagrantfile" so that # those continue to work as well, but anything custom will take precedence.
on_ivar on_op opts on_lbracket on_symbeg cwd on_rbracket on_nl on_ivar on_op opts on_lbracket on_symbeg home_path on_rbracket on_nl on_ivar on_op opts on_lbracket # Set instance variables for all the configuration parameters.
on_ivar on_op on_const on_period new on_nl on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ignored_nl on_ivar on_op on_const on_op on_const on_period new # This is the batch lock, that enforces that only one {BatchAction} # runs at a time from {#batch}.
on_ivar on_op on_const on_period UNK on_nl on_ivar on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_rparen on_nl on_ivar on_op on_ivar # Setup the home directory
UNK on_nl on_ignored_nl if on_op root_path on_period UNK on_nl if on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period to_s on_period # Prepare the directories
if on_op root_path on_period UNK on_nl if on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period to_s on_period empty? on_op on_op # Setup the local data directory. If a configuration path is given, # it is expanded relative to the root path. Otherwise, we use the # default (which is also expanded relative to the root path).
if root_path on_nl UNK on_op root_path on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if UNK on_period file? on_nl on_ivar # If we have a root path, load the ".vagrantplugins" file.
on_ivar on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_nl on_ignored_nl plugins on_op on_const on_op on_const on_op # Setup the default private key
plugins on_op on_const on_op on_const on_op on_const on_period instance on_period UNK on_lparen self on_rparen on_nl on_const on_op on_const on_op on_const # Initialize localized plugins
on_const on_op on_const on_op on_const on_period instance on_period UNK on_lparen plugins on_rparen on_nl on_ignored_nl plugins on_op on_const on_op on_const on_op # Load any environment local plugins
plugins on_op on_const on_op on_const on_op on_const on_period instance on_period UNK on_nl on_const on_op on_const on_op on_const on_period instance on_period # Initialize globalize plugins
on_const on_op on_const on_op on_const on_period instance on_period UNK on_lparen plugins on_rparen on_nl on_ignored_nl plugins on_op UNK on_nl on_ignored_nl hook # Load any global plugins
hook on_lparen on_symbeg UNK on_comma on_label on_const on_op on_const on_period new on_lparen on_label self on_rparen on_rparen on_nl on_ignored_nl hook on_lparen # Call the hooks that does not require configurations to be loaded # by using a "clean" action runner
hook on_lparen on_symbeg UNK on_comma on_label on_const on_op on_const on_period new on_lparen on_label self on_rparen on_rparen on_nl end on_nl on_ignored_nl # Call the environment load hooks
def UNK on_nl on_tstring_beg on_tstring_content on_embexpr_beg self on_period UNK on_embexpr_end on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_tstring_end on_period UNK on_lparen on_tstring_beg # Return a human-friendly string for pretty printed or inspected # instances. # # @return [String]
def UNK on_nl on_ivar on_op on_const on_op on_const on_period new do on_ignored_nl on_lbrace on_ignored_nl on_label UNK on_comma on_ignored_nl on_label UNK # Action runner for executing actions in the context of this environment. # # @return [Action::Runner]
def UNK on_nl return on_lbracket on_rbracket if on_op on_ivar on_nl on_ignored_nl UNK on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end # Returns a list of machines that this environment is currently # managing that physically have been created. # # An "active" machine is a machine that Vagrant manages that has # been created. The machine itself may be in any state such as running, # suspended, etc. but if a machine is "active" then it exists. # # Note that the machines in this array may no longer be present in # the Vagrantfile of this environment. In this case the machine can # be considered an "orphan." Determining which machines are orphan # and which aren't is not currently a supported feature, but will # be in a future version. # # @return [Array<String, Symbol>]
return on_lbracket on_rbracket if on_op on_ivar on_nl on_ignored_nl UNK on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl # We have no active machines if we have no data path
return on_lbracket on_rbracket if on_op UNK on_period UNK on_nl on_ignored_nl result on_op on_lbracket on_rbracket on_nl on_ignored_nl UNK on_period UNK on_lparen # If the machine folder is not a directory then we just return # an empty array since no active machines exist.
result on_op on_lbracket on_rbracket on_nl on_ignored_nl UNK on_period UNK on_lparen true on_rparen on_period each do on_op UNK on_op on_ignored_nl next # Traverse the machines folder accumulate a result
next if on_op UNK on_period UNK on_nl on_ignored_nl name on_op UNK on_period UNK on_period to_s on_period to_sym on_nl UNK on_period # If this isn't a directory then it isn't a machine
next if on_op UNK on_period UNK on_nl on_ignored_nl next if on_op UNK on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period # If this isn't a directory then it isn't a provider
next if on_op UNK on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period file? on_nl on_ignored_nl provider on_op UNK on_period UNK # If this machine doesn't have an ID, then ignore
result on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_op true on_rparen on_ignored_nl UNK on_op false if on_const on_lbracket on_tstring_beg # Return the results
def UNK on_lparen UNK on_op true on_rparen on_ignored_nl UNK on_op false if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ignored_nl # This creates a new batch action, yielding it, and then running it # once the block is called. # # This handles the case where batch actions are disabled by the # VAGRANT_NO_PARALLEL environmental variable.
UNK b on_nl on_ignored_nl b on_period UNK on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen on_op UNK # Yield it so that the caller can setup actions
b on_period UNK on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen on_op UNK on_rparen on_ignored_nl on_const on_period # And run it!
def UNK on_lparen on_op UNK on_rparen on_ignored_nl on_const on_period new on_lparen UNK on_period UNK on_comma self on_rparen on_period UNK on_nl # Makes a call to the CLI with the given arguments as if they # came from the real command line (sometimes they do!). An example: # # env.cli("package", "--vagrantfile", "Vagrantfile") #
def UNK on_lparen on_op opts on_rparen on_ignored_nl opts on_lbracket on_symbeg UNK on_rbracket on_op on_const on_period new on_lparen opts on_lbracket on_symbeg # This returns the provider name for the default provider for this # environment. # # @return [Symbol] Name of the default provider.
on_ignored_nl default on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period to_s on_nl if default on_period empty? on_nl default on_op nil # Implement the algorithm from # https://www.vagrantup.com/docs/providers/basic_usage.html#default-provider # with additional steps 2.5 and 3.5 from # https://bugzilla.redhat.com/show_bug.cgi?id=1444492 # to allow system-configured provider priorities. # # 1. The --provider flag on a vagrant up is chosen above all else, if it is # present. # # (Step 1 is done by the caller; this method is only called if --provider # wasn't given.) # # 2. If the VAGRANT_DEFAULT_PROVIDER environmental variable is set, it # takes next priority and will be the provider chosen.
if default on_op opts on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg default on_embexpr_end on_tstring_content on_tstring_end # If we're forcing the default, just short-circuit and return # that (the default behavior)
UNK on_op vagrantfile on_period config on_nl if opts on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_op vagrantfile on_period UNK on_lparen opts # Determine the config to use to look for provider definitions. By # default it is the global but if we're targeting a specific machine, # then look there.
config on_op UNK on_period UNK on_period UNK on_nl on_ignored_nl usable on_op on_lbracket on_rbracket on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content # Get the list of providers within our configuration, in order.
usable on_op on_lbracket on_rbracket on_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_period UNK on_period each do # Get the list of usable providers with their internally-declared # priorities.
next if opts on_lbracket on_symbeg UNK on_rbracket on_op opts on_lbracket on_symbeg UNK on_rbracket on_period include? on_lparen key on_rparen on_nl on_ignored_nl # Skip excluded providers
if on_op config on_period include? on_lparen key on_rparen on_nl next if UNK on_period key? on_lparen on_symbeg UNK on_rparen on_op on_op # Skip providers that can't be defaulted, unless they're in our # config, in which case someone made our decision for us.
next if opts on_lbracket on_symbeg UNK on_rbracket on_op on_op UNK on_period UNK on_lparen false on_rparen on_nl on_ignored_nl usable on_op on_lbracket # Skip providers that aren't usable.
usable on_op on_lbracket UNK on_lbracket on_symbeg UNK on_rbracket on_comma key on_rbracket on_nl end on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content # Each provider sets its own priority, defaulting to 5 so we can trust # it's always set.
usable on_op usable on_period UNK on_lbrace on_op UNK on_comma b on_op UNK on_lbracket on_int on_rbracket on_op b on_lbracket on_int on_rbracket # Sort the usable providers by priority. Higher numbers are higher # priority, otherwise alpha sort.
if usable on_period include? on_lparen default on_rparen on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg default on_embexpr_end on_tstring_content on_tstring_end on_rparen # If we're not forcing the default, but it's usable and hasn't been # otherwise excluded, return it now.
on_ignored_nl UNK on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen on_ignored_nl on_period UNK on_lparen on_tstring_beg on_tstring_content # 2.5. Vagrant will go through all of the config.vm.provider calls in the # Vagrantfile and try each in order. It will choose the first # provider that is usable and listed in VAGRANT_PREFERRED_PROVIDERS.
on_ignored_nl config on_period each do on_op key on_op on_ignored_nl if usable on_period include? on_lparen key on_rparen on_nl on_ivar on_period debug # 3. Vagrant will go through all of the config.vm.provider calls in the # Vagrantfile and try each in order. It will choose the first provider # that is usable. For example, if you configure Hyper-V, it will never # be chosen on Mac this way. It must be both configured and usable.
on_ignored_nl UNK on_period each do on_op key on_op on_ignored_nl if usable on_period include? on_lparen key on_rparen on_nl on_ivar on_period debug # 3.5. Vagrant will go through VAGRANT_PREFERRED_PROVIDERS and find the # first plugin that reports it is usable.
on_ignored_nl if on_op usable on_period empty? on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg usable on_lbracket on_int on_rbracket on_embexpr_end on_tstring_content # 4. Vagrant will go through all installed provider plugins (including the # ones that come with Vagrant), and find the first plugin that reports # it is usable. There is a priority system here: systems that are known # better have a higher priority than systems that are worse. For # example, if you have the VMware provider installed, it will always # take priority over VirtualBox.
on_ignored_nl raise on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen name on_rparen on_ignored_nl host on_period UNK on_lparen UNK # 5. If Vagrant still has not found any usable providers, it will error.
raise on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen name on_rparen on_ignored_nl host on_period UNK on_lparen UNK on_lparen # No providers available is a critical error for Vagrant.
def UNK on_lparen name on_rparen on_ignored_nl host on_period UNK on_lparen UNK on_lparen name on_rparen on_rparen on_nl end on_nl on_ignored_nl def # Returns whether or not we know how to install the provider with # the given name. # # @return [Boolean]
def UNK on_lparen name on_rparen on_ignored_nl host on_period UNK on_lparen UNK on_lparen name on_rparen on_rparen on_nl end on_nl on_ignored_nl def # Installs the provider with the given name. # # This will raise an exception if we don't know how to install the # provider with the given name. You should guard this call with # `can_install_provider?` for added safety. # # An exception will be raised if there are any failures installing # the provider.
def UNK on_nl on_ivar on_op on_const on_period new on_lparen on_ignored_nl UNK on_comma on_ignored_nl on_label UNK on_lparen on_symbeg hook on_rparen on_comma # Returns the collection of boxes for the environment. # # @return [BoxCollection]
def UNK on_nl return on_ivar if on_ivar on_nl on_ignored_nl UNK on_op nil on_nl UNK on_op nil on_nl UNK on_op UNK # Returns the {Config::Loader} that can be used to load Vagrantfiles # given the settings of this environment. # # @return [Config::Loader]
def UNK on_lparen vagrantfile on_comma on_op opts on_rparen on_ignored_nl path on_op on_const on_period expand_path on_lparen vagrantfile on_comma root_path on_rparen on_nl # Loads another environment for the given Vagrantfile, sharing as much # useful state from this Environment as possible (such as UI and paths). # Any initialization options can be overidden using the opts hash. # # @param [String] vagrantfile Path to a Vagrantfile # @return [Environment]
def hook on_lparen name on_comma opts on_op nil on_rparen on_ignored_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end # This defines a hook point where plugin action hooks that are registered # against the given name will be run in the context of this environment. # # @param [Symbol] name Name of the hook. # @param [Action::Runner] action_runner A custom action runner for running hooks.
def host on_nl return on_ivar if UNK on_lparen on_ivar on_rparen on_nl on_ignored_nl UNK on_op vagrantfile on_period config on_period UNK on_period # Returns the host object associated with this environment. # # @return [Class]
UNK on_op vagrantfile on_period config on_period UNK on_period host on_nl UNK on_op nil if UNK on_op on_symbeg UNK on_nl on_ignored_nl # Determine the host class to use. ":detect" is an old Vagrant config # that shouldn't be valid anymore, but we respect it here by assuming # its old behavior. No need to deprecate this because I thin it is # fairly harmless.
UNK on_op on_const on_period new on_lparen on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_symbeg host on_rparen on_rparen do on_ignored_nl # If the auto-detect failed, then we create a brand new host # with no capabilities and use that. This should almost never happen # since Vagrant works on most host OS's now, so this is a "slow path"
def UNK on_lparen name on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_op opts on_rparen on_ignored_nl f on_op nil on_nl on_ignored_nl return if # This acquires a process-level lock with the given name. # # The lock file is held within the data directory of this environment, # so make sure that all environments that are locking are sharing # the same data directory. # # This will raise Errors::EnvironmentLockedError if the lock can't # be obtained. # # @param [String] name Name of the lock, since multiple locks can # be held at one time.
return if on_op UNK on_nl on_ignored_nl return UNK if on_ivar on_lbracket name on_rbracket on_op opts on_lbracket on_symbeg UNK on_rbracket on_nl # If we don't have a block, then locking is useless, so ignore it
return UNK if on_ivar on_lbracket name on_rbracket on_op opts on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl UNK on_op UNK on_period join # This allows multiple locks in the same process to be nested
UNK on_op UNK on_period join on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl on_ivar on_period debug on_lparen # The path to this lock
UNK f on_period UNK on_lparen on_const on_op on_const on_op on_const on_op on_const on_rparen on_op false on_nl on_ivar on_period UNK on_lparen # The file locking fails only if it returns "false." If it # succeeds it returns a 0, so we must explicitly check for # the proper error case.
on_ivar on_lbracket name on_rbracket on_op true on_nl on_ignored_nl result on_op UNK on_nl UNK on_ignored_nl on_ivar on_period delete on_lparen name on_rparen # Mark that we have a lock
on_ivar on_period delete on_lparen name on_rparen on_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end on_rparen on_nl end # We need to make sure that no matter what this is always # reset to false so we don't think we have a lock when we # actually don't.
if name on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_label true on_rparen do on_ignored_nl f on_period # Clean up the lock file, this requires another lock
return result on_nl UNK on_ignored_nl begin on_ignored_nl f on_period UNK if f on_nl rescue on_const on_nl end on_nl end on_nl # Return the result
def UNK on_lparen name on_rparen on_ignored_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end on_rparen on_nl on_ignored_nl name # This executes the push with the given name, raising any exceptions that # occur. # # Precondition: the push is not nil and exists.
def pushes on_nl self on_period vagrantfile on_period config on_period UNK on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK # The list of pushes defined in this Vagrantfile. # # @return [Array<Symbol>]
def UNK on_lparen name on_comma provider on_comma UNK on_op false on_rparen on_ignored_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name # This returns a machine with the proper provider for this environment. # The machine named by `name` must be in this environment. # # @param [Symbol] name Name of the machine (as configured in the # Vagrantfile). # @param [Symbol] provider The provider that this machine should be # backed by. # @param [Boolean] refresh If true, then if there is a cached version # it is reloaded. # @return [Machine]
UNK on_op on_lbracket name on_comma provider on_rbracket on_nl on_ivar on_op on_lbrace on_rbrace on_nl if UNK on_nl on_ivar on_period info on_lparen # Compose the cache key of the name and provider, and return from # the cache if we have that.
UNK on_op on_ivar on_period join on_lparen on_ignored_nl on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_content on_embexpr_beg provider on_embexpr_end on_tstring_end on_rparen on_nl on_ignored_nl # Determine the machine data directory and pass it to the machine.
on_ivar on_lbracket UNK on_rbracket on_op vagrantfile on_period UNK on_lparen on_ignored_nl name on_comma provider on_comma UNK on_comma UNK on_comma self on_rparen # Create the machine and cache it for future calls. This will also # return the machine from this method.
def UNK on_nl on_ivar on_op on_const on_period new on_lparen on_ivar on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl vagrantfile on_period # The {MachineIndex} to store information about the machines. # # @return [MachineIndex]
def UNK on_nl vagrantfile on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl vagrantfile on_period UNK on_nl end on_nl on_ignored_nl # This returns a list of the configured machines for this environment. # Each of the names returned by this method is valid to be used with # the {#machine} method. # # @return [Array<Symbol>] Configured machine names.
def UNK on_nl vagrantfile on_period UNK on_nl end on_nl on_ignored_nl def root_path on_nl return on_ivar if UNK on_lparen on_ivar on_rparen # This returns the name of the machine that is the "primary." In the # case of a single-machine environment, this is just the single machine # name. In the case of a multi-machine environment, then this can # potentially be nil if no primary machine is specified. # # @return [Symbol]
def root_path on_nl return on_ivar if UNK on_lparen on_ivar on_rparen on_nl on_ignored_nl UNK on_op UNK do on_op path on_op on_ignored_nl # The root path is the path where the top-most (loaded last) # Vagrantfile resides. It can be considered the project root for # this environment. # # @return [String]
UNK on_op UNK on_lparen path on_comma on_ivar on_rparen on_nl return path if UNK on_nl return nil if path on_period UNK # Note: To remain compatible with Ruby 1.8, we have to use # a `find` here instead of an `each`.
def UNK on_nl hook on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def vagrantfile on_nl on_ivar on_op on_const on_period new # Unload the environment, running completion hooks. The environment # should not be used after this (but CAN be, technically). It is # recommended to always immediately set the variable to `nil` after # running this so you can't accidentally run any more methods. Example: # # env.unload # env = nil #
def vagrantfile on_nl on_ivar on_op on_const on_period new on_lparen UNK on_comma on_lbracket on_symbeg UNK on_comma on_symbeg UNK on_rbracket on_rparen on_nl # Represents the default Vagrantfile, or the Vagrantfile that is # in the working directory or a parent of the working directory # of this environment. # # The existence of this function is primarily a convenience. There # is nothing stopping you from instantiating your own {Vagrantfile} # and loading machines in any way you see fit. Typical behavior of # Vagrant, however, loads this Vagrantfile. # # This Vagrantfile is comprised of two major sources: the Vagrantfile # in the user's home directory as well as the "root" Vagrantfile or # the Vagrantfile in the working directory (or parent). # # @return [Vagrantfile]
on_ignored_nl def UNK on_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_end on_rparen on_nl on_ignored_nl UNK on_op on_lbracket #--------------------------------------------------------------- # Load Methods #---------------------------------------------------------------
def UNK on_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_end on_rparen on_nl on_ignored_nl UNK on_op on_lbracket on_ignored_nl # This sets the `@home_path` variable properly. # # @return [Pathname]
UNK on_op on_lbracket on_ignored_nl on_ivar on_comma on_ignored_nl on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_comma on_ignored_nl on_ivar on_comma on_ignored_nl # Setup the list of child directories that need to be created if they # don't already exist.
UNK on_period each do on_op UNK on_op on_ignored_nl next if on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl begin on_ignored_nl # Go through each required directory, creating it if it doesn't exist
begin on_ignored_nl UNK on_op on_lparen on_int on_op on_int on_rparen on_period UNK on_lbrace on_lparen on_int on_op UNK on_lparen on_int on_rparen on_rparen # Attempt to write into the home directory to verify we can
UNK on_op on_lparen on_int on_op on_int on_rparen on_period UNK on_lbrace on_lparen on_int on_op UNK on_lparen on_int on_rparen on_rparen on_period UNK # Append a random suffix to avoid race conditions if Vagrant # is running in parallel with other Vagrant processes.
version_file on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if version_file on_period file? on_nl version on_op version_file on_period # Create the version file that we use to track the structure of # the home directory. If we have an old version, we need to explicitly # upgrade it. Otherwise, we just mark that its the current version.
UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_nl on_ignored_nl version_file on_period delete on_nl UNK on_ignored_nl raise on_const on_op on_const on_comma on_ignored_nl # We're already good, at the latest version.
UNK on_nl on_ignored_nl version_file on_period delete on_nl UNK on_ignored_nl raise on_const on_op on_const on_comma on_ignored_nl on_label on_ivar on_period to_s on_comma # We need to update our directory structure
version_file on_period delete on_nl UNK on_ignored_nl raise on_const on_op on_const on_comma on_ignored_nl on_label on_ivar on_period to_s on_comma on_ignored_nl on_label version # Delete the version file so we put our latest version in
loader_file on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if on_op loader_file on_period file? # Create the rgloader/loader file so we can use encoded files.
def UNK on_lparen UNK on_op false on_rparen on_ignored_nl if on_ivar on_period UNK on_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # This creates the local data directory and show an error if it # couldn't properly be created.
if on_ivar on_period file? on_nl UNK on_lparen on_ivar on_rparen on_nl end on_nl on_ignored_nl return if on_op UNK on_op root_path on_period # If the local data path is a file, then we are probably seeing an # old (V1) "dotfile." In this case, we upgrade it. The upgrade process # will remove the old data file if it is successful.
return if on_op UNK on_op root_path on_period UNK on_nl on_ignored_nl begin on_ignored_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar # If we don't have a root path, we don't setup anything
loader_file on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if on_op loader_file on_period file? # Create the rgloader/loader file so we can use encoded files.
def UNK on_nl UNK on_op nil on_nl on_const on_period UNK do on_op val on_comma UNK on_op on_ignored_nl if val on_period # Attempt to guess the configured provider in use. Will fallback # to the default provider if an explicit provider name is not # provided. This can be pretty error prone, but is used during # initial environment setup to allow loading plugins so it doesn't # need to be perfect # # @return [String]
nil on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl plugins on_op on_lbracket on_rbracket on_nl provider on_op UNK on_nl vagrantfile # if a provider cannot be determined just return nil
def UNK on_nl plugins on_op on_lbracket on_rbracket on_nl provider on_op UNK on_nl vagrantfile on_period UNK on_period each do on_op UNK # Load any configuration provided by guests defined within # the Vagrantfile to pull plugin information they may have # defined.
def UNK on_nl return if on_op on_const on_period UNK on_nl UNK on_op vagrantfile on_period config on_period UNK on_period UNK on_lparen # Check for any local plugins defined within the Vagrantfile. If # found, validate they are available. If they are not available, # request to install them, or raise an exception # # @return [Hash] plugin list for loading
UNK on_op on_const on_op on_const on_period instance on_period UNK on_nl needs_install on_op on_lbracket on_rbracket on_nl UNK on_op UNK on_nl UNK # Check if defined plugins are installed
ui on_period UNK on_lparen on_const on_period t on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_rparen on_nl UNK on_lparen on_op on_int on_rparen on_nl # Force halt after installation and require command to be run again. This # will proper load any new locally installed plugins which are now available.
def UNK on_nl if on_op on_ivar on_period UNK on_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK # This method copies the private key into the home directory if it # doesn't already exist. # # This must be done because `ssh` requires that the key is chmod # 0600, but if Vagrant is installed as a separate user, then the # effective uid won't be able to read the key. So the key is copied # to the home directory and chmod 0600.
if on_const on_op on_const on_period UNK on_lparen on_ivar on_period UNK on_period UNK on_rparen on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ivar on_period # On Windows, permissions don't matter as much, so don't worry # about doing chmod.
def UNK on_lparen UNK on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # Finds the Vagrantfile in the given directory. # # @param [Pathname] path Path to search in. # @return [Pathname]
def UNK on_lparen name on_rparen on_ignored_nl on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_end on_period to_sym on_nl end on_nl on_ignored_nl def UNK # Returns the key used for the host capability for provider installs # of the given name.
def UNK on_nl if on_op on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ivar on_period UNK on_lparen on_const on_period t on_lparen # This upgrades a home directory that was in the v1.1 format to the # v1.5 format. It will raise exceptions if anything fails.
def UNK on_lparen path on_rparen on_ignored_nl on_ivar on_period info on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK on_op path on_period # This upgrades a Vagrant 1.0.x "dotfile" to the new V2 format. # # This is a destructive process. Once the upgrade is complete, the # old dotfile is removed, and the environment becomes incompatible for # Vagrant 1.0 environments. # # @param [Pathname] path The path to the dotfile
UNK on_op path on_period UNK on_period UNK on_nl if UNK on_period UNK on_op on_tstring_beg on_tstring_end on_nl on_ivar on_period info on_lparen # First, verify the file isn't empty. If it is an empty file, we # just delete it and go on with life.
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op nil on_nl begin on_ignored_nl UNK on_op on_const on_period UNK # Otherwise, verify there is valid JSON in here since a Vagrant # environment would always ensure valid JSON. This is a sanity check # to make sure we don't nuke a dotfile that is not ours...
raise on_const on_op on_const on_comma on_ignored_nl on_label path on_period to_s on_nl end on_nl on_ignored_nl UNK on_op path on_period UNK on_period # The file could've been tampered with since Vagrant 1.0.x is # supposed to ensure that the contents are valid JSON. Show an error.
UNK on_op path on_period UNK on_period join on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_period UNK on_embexpr_end on_tstring_end on_rparen on_nl # Alright, let's upgrade this guy to the new structure. Start by # backing up the old dotfile.
UNK on_lparen true on_rparen on_nl on_ignored_nl if UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content # Now, we create the actual local data directory. This should succeed # this time since we renamed the old conflicting V1.
UNK on_op on_ivar on_period join on_lparen on_tstring_beg on_tstring_content on_embexpr_beg name on_embexpr_end on_tstring_content on_tstring_end on_rparen on_nl on_const on_period UNK on_lparen UNK # Create the machine configuration directory
UNK on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op f on_op on_ignored_nl # Write the ID file
on_ivar on_period info on_lparen on_const on_period t on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_label UNK on_period to_s on_rparen on_rparen on_nl # Upgrade complete! Let the user know
