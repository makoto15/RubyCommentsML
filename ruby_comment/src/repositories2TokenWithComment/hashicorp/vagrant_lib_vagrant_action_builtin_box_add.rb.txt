UNK on_const on_nl on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_int on_op on_int on_nl on_ignored_nl def UNK on_lparen # This middleware will download a remote box and add it to the # given box collection.
on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_int on_op on_int on_nl on_ignored_nl def UNK on_lparen UNK on_comma env # This is the size in bytes that if a file exceeds, is considered # to NOT be metadata.
on_const on_op on_int on_op on_int on_op on_int on_nl on_ignored_nl def UNK on_lparen UNK on_comma env on_rparen on_ignored_nl on_ivar on_op UNK # This is the amount of time to "resume" downloads if a partial box # file already exists.
end on_nl end on_nl on_ignored_nl url on_op on_const on_lparen env on_lbracket on_symbeg box_url on_rbracket on_rparen on_period UNK do on_op u # do nothing
u on_op on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_lparen u on_rparen on_embexpr_end on_tstring_end on_nl end on_nl on_ignored_nl if u on_op # On Windows, we need to be careful about drive letters
UNK u on_nl end on_nl on_ignored_nl p on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen u on_period UNK on_lparen # This is not a file URL... carry on
p on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen u on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end # Expand the path and try to use that, if possible
expanded on_op false on_nl url on_period UNK do on_op UNK on_op on_ignored_nl UNK if url on_lbracket UNK on_rbracket on_op on_regexp_beg # If we received a shorthand URL ("mitchellh/precise64"), # then expand it properly.
UNK on_op env on_lbracket on_symbeg UNK on_rbracket on_period UNK on_lparen on_ignored_nl on_symbeg UNK on_comma on_label url on_period UNK on_rparen on_nl # Call the hook to transform URLs into authenticated URLs. # In the case we don't have a plugin that does this, then it # will just return the same URLs.
UNK on_op authed_urls on_period UNK do on_op u on_op on_ignored_nl begin on_ignored_nl UNK on_lparen u on_comma env on_rparen on_nl rescue # Test if any of our URLs point to metadata
def UNK on_lparen UNK on_comma env on_rparen on_ignored_nl env on_lbracket on_symbeg ui on_rbracket on_period UNK on_lparen on_const on_period t on_lparen # Adds a box file directly (no metadata component, versioning, # etc.) # # @param [Array<String>] urls # @param [Hash] env
def UNK on_lparen url on_comma env on_comma expanded on_rparen on_ignored_nl UNK on_op env on_lbracket on_symbeg box_url on_rbracket on_nl provider on_op # Adds a box given that the URL is a metadata document. # # @param [String | Array<String>] url The URL of the metadata for # the box to add. If this is an array, then it must be a two-element # array where the first element is the original URL and the second # element is an authenticated URL. # @param [Hash] env # @param [Bool] expanded True if the metadata URL was expanded with # a Atlas server URL.
UNK on_op url on_lbracket on_int on_rbracket on_nl url on_op url on_lbracket on_int on_rbracket on_nl end on_nl on_ignored_nl UNK on_op on_const # We have both a normal URL and "authenticated" URL. Split # them up.
provider on_period UNK do on_op p on_op on_ignored_nl metadata_provider on_op metadata_version on_period provider on_lparen p on_rparen on_nl UNK if metadata_provider # If a provider was specified, make sure we get that specific # version.
metadata_provider on_op metadata_version on_period provider on_lparen on_ignored_nl metadata_version on_period providers on_period UNK on_rparen on_nl UNK on_ignored_nl providers on_op metadata_version on_period # If we have only one provider in the metadata, just use that # provider.
choice on_op env on_lbracket on_symbeg ui on_rbracket on_period UNK on_lparen on_const on_period t on_lparen on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl # We have more than one provider, ask the user what they want
UNK on_op env on_lbracket on_symbeg UNK on_rbracket on_period UNK on_lparen on_symbeg UNK on_comma on_label on_lbracket UNK on_rbracket on_rparen on_nl authed_urls # Authenticate the provider URL since we're using auth
def UNK on_lparen UNK on_comma name on_comma version on_comma provider on_comma UNK on_comma env on_comma on_op opts on_rparen on_ignored_nl env # Shared helper to add a box once you know various details # about it. Shared between adding via metadata or by direct. # # @param [Array<String>] urls # @param [String] name # @param [String] version # @param [String] provider # @param [Hash] env # @return [Box]
if provider on_op on_op env on_lbracket on_symbeg UNK on_rbracket on_nl box on_op env on_lbracket on_symbeg UNK on_rbracket on_period UNK on_lparen # Verify the box we're adding doesn't already exist
box on_op nil on_nl begin on_ignored_nl box_url on_op nil on_nl on_ignored_nl UNK on_period UNK do on_op url on_op on_ignored_nl show_url # Now we have a URL, we have to download this URL.
raise if UNK on_period length on_op on_int on_nl on_ignored_nl env on_lbracket on_symbeg ui on_rbracket on_period UNK on_lparen on_const on_period t # If we don't have multiple URLs, just raise the error
box on_op env on_lbracket on_symbeg UNK on_rbracket on_period UNK on_lparen on_ignored_nl box_url on_comma name on_comma version on_comma on_ignored_nl on_label env # Add the box!
if on_op on_ivar on_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg box_url on_embexpr_end on_tstring_end on_rparen on_nl begin on_ignored_nl box_url on_period # Make sure we delete the temporary file after we add it, # unless we were interrupted, in which case we keep it around # so we can resume the download later.
end on_nl end on_nl end on_nl on_ignored_nl env on_lbracket on_symbeg ui on_rbracket on_period UNK on_lparen on_const on_period t on_lparen on_ignored_nl # Not a big deal, the temp file may not actually exist
env on_lbracket on_symbeg UNK on_rbracket on_op box on_nl on_ignored_nl box on_nl end on_nl on_ignored_nl def UNK on_lparen url on_comma env # Store the added box in the env for future middleware
def UNK on_lparen url on_comma env on_comma on_op opts on_rparen on_ignored_nl opts on_lbracket on_symbeg ui on_rbracket on_op true if on_op # Returns the download options for the download. # # @return [Hash]
if temp_path on_period file? on_nl delete on_op false on_nl if env on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_period info on_lparen # If the temporary path exists, verify it is not too old. If its # too old, delete it first because the data may have changed.
if opts on_lbracket on_symbeg ui on_rbracket on_nl show_url on_op opts on_lbracket on_symbeg show_url on_rbracket on_nl show_url on_op url on_nl display_url # Download the box to a temporary path. We store the temporary # path as an instance variable so that the `#recover` method can # access it.
if show_url on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl env # Adjust status message when 'downloading' a local box.
on_ivar on_op true on_nl env on_lbracket on_symbeg ui on_rbracket on_period info on_lparen on_const on_period t on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # The downloader was interrupted, so just return, because that # means we were interrupted as well.
def UNK on_lparen url on_comma env on_rparen on_ignored_nl d on_op UNK on_lparen url on_comma env on_comma on_label true on_comma on_label # Tests whether the given URL points to a metadata file or a # box file without completely downloading the file. # # @param [String] url # @return [Boolean] true if metadata
UNK on_op on_const on_period UNK on_lparen d on_period UNK on_rparen on_nl if UNK on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl # If we're downloading a file, cURL just returns no # content-type (makes sense), so we just test if it is JSON # by trying to parse JSON!
on_const on_op on_const on_period UNK on_op url on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl url #7570 Strip leading slash left in front of drive letter by uri.path
return false on_nl end on_nl on_ignored_nl on_const on_period new on_lparen UNK on_rparen on_nl end on_nl return true on_nl rescue on_const # Quit early, don't try to parse the JSON of gigabytes # of box files...
return false on_nl rescue on_const on_op on_const on_nl return false on_nl rescue on_const on_op on_const on_nl return false on_nl end # Actually not sure what causes this, but its always # in a case that isn't true.
if on_op UNK on_period UNK on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ivar on_period info on_lparen on_tstring_beg # If this isn't HTTP, then don't do the HEAD request
