UNK on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl on_const # Represents a collection a boxes found on disk. This provides methods # for accessing/finding individual boxes, adding new boxes, or deleting # boxes.
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl # The directory where the boxes in this collection are stored. # # A box collection matches a very specific folder structure that Vagrant # expects in order to easily manage and modify boxes. The folder structure # is the following: # # COLLECTION_ROOT/BOX_NAME/PROVIDER/metadata.json # # Where: # # * COLLECTION_ROOT - This is the root of the box collection, and is # the directory given to the initializer. # * BOX_NAME - The name of the box. This is a logical name given by # the user of Vagrant. # * PROVIDER - The provider that the box was built for (VirtualBox, # VMware, etc.). # * metadata.json - A simple JSON file that at the bare minimum # contains a "provider" key that matches the provider for the # box. This metadata JSON, however, can contain anything. # # @return [Pathname]
def UNK on_lparen UNK on_comma UNK on_op nil on_rparen on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl on_ignored_nl on_ivar on_op UNK on_nl # Initializes the collection. # # @param [Pathname] directory The directory that contains the collection # of boxes.
def UNK on_lparen UNK on_comma name on_comma version on_comma on_op UNK on_rparen on_ignored_nl providers on_op UNK on_lbracket on_symbeg providers on_rbracket # This adds a new box to the system. # # There are some exceptional cases: # * BoxAlreadyExists - The box you're attempting to add already exists. # * BoxProviderDoesntMatch - If the given box provider doesn't match the # actual box provider in the untarred box. # * BoxUnpackageFailure - An invalid tar file. # # Preconditions: # * File given in `path` must exist. # # @param [Pathname] path Path to the box file on disk. # @param [String] name Logical name for the box. # @param [String] version The version of this box. # @param [Array<String>] providers The providers that this box can # be a part of. This will be verified with the `metadata.json` and is # meant as a basic check. If this isn't given, then whatever provider # the box represents will be added. # @param [Boolean] force If true, any existing box with the same name # and provider will be replaced.
UNK on_op UNK do on_op UNK on_op on_ignored_nl box on_op UNK on_lparen name on_comma UNK on_comma version on_rparen on_nl next # A helper to check if a box exists. We store this in a variable # since we call it multiple times.
on_ivar on_period UNK on_lparen on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_ignored_nl on_tstring_beg on_embexpr_beg name on_embexpr_end on_tstring_content on_embexpr_beg version on_embexpr_end on_tstring_content on_embexpr_beg # We're forcing, so just delete the old box
UNK on_period UNK on_lparen providers on_rparen if providers on_nl on_ignored_nl UNK do on_op temp_dir on_op on_ignored_nl on_ivar on_period debug on_lparen # Verify the box doesn't exist early if we're given a provider. This # can potentially speed things up considerably since we don't need # to unpack any files.
UNK do on_op temp_dir on_op on_ignored_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg temp_dir on_embexpr_end on_tstring_end on_rparen on_nl UNK on_op # Create a temporary directory since we're not sure at this point if # the box we're unpackaging already exists (if no provider was given)
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg temp_dir on_embexpr_end on_tstring_end on_rparen on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen # Extract the box into a temporary directory.
if UNK on_lparen temp_dir on_rparen on_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl temp_dir on_op UNK on_lparen temp_dir # If we get a V1 box, we want to update it in place
UNK on_lparen temp_dir on_rparen do on_op UNK on_op on_ignored_nl box on_op on_const on_period new on_lparen name on_comma nil on_comma version # We re-wrap ourselves in the safety net in case we upgraded. # If we didn't upgrade, then this is still safe because the # helper will only delete the directory if it exists
box on_op on_const on_period new on_lparen name on_comma nil on_comma version on_comma UNK on_rparen on_nl on_ignored_nl UNK on_op box on_period # Get an instance of the box we just added before it is finalized # in the system so we can inspect and use its metadata.
UNK on_op box on_period UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ignored_nl if providers on_nl UNK on_op providers on_period UNK # Get the provider, since we'll need that to at the least add it # to the system or check that it matches what is given to us.
UNK on_period UNK on_lparen on_lbracket UNK on_rbracket on_rparen on_nl end on_nl on_ignored_nl provider on_op UNK on_period UNK on_nl on_ignored_nl UNK # Verify the box doesn't already exist
provider on_op UNK on_period UNK on_nl on_ignored_nl UNK on_op on_ivar on_period join on_lparen UNK on_lparen name on_rparen on_rparen on_nl UNK # We weren't given a provider, so store this one.
UNK on_op on_ivar on_period join on_lparen UNK on_lparen name on_rparen on_rparen on_nl UNK on_op UNK on_period join on_lparen version on_rparen # Create the directory for this box, not including the provider
UNK on_op UNK on_period join on_lparen provider on_period to_s on_rparen on_nl if UNK on_period UNK on_nl on_ivar on_period debug on_lparen # This is the final directory we'll move it to
UNK on_period UNK on_nl on_ignored_nl UNK on_op on_lbracket on_lbracket UNK on_comma UNK on_rbracket on_rbracket on_nl UNK on_op UNK on_period UNK # Move to final destination
UNK on_op on_lbracket on_lbracket UNK on_comma UNK on_rbracket on_rbracket on_nl UNK on_op UNK on_period UNK on_nl UNK on_comma UNK on_op # Recursively move individual files from the temporary directory # to the final location. We do this instead of moving the entire # directory to avoid issues on Windows. [GH-1424]
if f on_period directory? on_nl UNK on_period UNK on_nl UNK on_op on_lbracket f on_comma UNK on_rbracket on_nl next on_nl end # We don't copy entire directories, so create the # directory and then add to our list to copy.
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg f on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end on_rparen on_nl on_const on_period UNK on_lparen # Copy the single file
UNK on_lparen name on_comma provider on_comma version on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl # Return the box
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl on_ignored_nl UNK do on_ignored_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg on_ivar # This returns an array of all the boxes on the system, given by # their name and their provider. # # @return [Array] Array of `[name, version, provider]` of the boxes # installed on this system.
next if on_op child on_period directory? on_nl on_ignored_nl box_name on_op UNK on_lparen child on_period basename on_period to_s on_rparen on_nl on_ignored_nl # Ignore non-directories, since files are not interesting to # us in our folder structure.
child on_period children on_lparen true on_rparen on_period each do on_op versiondir on_op on_ignored_nl next if on_op versiondir on_period directory? on_nl # Otherwise, traverse the subdirectories and see what versions # we have.
if on_op on_const on_op on_const on_period UNK on_lparen version on_rparen on_nl UNK on_op on_const on_op on_const on_op on_const on_period new # Ensure version of box is correct before continuing
if provider on_period directory? on_op provider on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_nl UNK on_op provider on_period # Verify this is a potentially valid box. If it looks # correct enough then include it.
UNK on_period UNK do on_op UNK on_op on_ignored_nl on_lbracket UNK on_lbracket UNK on_rbracket on_comma UNK on_lbracket UNK on_rbracket on_comma on_const # Sort the list to group like providers and properly ordered versions
def UNK on_lparen name on_comma providers on_comma version on_rparen on_ignored_nl providers on_op on_const on_lparen providers on_rparen on_nl on_ignored_nl UNK on_op # Find a box in the collection with the given name and provider. # # @param [String] name Name of the box (logical name). # @param [Array] providers Providers that the box implements. # @param [String] version Version constraints to adhere to. Example: # "~> 1.0" or "= 1.0, ~> 1.1" # @return [Box] The box found, or `nil` if not found.
UNK on_op version on_period to_s on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK do on_op v on_op on_ignored_nl on_const # Build up the requirements we have
UNK on_op on_lbrace on_rbrace on_nl on_ignored_nl UNK on_op UNK on_period children on_lparen true on_rparen on_period UNK do on_op versiondir on_op # Keep a mapping of Gem::Version mangled versions => directories. # ie. 0.1.0.pre.alpha.2 => 0.1.0-alpha.2 # This is so we can sort version numbers properly here, but still # refer to the real directory names in path checks below and pass an # unmangled version string to Box.new
UNK on_period UNK on_period UNK on_period each do on_op v on_op on_ignored_nl if on_op UNK on_period UNK on_lbrace on_op UNK # Traverse through versions with the latest version first
next on_nl end on_nl on_ignored_nl versiondir on_op UNK on_period join on_lparen UNK on_lbracket v on_period to_s on_rbracket on_rparen on_nl providers # Unsatisfied version requirements
def UNK on_nl UNK do on_ignored_nl temp_dir on_op on_const on_period new on_lparen on_const on_period UNK on_lparen on_const on_comma on_ivar on_rparen # This upgrades a v1.1 - v1.4 box directory structure up to a v1.5 # directory structure. This will raise exceptions if it fails in any # way.
next if on_op boxdir on_period directory? on_nl on_ignored_nl box_name on_op boxdir on_period basename on_period to_s on_nl on_ignored_nl if UNK on_lparen # Ignore all non-directories because they can't be boxes
if UNK on_lparen boxdir on_rparen on_nl UNK on_op UNK on_lparen boxdir on_rparen on_nl on_const on_period UNK on_lparen UNK on_comma boxdir # If it is a v1 box, then we need to upgrade it first
UNK on_op temp_dir on_period join on_lparen UNK on_lparen box_name on_rparen on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_period UNK on_nl # Create the directory for this box
boxdir on_period children on_lparen true on_rparen on_period each do on_op UNK on_op on_ignored_nl on_const on_period UNK on_lparen UNK on_comma UNK # Go through each provider and move it
on_ivar on_period UNK on_nl on_const on_period UNK on_lparen temp_dir on_period to_s on_comma on_ivar on_period to_s on_rparen on_nl end on_nl end # Move the folder into place
def UNK on_lparen name on_rparen on_ignored_nl UNK UNK if UNK on_lparen name on_rparen on_nl UNK on_op on_const on_period join on_lparen # Cleans the directory for a box by removing the folders that are # empty.
def UNK on_lparen name on_rparen on_ignored_nl name on_op name on_period UNK on_nl name on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma # Returns the directory name for the box of the given name. # # @param [String] name # @return [String]
def UNK on_lparen name on_rparen on_ignored_nl name on_op name on_period UNK on_nl name on_period UNK on_lparen on_const on_comma on_tstring_beg on_tstring_content # Returns the directory name for the box cleaned up
def UNK on_lparen dir on_rparen on_ignored_nl dir on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_nl end on_nl on_ignored_nl # This checks if the given directory represents a V1 box on the # system. # # @param [Pathname] dir Directory where the box is unpacked. # @return [Boolean]
dir on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen dir on_rparen on_ignored_nl # We detect a V1 box given by whether there is a "box.ovf" which # is a heuristic but is pretty accurate.
def UNK on_lparen dir on_rparen on_ignored_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg dir on_embexpr_end on_tstring_end on_rparen on_nl on_ignored_nl temp_dir # This upgrades the V1 box contained unpacked in the given directory # and returns the directory of the upgraded version. This is # _destructive_ to the contents of the old directory. That is, the # contents of the old V1 box will be destroyed or moved. # # Preconditions: # * `dir` is a valid V1 box. Verify with {#v1_box?} # # @param [Pathname] dir Directory where the V1 box is unpacked. # @return [Pathname] Path to the unpackaged V2 box.
dir on_period children on_lparen true on_rparen on_period each do on_op child on_op on_ignored_nl next if child on_op temp_dir on_nl on_ignored_nl # Move all the things into the temporary directory
next if child on_op temp_dir on_nl on_ignored_nl on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg child on_embexpr_end on_tstring_end on_rparen on_nl on_const # Don't move the temp_dir
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_embexpr_beg child on_embexpr_end on_tstring_end on_rparen on_nl on_const on_period UNK on_lparen child on_comma temp_dir on_period # Move every other directory into the temporary directory
UNK on_op temp_dir on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if on_op UNK on_period UNK on_nl UNK on_period UNK # If there is no metadata.json file, make one, since this is how # we determine if the box is a V2 box.
temp_dir on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK do on_ignored_nl UNK UNK on_nl end on_nl end on_nl # Return the temporary directory
def UNK on_nl on_ivar on_period UNK do on_ignored_nl UNK UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen dir # This locks the region given by the block with a lock on this # collection.
def UNK on_lparen dir on_op nil on_rparen on_ignored_nl dir on_op on_const on_period UNK on_lparen on_const on_comma on_ivar on_rparen on_nl dir # This is a helper that makes sure that our temporary directories # are cleaned up no matter what. # # @param [String] dir Path to a temporary directory # @return [Object] The result of whatever the yield is
def UNK on_lparen box_name on_rparen on_ignored_nl UNK on_period UNK on_lbrace on_op box on_op box on_period UNK on_period UNK on_lparen box_name # Checks if a box with a given name exists.
