UNK on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op UNK # MachineIndex is able to manage the index of created Vagrant environments # in a central location. # # The MachineIndex stores a mapping of UUIDs to basic information about # a machine. The UUIDs are stored with the Vagrant environment and are # looked up in the machine index. # # The MachineIndex stores information such as the name of a machine, # the directory it was last seen at, its last known state, etc. Using # this information, we can load the entire {Machine} object for a machine, # or we can just display metadata if needed. # # The internal format of the data file is currently JSON in the following # structure: # # { # "version": 1, # "machines": { # "uuid": { # "name": "foo", # "provider": "vmware_fusion", # "data_path": "/path/to/data/dir", # "vagrantfile_path": "/path/to/Vagrantfile", # "state": "running", # "updated_at": "2014-03-02 11:11:44 +0100" # } # } # } #
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Initializes a MachineIndex at the given file location. # # @param [Pathname] data_dir Path to the directory where data for the # index can be stored. This folder should exist and must be writable.
def UNK on_lparen entry on_rparen on_ignored_nl return UNK if on_op entry on_period id on_nl on_ignored_nl on_ivar on_period synchronize do on_ignored_nl # Deletes a machine by UUID. # # The machine being deleted with this UUID must either be locked # by this index or must be unlocked. # # @param [Entry] entry The entry to delete. # @return [Boolean] true if delete is successful
if on_op on_ivar on_lbracket entry on_period id on_rbracket on_nl raise on_tstring_beg on_tstring_content UNK entry on_period id UNK on_tstring_end on_nl end # If we don't have the lock, then we need to acquire it.
unlocked_reload on_nl on_ivar on_period UNK on_lparen entry on_period id on_rparen on_nl UNK on_nl on_ignored_nl UNK on_lparen entry on_period id on_rparen # Reload so we have the latest data, then delete and save
UNK on_lparen entry on_period id on_rparen on_nl end on_nl end on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen # Release access on this machine
def UNK on_lparen UNK on_op false on_rparen on_ignored_nl if UNK on_nl on_ivar on_period synchronize do on_ignored_nl with_index_lock do on_ignored_nl unlocked_reload # Iterate over every machine in the index. The yielded {Entry} objects # will NOT be locked, so you'll have to call {#get} manually to acquire # the lock on them.
def UNK on_lparen uuid on_rparen on_ignored_nl entry on_op nil on_nl on_ignored_nl on_ivar on_period synchronize do on_ignored_nl with_index_lock do on_ignored_nl unlocked_reload # Accesses a machine by UUID and returns a {MachineIndex::Entry} # # The entry returned is locked and can't be read again or updated by # this process or any other. To unlock the machine, call {#release} # with the entry. # # You can only {#set} an entry (update) when the lock is held. # # @param [String] uuid UUID for the machine to access. # @return [MachineIndex::Entry]
unlocked_reload on_nl on_ignored_nl data on_op UNK on_lparen uuid on_rparen on_nl return nil if on_op data on_nl uuid on_op data on_lbracket # Reload the data
lock_file on_op UNK on_lparen uuid on_rparen on_nl if on_op lock_file on_nl raise on_const on_op on_const on_comma on_ignored_nl on_label entry on_period # Lock this machine
def UNK on_lparen uuid on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl with_index_lock do on_ignored_nl unlocked_reload on_nl return on_op on_op UNK # Tests if the index has the given UUID. # # @param [String] uuid # @return [Boolean]
def UNK on_lparen entry on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl UNK on_lparen entry on_period id on_rparen on_nl end on_nl # Releases an entry, unlocking it. # # This is an idempotent operation. It is safe to call this even if you're # unsure if an entry is locked or not. # # After calling this, the previous entry should no longer be used. # # @param [Entry] entry
def UNK on_lparen entry on_rparen on_ignored_nl UNK on_op entry on_period UNK on_nl on_ignored_nl id on_op entry on_period id on_nl on_ignored_nl # Creates/updates an entry object and returns the resulting entry. # # If the entry was new (no UUID), then the UUID will be set on the # resulting entry and can be used. Additionally, the a lock will # be created for the resulting entry, so you must {#release} it # if you want others to be able to access it. # # If the entry isn't new (has a UUID). then this process must hold # that entry's lock or else this set will fail. # # @param [Entry] entry # @return [Entry]
UNK on_op entry on_period UNK on_nl on_ignored_nl id on_op entry on_period id on_nl on_ignored_nl on_ivar on_period synchronize do on_ignored_nl with_index_lock # Get the struct and update the updated_at attribute
id on_op entry on_period id on_nl on_ignored_nl on_ivar on_period synchronize do on_ignored_nl with_index_lock do on_ignored_nl unlocked_reload on_nl on_ignored_nl if on_op # Set an ID if there isn't one already set
unlocked_reload on_nl on_ignored_nl if on_op id on_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl if entry on_period name on_op # Reload so we have the latest machine data. This allows other # processes to update their own machines without conflicting # with our own.
if on_op id on_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl if entry on_period name on_op UNK on_period name # If we don't have a machine ID, try to look one up
id on_op on_const on_period uuid on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen if on_op id on_nl on_ignored_nl # If we still don't have an ID, generate a random one
lock_file on_op UNK on_lparen id on_rparen on_nl if on_op lock_file on_nl raise on_tstring_beg on_tstring_content UNK entry on_period name UNK on_tstring_end # Get a lock on this machine
on_ivar on_lbracket id on_rbracket on_op UNK on_nl UNK on_nl end on_nl end on_nl on_ignored_nl on_const on_period new on_lparen id on_comma # Set our machine and save
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_period UNK do on_op uuid on_comma data on_op on_ignored_nl return data on_period UNK # Finds a machine where the UUID is prefixed by the given string. # # @return [Hash]
def UNK on_lparen uuid on_rparen on_ignored_nl UNK on_op on_ivar on_period UNK on_lparen on_tstring_beg UNK uuid UNK on_tstring_content on_tstring_end on_rparen on_nl # Locks a machine exclusively to us, returning the file handle # that holds the lock. # # If the lock cannot be acquired, then nil is returned. # # This should be called within an index lock. # # @return [File]
def UNK on_lparen id on_rparen on_ignored_nl lock_file on_op on_ivar on_lbracket id on_rbracket on_nl if lock_file on_nl lock_file on_period UNK on_nl # Releases a local lock on a machine. This does not acquire any locks # so make sure to lock around it. # # @param [String] id
end on_nl on_ignored_nl on_ivar on_period UNK on_lparen id on_rparen on_nl end on_nl end on_nl on_ignored_nl def unlocked_reload on_nl return if # Another process is probably opened it, no problem.
def unlocked_reload on_nl return if on_op on_ivar on_period UNK on_nl on_ignored_nl data on_op nil on_nl UNK on_ignored_nl data on_op on_const # This will reload the data without locking the index. It is assumed # the caller with lock the index outside of this call. # # @param [File] f
def UNK on_nl on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do on_op UNK on_op on_ignored_nl UNK on_period UNK on_lparen # Saves the index.
def with_index_lock on_nl UNK on_op on_tstring_beg UNK on_ivar UNK on_tstring_content on_tstring_end on_nl on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content # This will hold a lock to the index so it can be read or updated.
UNK on_const on_nl UNK on_symbeg id on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg name on_nl on_ignored_nl attr_accessor on_symbeg # An entry in the MachineIndex.
UNK on_symbeg id on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg name on_nl on_ignored_nl attr_accessor on_symbeg provider on_nl on_ignored_nl # The unique ID for this entry. This is _not_ the ID for the # machine itself (which is provider-specific and in the data directory). # # @return [String]
attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg name on_nl on_ignored_nl attr_accessor on_symbeg provider on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl # The path for the "local data" directory for the environment. # # @return [Pathname]
attr_accessor on_symbeg name on_nl on_ignored_nl attr_accessor on_symbeg provider on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl # The name of the machine. # # @return [String]
attr_accessor on_symbeg provider on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl # The name of the provider. # # @return [String]
attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl # The last known state of this machine. # # @return [String]
attr_accessor on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl # The valid Vagrantfile filenames for this environment. # # @return [Array<String>]
attr_accessor on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen id on_op # The path to the Vagrantfile that manages this machine. # # @return [Pathname]
UNK on_symbeg UNK on_nl on_ignored_nl attr_accessor on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen id on_op nil on_comma raw on_op nil # The last time this entry was updated. # # @return [DateTime]
attr_accessor on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen id on_op nil on_comma raw on_op nil on_rparen on_ignored_nl on_ivar on_op on_lbrace # Extra data to store with the index entry. This can be anything # and is treated like a general global state bag. # # @return [Hash]
def UNK on_lparen id on_op nil on_comma raw on_op nil on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ignored_nl return if # Initializes an entry. # # The parameter given should be nil if this is being created # publicly.
return if on_op raw on_nl on_ignored_nl on_ivar on_op id on_nl on_ivar on_op raw on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ivar # Do nothing if we aren't given a raw value. Otherwise, parse it.
on_ivar on_op raw on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl on_ivar on_op raw on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_lbrace on_rbrace # TODO(mitchellh): parse into a proper datetime
on_ivar on_op nil if on_ivar on_op on_tstring_beg on_tstring_end on_nl on_ivar on_op nil if on_ivar on_op on_tstring_beg on_tstring_end on_nl on_ignored_nl on_ivar # Be careful with the paths
on_ivar on_op on_const on_period new on_lparen on_ivar on_rparen if on_ivar on_nl on_ivar on_op on_const on_period new on_lparen on_ivar on_rparen if # Convert to proper types
def UNK on_lparen UNK on_rparen on_ignored_nl return false if on_op UNK on_nl return false if on_op UNK on_period UNK on_nl # Returns boolean true if this entry appears to be valid. # The criteria for being valid: # # * Vagrantfile directory exists # * Vagrant environment contains a machine with this # name and provider. # # This method is _slow_. It should be used with care. # # @param [Pathname] home_path The home path for the Vagrant # environment. # @return [Boolean]
UNK on_op false on_nl UNK on_op UNK on_lparen UNK on_rparen on_nl UNK on_period UNK on_period UNK do on_op name on_comma # Create an environment so we can determine the active # machines...
return false if on_op UNK on_nl on_ignored_nl UNK on_op nil on_nl UNK on_ignored_nl UNK on_op UNK on_period UNK on_lparen UNK # If an active machine of the same name/provider was not # found, it is already false.
UNK on_op nil on_nl UNK on_ignored_nl UNK on_op UNK on_period UNK on_lparen UNK on_period name on_period UNK on_comma UNK on_period # Get the machine
return false if UNK on_period UNK on_period id on_op on_const on_op on_const on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl def # Refresh the machine state
def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_period UNK do on_ignored_nl on_const on_period # Creates a {Vagrant::Environment} for this entry. # # @return [Vagrant::Environment]
def UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_period to_s on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_comma # Converts to the structure used by the JSON
