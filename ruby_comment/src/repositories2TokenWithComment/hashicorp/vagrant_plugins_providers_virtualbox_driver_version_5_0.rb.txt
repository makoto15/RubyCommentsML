UNK on_const on_op on_const on_nl def UNK on_lparen uuid on_rparen on_ignored_nl UNK on_lparen on_rparen on_nl on_ignored_nl on_ivar on_op on_const on_op # Driver for VirtualBox 5.0.x
def UNK on_lparen UNK on_comma UNK on_comma UNK on_comma type on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_op UNK on_rparen on_ignored_nl UNK # Controller-Port-Device looks like: # SATA Controller-ImageUUID-0-0 (sub out ImageUUID) # - Controller: SATA Controller # - Port: 0 # - Device: 0 # # @param [String] port - port on device to attach disk to # @param [String] device - device on controller for disk # @param [String] file - disk file path # @param [String] type - type of disk to attach # @param [Hash] opts - additional options
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma # Maybe only support SATA Controller for `:disk`???
def UNK on_lparen source on_comma destination on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma source # @param [String] source # @param [String] destination # @param [String] disk_format
def UNK on_lparen UNK on_rparen on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end # Removes a disk from the given virtual machine # # @param [String] disk_uuid or file path # @param [Hash] opts - additional options
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_op UNK on_rparen on_ignored_nl execute on_lparen on_tstring_beg # Creates a disk. Default format is VDI unless overridden # # @param [String] disk_file # @param [Integer] disk_size - size in bytes # @param [String] disk_format - format of disk, defaults to "VDI" # @param [Hash] opts - additional options
execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_label true on_rparen on_op on_regexp_beg on_tstring_content on_regexp_end on_nl name on_op # Create the interface
ip on_op on_const on_period UNK on_lparen options on_lbracket on_symbeg UNK on_rbracket on_rparen on_nl on_ignored_nl if ip on_period UNK on_nl execute # Get the IP so we can determine v4 vs v6
if ip on_period UNK on_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma name on_comma on_ignored_nl on_tstring_beg on_tstring_content # Configure
return on_lbrace on_ignored_nl on_label name on_comma on_ignored_nl on_label options on_lbracket on_symbeg UNK on_rbracket on_comma on_ignored_nl on_label options on_lbracket on_symbeg netmask # Return the details
last on_op on_int on_nl total on_op on_tstring_beg on_tstring_end on_nl UNK on_int if UNK on_nl on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end # Start with 0%
execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma machine_id on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma snapshot_name on_comma on_label true on_rparen do on_op type # Snapshot and report the % progress
total on_op data on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_ignored_nl lines on_op total on_period split # Append the data so we can see the full view
lines on_op total on_period split on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl match on_op on_regexp_beg on_tstring_content on_regexp_end on_period match on_lparen # Break up the lines. We can't get the progress until we see an "OK"
match on_op on_regexp_beg on_tstring_content on_regexp_end on_period match on_lparen lines on_period last on_rparen on_nl if match on_nl current on_op match on_lbracket # The progress of the import will be in the last line. Do a greedy # regular expression to find what we're looking for.
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl tmp_drive on_op on_lbrace on_rbrace on_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Lists all attached harddisks from a given virtual machine. Additionally, # this method adds a new key "Disk Name" based on the disks file path from "Location" # # @return [Array] hdds An array of hashes of harddrive info for a guest
UNK on_op tmp_drive on_nl tmp_drive on_op on_lbrace on_rbrace on_nl UNK on_nl end on_nl UNK on_op line on_period UNK on_lparen on_tstring_beg # separator between disks
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma # @param [String] port - port on device to attach disk to # @param [String] device - device on controller for disk # @param [Hash] opts - additional options
def UNK on_lparen UNK on_comma UNK on_comma on_op UNK on_rparen on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma UNK on_comma on_tstring_beg # @param [String] disk_file # @param [Integer] disk_size in bytes # @param [Hash] opts - additional options
last on_op on_int on_nl total on_op on_tstring_beg on_tstring_end on_nl UNK on_int if UNK on_nl on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end # Start with 0%
total on_op data on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_ignored_nl lines on_op total on_period split # Append the data so we can see the full view
lines on_op total on_period split on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl match on_op on_regexp_beg on_tstring_content on_regexp_end on_period match on_lparen # Break up the lines. We can't get the progress until we see an "OK"
match on_op on_regexp_beg on_tstring_content on_regexp_end on_period match on_lparen lines on_period last on_rparen on_nl if match on_nl current on_op match on_lbracket # The progress of the import will be in the last line. Do a greedy # regular expression to find what we're looking for.
end on_nl end on_nl end on_nl on_ignored_nl UNK on_period each do on_op name on_op on_ignored_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # VirtualBox could not find the vm. It may have been deleted # by another process after we called 'vboxmanage list vms'? Ignore this error.
UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma name on_rparen on_nl on_ignored_nl execute on_lparen # First try to remove any DHCP servers attached. We use `raw` because # it is okay if this fails. It usually means that a DHCP server was # never attached.
execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma name on_comma on_label true on_rparen on_nl end on_nl end on_nl # Delete the actual host only network interface.
raise on_const on_op on_const on_op on_const on_comma on_ignored_nl on_label e on_period extra_data on_lbracket on_symbeg stderr on_rbracket on_nl end on_nl end # If the file already exists we'll throw a custom error
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_nl on_ignored_nl UNK on_op on_lbrace on_rbrace on_nl UNK on_op UNK on_period # Returns port and device for an attached disk given a disk uuid. Returns # empty hash if disk is not attachd to guest # # @param [Hash] vm_info - A guests information from vboxmanage # @param [String] disk_uuid - the UUID for the disk we are searching for # @return [Hash] disk_info - Contains a device and port number
on_ivar on_period debug on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl output on_op execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end # Dry-run the import to get the suggested name and path
specified_name on_op on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg on_lparen on_const on_period UNK on_period UNK on_op UNK on_rparen on_period to_i on_embexpr_end # Append millisecond plus a random to the path in case we're # importing the same box elsewhere.
UNK on_op on_lbracket on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma specified_name on_comma on_ignored_nl # Build the specified name param list
disk_params on_op on_lbracket on_rbracket on_nl UNK on_op output on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl UNK on_period each do # Extract the disks list and build the disk target params
disk_params on_op path on_period reverse on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end on_period reverse on_rparen on_lbrace on_tstring_beg # we use the block form of sub here to ensure that if the specified_name happens to end with a number (which is fairly likely) then # we won't end up having the character sequence of a \ followed by a number be interpreted as a back reference. For example, if # specified_name were "abc123", then "\\abc123\\".reverse would be "\\321cba\\", and the \3 would be treated as a back reference by the sub
UNK on_ignored_nl disk_params on_op path on_period reverse on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end on_period reverse on_comma # Replace only last occurrence
end on_nl end on_nl on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma UNK on_comma on_op UNK on_comma on_op disk_params on_comma on_label # Replace only last occurrence
output on_op data on_nl elsif type on_op on_symbeg stderr on_nl total on_op data on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma # Keep track of the stdout so that we can get the VM name
total on_op data on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_ignored_nl lines on_op total on_period split # Append the data so we can see the full view
lines on_op total on_period split on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if lines on_period include? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Break up the lines. We can't get the progress until we see an "OK"
match on_op on_regexp_beg on_tstring_content on_regexp_end on_period match on_lparen lines on_period last on_rparen on_nl if match on_nl current on_op match on_lbracket # The progress of the import will be in the last line. Do a greedy # regular expression to find what we're looking for.
UNK on_op on_backref on_period to_i if line on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl if UNK on_op line on_op on_regexp_beg on_tstring_content # This is how we find the nic that a FP is attached to, # since this comes first.
if UNK on_op line on_op on_regexp_beg on_tstring_content on_regexp_end on_op on_backref on_period to_s on_op on_tstring_beg on_tstring_content on_tstring_end on_nl return on_lbracket on_rbracket # If we care about active VMs only, then we check the state # to verify the VM is running.
if line on_op on_regexp_beg on_tstring_content on_regexp_end on_nl result on_op on_lbracket UNK on_comma on_backref on_period to_s on_comma on_backref on_period to_i on_comma # Parse out the forwarded port information # Forwarding(1)="172.22.8.201tcp32977,tcp,172.22.8.201,32977,,3777" # Forwarding(2)="tcp32978,tcp,,32978,,3777"
info on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma # Return the info to build up the results
UNK on_op on_backref on_period to_s on_nl return UNK on_period split on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_nl end on_nl # Split the version by _ since some distro versions modify it # to look like this: 4.1.2_ubuntu, and the distro part isn't # too important.
info on_op execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_label true on_rparen on_nl info on_period # If we can't get the guest additions version by guest property, try # to get it from the VM info itself.
UNK if uuid on_op on_ivar on_nl on_ignored_nl begin on_ignored_nl UNK on_lparen uuid on_comma true on_rparen on_period each do on_op _ # Ignore our own used ports
end on_nl end on_nl end on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl results on_op on_lbrace on_rbrace on_nl # VirtualBox could not find the vm. It may have been deleted # by another process after we called 'vboxmanage list vms'? Ignore this error.
raise on_const on_op on_const on_op on_const on_comma on_ignored_nl on_label e on_period extra_data on_lbracket on_symbeg stderr on_rbracket on_nl end on_nl end # We got VERR_ALREADY_EXISTS. This means that we're renaming to # a VM name that already exists. Raise a custom error.
if UNK on_nl UNK on_op folder on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_ignored_nl UNK on_op on_const on_op on_const on_op on_const # NOTE: Guest additions on Solaris guests do not properly handle # UNC style paths so prevent conversion (See GH-7264)
execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_comma on_tstring_beg on_tstring_content on_embexpr_beg folder on_lbracket on_symbeg name on_rbracket on_embexpr_end on_tstring_end on_comma on_tstring_beg # Enable symlinks on the shared folder
execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_comma on_op args on_comma on_label true on_rparen on_nl end # Add the shared folder
UNK on_op UNK on_period UNK do on_op _ on_comma name on_comma UNK on_comma UNK on_comma UNK on_op on_ignored_nl UNK if # Look for the forwarded port. Valid based on the guest port, but will do # scoring based matching to determine best value when multiple results are # available.
return true on_nl end on_nl on_ignored_nl raise on_const on_op on_const on_op on_const on_comma on_ignored_nl on_label UNK on_period UNK on_comma on_ignored_nl # Some systems return an exit code 1 for some reason. For that # we depend on the output.
raise on_const on_op on_const on_op on_const on_comma on_ignored_nl on_label UNK on_period UNK on_comma on_ignored_nl on_label r on_period stderr on_nl end # If we reached this point then it didn't work out.
execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_label true on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # This command sometimes fails if kernel drivers aren't properly loaded # so we just run the command and verify that it succeeded.
return UNK if result on_period stderr on_period include? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK on_int on_nl end on_nl # If vboxmanage returned VBOX_E_OBJECT_NOT_FOUND, # then the vm truly does not exist. Any other error might be transient
UNK on_int on_nl end on_nl on_ignored_nl execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma uuid on_rparen on_nl return true on_nl end on_nl # Sleep a bit though to give VirtualBox time to fix itself
execute on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma uuid on_rparen on_nl return true on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen # If we reach this point, it means that we consistently got the # failure, do a standard vboxmanage now. This will raise an # exception if it fails again.
def UNK on_lparen UNK on_rparen on_ignored_nl source on_op UNK on_nl destination on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen # @param [VagrantPlugins::VirtualboxProvider::Driver] driver # @param [String] defined_disk_path # @return [String] destination - The cloned disk
def UNK on_lparen UNK on_rparen on_ignored_nl source on_op UNK on_nl destination on_op on_const on_period UNK on_lparen on_const on_period UNK on_lparen # @param [VagrantPlugins::VirtualboxProvider::Driver] driver # @param [String] defined_disk_path # @return [String] destination - The cloned disk
if ip on_op on_tstring_beg on_tstring_content on_tstring_end on_op ip on_period UNK on_nl return UNK on_nl UNK on_ignored_nl return true on_nl end # Filter out invalid IP addresses # GH-4658 VirtualBox can report an IP address of 0.0.0.0 for FreeBSD guests.
