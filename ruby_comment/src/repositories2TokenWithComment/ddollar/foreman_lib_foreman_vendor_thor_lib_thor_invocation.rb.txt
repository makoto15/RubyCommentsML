UNK on_period UNK on_const on_nl end on_nl on_ignored_nl UNK on_const on_nl def UNK on_lparen UNK on_comma name on_rparen UNK name #:nodoc:
def UNK on_lparen UNK on_comma name on_rparen UNK name on_nl UNK on_const on_comma on_const on_nl on_const on_op on_const on_op on_const # This method is responsible for receiving a name and find the proper # class and command for it. The key is an optional parameter which is # available only in class methods invocations (i.e. in Foreman::Thor::Group).
UNK name on_nl UNK on_const on_comma on_const on_nl on_const on_op on_const on_op on_const on_period UNK on_lparen name on_period UNK on_comma #:nodoc:
def UNK on_lparen args on_op on_lbracket on_rbracket on_comma UNK on_op on_lbrace on_rbrace on_comma config on_op on_lbrace on_rbrace on_comma on_op UNK # Make initializer aware of invocations and the initialization args.
on_ivar on_op config on_lbracket on_symbeg UNK on_rbracket on_op on_const on_period UNK on_lbrace on_op UNK on_comma UNK on_op UNK on_lbracket UNK #:nodoc:
def UNK on_nl on_ivar on_period UNK on_period UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def # Make the current command chain accessible with in a Foreman::Thor-(sub)command
def UNK on_lparen name on_op UNK on_comma on_op args on_rparen on_ignored_nl UNK name on_period UNK on_nl UNK UNK UNK UNK # Receives a name and invokes it. The name can be a string (either "command" or # "namespace:command"), a Foreman::Thor::Command, a Class or a Foreman::Thor instance. If the # command cannot be guessed by name, it can also be supplied as second argument. # # You can also supply the arguments, options and configuration values for # the command to be invoked, if none is given, the same values used to # initialize the invoker are used to initialize the invoked. # # When no name is given, it will invoke the default command of the current class. # # ==== Examples # # class A < Foreman::Thor # def foo # invoke :bar # invoke "b:hello", ["Erik"] # end # # def bar # invoke "b:hello", ["Erik"] # end # end # # class B < Foreman::Thor # def hello(name) # puts "hello #{name}" # end # end # # You can notice that the method "foo" above invokes two commands: "bar", # which belongs to the same class and "hello" which belongs to the class B. # # By using an invocation system you ensure that a command is invoked only once. # In the example above, invoking "foo" will invoke "b:hello" just once, even # if it's invoked later by "bar" method. # # When class A invokes class B, all arguments used on A initialization are # supplied to B. This allows lazy parse of options. Let's suppose you have # some rspec commands: # # class Rspec < Foreman::Thor::Group # class_option :mock_framework, :type => :string, :default => :rr # # def invoke_mock_framework # invoke "rspec:#{options[:mock_framework]}" # end # end # # As you noticed, it invokes the given mock framework, which might have its # own options: # # class Rspec::RR < Foreman::Thor::Group # class_option :style, :type => :string, :default => :mock # end # # Since it's not rspec concern to parse mock framework options, when RR # is invoked all options are parsed again, so RR can extract only the options # that it's going to use. # # If you want Rspec::RR to be initialized with its own set of options, you # have to do that explicitly: # # invoke "rspec:rr", [], :style => :foo # # Besides giving an instance, you can also give a class to invoke: # # invoke Rspec::RR, [], :style => :foo #
def UNK on_lparen command on_comma on_op args on_rparen UNK on_op on_ivar on_lbracket self on_period class on_rbracket on_nl on_ignored_nl UNK UNK # Invoke the given command if the given args.
UNK on_op on_ivar on_lbracket self on_period class on_rbracket on_nl on_ignored_nl UNK UNK on_period UNK on_lparen command on_period name on_rparen on_nl #:nodoc:
def UNK self on_period class on_period UNK on_period UNK on_lbrace on_op UNK on_comma command on_op UNK on_lparen command on_rparen on_rbrace # Invoke all commands for the current instance.
self on_period class on_period UNK on_period UNK on_lbrace on_op UNK on_comma command on_op UNK on_lparen command on_rparen on_rbrace on_nl end #:nodoc:
def UNK on_lparen on_op args on_rparen on_ignored_nl UNK on_lbrace UNK on_lparen on_op args on_rparen on_rbrace on_nl end on_nl on_ignored_nl UNK # Invokes using shell padding.
def UNK on_lbrace on_symbeg UNK on_op on_ivar on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen name on_comma UNK on_op UNK # Configuration values that are shared between invocations.
on_lbrace on_symbeg UNK on_op on_ivar on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen name on_comma UNK on_op UNK on_rparen UNK #:nodoc:
def UNK on_lparen name on_comma UNK on_op UNK on_rparen UNK name on_period UNK on_nl on_lbracket self on_period class on_comma UNK # This method simply retrieves the class and command to be invoked. # If the name is nil or the given name is a command in the current class, # use the given name and return self as class. Otherwise, call # prepare_for_invocation in the current class.
UNK name on_period UNK on_nl on_lbracket self on_period class on_comma UNK on_rbracket on_nl UNK self on_period class on_period UNK on_lbracket #:nodoc:
def UNK on_lparen args on_comma opts on_comma config on_rparen UNK on_comma UNK on_comma UNK on_op on_ivar on_nl on_ignored_nl args on_op # Initialize klass using values stored in the @_initializer.
UNK on_comma UNK on_comma UNK on_op on_ivar on_nl on_ignored_nl args on_op UNK on_period UNK on_nl opts on_op UNK on_period UNK #:nodoc:
