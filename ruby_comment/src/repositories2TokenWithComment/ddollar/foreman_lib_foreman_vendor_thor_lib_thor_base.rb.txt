on_const on_op UNK on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_tstring_end on_nl on_ignored_nl on_const on_op UNK on_tstring_content on_words_sep on_tstring_content on_words_sep # Shortcuts for help.
on_const on_op UNK on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content # Foreman::Thor methods that should not be overwritten by the user.
def UNK on_lparen args on_op on_lbracket on_rbracket on_comma UNK on_op on_lbrace on_rbrace on_comma config on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK # It receives arguments in an Array and two hashes, one for options and # other for configuration. # # Notice that it does not check if all required arguments were supplied. # It should be done by the parser. # # ==== Parameters # args<Array[Object]>:: An array of objects. The objects are applied to their # respective accessors declared with <tt>argument</tt>. # # options<Hash>:: An options hash that will be available as self.options. # The hash given is converted to a hash with indifferent # access, magic predicates (options.skip?) and then frozen. # # config<Hash>:: Configuration for this Foreman::Thor class. #
on_ignored_nl UNK on_op config on_period UNK on_lparen on_symbeg UNK on_rparen UNK on_op UNK on_period UNK on_lparen UNK on_rparen if UNK # The start method splits inbound arguments at the first argument # that looks like an option (starts with - or --). It then calls # new, passing in the two halves of the arguments Array as the # first two parameters.
UNK on_op UNK on_period UNK on_lparen UNK on_rparen if UNK on_nl if UNK on_period UNK on_lparen on_const on_rparen on_nl UNK # hook for start
UNK on_op on_lbracket on_rbracket on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl UNK on_op self on_period class on_period UNK config # Handle the case where the class was explicitly instantiated # with pre-parsed options.
UNK on_op self on_period class on_period UNK config on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_op on_const on_op on_const on_op on_const # Let Foreman::Thor::Options parse the options first, so it can remove # declared options from the array. This will leave us with # a list of arguments that weren't declared.
UNK on_period UNK if self on_period class on_period UNK on_lparen config on_rparen on_nl on_ignored_nl UNK on_op args on_nl UNK on_op # If unknown options are disallowed, make sure that none of the # remaining arguments looks like an option.
UNK on_op args on_nl UNK on_op UNK on_period UNK unless self on_period class on_period UNK on_lparen config on_rparen on_nl on_ignored_nl # Add the remaining arguments from the options parser to the # arguments passed in to initialize. Then remove any positional # arguments declared using #argument (this is primarily used # by Foreman::Thor::Group). Tis will leave us with the remaining # positional arguments.
UNK on_period UNK on_const on_nl UNK on_period UNK on_symbeg UNK on_comma on_const on_nl UNK on_period UNK on_symbeg UNK on_comma on_const #:nodoc:
def UNK on_nl on_ivar on_op on_lbracket on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_const on_period new on_lbrace # Returns the classes that inherits from Foreman::Thor or Foreman::Thor::Group. # # ==== Returns # Array[Class] #
def UNK on_nl on_ivar on_op on_const on_period new on_lbrace on_op UNK on_comma UNK on_op UNK on_lbracket UNK on_rbracket on_op on_lbracket # Returns the files where the subclasses are kept. # # ==== Returns # Hash[path<String> => Class] #
def UNK on_lparen klass on_rparen UNK on_op UNK on_lbracket on_int on_rbracket on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_lbracket on_int # Whenever a class inherits from Foreman::Thor or Foreman::Thor::Group, we should track the # class and the file on Foreman::Thor::Base. This is the method responsable for it. #
UNK on_op UNK on_lbracket on_int on_rbracket on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_lbracket on_int on_rbracket on_nl on_const on_op on_const #:nodoc:
no_commands on_lbrace UNK on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen on_op on_rparen no_commands on_lbrace UNK on_rbrace on_nl end on_nl #:nodoc:
no_commands on_lbrace UNK on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen on_op on_rparen no_commands on_lbrace UNK on_rbrace on_nl end on_nl #:nodoc:
no_commands on_lbrace UNK on_rbrace on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK #:nodoc:
def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_ivar on_op from_superclass on_lparen on_symbeg UNK on_comma false # If you want to raise an error for unknown options, call check_unknown_options! # This is disabled by default to allow dynamic invocations.
on_ivar on_op from_superclass on_lparen on_symbeg UNK on_comma false on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen config on_rparen on_op on_op #:nodoc:
on_op on_op UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen false on_nl end on_nl on_ignored_nl def UNK on_nl #:nodoc:
def UNK on_lparen UNK on_rparen false on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl # If true, option parsing is suspended as soon as an unknown option or a # regular argument is encountered. All remaining arguments are passed to # the command as regular arguments.
false on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_ivar on_op from_superclass #:nodoc:
def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_ivar on_op from_superclass on_lparen on_symbeg UNK on_comma false # If you want only strict string args (useful when cascading thor classes), # call strict_args_position! This is disabled by default to allow dynamic # invocations.
on_ivar on_op from_superclass on_lparen on_symbeg UNK on_comma false on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen config on_rparen on_op on_op #:nodoc:
on_op on_op UNK on_nl end on_nl on_ignored_nl def UNK on_lparen name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_lparen #:nodoc:
def UNK on_lparen name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_lparen name on_comma on_symbeg UNK on_rparen on_nl no_commands # Adds an argument to the class and creates an attr_accessor for it. # # Arguments are different from options in several aspects. The first one # is how they are parsed from the command line, arguments are retrieved # from position: # # thor command NAME # # Instead of: # # thor command --name=NAME # # Besides, arguments are used inside your code as an accessor (self.argument), # while options are all kept in a hash (self.options). # # Finally, arguments cannot have type :default or :boolean but can be # optional (supplying :optional => :true or :required => false), although # you cannot have a required argument after a non-required argument. If you # try it, an error is raised. # # ==== Parameters # name<Symbol>:: The name of the argument. # options<Hash>:: Described below. # # ==== Options # :desc - Description for the argument. # :required - If the argument is required or not. # :optional - If the argument is optional or not. # :type - The type of the argument, can be :string, :hash, :array, :numeric. # :default - Default value for this argument. It cannot be required and have default values. # :banner - String to show on usage notes. # # ==== Errors # ArgumentError:: Raised if you supply a required argument after a non required one. #
def arguments on_nl on_ivar on_op from_superclass on_lparen on_symbeg arguments on_comma on_lbracket on_rbracket on_rparen on_nl end on_nl on_ignored_nl def class_options on_lparen # Returns this class arguments, looking up in the ancestors chain. # # ==== Returns # Array[Foreman::Thor::Argument] #
def class_options on_lparen options on_op nil on_rparen on_ignored_nl on_ivar on_op from_superclass on_lparen on_symbeg class_options on_comma on_lbrace on_rbrace on_rparen on_nl UNK # Adds a bunch of options to the set of class options. # # class_options :foo => false, :bar => :required, :baz => :string # # If you prefer more detailed declaration, check class_option. # # ==== Parameters # Hash[Symbol => Object] #
def UNK on_lparen name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_lparen name on_comma options on_comma class_options on_rparen on_nl # Adds an option to the set of class options # # ==== Parameters # name<Symbol>:: The name of the argument. # options<Hash>:: Described below. # # ==== Options # :desc:: -- Description for the argument. # :required:: -- If the argument is required or not. # :default:: -- Default value for this argument. # :group:: -- The group for this options. Use by class options to output options in different levels. # :aliases:: -- Aliases for this option. <b>Note:</b> Foreman::Thor follows a convention of one-dash-one-letter options. Thus aliases like "-something" wouldn't be parsed; use either "\--something" or "-s" instead. # :type:: -- The type of the argument, can be :string, :hash, :array, :numeric or :boolean. # :banner:: -- String to show on usage notes. # :hide:: -- If you want to hide this option from the help. #
def UNK on_lparen on_op names on_rparen on_ignored_nl options on_op names on_period UNK on_period UNK on_lparen on_const on_rparen on_op names on_period # Removes a previous defined argument. If :undefine is given, undefine # accessors as well. # # ==== Parameters # names<Array>:: Arguments to be removed # # ==== Examples # # remove_argument :foo # remove_argument :foo, :bar, :baz, :undefine => true #
def UNK on_lparen on_op names on_rparen on_ignored_nl names on_period each do on_op name on_op on_ignored_nl class_options on_period UNK on_lparen name # Removes a previous defined class option. # # ==== Parameters # names<Array>:: Class options to be removed # # ==== Examples # # remove_class_option :foo # remove_class_option :foo, :bar, :baz #
def UNK on_lparen name on_op nil on_rparen on_ignored_nl if name on_nl on_ivar on_op name on_period to_s on_nl else on_ignored_nl on_ivar # Defines the group. This is used when thor list is invoked so you can specify # that only commands from a pre-defined group will be shown. Defaults to standard. # # ==== Parameters # name<String|Symbol> #
def commands on_nl on_ivar on_op on_const on_op on_const on_op on_const on_op on_const on_period new on_nl end on_nl alias_method on_symbeg UNK # Returns the commands for this Foreman::Thor class. # # ==== Returns # OrderedHash:: An ordered hash with commands names as keys and Foreman::Thor::Command # objects as values. #
def UNK on_nl on_ivar on_op from_superclass on_lparen on_symbeg UNK on_comma on_const on_op on_const on_op on_const on_op on_const on_period new on_rparen # Returns the commands for this Foreman::Thor class and all subclasses. # # ==== Returns # OrderedHash:: An ordered hash with commands names as keys and Foreman::Thor::Command # objects as values. #
def UNK on_lparen on_op names on_rparen on_ignored_nl options on_op names on_period UNK on_period UNK on_lparen on_const on_rparen on_op names on_period # Removes a given command from this Foreman::Thor class. This is usually done if you # are inheriting from another class and don't want it to be available # anymore. # # By default it only remove the mapping to the command. But you can supply # :undefine => true to undefine the method from the class as well. # # ==== Parameters # name<Symbol|String>:: The name of the command to be removed # options<Hash>:: You can give :undefine => true if you want commands the method # to be undefined from the class as well. #
def no_commands on_nl on_ivar on_op UNK on_nl UNK on_nl UNK on_ignored_nl on_ivar on_op false on_nl end on_nl alias_method on_symbeg UNK # All methods defined inside the given block are not added as commands. # # So you can do: # # class MyScript < Foreman::Thor # no_commands do # def this_is_not_a_command # end # end # end # # You can also add the method and remove it from the command list: # # class MyScript < Foreman::Thor # def this_is_not_a_command # end # remove_command :this_is_not_a_command # end #
def UNK on_lparen name on_op nil on_rparen on_ignored_nl if name on_nl on_ivar on_op name on_period to_s on_nl else on_ignored_nl on_ivar # Sets the namespace for the Foreman::Thor or Foreman::Thor::Group class. By default the # namespace is retrieved from the class name. If your Foreman::Thor class is named # Scripts::MyScript, the help method, for example, will be called as: # # thor scripts:my_script -h # # If you change the namespace: # # namespace :my_scripts # # You change how your commands are invoked: # # thor my_scripts -h # # Finally, if you change your namespace to default: # # namespace :default # # Your commands can be invoked with a shortcut. Instead of: # # thor :my_command #
def UNK on_lparen UNK on_op on_const on_comma config on_op on_lbrace on_rbrace on_rparen on_ignored_nl config on_lbracket on_symbeg shell on_rbracket on_op on_const # Parses the command and options from the given args, instantiate the class # and invoke the command. This method is used when the arguments must be parsed # from an array. If you are inside Ruby and want to use a Foreman::Thor class, you # can simply initialize it: # # script = MyScript.new(args, options, config) # script.invoke(:command, first_arg, second_arg, third_arg) #
UNK on_lparen on_int on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen on_op names on_rparen on_ignored_nl names on_period each do on_op # This happens if a thor command is piped to something like `head`, # which closes the pipe when it's done reading. This will also # mean that if the pipe is closed, further unnecessary # computation will not occur.
def UNK on_lparen on_op names on_rparen on_ignored_nl names on_period each do on_op name on_op on_ignored_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg name # Allows to use private methods from parent in child classes as commands. # # ==== Parameters # names<Array>:: Method names to be used as commands # # ==== Examples # # public_command :foo # public_command :foo, :bar, :baz #
raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg command on_period inspect on_embexpr_end on_tstring_content on_embexpr_beg UNK on_period inspect on_embexpr_end on_tstring_content on_tstring_end if UNK #:nodoc:
UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg command on_period name on_embexpr_end on_tstring_content on_tstring_end on_nl UNK on_op on_tstring_beg on_tstring_content #:nodoc:
def UNK on_lparen shell on_comma UNK on_op on_lbrace on_rbrace on_rparen class_options on_period each do on_op UNK on_comma value on_op on_ignored_nl # Prints the class options per group. If an option does not belong to # any group, it's printed as Class option. #
class_options on_period each do on_op UNK on_comma value on_op on_ignored_nl UNK on_lbracket value on_period UNK on_rbracket on_op on_lbracket on_rbracket on_nl #:nodoc: # Group options by group
UNK on_op UNK on_period UNK on_lparen nil on_rparen on_op on_lbracket on_rbracket on_nl UNK on_lparen shell on_comma UNK on_rparen on_nl on_ignored_nl # Deal with default group
UNK on_period each do on_op UNK on_comma options on_op on_ignored_nl UNK on_lparen shell on_comma options on_comma UNK on_rparen on_nl end # Print all others
def UNK on_lparen shell on_comma options on_comma UNK on_op nil on_rparen on_ignored_nl UNK if options on_period UNK on_nl on_ignored_nl UNK # Receives a set of options and print them.
def UNK on_lparen UNK on_comma UNK on_rparen UNK false unless on_const on_period UNK on_lparen UNK on_period to_s on_rparen on_nl raise # Raises an error if the word given is a Foreman::Thor reserved word.
UNK false unless on_const on_period UNK on_lparen UNK on_period to_s on_rparen on_nl raise on_tstring_beg on_embexpr_beg UNK on_period inspect on_embexpr_end on_tstring_content #:nodoc:
def UNK on_lparen name on_comma options on_comma UNK on_rparen UNK on_lbracket name on_rbracket on_op on_const on_op on_const on_op on_const on_period # Build an option and adds it to the given scope. # # ==== Parameters # name<Symbol>:: The name of the argument. # options<Hash>:: Described in both class_option and method_option. # scope<Hash>:: Options hash that is being built up
UNK on_lbracket name on_rbracket on_op on_const on_op on_const on_op on_const on_period new on_lparen name on_comma options on_rparen on_nl end on_nl #:nodoc:
def UNK on_lparen options on_comma UNK on_rparen options on_period each do on_op UNK on_comma value on_op on_ignored_nl UNK on_lbracket UNK # Receives a hash of options, parse them and add to the scope. This is a # fast way to set a bunch of options: # # build_options :foo => true, :bar => :required, :baz => :string # # ==== Parameters # Hash[Symbol => Object]
options on_period each do on_op UNK on_comma value on_op on_ignored_nl UNK on_lbracket UNK on_rbracket on_op on_const on_op on_const on_op on_const #:nodoc:
def UNK on_lparen name on_rparen if commands on_lbracket name on_period to_s on_rbracket on_nl commands on_lbracket name on_period to_s on_rbracket on_nl # Finds a command with the given name. If the command belongs to the current # class, just return it, otherwise dup it and add the fresh copy to the # current command hash.
if commands on_lbracket name on_period to_s on_rbracket on_nl commands on_lbracket name on_period to_s on_rbracket on_nl UNK command on_op UNK on_lbracket #:nodoc:
commands on_lbracket name on_period to_s on_rbracket on_op command on_period UNK on_nl else on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg name # rubocop:disable AssignmentInCondition
def UNK on_lparen klass on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_period UNK on_lparen klass on_rparen on_nl klass on_period UNK # Everytime someone inherits from a Foreman::Thor class, register the klass # and file into baseclass.
def UNK on_lparen meth on_rparen on_ignored_nl meth on_op meth on_period to_s on_nl on_ignored_nl if meth on_op on_tstring_beg on_tstring_content on_tstring_end on_nl # Fire this callback whenever a method is added. Added methods are # tracked as commands by invoking the create_command method.
UNK unless UNK on_lparen meth on_period UNK on_rparen on_nl on_ignored_nl on_ivar on_op false on_nl UNK if on_ivar on_op on_op UNK # Return if it's not a public instance method
def from_superclass on_lparen UNK on_comma UNK on_op nil on_rparen on_ignored_nl if self on_op UNK on_op on_op UNK on_period UNK on_lparen # Retrieves a value from superclass. If it reaches the baseclass, # returns default.
UNK on_ignored_nl value on_period UNK on_nl UNK on_const on_nl value on_nl end on_nl on_ignored_nl end on_nl end on_nl on_ignored_nl def # Ruby implements `dup` on Object, but raises a `TypeError` # if the method is called on immediates. As a result, we # don't have a good way to check whether dup will succeed # without calling it and rescuing the TypeError.
def UNK on_nl false on_nl end on_nl on_ignored_nl def UNK on_nl on_const on_period UNK on_lparen UNK on_rparen on_period UNK on_lparen # A flag that makes the process exit with status 1 if any error happens.
def UNK on_nl on_const on_period UNK on_lparen UNK on_rparen on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_nl end # # The basename of the program invoking the thor class. #
def UNK end on_nl on_ignored_nl def UNK on_lparen meth on_rparen end on_nl alias_method on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl # SIGNATURE: Sets the baseclass. This is where the superclass lookup # finishes.
end on_nl on_ignored_nl def UNK on_lparen meth on_rparen end on_nl alias_method on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK #:nodoc:
def UNK on_lparen meth on_rparen end on_nl alias_method on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK end on_nl on_ignored_nl # SIGNATURE: Creates a new command if valid_command? is true. This method is # called when a new method is added to the class.
end on_nl alias_method on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK end on_nl on_ignored_nl def UNK on_lparen command on_comma #:nodoc:
def UNK end on_nl on_ignored_nl def UNK on_lparen command on_comma UNK on_comma UNK on_comma config on_rparen raise on_const on_nl end # SIGNATURE: Defines behavior when the initialize method is added to the # class.
end on_nl on_ignored_nl def UNK on_lparen command on_comma UNK on_comma UNK on_comma config on_rparen raise on_const on_nl end on_nl end #:nodoc:
def UNK on_lparen command on_comma UNK on_comma UNK on_comma config on_rparen raise on_const on_nl end on_nl end on_nl end on_nl # SIGNATURE: The hook invoked by start.
raise on_const on_nl end on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP #:nodoc:
