def UNK on_lparen name on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl on_ivar on_op name on_period UNK on_op name on_op on_tstring_beg # Allows for custom "Command" package naming. # # === Parameters # name<String> # options<Hash> #
def default_command on_lparen meth on_op nil on_rparen on_ignored_nl if meth on_nl on_ivar on_op meth on_op on_symbeg UNK on_op on_tstring_beg on_tstring_content # Sets the default command when thor is executed without an explicit command to be called. # # ==== Parameters # meth<Symbol>:: name of the default command #
def UNK on_lparen klass on_comma UNK on_comma usage on_comma description on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl if klass on_op # Registers another Foreman::Thor subclass as a command. # # ==== Parameters # klass<Class>:: Foreman::Thor subclass to register # command<String>:: Subcommand name to use # usage<String>:: Short usage for the subcommand # description<String>:: Description for the subcommand
def UNK on_lparen usage on_comma description on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl if options on_lbracket on_symbeg for on_rbracket on_nl # Defines the usage and the description of the next command. # # ==== Parameters # usage<String> # description<String> # options<String> #
def UNK on_lparen long_description on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl if options on_lbracket on_symbeg for on_rbracket on_nl command on_op # Defines the long description of the next command. # # ==== Parameters # long description<String> #
def map on_lparen UNK on_op nil on_rparen on_ignored_nl on_ivar on_op UNK on_lparen on_symbeg map on_comma on_lbrace on_rbrace on_rparen on_nl on_ignored_nl # Maps an input to a command. If you define: # # map "-T" => "list" # # Running: # # thor -T # # Will invoke the list command. # # ==== Parameters # Hash[String|Array => Symbol]:: Maps the string or the strings in the array to the given command. #
def UNK on_lparen options on_op nil on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl UNK on_lparen options on_comma on_ivar on_rparen if # Declares the options for the next command to be declared. # # ==== Parameters # Hash[Symbol => Object]:: The hash key is the name of the option and the value # is the type of the option. Can be :string, :array, :hash, :boolean, :numeric # or :required (string). If you give a value, the type of the value is used. #
def UNK on_lparen name on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op if options on_lbracket on_symbeg for on_rbracket on_nl # Adds an option to the set of method options. If :for is given as option, # it allows you to change the options from a previous defined command. # # def previous_command # # magic # end # # method_option :foo => :bar, :for => :previous_command # # def next_command # # magic # end # # ==== Parameters # name<Symbol>:: The name of the argument. # options<Hash>:: Described below. # # ==== Options # :desc - Description for the argument. # :required - If the argument is required or not. # :default - Default value for this argument. It cannot be required and have default values. # :aliases - Aliases for this option. # :type - The type of the argument, can be :string, :hash, :array, :numeric or :boolean. # :banner - String to show on usage notes. # :hide - If you want to hide this option from the help. #
def UNK on_lparen shell on_comma UNK on_rparen on_ignored_nl meth on_op UNK on_lparen UNK on_rparen on_nl command on_op all_commands on_lbracket meth # Prints help information for the given command. # # ==== Parameters # shell<Foreman::Thor::Shell> # command_name<String> #
def UNK on_lparen shell on_comma subcommand on_op false on_rparen on_ignored_nl UNK on_op UNK on_lparen true on_comma subcommand on_rparen on_nl on_const # Prints help information for this class. # # ==== Parameters # shell<Foreman::Thor::Shell> #
def UNK on_lparen UNK on_op true on_comma subcommand on_op false on_rparen on_ignored_nl on_lparen UNK on_op all_commands on_op UNK on_rparen on_period # Returns commands ready to be printed.
def UNK on_lparen options on_op on_lbrace on_rbrace on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl options on_period UNK UNK on_op key # Extend check unknown options to accept a hash of conditions. # # === Parameters # options<Hash>: A hash containing :only and/or :except keys
def UNK on_lparen config on_rparen options on_op UNK on_nl UNK false UNK options on_nl on_ignored_nl command on_op config on_lbracket on_symbeg # Overwrite check_unknown_options? to take subcommands and options into account.
options on_op UNK on_nl UNK false UNK options on_nl on_ignored_nl command on_op config on_lbracket on_symbeg UNK on_rbracket on_nl UNK true #:nodoc:
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Stop parsing of options as soon as an unknown option or a regular # argument is encountered. All remaining arguments are passed to the command. # This is useful if you have a command that can receive arbitrary additional # options, and where those additional options should not be handled by # Foreman::Thor. # # ==== Example # # To better understand how this is useful, let's consider a command that calls # an external command. A user may want to pass arbitrary options and # arguments to that command. The command itself also accepts some options, # which should be handled by Foreman::Thor. # # class_option "verbose", :type => :boolean # stop_on_unknown_option! :exec # check_unknown_options! :except => :exec # # desc "exec", "Run a shell command" # def exec(*args) # puts "diagnostic output" if options[:verbose] # Kernel.exec(*args) # end # # Here +exec+ can be called with +--verbose+ to get diagnostic output, # e.g.: # # $ thor exec --verbose echo foo # diagnostic output # foo # # But if +--verbose+ is given after +echo+, it is passed to +echo+ instead: # # $ thor exec echo --verbose foo # --verbose foo # # ==== Parameters # Symbol ...:: A list of commands that should be affected.
command on_op UNK on_period include? on_lparen command on_period name on_period UNK on_rparen on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def #:nodoc:
on_ivar on_op on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen meth on_comma UNK on_comma UNK on_comma config on_rparen #:nodoc:
def UNK on_lparen meth on_comma UNK on_comma UNK on_comma config on_rparen meth on_op UNK on_lparen UNK on_rparen on_nl command on_op # The method responsible for dispatching given the args.
meth on_op UNK on_lparen UNK on_rparen on_nl command on_op all_commands on_lbracket UNK on_lparen meth on_rparen on_rbracket on_nl on_ignored_nl if on_op #:nodoc: # rubocop:disable MethodLength
UNK on_period UNK on_lparen meth on_rparen on_nl command on_op all_commands on_lbracket UNK on_lparen default_command on_rparen on_rbracket on_nl end on_nl on_ignored_nl # We're a subcommand and our first argument didn't match any of our # commands. So we put it back and call our default command.
args on_period UNK opts on_nl opts on_period UNK on_nl end on_nl else on_ignored_nl args on_op UNK on_nl opts on_op nil # given_args starts with a non-option, so we treat everything as # ordinary arguments
def UNK on_lparen command on_comma UNK on_op nil on_comma subcommand on_op false on_rparen on_ignored_nl on_tstring_beg on_embexpr_beg UNK on_embexpr_end on_tstring_content on_embexpr_beg # The banner for this class. You can customize it if you are invoking the # thor class by another ways which is not the Foreman::Thor::Runner. It receives # the command that is going to be invoked and a boolean which indicates if # the namespace should be displayed as arguments. #
on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_const on_op on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK #:nodoc:
on_const on_op on_const on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen meth on_rparen on_ivar on_op nil on_nl on_ivar on_op #:nodoc:
on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ignored_nl if on_ivar on_op #:nodoc:
UNK on_period UNK on_lparen UNK on_rparen on_nl on_ivar on_op nil on_nl end on_nl on_ignored_nl def UNK on_lparen args on_rparen meth #:nodoc:
def UNK on_lparen args on_rparen meth on_op args on_period UNK on_period to_s UNK args on_period UNK on_nl args on_period UNK # Retrieve the command name from given args.
meth on_op args on_period UNK on_period to_s UNK args on_period UNK on_nl args on_period UNK if meth on_op on_lparen map #:nodoc:
def UNK on_lparen meth on_rparen UNK default_command on_period to_s on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # receives a (possibly nil) command name and returns a name that is in # the commands hash. In addition to normalizing aliases, this logic # will determine if a shortened command is an unambiguous substring of # a command or alias. # # +normalize_command_name+ also converts names like +animal-prison+ # into +animal_prison+.
UNK default_command on_period to_s on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK meth on_nl on_ignored_nl possibilities #:nodoc:
end on_nl alias_method on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen meth on_rparen on_ignored_nl UNK on_op meth on_period # treat foo-bar as foo_bar
def UNK on_lparen meth on_rparen on_ignored_nl UNK on_op meth on_period to_s on_period UNK on_nl possibilities on_op all_commands on_period UNK on_lparen # this is the logic that takes the command name passed in by the user # and determines whether it is an unambiguous substrings of a command or # alias name.
