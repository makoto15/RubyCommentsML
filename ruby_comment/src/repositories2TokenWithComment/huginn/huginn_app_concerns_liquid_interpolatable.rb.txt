on_ignored_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl UNK do on_ignored_nl UNK on_symbeg UNK on_nl end on_nl on_ignored_nl # :markup: markdown
rescue on_const on_op on_const on_op e on_nl UNK on_period UNK on_lparen on_symbeg options on_comma on_tstring_beg on_tstring_content on_embexpr_beg e on_period UNK # Ignore error (likely due to possibly missing variables on "divided_by")
end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_const on_period new on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Calling `interpolated` without an incoming may naturally fail # with various errors when an agent expects one.
def UNK on_nl on_ivar on_op on_const on_period new on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen self_object on_rparen # Return the current interpolation context. Use this in your Agent # class to manipulate interpolation context for user. # # For example, to provide local variables: # # # Create a new scope to define variables in: # interpolation_context.stack { # interpolation_context['_something_'] = 42 # # And user can say "{{_something_}}" in their options. # value = interpolated['some_key'] # } #
def UNK on_lparen self_object on_rparen on_ignored_nl case self_object on_nl when nil on_nl UNK on_nl else on_ignored_nl context on_op UNK on_nl # Take the given object as "self" in the current interpolation # context while running a given block. # # The most typical use case for this is to evaluate options for each # received event like this: # # def receive(incoming_events) # incoming_events.each do |event| # interpolate_with(event) do # # Handle each event based on "interpolated" options. # end # end # end
def UNK on_lparen string on_rparen on_ignored_nl on_const on_period UNK on_lparen string on_rparen rescue string on_nl end on_nl on_ignored_nl def UNK # Percent encoding for URI conforming to RFC 3986. # Ref: http://tools.ietf.org/html/rfc3986#page-12
def UNK on_lparen uri on_comma UNK on_op nil on_rparen on_ignored_nl case UNK on_nl when nil on_comma on_tstring_beg on_tstring_end on_nl on_const # Parse an input into a URI object, optionally resolving it # against a base URI if given. # # A URI object will have the following properties: scheme, # userinfo, host, port, registry, path, opaque, query, and # fragment.
def UNK on_lparen url on_comma UNK on_op on_int on_rparen on_ignored_nl case url on_nl when on_const on_nl uri on_op url on_nl # Get the destination URL of a given URL by recursively following # redirects, up to 5 times in a row. If a given string is not a # valid absolute HTTP URL or in case of too many redirects, the # original string is returned. If any network/protocol error # occurs while following redirects, the last URL followed is # returned.
end on_nl on_ignored_nl UNK on_period UNK do on_ignored_nl UNK on_ignored_nl case uri on_nl when on_const on_op on_const on_nl UNK uri # builder.use FaradayMiddleware::FollowRedirects, limit: limit # ...does not handle non-HTTP URLs.
def UNK on_lparen input on_comma UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen input on_comma UNK on_rparen rescue input on_nl end # Rebase URIs contained in attributes in a given HTML fragment
def UNK on_lparen input on_rparen on_ignored_nl on_const on_period UNK on_lparen input on_rparen rescue input on_nl end on_nl on_ignored_nl def UNK # Unescape (basic) HTML entities in a string # # This currently decodes the following entities only: "&apos;", # "&quot;", "&lt;", "&gt;", "&amp;", "&#dd;" and "&#xhh;".
def UNK on_lparen string on_rparen on_ignored_nl UNK on_op string on_period to_s on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_period UNK # Escape a string for use in XPath expression
def UNK on_lparen input on_rparen on_ignored_nl on_const on_period UNK on_lparen input on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen input # Serializes data as JSON
def UNK on_lparen object on_rparen on_ignored_nl UNK on_symbeg UNK on_comma object on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen # Returns a Ruby object # # It can be used as a JSONPath replacement for Agents that only support Liquid: # # Event: {"something": {"nested": {"data": 1}}} # Liquid: {{something.nested | as_object}} # Returns: {"data": 1} # # Splitting up a string with Liquid filters and return the Array: # # Event: {"data": "A,B,C"}} # Liquid: {{data | split: ',' | as_object}} # Returns: ['A', 'B', 'C'] # # as_object ALWAYS has be the last filter in a Liquid expression!
def UNK on_lparen input on_comma UNK on_rparen on_ignored_nl if input on_period UNK on_lparen on_symbeg UNK on_rparen on_nl input on_period UNK # Group an array of items by a property # # Example usage: # # {% assign posts_by_author = site.posts | group_by: "author" %} # {% for author in posts_by_author %} # <dt>{{author.name}}</dt> # {% for post in author.items %} # <dd><a href="{{post.url}}">{{post.title}}</a></dd> # {% endfor %} # {% endfor %}
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_lbrace on_ignored_nl if c on_op on_backref # Unescape a replacement text for use in the second argument of # gsub/sub. The following escape sequences are recognized: # # - "\\" (backslash itself) # - "\a" (alert) # - "\b" (backspace) # - "\e" (escape) # - "\f" (form feed) # - "\n" (new line) # - "\r" (carriage return) # - "\s" (space) # - "\t" (horizontal tab) # - "\u{XXXX}" (unicode codepoint) # - "\v" (vertical tab) # - "\xXX" (hexadecimal character) # - "\1".."\9" (numbered capture groups) # - "\+" (last capture group) # - "\k<name>" (named capture group) # - "\&" or "\0" (complete matched text) # - "\`" (string before match) # - "\'" (string after match) # # Octal escape sequences are deliberately unsupported to avoid # conflict with numbered capture groups. Rather obscure Emacs # style character codes ("\C-x", "\M-\C-x" etc.) are also omitted # from this implementation.
UNK on_const on_op on_const on_op on_const on_nl on_const on_op UNK on_tstring_content on_embexpr_beg on_const on_op on_const on_embexpr_end on_tstring_content UNK on_nl on_ignored_nl # Replace every occurrence of a given regex pattern in the first # "in" block with the result of the "with" block in which the # variable `match` is set for each iteration, which can be used as # follows: # # - `match[0]` or just `match`: the whole matching string # - `match[1]`..`match[n]`: strings matching the numbered capture groups # - `match.size`: total number of the elements above (n+1) # - `match.names`: array of names of named capture groups # - `match[name]`..: strings matching the named capture groups # - `match.pre_match`: string preceding the match # - `match.post_match`: string following the match # - `match.***`: equivalent to `match['***']` unless it conflicts with the existing methods above # # If named captures (`(?<name>...)`) are used in the pattern, they # are also made accessible as variables. Note that if numbered # captures are used mixed with named captures, you could get # unexpected results. # # Example usage: # # {% regex_replace "\w+" in %}Use me like this.{% with %}{{ match | capitalize }}{% endregex_replace %} # {% assign fullname = "Doe, John A." %} # {% regex_replace_first "\A(?<name1>.+), (?<name2>.+)\z" in %}{{ fullname }}{% with %}{{ name2 }} {{ name1 }}{% endregex_replace_first %} # # Use Me Like This. # # John A. Doe #
