on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK UNK on_nl UNK UNK on_nl UNK on_op UNK on_nl def UNK on_lparen # frozen_string_literal: true
UNK UNK on_nl UNK on_op UNK on_nl def UNK on_lparen version on_comma options on_rparen on_ignored_nl options on_op UNK on_lparen options # Given a version record and some options, builds a new model object. # @api private
def UNK on_lparen version on_comma options on_rparen on_ignored_nl options on_op UNK on_lparen options on_comma version on_rparen on_nl attrs on_op version # See `VersionConcern#reify` for documentation. # @api private
def UNK on_lparen options on_comma version on_rparen on_ignored_nl UNK on_ignored_nl on_label version on_period UNK on_comma on_ignored_nl on_label UNK on_comma on_ignored_nl # Given a hash of `options` for `.reify`, return a new hash with default # values applied. # @api private
def UNK on_lparen attrs on_comma options on_comma version on_rparen on_ignored_nl UNK on_op UNK on_lparen version on_comma attrs on_rparen on_nl on_ignored_nl # Initialize a model object suitable for reifying `version` into. Does # not perform reification, merely instantiates the appropriate model # class and, if specified by `options[:unversioned_attributes]`, sets # unversioned attributes to `nil`. # # Normally a polymorphic belongs_to relationship allows us to get the # object we belong to by calling, in this case, `item`. However this # returns nil if `item` has been destroyed, and we need to be able to # retrieve destroyed objects. # # In this situation we constantize the `item_type` to get hold of the # class...except when the stored object's attributes include a `type` # key. If this is the case, the object we belong to is using single # table inheritance (STI) and the `item_type` will be the base class, # not the actual subclass. If `type` is present but empty, the class is # the base class.
model on_op UNK options UNK UNK UNK UNK on_op UNK on_op version on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK # The `dup` option and destroyed version always returns a new object, # otherwise we should attempt to load item or to look for the item # outside of default scope(s).
def UNK on_lparen attrs on_comma model on_rparen on_ignored_nl on_lparen model on_period UNK on_op attrs on_period UNK on_rparen on_period UNK UNK # Look for attributes that exist in `model` and not in this version. # These attributes should be set to nil. Modifies `attrs`. # @api private
def UNK on_lparen k on_comma UNK on_comma model on_comma version on_rparen on_ignored_nl UNK model on_period UNK on_lparen k on_rparen on_nl # Reify onto `model` an attribute named `k` with value `v` from `version`. # # `ObjectAttribute#deserialize` will return the mapped enum value and in # Rails < 5, the []= uses the integer type caster from the column # definition (in general) and thus will turn a (usually) string to 0 # instead of the correct value. # # @api private
def UNK on_lparen model on_comma version on_comma attrs on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_lparen model on_period UNK on_rparen # Reify onto `model` all the attributes of `version`. # @api private
def UNK on_lparen version on_comma attrs on_rparen on_ignored_nl UNK on_op version on_period UNK on_period UNK on_period UNK on_nl UNK on_op # Given a `version`, return the class to reify. This method supports # Single Table Inheritance (STI) with custom inheritance columns. # # For example, imagine a `version` whose `item_type` is "Animal". The # `animals` table is an STI table (it has cats and dogs) and it has a # custom inheritance column, `species`. If `attrs["species"]` is "Dog", # this method returns the constant `Dog`. If `attrs["species"]` is blank, # this method returns the constant `Animal`. You can see this particular # example in action in `spec/models/animal_spec.rb`. # # TODO: Duplication: similar `constantize` in VersionConcern#version_limit
