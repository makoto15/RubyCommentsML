on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_op on_const # frozen_string_literal: true
UNK unless on_ivar on_nl on_ignored_nl UNK on_op UNK on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen on_label UNK on_rparen # Use instance variable directly so we avoid starting the browser just to reset the session
UNK unless UNK on_nl UNK on_op UNK on_nl UNK on_lparen UNK on_rparen on_nl rescue on_op UNK on_nl UNK on_nl UNK # Only trigger a navigation if we haven't done it already, otherwise it # can trigger an endless series of unload modals
UNK on_lparen UNK on_rparen on_nl rescue on_op UNK on_nl UNK on_nl UNK on_nl end on_nl end on_nl on_ignored_nl def UNK # Ensure the page is empty and trigger an UnhandledAlertError for any modals that appear during unload
UNK on_nl UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen on_label on_comma on_label on_rparen on_ignored_nl frame on_op on_ivar # This error is thrown if an unhandled alert is on the page # Firefox appears to automatically dismiss this alert, chrome does not # We'll try to accept it
UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen on_label on_comma on_label on_rparen on_ignored_nl frame on_op on_ivar on_lbracket UNK # try cleaning up the browser again
end on_nl on_ignored_nl def UNK on_lparen handle on_rparen on_ignored_nl within_given_window on_lparen handle on_rparen do on_ignored_nl browser on_period manage on_period UNK # work around for https://code.google.com/p/selenium/issues/detail?id=7405
browser on_period execute_script on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen handle on_rparen on_ignored_nl browser on_period # If not supported by the driver or browser default to using JS
rescue on_const on_op on_const on_op on_const on_op on_const on_op e on_nl unless UNK on_lparen e on_period message on_rparen UNK on_tstring_beg # Browser must have already gone
UNK on_tstring_beg on_tstring_content on_embexpr_beg e on_period message on_embexpr_end on_tstring_end on_nl end on_nl UNK on_ignored_nl on_ivar on_op nil on_nl end on_nl # Most likely already gone # probably already gone but not sure - so warn
on_op on_const on_op on_const on_op on_const on_op on_const on_comma on_ignored_nl on_op on_const on_op on_const on_op on_const on_op on_const on_comma on_op # Work around chromedriver go_back/go_forward race condition
on_op on_const on_op on_const on_op on_const on_op on_const on_rbracket on_period UNK do on_op UNK on_op on_ignored_nl unless UNK on_nl on_op # IE
on_rbracket on_period UNK do on_op UNK on_op on_ignored_nl unless UNK on_nl on_op on_const on_op on_const on_period UNK on_period UNK do # IE
end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_lbracket on_const on_op on_const on_op on_const on_op on_const on_rbracket on_nl end on_nl # delete_all_cookies fails when we've previously gone # to about:blank, so we rescue this error and do nothing # instead.
end on_nl on_ignored_nl def UNK on_nl if on_ivar on_period UNK on_symbeg UNK on_nl on_ivar on_period UNK on_period UNK on_nl else # session/local storage may not be available if on non-http pages (e.g. about:blank)
unless options on_lbracket on_symbeg UNK on_rbracket on_period UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl end on_nl # rubocop:disable Style/RescueStandardError
unless options on_lbracket on_symbeg UNK on_rbracket on_period UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl end on_nl # rubocop:disable Style/RescueStandardError
on_ivar on_period switch_to on_period alert on_period UNK on_nl rescue UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_const on_op on_const # slight wait for alert
end on_nl on_ignored_nl def UNK on_nl on_const on_op on_const on_op on_const on_op on_const on_nl end on_nl on_ignored_nl def within_given_window on_lparen # alert now gone, should mean navigation happened
UNK on_op on_const on_op on_const on_op on_const on_period new on_lparen on_ignored_nl on_label options on_period UNK on_lparen on_symbeg UNK on_comma UNK # Selenium has its own built in wait (2 seconds)for a modal to show up, so this wait is really the minimum time # Actual wait time may be longer than specified
UNK UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_const on_period UNK on_nl UNK do on_ignored_nl # rubocop:disable Style/CaseEquality
on_ivar on_op UNK on_period UNK if UNK on_period UNK on_lparen on_const on_rparen on_nl UNK if on_const on_period UNK on_op UNK # Store the exit status of the test run since it goes away after calling the at_exit proc...
end on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl on_ivar on_period navigate on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Force exit with stored status
on_ivar on_period navigate on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end # It has been observed that it is possible that asynchronous JS code in # the application under test can navigate the browser away from about:blank # if the timing is just right. Ensure we are still at about:blank...
rescue UNK on_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen if UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl # allow time for the modal to be handled
UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen if UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl on_ignored_nl require on_tstring_beg # The alert is now gone. # If navigation has not occurred attempt again and accept alert # since FF may have dismissed the alert at first attempt.
