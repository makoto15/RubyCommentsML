on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_lparen locator on_op nil on_comma on_op options # frozen_string_literal: true
on_ignored_nl def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl find on_lparen on_symbeg UNK on_comma locator on_comma on_op # @!macro waiting_behavior # If the driver is capable of executing JavaScript, this method will wait for a set amount of time # and continuously retry finding the element until either the element is found or the time # expires. The length of time this method will wait is controlled through {Capybara.configure default_max_wait_time}. # # @option options [false, true, Numeric] wait # Maximum time to wait for matching element to appear. Defaults to {Capybara.configure default_max_wait_time}.
def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl find on_lparen on_symbeg UNK on_comma locator on_comma on_op options ## # # Finds a button or link and clicks it. See {#click_button} and # {#click_link} for what locator will match against for each type of element. # # @overload click_link_or_button([locator], **options) # @macro waiting_behavior # @param [String] locator See {#click_button} and {#click_link} # # @return [Capybara::Node::Element] The element clicked #
def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl find on_lparen on_symbeg UNK on_comma locator on_comma on_op options ## # # Finds a link by id, {Capybara.configure test_id} attribute, text or title and clicks it. Also looks at image # alt text inside the link. # # @overload click_link([locator], **options) # @macro waiting_behavior # @param [String] locator text, id, {Capybara.configure test_id} attribute, title or nested image's alt attribute # @param [Hash] options See {Capybara::Node::Finders#find_link} # # @return [Capybara::Node::Element] The element clicked
def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl find on_lparen on_symbeg UNK on_comma locator on_comma on_op options ## # # Finds a button on the page and clicks it. # This can be any `<input>` element of type submit, reset, image, button or it can be a # `<button>` element. All buttons can be found by their id, name, {Capybara.configure test_id} attribute, value, or title. `<button>` elements can also be found # by their text content, and image `<input>` elements by their alt attribute. # # @overload click_button([locator], **options) # @macro waiting_behavior # @param [String] locator Which button to find # @param [Hash] options See {Capybara::Node::Finders#find_button} # @return [Capybara::Node::Element] The element clicked
def UNK on_lparen locator on_op nil on_comma on_label on_comma on_label nil on_comma on_label UNK UNK on_comma on_op UNK on_rparen on_ignored_nl ## # # Locate a text field or text area and fill it in with the given text. # The field can be found via its name, id, {Capybara.configure test_id} attribute, placeholder, or label text. # If no locator is provided this will operate on self or a descendant. # # # will fill in a descendant fillable field with name, id, or label text matching 'Name' # page.fill_in 'Name', with: 'Bob' # # # will fill in `el` if it's a fillable field # el.fill_in with: 'Tom' # # # @overload fill_in([locator], with:, **options) # @param [String] locator Which field to fill in # @param [Hash] options # @param with: [String] The value to fill in # @macro waiting_behavior # @option options [String] currently_with The current value property of the field to fill in # @option options [Boolean] multiple Match fields that can have multiple values? # @option options [String, Regexp] id Match fields that match the id attribute # @option options [String] name Match fields that match the name attribute # @option options [String] placeholder Match fields that match the placeholder attribute # @option options [String, Array<String>, Regexp] class Match fields that match the class(es) provided # @option options [Hash] fill_options Driver specific options regarding how to fill fields (Defaults come from {Capybara.configure default_set_options}) # # @return [Capybara::Node::Element] The element filled in
on_ignored_nl def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma true on_comma locator # @!macro label_click # @option options [Boolean] allow_label_click # Attempt to click the label to toggle state if element is non-visible. Defaults to {Capybara.configure automatic_label_click}.
def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma true on_comma locator on_comma ## # # Find a descendant radio button and mark it as checked. The radio button can be found # via name, id, {Capybara.configure test_id} attribute or label text. If no locator is # provided this will match against self or a descendant. # # # will choose a descendant radio button with a name, id, or label text matching 'Male' # page.choose('Male') # # # will choose `el` if it's a radio button element # el.choose() # # @overload choose([locator], **options) # @param [String] locator Which radio button to choose # # @option options [String] option Value of the radio_button to choose # @option options [String, Regexp] id Match fields that match the id attribute # @option options [String] name Match fields that match the name attribute # @option options [String, Array<String>, Regexp] class Match fields that match the class(es) provided # @macro waiting_behavior # @macro label_click # # @return [Capybara::Node::Element] The element chosen or the label clicked
def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma true on_comma locator on_comma ## # # Find a descendant check box and mark it as checked. The check box can be found # via name, id, {Capybara.configure test_id} attribute, or label text. If no locator # is provided this will match against self or a descendant. # # # will check a descendant checkbox with a name, id, or label text matching 'German' # page.check('German') # # # will check `el` if it's a checkbox element # el.check() # # # @overload check([locator], **options) # @param [String] locator Which check box to check # # @option options [String] option Value of the checkbox to select # @option options [String, Regexp] id Match fields that match the id attribute # @option options [String] name Match fields that match the name attribute # @option options [String, Array<String>, Regexp] class Match fields that match the class(es) provided # @macro label_click # @macro waiting_behavior # # @return [Capybara::Node::Element] The element checked or the label clicked
def UNK on_lparen locator on_op nil on_comma on_op options on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma UNK on_comma locator on_comma ## # # Find a descendant check box and uncheck it. The check box can be found # via name, id, {Capybara.configure test_id} attribute, or label text. If # no locator is provided this will match against self or a descendant. # # # will uncheck a descendant checkbox with a name, id, or label text matching 'German' # page.uncheck('German') # # # will uncheck `el` if it's a checkbox element # el.uncheck() # # # @overload uncheck([locator], **options) # @param [String] locator Which check box to uncheck # # @option options [String] option Value of the checkbox to deselect # @option options [String, Regexp] id Match fields that match the id attribute # @option options [String] name Match fields that match the name attribute # @option options [String, Array<String>, Regexp] class Match fields that match the class(es) provided # @macro label_click # @macro waiting_behavior # # @return [Capybara::Node::Element] The element unchecked or the label clicked
def UNK on_lparen value on_op nil on_comma on_label nil on_comma on_op options on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end ## # # If `from` option is present, {#select} finds a select box, or text input with associated datalist, # on the page and selects a particular option from it. # Otherwise it finds an option inside current scope and selects it. # If the select box is a multiple select, {#select} can be called multiple times to select more than # one option. # The select box can be found via its name, id, {Capybara.configure test_id} attribute, or label text. # The option can be found by its text. # # page.select 'March', from: 'Month' # # @overload select(value = nil, from: nil, **options) # @macro waiting_behavior # # @param value [String] Which option to select # @param from [String] The id, {Capybara.configure test_id} attribute, name or label of the select box # # @return [Capybara::Node::Element] The option element selected
def UNK on_lparen value on_op nil on_comma on_label nil on_comma on_op options on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end ## # # Find a select box on the page and unselect a particular option from it. If the select # box is a multiple select, {#unselect} can be called multiple times to unselect more than # one option. The select box can be found via its name, id, {Capybara.configure test_id} attribute, # or label text. # # page.unselect 'March', from: 'Month' # # @overload unselect(value = nil, from: nil, **options) # @macro waiting_behavior # # @param value [String] Which option to unselect # @param from [String] The id, {Capybara.configure test_id} attribute, name or label of the select box # # # @return [Capybara::Node::Element] The option element unselected
def UNK on_lparen locator on_op nil on_comma UNK on_comma on_label nil on_comma on_op options on_rparen if locator on_op UNK on_nl ## # # Find a descendant file field on the page and attach a file given its path. There are two ways to use # {#attach_file}, in the first method the file field can be found via its name, id, # {Capybara.configure test_id} attribute, or label text. In the case of the file field being hidden for # styling reasons the `make_visible` option can be used to temporarily change the CSS of # the file field, attach the file, and then revert the CSS back to original. If no locator is # passed this will match self or a descendant. # The second method, which is currently in beta and may be changed/removed, involves passing a block # which performs whatever actions would trigger the file chooser to appear. # # # will attach file to a descendant file input element that has a name, id, or label_text matching 'My File' # page.attach_file('My File', '/path/to/file.png') # # # will attach file to el if it's a file input element # el.attach_file('/path/to/file.png') # # # will attach file to whatever file input is triggered by the block # page.attach_file('/path/to/file.png') do # page.find('#upload_button').click # end # # @overload attach_file([locator], paths, **options) # @macro waiting_behavior # # @param [String] locator Which field to attach the file to # @param [String, Array<String>] paths The path(s) of the file(s) that will be attached # # @option options [Symbol] match # The matching strategy to use (:one, :first, :prefer_exact, :smart). Defaults to {Capybara.configure match}. # @option options [Boolean] exact # Match the exact label name/contents or accept a partial match. Defaults to {Capybara.configure exact}. # @option options [Boolean] multiple Match field which allows multiple file selection # @option options [String, Regexp] id Match fields that match the id attribute # @option options [String] name Match fields that match the name attribute # @option options [String, Array<String>, Regexp] class Match fields that match the class(es) provided # @option options [true, Hash] make_visible # A Hash of CSS styles to change before attempting to attach the file, if `true`, `{ opacity: 1, display: 'block', visibility: 'visible' }` is used (may not be supported by all drivers). # @overload attach_file(paths, &blk) # @param [String, Array<String>] paths The path(s) of the file(s) that will be attached # @yield Block whose actions will trigger the system file chooser to be shown # @return [Capybara::Node::Element] The file field element
if locator on_op UNK on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl on_const on_lparen UNK on_rparen on_period # rubocop:disable Style/OptionalArguments
if UNK on_nl UNK on_op file_field on_op find on_lparen on_symbeg file_field on_comma locator on_comma on_op options on_period UNK on_lparen on_label # Allow user to update the CSS style of the file input since they are so often hidden on a page
raise if UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content on_tstring_end on_period UNK UNK on_op option on_op options on_period UNK on_lparen option # rubocop:disable Naming/RescuedExceptionsVariableName
raise on_const on_op on_const on_comma on_tstring_beg UNK UNK on_period UNK UNK on_tstring_content UNK UNK on_period UNK UNK on_tstring_end on_nl end # rubocop:disable Naming/RescuedExceptionsVariableName
UNK on_op find on_lparen on_symbeg UNK on_comma on_const on_period UNK on_lparen on_symbeg UNK on_rparen on_lbracket on_const on_period UNK on_lparen on_symbeg # Implement for drivers that don't support JS
end on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_comma locator on_comma on_ignored_nl on_label UNK on_period UNK on_comma on_op options # rubocop:disable Lint/SuppressedException swallow extra errors
raise UNK on_nl end on_nl end on_nl end on_nl on_ignored_nl on_const on_op UNK on_nl on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content # swallow extra errors - raise original
