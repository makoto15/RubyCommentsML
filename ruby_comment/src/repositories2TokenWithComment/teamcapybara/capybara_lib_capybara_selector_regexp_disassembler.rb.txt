on_ignored_nl UNK UNK UNK UNK on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl def UNK on_lparen UNK # frozen_string_literal: true
UNK on_const on_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar # @api private
strings on_period UNK on_nl on_ignored_nl strings on_period UNK do on_op UNK on_op on_ignored_nl strings on_period UNK do on_op UNK on_op # delete_if is documented to modify the array after every block iteration - this doesn't appear to be true # uniq the strings to prevent identical strings from removing each other
strings on_period UNK do on_op UNK on_op on_ignored_nl strings on_period UNK do on_op UNK on_op on_ignored_nl UNK if UNK on_period # If we have "ab" and "abcd" required - only need to check for "abcd"
on_ignored_nl UNK on_period each on_lbrace on_op strs on_op UNK on_lparen strs on_rparen on_rbrace on_nl on_ignored_nl UNK on_period UNK do on_op # If we are going to match `("a" and "b") or ("ade" and "bce")` it only makes sense to match ("a" and "b")
UNK on_period each on_lbrace on_op strs on_op UNK on_lparen strs on_rparen on_rbrace on_nl on_ignored_nl UNK on_period UNK do on_op UNK # Ensure minimum sets of strings are being or'd
UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK if UNK on_period # Remove any of the alternated string series that fully contain any other string series
UNK on_const on_nl def UNK on_lparen exp on_rparen on_ignored_nl on_ivar on_op exp on_nl end on_nl on_ignored_nl def extract_strings on_lparen process_alternatives # @api private
