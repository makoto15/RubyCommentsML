on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK UNK session on_comma UNK base on_comma UNK UNK on_nl # frozen_string_literal: true
UNK on_const on_nl UNK UNK session on_comma UNK base on_comma UNK UNK on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const ## # # A {Capybara::Node::Base} represents either an element on a page through the subclass # {Capybara::Node::Element} or a document through {Capybara::Node::Document}. # # Both types of Node share the same methods, used for interacting with the # elements on the page. These methods are divided into three categories, # finders, actions and matchers. These are found in the modules # {Capybara::Node::Finders}, {Capybara::Node::Actions} and {Capybara::Node::Matchers} # respectively. # # A {Capybara::Session} exposes all methods from {Capybara::Node::Document} directly: # # session = Capybara::Session.new(:rack_test, my_app) # session.visit('/') # session.fill_in('Foo', with: 'Bar') # from Capybara::Node::Actions # bar = session.find('#bar') # from Capybara::Node::Finders # bar.select('Baz', from: 'Quox') # from Capybara::Node::Actions # session.has_css?('#foobar') # from Capybara::Node::Matchers #
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_op UNK on_comma UNK UNK on_rparen on_ignored_nl UNK # overridden in subclasses, e.g. Capybara::Node::Element
def UNK on_lparen UNK on_op UNK on_comma UNK UNK on_rparen on_ignored_nl UNK UNK if session on_period UNK on_nl on_ignored_nl UNK ## # # This method is Capybara's primary defence against asynchronicity # problems. It works by attempting to run a given block of code until it # succeeds. The exact behaviour of this method depends on a number of # factors. Basically there are certain exceptions which, when raised # from the block, instead of bubbling up, are caught, and the block is # re-run. # # Certain drivers, such as RackTest, have no support for asynchronous # processes, these drivers run the block, and any error raised bubbles up # immediately. This allows faster turn around in the case where an # expectation fails. # # Only exceptions that are {Capybara::ElementNotFound} or any subclass # thereof cause the block to be rerun. Drivers may specify additional # exceptions which also cause reruns. This usually occurs when a node is # manipulated which no longer exists on the page. For example, the # Selenium driver specifies # `Selenium::WebDriver::Error::ObsoleteElementError`. # # As long as any of these exceptions are thrown, the block is re-run, # until a certain amount of time passes. The amount of time defaults to # {Capybara.default_max_wait_time} and can be overridden through the `seconds` # argument. This time is compared with the system time to see how much # time has passed. On rubies/platforms which don't support access to a monotonic process clock # if the return value of `Time.now` is stubbed out, Capybara will raise `Capybara::FrozenInTime`. # # @param [Integer] seconds (current sessions default_max_wait_time) Maximum number of seconds to retry this block # @param [Array<Exception>] errors (driver.invalid_element_errors + # [Capybara::ElementNotFound]) exception types that cause the block to be rerun # @return [Object] The result of the given block # @raise [Capybara::FrozenInTime] If the return value of `Time.now` appears stuck #
def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl if base on_period UNK on_lparen UNK UNK on_rparen on_period UNK on_op # @api private
def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl if base on_period UNK on_lparen UNK UNK on_rparen on_period UNK on_op # @api private
def UNK on_nl session on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl UNK on_nl # @api private
