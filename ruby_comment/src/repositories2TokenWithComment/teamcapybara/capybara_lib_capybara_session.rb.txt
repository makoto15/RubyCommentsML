on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl on_const on_op UNK on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content ## # # The {Session} class represents a single user's interaction with the system. The {Session} can use # any of the underlying drivers. A session can be initialized manually like this: # # session = Capybara::Session.new(:culerity, MyRackApp) # # The application given as the second argument is optional. When running Capybara against an external # page, you might want to leave it out: # # session = Capybara::Session.new(:culerity) # session.visit('http://www.google.com') # # When {Capybara.configure threadsafe} is `true` the sessions options will be initially set to the # current values of the global options and a configuration block can be passed to the session initializer. # For available options see {Capybara::SessionConfig::OPTIONS}: # # session = Capybara::Session.new(:driver, MyRackApp) do |config| # config.app_host = "http://my_host.dev" # end # # The {Session} provides a number of methods for controlling the navigation of the page, such as {#visit}, # {#current_path}, and so on. It also delegates a number of methods to a {Capybara::Document}, representing # the current HTML document. This allows interaction: # # session.fill_in('q', with: 'Capybara') # session.click_button('Search') # expect(session).to have_content('Capybara') # # When using `capybara/dsl`, the {Session} is initialized automatically for you. #
on_const on_op UNK on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_end on_period UNK on_nl on_const on_op # @api private
on_ivar on_op mode on_nl on_ivar on_op app on_nl if block_given? on_nl raise on_tstring_beg on_tstring_content on_tstring_end unless on_const on_period UNK on_nl # rubocop:disable Style/ClassVars
def UNK on_nl if on_ivar on_nl driver on_period UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ivar on_op UNK on_nl ## # # Reset the session (i.e. remove cookies and navigate to blank page). # # This method does not: # # * accept modal dialogs if they are present (Selenium driver now does, others may not) # * clear browser cache/HTML 5 local storage/IndexedDB/Web SQL database/etc. # * modify state of the driver/underlying browser in any other way # # as doing so will result in performance downsides and it's not needed to do everything from the list above for most apps. # # If you want to do anything from the list above on a general basis you can: # # * write RSpec/Cucumber/etc. after hook # * monkeypatch this method # * use Ruby's `prepend` method #
def UNK on_nl on_ivar on_period UNK if on_ivar on_period UNK on_symbeg UNK on_nl on_ivar on_op on_ivar on_op nil on_nl on_ivar ## # # Disconnect from the current driver. A new driver will be instantiated on the next interaction. #
def UNK on_nl UNK unless on_ivar on_op UNK on_nl on_ignored_nl begin on_ignored_nl if config on_period UNK on_nl raise on_const on_comma ## # # Raise errors encountered in the server. #
begin on_ignored_nl if config on_period UNK on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl UNK on_const on_nl raise # Force an explanation for the error being raised as the exception cause
raise on_ivar on_period UNK on_comma on_ivar on_period UNK on_period UNK on_comma on_ivar on_period UNK on_period UNK on_nl ensure on_ignored_nl on_ivar # needed to get the cause set correctly in JRuby -- otherwise we could just do raise @server.error
def UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl ## # # Returns a hash of response headers. Not supported by all drivers (e.g. Selenium). # # @return [Hash<String, String>] A hash of response headers. #
def UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl driver on_period UNK on_nl end on_nl UNK ## # # Returns the current HTTP status code as an integer. Not supported by all drivers (e.g. Selenium). # # @return [Integer] Current HTTP status code #
def UNK on_nl driver on_period UNK on_nl end on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl UNK on_symbeg UNK on_comma ## # # @return [String] A snapshot of the DOM of the current document, as it looks right now (potentially modified by JavaScript). #
def UNK on_nl uri on_op on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK nil if uri ## # # @return [String] Path of the current page, without any domain information #
uri on_op on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK nil if uri on_op UNK on_op # Addressable parsing is more lenient than URI
UNK nil if uri on_op UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl path on_op uri on_op path on_nl path unless # Addressable doesn't support opaque URIs - we want nil here
def UNK on_nl uri on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_tstring_beg on_embexpr_beg uri on_period UNK on_embexpr_end on_tstring_content on_embexpr_beg ## # # @return [String] Host of the current page #
def UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen visit_uri on_rparen on_ignored_nl UNK on_nl on_ivar on_op ## # # @return [String] Fully qualified URL of the current page #
def UNK on_lparen visit_uri on_rparen on_ignored_nl UNK on_nl on_ivar on_op true on_nl on_ignored_nl visit_uri on_op on_op on_const on_op on_const on_period ## # # Navigate to the given URL. The URL can either be a relative URL or an absolute URL # The behaviour of either depends on the driver. # # session.visit('/foo') # session.visit('http://google.com') # # For drivers which can run against an external application, such as the selenium driver # giving an absolute URL will navigate to that page. This allows testing applications # running on remote servers. For these drivers, setting {Capybara.configure app_host} will make the # remote server the default. For example: # # Capybara.app_host = 'http://google.com' # session.visit('/') # visits the google homepage # # If {Capybara.configure always_include_port} is set to `true` and this session is running against # a rack application, then the port that the rack application is running on will automatically # be inserted into the URL. Supposing the app is running on port `4567`, doing something like: # # visit("http://google.com/test") # # Will actually navigate to `http://google.com:4567/test`. # # @param [#to_s] visit_uri The URL to navigate to. The parameter will be cast to a String. #
UNK on_lbracket on_symbeg path on_rbracket on_op UNK on_period path on_op visit_uri on_period path on_nl on_ignored_nl visit_uri on_op UNK on_period UNK # Useful to people deploying to a subdirectory # and/or single page apps where only the url fragment changes
def UNK on_nl UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl driver on_period UNK on_nl end ## # # Refresh the page. #
def UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl ## # # Move back a single entry in the browser's history. #
def UNK on_nl driver on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op args on_comma on_op kw_args on_rparen on_ignored_nl ## # # Move forward a single entry in the browser's history. #
def UNK on_lparen on_op args on_comma on_op kw_args on_rparen on_ignored_nl UNK on_op args on_period UNK on_period UNK on_lparen on_symbeg UNK ## # # Executes the given block within the context of a node. {#within} takes the # same options as {Capybara::Node::Finders#find #find}, as well as a block. For the duration of the # block, any command to Capybara will be handled as though it were scoped # to the given element. # # within(:xpath, './/div[@id="delivery-address"]') do # fill_in('Street', with: '12 Main Street') # end # # Just as with `#find`, if multiple elements match the selector given to # {#within}, an error will be raised, and just as with `#find`, this # behaviour can be controlled through the `:match` and `:exact` options. # # It is possible to omit the first parameter, in that case, the selector is # assumed to be of the type set in {Capybara.configure default_selector}. # # within('div#delivery-address') do # fill_in('Street', with: '12 Main Street') # end # # Note that a lot of uses of {#within} can be replaced more succinctly with # chaining: # # find('div#delivery-address').fill_in('Street', with: '12 Main Street') # # @overload within(*find_args) # @param (see Capybara::Node::Finders#all) # # @overload within(a_node) # @param [Capybara::Node::Base] a_node The node in whose scope the block should be evaluated # # @raise [Capybara::ElementNotFound] If the scope can't be found before time expires #
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma UNK on_rparen on_lbrace yield on_rbrace on_nl end on_nl on_ignored_nl ## # # Execute the given block within the a specific fieldset given the id or legend of that fieldset. # # @param [String] locator Id or legend of the fieldset #
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma UNK on_rparen on_lbrace yield on_rbrace on_nl end on_nl on_ignored_nl ## # # Execute the given block within the a specific table given the id or caption of that table. # # @param [String] locator Id or caption of the table #
def switch_to_frame on_lparen frame on_rparen on_ignored_nl UNK frame on_nl when on_const on_op on_const on_op on_const on_nl driver on_period switch_to_frame on_lparen ## # # Switch to the given frame. # # If you use this method you are responsible for making sure you switch back to the parent frame when done in the frame changed to. # {#within_frame} is preferred over this method and should be used when possible. # May not be supported by all drivers. # # @overload switch_to_frame(element) # @param [Capybara::Node::Element] element iframe/frame element to switch to # @overload switch_to_frame(location) # @param [Symbol] location relative location of the frame to switch to # * :parent - the parent frame # * :top - the top level document #
def UNK on_lparen on_op args on_comma on_op kw_args on_rparen on_ignored_nl switch_to_frame on_lparen UNK on_lparen on_op args on_comma on_op kw_args on_rparen ## # # Execute the given block within the given iframe using given frame, frame name/id or index. # May not be supported by all drivers. # # @overload within_frame(element) # @param [Capybara::Node::Element] frame element # @overload within_frame([kind = :frame], locator, **options) # @param [Symbol] kind Optional selector type (:frame, :css, :xpath, etc.) - Defaults to :frame # @param [String] locator The locator for the given selector kind. For :frame this is the name/id of a frame/iframe element # @overload within_frame(index) # @param [Integer] index index of a frame (0 based)
def UNK on_nl on_const on_period new on_lparen self on_comma driver on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl ## # @return [Capybara::Window] current window #
def UNK on_nl driver on_period UNK on_period UNK do on_op handle on_op on_ignored_nl on_const on_period new on_lparen self on_comma handle ## # Get all opened windows. # The order of windows in returned array is not defined. # The driver may sort windows by their creation time but it's not required. # # @return [Array<Capybara::Window>] an array of all windows #
def UNK on_lparen UNK on_op on_symbeg UNK on_rparen on_ignored_nl UNK do on_ignored_nl if driver on_period method on_lparen on_symbeg UNK on_rparen ## # Open a new window. # The current window doesn't change as the result of this call. # It should be switched to explicitly. # # @return [Capybara::Window] window that has been opened #
def UNK on_lparen window on_op nil on_comma on_op options on_comma on_op UNK on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end ## # Switch to the given window. # # @overload switch_to_window(&block) # Switches to the first window for which given block returns a value other than false or nil. # If window that matches block can't be found, the window will be switched back and {Capybara::WindowError} will be raised. # @example # window = switch_to_window { title == 'Page title' } # @raise [Capybara::WindowError] if no window matches given block # @overload switch_to_window(window) # @param window [Capybara::Window] window that should be switched to # @raise [Capybara::Driver::Base#no_such_window_error] if nonexistent (e.g. closed) window was passed # # @return [Capybara::Window] window that has been switched to # @raise [Capybara::ScopeError] if this method is invoked inside {#within} or # {#within_frame} methods # @raise [ArgumentError] if both or neither arguments were provided #
def UNK on_lparen window_or_proc on_rparen on_ignored_nl UNK on_op UNK on_nl scopes on_op nil on_nl begin on_ignored_nl UNK window_or_proc on_nl when ## # This method does the following: # # 1. Switches to the given window (it can be located by window instance/lambda/string). # 2. Executes the given block (within window located at previous step). # 3. Switches back (this step will be invoked even if an exception occurs at the second step). # # @overload within_window(window) { do_something } # @param window [Capybara::Window] instance of {Capybara::Window} class # that will be switched to # @raise [driver#no_such_window_error] if nonexistent (e.g. closed) window was passed # @overload within_window(proc_or_lambda) { do_something } # @param lambda [Proc] First window for which lambda # returns a value other than false or nil will be switched to. # @example # within_window(->{ page.title == 'Page title' }) { click_button 'Submit' } # @raise [Capybara::WindowError] if no window matching lambda was found # # @raise [Capybara::ScopeError] if this method is invoked inside {#within_frame} method # @return value returned by the block #
def UNK on_lparen on_op options on_rparen on_ignored_nl UNK on_op driver on_period UNK on_nl yield on_nl on_ignored_nl UNK on_lparen options on_rparen ## # Get the window that has been opened by the passed block. # It will wait for it to be opened (in the same way as other Capybara methods wait). # It's better to use this method than `windows.last` # {https://dvcs.w3.org/hg/webdriver/raw-file/default/webdriver-spec.html#h_note_10 as order of windows isn't defined in some drivers}. # # @overload window_opened_by(**options, &block) # @param options [Hash] # @option options [Numeric] :wait maximum wait time. Defaults to {Capybara.configure default_max_wait_time} # @return [Capybara::Window] the window that has been opened within a block # @raise [Capybara::WindowError] if block passed to window hasn't opened window # or opened more than one window #
def UNK on_lparen script on_comma on_op args on_rparen on_ignored_nl on_ivar on_op true on_nl driver on_period UNK on_lparen script on_comma on_op ## # # Execute the given script, not returning a result. This is useful for scripts that return # complex objects, such as jQuery statements. {#execute_script} should be used over # {#evaluate_script} whenever possible. # # @param [String] script A string of JavaScript to execute # @param args Optional arguments that will be passed to the script. Driver support for this is optional and types of objects supported may differ between drivers #
def UNK on_lparen script on_comma on_op args on_rparen on_ignored_nl on_ivar on_op true on_nl UNK on_op driver on_period UNK on_lparen script ## # # Evaluate the given JavaScript and return the result. Be careful when using this with # scripts that return complex objects, such as jQuery statements. {#execute_script} might # be a better alternative. # # @param [String] script A string of JavaScript to evaluate # @param args Optional arguments that will be passed to the script # @return [Object] The result of the evaluated JavaScript (may be driver specific) #
def UNK on_lparen script on_comma on_op args on_rparen on_ignored_nl on_ivar on_op true on_nl UNK on_op driver on_period UNK on_lparen script ## # # Evaluate the given JavaScript and obtain the result from a callback function which will be passed as the last argument to the script. # # @param [String] script A string of JavaScript to evaluate # @param args Optional arguments that will be passed to the script # @return [Object] The result of the evaluated JavaScript (may be driver specific) #
def UNK on_lparen text on_op nil on_comma on_op options on_comma on_op blk on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma text ## # # Execute the block, accepting a alert. # # @!macro modal_params # Expects a block whose actions will trigger the display modal to appear. # @example # $0 do # click_link('link that triggers appearance of system modal') # end # @overload $0(text, **options, &blk) # @param text [String, Regexp] Text or regex to match against the text in the modal. If not provided any modal is matched. # @option options [Numeric] :wait Maximum time to wait for the modal to appear after executing the block. Defaults to {Capybara.configure default_max_wait_time}. # @yield Block whose actions will trigger the system modal # @overload $0(**options, &blk) # @option options [Numeric] :wait Maximum time to wait for the modal to appear after executing the block. Defaults to {Capybara.configure default_max_wait_time}. # @yield Block whose actions will trigger the system modal # @return [String] the message shown in the modal # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found #
def UNK on_lparen text on_op nil on_comma on_op options on_comma on_op blk on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma text ## # # Execute the block, accepting a confirm. # # @macro modal_params #
def UNK on_lparen text on_op nil on_comma on_op options on_comma on_op blk on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma text ## # # Execute the block, dismissing a confirm. # # @macro modal_params #
def UNK on_lparen text on_op nil on_comma on_op options on_comma on_op blk on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma text ## # # Execute the block, accepting a prompt, optionally responding to the prompt. # # @macro modal_params # @option options [String] :with Response to provide to the prompt #
def UNK on_lparen text on_op nil on_comma on_op options on_comma on_op blk on_rparen on_ignored_nl UNK on_lparen on_symbeg UNK on_comma text ## # # Execute the block, dismissing a prompt. # # @macro modal_params #
def UNK on_lparen path on_op nil on_rparen on_ignored_nl UNK on_lparen path on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK do on_op ## # # Save a snapshot of the page. If {Capybara.configure asset_host} is set it will inject `base` tag # pointing to {Capybara.configure asset_host}. # # If invoked without arguments it will save file to {Capybara.configure save_path} # and file will be given randomly generated filename. If invoked with a relative path # the path will be relative to {Capybara.configure save_path}. # # @param [String] path the path to where it should be saved # @return [String] the path to which the file was saved #
def UNK on_lparen path on_op nil on_rparen on_ignored_nl UNK on_lparen path on_rparen on_period UNK on_lbrace on_op UNK on_op UNK on_lparen ## # # Save a snapshot of the page and open it in a browser for inspection. # # If invoked without arguments it will save file to {Capybara.configure save_path} # and file will be given randomly generated filename. If invoked with a relative path # the path will be relative to {Capybara.configure save_path}. # # @param [String] path the path to where it should be saved #
def UNK on_lparen path on_op nil on_comma on_op options on_rparen on_ignored_nl UNK on_lparen path on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period ## # # Save a screenshot of page. # # If invoked without arguments it will save file to {Capybara.configure save_path} # and file will be given randomly generated filename. If invoked with a relative path # the path will be relative to {Capybara.configure save_path}. # # @param [String] path the path to where it should be saved # @param [Hash] options a customizable set of options # @return [String] the path to which the file was saved
def UNK on_lparen path on_op nil on_comma on_op options on_rparen on_ignored_nl UNK on_lparen path on_comma on_op options on_rparen on_period UNK ## # # Save a screenshot of the page and open it for inspection. # # If invoked without arguments it will save file to {Capybara.configure save_path} # and file will be given randomly generated filename. If invoked with a relative path # the path will be relative to {Capybara.configure save_path}. # # @param [String] path the path to where it should be saved # @param [Hash] options a customizable set of options #
end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_const on_op on_const on_op on_const on_period new on_lparen self on_comma driver on_rparen # rubocop:disable Lint/Debugger
def UNK on_lparen UNK on_rparen on_ignored_nl if on_const on_period UNK on_nl begin on_ignored_nl UNK on_op config on_period UNK on_nl config ## # # Yield a block using a specific maximum wait time. #
def UNK on_nl raise on_tstring_beg on_tstring_content on_tstring_end unless on_const on_period UNK on_nl on_ignored_nl yield config on_nl end on_nl on_ignored_nl def ## # # Accepts a block to set the configuration options if {Capybara.configure threadsafe} is `true`. Note that some options only have an effect # if set at initialization time, so look at the configuration block that can be passed to the initializer too. #
on_ignored_nl def UNK on_lparen args on_rparen on_ignored_nl args on_period UNK on_lbrace on_op arg on_op arg on_period UNK on_lparen on_const on_op # rubocop:disable Style/ClassVars
