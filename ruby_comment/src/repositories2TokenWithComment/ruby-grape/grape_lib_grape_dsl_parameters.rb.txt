on_ignored_nl UNK UNK UNK UNK on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl on_ivar on_period UNK # Defines DSL methods, meant to be applied to a ParamsScope, which define # and describe the parameters accepted by an endpoint, or all endpoints # within a namespace.
def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl on_ivar on_period UNK on_lparen on_symbeg UNK on_comma UNK on_rparen on_nl end on_nl # Set the module used to build the request.params. # # @param build_with the ParamBuilder module to use when building request.params # Available builders are: # # * Grape::Extensions::ActiveSupport::HashWithIndifferentAccess::ParamBuilder (default) # * Grape::Extensions::Hash::ParamBuilder # * Grape::Extensions::Hashie::Mash::ParamBuilder # # @example # # require 'grape/extenstions/hashie_mash' # class API < Grape::API # desc "Get collection" # params do # build_with Grape::Extensions::Hashie::Mash::ParamBuilder # requires :user_id, type: Integer # end # get do # params['user_id'] # end # end
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_op on_ivar on_period UNK on_lparen on_symbeg UNK on_rparen on_op on_lbrace on_rbrace on_nl # Include reusable params rules among current. # You can define reusable params with helpers method. # # @example # # class API < Grape::API # helpers do # params :pagination do # optional :page, type: Integer # optional :per_page, type: Integer # end # end # # desc "Get collection" # params do # use :pagination # end # get do # Collection.page(params[:page]).per(params[:per_page]) # end # end
def UNK on_lparen on_op attrs on_comma on_op block on_rparen on_ignored_nl UNK on_op attrs on_period UNK on_nl on_ignored_nl opts on_op attrs # Require one or more parameters for the current endpoint. # # @param attrs list of parameter names, or, if :using is # passed as an option, which keys to include (:all or :none) from # the :using hash. The last key can be a hash, which specifies # options for the parameters # @option attrs :type [Class] the type to coerce this parameter to before # passing it to the endpoint. See {Grape::Validations::Types} for a list of # types that are supported automatically. Custom classes may be used # where they define a class-level `::parse` method, or in conjunction # with the `:coerce_with` parameter. `JSON` may be supplied to denote # `JSON`-formatted objects or arrays of objects. `Array[JSON]` accepts # the same values as `JSON` but will wrap single objects in an `Array`. # @option attrs :types [Array<Class>] may be supplied in place of +:type+ # to declare an attribute that has multiple allowed types. See # {Validations::Types::MultipleTypeCoercer} for more details on coercion # and validation rules for variant-type parameters. # @option attrs :desc [String] description to document this parameter # @option attrs :default [Object] default value, if parameter is optional # @option attrs :values [Array] permissable values for this field. If any # other value is given, it will be handled as a validation error # @option attrs :using [Hash[Symbol => Hash]] a hash defining keys and # options, like that returned by {Grape::Entity#documentation}. The value # of each key is an options hash accepting the same parameters # @option attrs :except [Array[Symbol]] a list of keys to exclude from # the :using Hash. The meaning of this depends on if :all or :none was # passed; :all + :except will make the :except fields optional, whereas # :none + :except will make the :except fields required # @option attrs :coerce_with [#parse, #call] method to be used when coercing # the parameter to the type named by `attrs[:type]`. Any class or object # that defines `::parse` or `::call` may be used. # # @example # # params do # # Basic usage: require a parameter of a certain type # requires :user_id, type: Integer # # # You don't need to specify type; String is default # requires :foo # # # Multiple params can be specified at once if they share # # the same options. # requires :x, :y, :z, type: Date # # # Nested parameters can be handled as hashes. You must # # pass in a block, within which you can use any of the # # parameters DSL methods. # requires :user, type: Hash do # requires :name, type: String # end # end
def UNK on_lparen on_op attrs on_comma on_op block on_rparen on_ignored_nl UNK on_op attrs on_period UNK on_nl on_ignored_nl opts on_op attrs # Allow, but don't require, one or more parameters for the current # endpoint. # @param (see #requires) # @option (see #requires)
if attrs on_op UNK on_nl UNK on_const on_op on_const on_op on_const on_period UNK if UNK on_period UNK on_nl UNK on_const # check type for optional parameter group
def UNK on_lparen on_op attrs on_comma on_op block on_rparen on_ignored_nl UNK on_lparen attrs on_period UNK on_comma on_op block on_rparen on_nl # Define common settings for one or more parameters # @param (see #requires) # @option (see #requires)
def UNK on_lparen on_op attrs on_rparen on_ignored_nl UNK on_lparen attrs on_comma on_label on_lbrace on_label true on_comma on_label UNK on_lparen attrs # Disallow the given parameters to be present in the same request. # @param attrs [*Symbol] parameters to validate
def UNK on_lparen on_op attrs on_rparen on_ignored_nl UNK on_lparen attrs on_comma on_label on_lbrace on_label true on_comma on_label UNK on_lparen attrs # Require exactly one of the given parameters to be present. # @param (see #mutually_exclusive)
def UNK on_lparen on_op attrs on_rparen on_ignored_nl UNK on_lparen attrs on_comma on_label on_lbrace on_label true on_comma on_label UNK on_lparen attrs # Require at least one of the given parameters to be present. # @param (see #mutually_exclusive)
def UNK on_lparen on_op attrs on_rparen on_ignored_nl UNK on_lparen attrs on_comma on_label on_lbrace on_label true on_comma on_label UNK on_lparen attrs # Require that either all given params are present, or none are. # @param (see #mutually_exclusive)
def UNK on_lparen on_op attrs on_comma on_op block on_rparen on_ignored_nl attrs on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_op # Define a block of validations which should be applied if and only if # the given parameter is present. The parameters are not nested. # @param attr [Symbol] the parameter which, if present, triggers the # validations # @raise Grape::Exceptions::UnknownParameter if `attr` has not been # defined in this scope yet # @yield a parameter definition DSL
def UNK on_lparen UNK on_rparen on_ignored_nl if UNK on_nl on_ivar on_period UNK on_lparen UNK on_rparen on_nl UNK on_ignored_nl on_ivar on_period # Test for whether a certain parameter has been defined in this params # block yet. # @return [Boolean] whether the parameter has been defined
on_ivar on_period UNK on_lparen UNK on_rparen on_nl UNK on_ignored_nl on_ivar on_period UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK # Elements of @declared_params of lateral scope are pushed in @parent. So check them in @parent.
on_ivar on_period UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_lparen UNK on_rparen on_op UNK on_nl end on_nl end # @declared_params also includes hashes of options and such, but those # won't be flattened out.
def params on_lparen params on_rparen on_ignored_nl params on_op on_ivar on_period params on_lparen params on_rparen if UNK on_lparen on_symbeg on_ivar on_rparen # @param params [Hash] initial hash of parameters # @return hash of parameters relevant for the current scope # @api private
