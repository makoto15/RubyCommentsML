on_ignored_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
UNK on_const on_nl UNK on_const UNK end on_nl on_ignored_nl on_const on_op UNK on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const # Module for code related to grape's system for # coercion and type validation of incoming request # parameters. # # Grape uses a number of tests and assertions to # work out exactly how a parameter should be handled, # based on the +type+ and +coerce_with+ options that # may be supplied to {Grape::Dsl::Parameters#requires} # and {Grape::Dsl::Parameters#optional}. The main # entry point for this process is {Types.build_coercer}.
UNK on_const UNK end on_nl on_ignored_nl on_const on_op UNK on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const # Instances of this class may be used as tokens to denote that # a parameter value could not be coerced.
on_const on_op UNK on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_ignored_nl on_const on_comma on_ignored_nl # Types representing a single value, which are coerced.
on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const # Numerical
on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_ignored_nl on_const on_op on_const on_op on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl # Date/time
on_const on_op on_const on_op on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_nl UNK on_period # Misc
on_const on_op UNK on_ignored_nl on_const on_comma on_ignored_nl on_const on_comma on_ignored_nl on_const on_nl UNK on_period UNK on_nl on_ignored_nl on_const on_op UNK # Types representing data structures.
on_const on_op UNK on_ignored_nl on_const on_op on_const on_comma on_ignored_nl on_const UNK on_const UNK on_op on_const on_comma on_ignored_nl on_op on_const on_op # Special custom types provided by Grape.
def self on_period UNK on_lparen type on_rparen on_ignored_nl on_const on_period UNK on_lparen type on_rparen on_nl end on_nl on_ignored_nl def self # Is the given class a primitive type as recognized by Grape? # # @param type [Class] type to check # @return [Boolean] whether or not the type is known by Grape as a valid # type for a single value
def self on_period UNK on_lparen type on_rparen on_ignored_nl on_const on_period UNK on_lparen type on_rparen on_nl end on_nl on_ignored_nl def self # Is the given class a standard data structure (collection or map) # as recognized by Grape? # # @param type [Class] type to check # @return [Boolean] whether or not the type is known by Grape as a valid # data structure type
def self on_period UNK on_lparen type on_rparen on_ignored_nl on_lparen type on_period UNK on_lparen on_const on_rparen on_op type on_period UNK on_lparen # Is the declared type in fact an array of multiple allowed types? # For example the declaration +types: [Integer,String]+ will attempt # first to coerce given values to integer, but will also accept any # other string. # # @param type [Array<Class>,Set<Class>] type (or type list!) to check # @return [Boolean] +true+ if the given value will be treated as # a list of types.
def self on_period UNK on_lparen type on_rparen on_ignored_nl on_const on_period UNK type on_nl end on_nl on_ignored_nl def self on_period UNK # Does Grape provide special coercion and validation # routines for the given class? This does not include # automatic handling for primitives, structures and # otherwise recognized types. See {Types::SPECIAL}. # # @param type [Class] type to check # @return [Boolean] +true+ if special routines are available
def self on_period UNK on_lparen type on_rparen on_ignored_nl on_const on_period UNK type on_nl end on_nl on_ignored_nl def self on_period UNK # Is the declared type a supported group type? # Currently supported group types are Array, Hash, JSON, and Array[JSON] # # @param type [Array<Class>,Class] type to check # @return [Boolean] +true+ if the type is a supported group type
def self on_period UNK on_lparen type on_rparen on_ignored_nl on_op UNK on_lparen type on_rparen on_op on_ignored_nl on_op UNK on_lparen type on_rparen # A valid custom type must implement a class-level `parse` method, taking # one String argument and returning the parsed value in its correct type. # # @param type [Class] type to check # @return [Boolean] whether or not the type can be used as a custom type
def self on_period UNK on_lparen type on_rparen on_ignored_nl on_lparen type on_period UNK on_lparen on_const on_rparen on_op type on_period UNK on_lparen # Is the declared type an +Array+ or +Set+ of a {#custom?} type? # # @param type [Array<Class>,Class] type to check # @return [Boolean] true if +type+ is a collection of a type that implements # its own +#parse+ method.
