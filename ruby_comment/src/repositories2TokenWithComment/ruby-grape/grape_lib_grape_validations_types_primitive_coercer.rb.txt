on_ignored_nl UNK UNK UNK UNK on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op UNK on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_const # Coerces the given value to a type defined via a +type+ argument during # initialization. When +strict+ is true, it doesn't coerce a value but check # that it has the proper type.
on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_period UNK on_nl on_ignored_nl on_const on_op UNK on_ignored_nl on_const on_op on_const # unfortunately, a +Params+ scope doesn't contain String
UNK UNK on_lparen val on_rparen on_ignored_nl on_lparen val on_period UNK on_lparen on_const on_rparen on_op type on_op on_const on_rparen on_op on_ignored_nl # This method maintains logic which was defined by Virtus. For example, # dry-types is ok to convert an array or a hash to a string, it is supported, # but Virtus wouldn't accept it. So, this method only exists to not introduce # breaking changes.
UNK UNK on_lparen val on_rparen on_ignored_nl val on_op UNK UNK on_op type on_op on_const on_op on_const on_op on_const on_nl end # Dry-Types treats an empty string as invalid. However, Grape considers an empty string as # absence of a value and coerces it into nil. See a discussion there # https://github.com/ruby-grape/grape/pull/2045
