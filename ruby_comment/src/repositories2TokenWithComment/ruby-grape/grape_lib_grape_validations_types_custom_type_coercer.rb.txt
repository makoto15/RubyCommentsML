on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl def UNK on_lparen type on_comma method on_op # frozen_string_literal: true
UNK on_const on_nl def UNK on_lparen type on_comma method on_op UNK on_rparen on_ignored_nl UNK on_op UNK type on_comma method on_nl # This class will detect type classes that implement # a class-level +parse+ method. The method should accept one # +String+ argument and should return the value coerced to # the appropriate type. The method may raise an exception if # there are any problems parsing the string. # # Alternately an optional +method+ may be supplied (see the # +coerce_with+ option of {Grape::Dsl::Parameters#requires}). # This may be any class or object implementing +parse+ or +call+, # with the same contract as described above. # # Type Checking # ------------- # # Calls to +coerced?+ will consult this class to check # that the coerced value produced above is in fact of the # expected type. By default this class performs a basic check # against the type supplied, but this behaviour will be # overridden if the class implements a class-level # +coerced?+ or +parsed?+ method. This method # will receive a single parameter that is the coerced value # and should return +true+ if the value meets type expectations. # Arbitrary assertions may be made here but the grape validation # system should be preferred. # # Alternately a proc or other object responding to +call+ may be # supplied in place of a type. This should implement the same # contract as +coerced?+, and must be supplied with a coercion # +method+.
def UNK on_lparen type on_comma method on_op UNK on_rparen on_ignored_nl UNK on_op UNK type on_comma method on_nl UNK on_op UNK # A new coercer for the given type specification # and coercion method. # # @param type [Class,#coerced?,#parsed?,#call?] # specifier for the target type. See class docs. # @param method [#parse,#call] # optional coercion method. See class docs.
def call on_lparen val on_rparen on_ignored_nl UNK if val on_period UNK on_nl on_ignored_nl UNK on_op UNK on_period call on_lparen val # Coerces the given value. # # @param value [String] value to be coerced, in grape # this should always be a string. # @return [Object] the coerced result
def UNK on_lparen type on_comma method on_rparen on_ignored_nl if method on_nl if method on_period respond_to? on_symbeg UNK on_nl method on_period # Determine the coercion method we're expected to use # based on the parameters given. # # @param type see #new # @param method see #new # @return [#call] coercion method
type on_period method on_symbeg UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen type on_rparen on_ignored_nl if type on_period # Try to use parse() declared on the target type. # This may raise an exception, but we are out of ideas anyway.
def UNK on_lparen type on_rparen on_ignored_nl if type on_period respond_to? on_symbeg UNK on_nl type on_period method on_symbeg UNK on_nl UNK # Determine how the type validity of a coerced # value should be decided. # # @param type see #new # @return [#call] a procedure which accepts a single parameter # and returns +true+ if the passed object is of the correct type.
if type on_period respond_to? on_symbeg UNK on_nl type on_period method on_symbeg UNK on_nl UNK type on_period respond_to? on_symbeg UNK on_nl # First check for special class methods
type on_nl UNK type on_period UNK on_lparen on_const on_rparen on_nl UNK on_lparen value on_rparen UNK value on_period respond_to? on_lparen on_symbeg # Arbitrary proc passed for type validation. # Note that this will fail unless a method is also # passed, or if the type also implements a parse() method.
UNK on_lparen value on_rparen UNK value on_period UNK type UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen type # By default, do a simple type check
def UNK on_lparen type on_comma method on_rparen on_ignored_nl if UNK on_const on_comma on_const UNK on_period UNK on_lparen type on_rparen on_nl # Enforce symbolized keys for complex types # by wrapping the coercion method such that # any Hash objects in the immediate heirarchy # have their keys recursively symbolized. # This helps common libs such as JSON to work easily. # # @param type see #new # @param method see #infer_coercion_method # @return [#call] +method+ wrapped in an additional # key-conversion step, or just returns +method+ # itself if no conversion is deemed to be # necessary.
if UNK on_const on_comma on_const UNK on_period UNK on_lparen type on_rparen on_nl UNK do on_op val on_op on_ignored_nl method on_period # Collections have all values processed individually
UNK type on_op on_const on_nl UNK do on_op val on_op on_ignored_nl UNK method on_period call on_lparen val on_rparen on_nl end # Hash objects are processed directly
UNK on_ignored_nl method on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen hash on_rparen on_ignored_nl hash on_period UNK do on_op # Simple types are not processed. # This includes Array<primitive> types.
