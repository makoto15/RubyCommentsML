on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_nl # frozen_string_literal: true
def UNK on_lparen opts on_comma on_op block on_rparen on_ignored_nl on_ivar on_op opts on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_op opts # Open up a new ParamsScope, allowing parameter definitions per # Grape::DSL::Params. # @param opts [Hash] options for this scope # @option opts :element [Symbol] the element that contains this scope; for # this to be relevant, @parent must be set # @option opts :parent [ParamsScope] the scope containing this scope # @option opts :api [API] the API endpoint to modify # @option opts :optional [Boolean] whether or not this scope needs to have # any parameters set or not # @option opts :type [Class] a type meant to govern this scope (deprecated) # @option opts :type [Hash] group options for this scope # @option opts :dependent_on [Symbol] if present, this scope should only # validate if this param is present in the parent scope # @yield the instance context, open for parameter definitions
def UNK on_lparen UNK on_rparen on_ignored_nl scoped_params on_op params on_lparen UNK on_rparen on_nl on_ignored_nl return false if on_ivar on_op on_lparen # @return [Boolean] whether or not this entire scope needs to be # validated
def UNK on_lparen name on_comma on_label nil on_rparen on_ignored_nl if UNK on_nl on_tstring_beg UNK on_ivar on_period UNK on_lparen on_ivar on_rparen # @return [String] the proper attribute name, with nesting considered.
on_tstring_beg UNK on_ivar on_period UNK on_lparen on_ivar on_rparen UNK UNK UNK on_lparen on_ivar on_op UNK on_rparen UNK UNK UNK on_lparen # Find our containing element's name, and append ours.
on_ivar on_period UNK on_lparen name on_comma on_label on_ivar on_rparen on_nl UNK on_ignored_nl name on_period UNK on_nl end on_nl end on_nl # Find the name of the element as if it was at the same nesting level # as our parent. We need to forward our index upward to achieve this.
name on_period UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_tstring_beg on_tstring_content UNK UNK UNK # We must be the root scope, so no prefix needed.
def UNK on_nl on_op on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_ivar on_nl end on_nl on_ignored_nl def # @return [Boolean] whether or not this scope is the root-level scope
def UNK on_nl on_ivar on_op on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_op on_ivar on_nl end on_nl # A nested scope is contained in one of its parent's elements. # @return [Boolean] whether or not this scope is nested
def UNK on_nl on_ivar on_op on_op on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl on_op on_ivar on_nl end on_nl on_ignored_nl # A lateral scope is subordinate to its parent, but its keys are at the # same level as its parent and thus is not contained within an element. # @return [Boolean] whether or not this scope is lateral
def UNK on_nl on_op on_ivar on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen attrs on_comma on_op opts on_rparen # @return [Boolean] whether or not this scope needs to be present, or can # be blank
def UNK on_lparen attrs on_comma on_op opts on_rparen on_ignored_nl if UNK on_nl on_ivar on_period UNK on_lparen attrs on_comma on_op opts # Adds a parameter declaration to our list of validations. # @param attrs [Array] (see Grape::DSL::Parameters#requires)
UNK on_op on_const on_lparen opts on_lbracket on_symbeg except on_rbracket on_rparen on_nl optional_fields on_op opts on_lbracket on_symbeg using on_rbracket on_period UNK # context == :none
def UNK on_lparen attrs on_comma optional on_op false on_comma on_op block on_rparen on_ignored_nl type on_op attrs on_lbracket UNK on_rbracket on_op # Returns a new parameter scope, subordinate to the current one and nested # under the parameter corresponding to `attrs.first`. # @param attrs [Array] the attributes passed to the `requires` or # `optional` invocation that opened this scope. # @param optional [Boolean] whether the parameter this are nested under # is optional or not (and hence, whether this block's params will be). # @yield parameter scope
type on_op attrs on_lbracket UNK on_rbracket on_op attrs on_lbracket UNK on_rbracket on_lbracket on_symbeg type on_rbracket on_op nil on_nl if attrs # if required params are grouped and no type or unsupported type is provided, raise an error
def UNK on_lparen options on_comma on_op block on_rparen on_ignored_nl self on_period UNK on_period new on_lparen on_ignored_nl on_label on_ivar on_comma on_ignored_nl # Returns a new parameter scope, not nested under any current-level param # but instead at the same level as the current scope. # @param options [Hash] options to control how this new scope behaves # @option options :dependent_on [Symbol] if given, specifies that this # scope should only validate if this parameter from the above scope is # present # @yield parameter scope
def UNK on_lparen attrs on_comma on_op block on_rparen on_ignored_nl self on_period UNK on_period new on_lparen on_ignored_nl on_label on_ivar on_comma on_ignored_nl # Returns a new parameter scope, subordinate to the current one and nested # under the parameter corresponding to `attrs.first`. # @param attrs [Array] the attributes passed to the `requires` or # `optional` invocation that opened this scope. # @yield parameter scope
def UNK on_nl if UNK on_nl on_ivar on_period UNK on_lbracket UNK on_op on_ivar on_rbracket on_nl UNK on_ignored_nl on_ivar on_period UNK # Pushes declared params to parent or settings
excepts on_op UNK on_lbracket on_symbeg except on_rbracket on_nl UNK on_ignored_nl values on_op validations on_lbracket on_symbeg values on_rbracket on_nl end on_nl # NB: excepts is deprecated
on_ignored_nl coerce_type on_op UNK on_lparen coerce_type on_comma values on_comma except_values on_comma excepts on_rparen on_nl on_ignored_nl UNK on_lparen default on_comma values # NB. values and excepts should be nil, Proc, Array, or Range. # Specifically, values should NOT be a Hash
coerce_type on_op UNK on_lparen coerce_type on_comma values on_comma except_values on_comma excepts on_rparen on_nl on_ignored_nl UNK on_lparen default on_comma values on_comma # use values or excepts to guess coerce type when stated type is Array
UNK on_lparen default on_comma values on_comma except_values on_comma excepts on_rparen on_nl on_ignored_nl UNK on_lparen coerce_type on_comma values on_comma except_values on_comma # default value should be present in values array, if both exist and are not procs
UNK on_lparen coerce_type on_comma values on_comma except_values on_comma excepts on_rparen on_nl on_ignored_nl doc_attrs on_lbracket on_symbeg UNK on_rbracket on_op validations on_period # type should be compatible with values array, if both exist
if validations on_period key? on_lparen on_symbeg UNK on_rparen on_op validations on_lbracket on_symbeg UNK on_rbracket on_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # Validate for presence before any other validators
coerce_type validations on_comma attrs on_comma doc_attrs on_comma opts on_nl on_ignored_nl validations on_period each do on_op type on_comma options on_op on_ignored_nl # Before we run the rest of the validators, let's handle # whatever coercion so that we are working with correctly # type casted values
def UNK on_lparen validations on_rparen on_ignored_nl if validations on_period key? on_lparen on_symbeg type on_rparen on_op validations on_period key? on_lparen on_symbeg # Validate and comprehend the +:type+, +:types+, and +:coerce_with+ # options that have been supplied to the parameter declaration. # The +:type+ and +:types+ options will be removed from the # validations list, replaced appropriately with +:coerce+ and # +:coerce_with+ options that will later be passed to # {Validators::CoerceValidator}. The type that is returned may be # used for documentation and further validation of parameter # options. # # @param validations [Hash] list of validations supplied to the # parameter declaration # @return [class-like] type to which the parameter will be coerced # @raise [ArgumentError] if the given type options are invalid
if on_const on_period UNK on_lparen coerce_type on_rparen on_op validations on_period key? on_lparen on_symbeg type on_rparen on_nl validations on_lbracket on_symbeg coerce # Special case - when the argument is a single type that is a # variant-type collection.
def UNK on_lparen validations on_rparen on_ignored_nl return unless validations on_period key? on_lparen on_symbeg UNK on_rparen on_nl raise on_const on_comma on_tstring_beg # Enforce correct usage of :coerce_with parameter. # We do not allow coercion without a type, nor with # +JSON+ as a type since this defines its own coercion # method.
raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end unless validations on_period key? on_lparen on_symbeg coerce on_rparen on_nl on_ignored_nl return unless on_lbracket on_const # type must be supplied for coerce_with..
return unless on_lbracket on_const on_comma on_const on_lbracket on_const on_rbracket on_rbracket on_period UNK validations on_lbracket on_symbeg coerce on_rbracket on_nl raise on_const # but not special JSON types, which # already imply coercion method
def coerce_type on_lparen validations on_comma attrs on_comma doc_attrs on_comma opts on_rparen on_ignored_nl UNK on_lparen validations on_rparen on_nl on_ignored_nl return unless # Add type coercion validation to this scope, # if any has been specified. # This validation has special handling since it is # composited from more than one +requires+/+optional+ # parameter, and needs to be run before most other # validations.
def UNK on_lparen validations on_rparen on_ignored_nl UNK on_op validations on_lbracket on_symbeg UNK on_rbracket on_nl on_ignored_nl on_lbrace on_ignored_nl on_label UNK on_period # Validators don't have access to each other and they don't need, however, # some validators might influence others, so their options should be shared
