on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl describe on_const on_op on_const do on_ignored_nl subject on_lbrace # frozen_string_literal: true
describe on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl on_ignored_nl end on_nl on_ignored_nl end on_nl on_ignored_nl describe on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK # Behavior as defined by rfc2616 when no header is defined # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
on_ignored_nl end on_nl on_ignored_nl end on_nl on_ignored_nl describe on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl let # subject.version 'v1', using: :header # subject.get '/hello' do # 'hello' # end
end on_nl on_ignored_nl end on_nl on_ignored_nl describe on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl let on_lparen # it 'routes' do # get '/hello' # last_response.status.should eql 200 # end
end on_nl on_ignored_nl describe on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl let on_lparen on_symbeg UNK on_rparen # pending 'routes if any media type is allowed'
end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl get on_tstring_beg on_tstring_content on_tstring_end on_nl expect on_lparen last_response on_period status on_rparen # json-encoded symbol
end on_nl end on_nl on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl subject on_period get on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen do # raw text
on_lparen UNK on_op on_lbracket verb on_rbracket on_rparen on_period each do on_op UNK on_op on_ignored_nl send on_lparen UNK on_comma on_tstring_beg on_tstring_content # Call it with all methods other than the properly constrained one.
describe on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl context on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl expect on_lparen # NOTE: this method is required to preserve the ability of pre-mounting # the root API into a namespace, it may be deprecated in the future.
header on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_embexpr_beg on_const on_period UNK on_lparen filename on_rparen on_embexpr_end on_tstring_end on_nl params on_lbracket on_symbeg # there's no formatter for :binary, data will be returned "as is"
it on_tstring_beg on_tstring_content on_tstring_end do on_ignored_nl subject on_period prefix on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl subject on_period UNK on_symbeg UNK do # TODO: refactor this to not be tied to versioning. How about a generic # .setting macro?
on_ignored_nl subject on_period rescue_from on_const do on_op e on_op on_ignored_nl error! on_lparen e on_comma on_int on_rparen on_nl end on_nl subject # The exception is matched to the rescue starting at the top, and matches only once
subject on_period version on_tstring_beg on_tstring_content on_tstring_end on_comma on_label on_symbeg path on_nl subject on_period prefix on_tstring_beg on_tstring_content on_tstring_end on_nl subject on_period # version v2
on_const on_op subject on_nl on_const on_period mount on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_period mount on_const on_op on_tstring_beg on_tstring_content # note that the reverse won't work, mount from outside-in
