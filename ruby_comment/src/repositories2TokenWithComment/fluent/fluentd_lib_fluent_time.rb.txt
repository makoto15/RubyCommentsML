on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # # Fluentd # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. #
def UNK on_nl on_const on_lparen on_ivar on_op on_int on_op on_ivar on_comma on_int on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # for Time.at
def UNK on_lparen other on_rparen on_ignored_nl on_lbracket other on_comma on_ivar on_rbracket on_nl end on_nl on_ignored_nl def to_s on_nl on_ivar on_period # for > and others
on_const on_period at on_lparen on_int on_comma on_int on_comma on_symbeg UNK on_rparen on_nl on_ignored_nl def UNK on_nl on_const on_period at on_lparen # ruby 2.5 or later
now on_op on_const on_period UNK on_lparen on_const on_op on_const on_comma on_symbeg UNK on_rparen on_nl on_const on_op on_const on_period new on_lparen # This method is called many time. so call Process.clock_gettime directly instead of Fluent::Clock.real_now
def UNK on_lparen name on_comma on_op UNK on_comma on_op UNK on_rparen on_ignored_nl on_ivar on_period UNK on_lparen name on_comma on_op UNK ## TODO: For performance, implement +, -, and so on
on_lbracket on_symbeg UNK on_comma on_symbeg UNK on_comma UNK on_label UNK on_rbrace on_rbracket on_comma on_lbracket on_symbeg timezone on_comma on_symbeg UNK on_comma # UTC if :localtime is false and :timezone is nil
on_lbracket on_symbeg timezone on_comma on_symbeg UNK on_comma UNK on_label nil on_rbrace on_rbracket on_comma on_ignored_nl on_rbracket on_nl on_const on_op on_lbracket on_ignored_nl # to turn :localtime false
on_lbracket on_symbeg UNK on_comma on_symbeg UNK on_comma UNK on_label on_symbeg UNK on_comma on_label on_const on_period UNK on_lparen on_op on_symbeg UNK # To avoid to define :time_type twice (in plugin_helper/inject)
end on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl if conf on_period has_key? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op conf on_period # Specifying "localtime false" means using UTC in TimeFormatter # And specifying "utc" is different from specifying "timezone +0000"(it's not always UTC). # There are difference between "Z" and "+0000" in timezone formatting. # TODO: add kwargs to TimeFormatter to specify "using localtime", "using UTC" or "using specified timezone" in more explicit way
offset_diff on_op UNK on_ignored_nl when UNK then nil on_nl when timezone then on_ignored_nl UNK on_op on_const on_op on_const on_period UNK # unixtime_in_expected_tz = unixtime_in_localtime + offset_diff
end on_nl on_ignored_nl strptime on_op format on_op on_lparen on_const on_period new on_lparen format on_rparen rescue nil on_rparen on_nl on_ignored_nl on_ivar # utc
def parse on_lparen value on_rparen on_ignored_nl UNK value on_period is_a? on_lparen on_const on_rparen on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg # TODO: new cache mechanism using format string
def UNK on_lparen type on_comma localtime on_op nil on_comma timezone on_op nil on_rparen on_ignored_nl on_ivar on_op on_ivar on_op on_ivar on_op # to include TimeParseError
define_singleton_method on_lparen on_symbeg parse on_comma method on_lparen on_symbeg UNK on_rparen on_rparen on_nl define_singleton_method on_lparen on_symbeg call on_comma method on_lparen on_symbeg # :float
def UNK on_lparen value on_rparen on_ignored_nl UNK value on_period is_a? on_lparen on_const on_rparen on_op value on_period is_a? on_lparen on_const on_rparen # rough benchmark result to compare handmade parser vs Fluent::EventTime.from_time(Time.at(value.to_r)) # full: with 9-digits of nsec after dot # msec: with 3-digits of msec after dot # 10_000_000 times loop on MacBookAir ## parse_by_myself(full): 12.162475 sec ## parse_by_myself(msec): 15.050435 sec ## parse_by_to_r (full): 28.722362 sec ## parse_by_to_r (msec): 28.232856 sec
nsec_s on_op nsec_s on_op nsec_s on_lbracket on_int on_op on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl nsec_s on_op on_tstring_beg on_tstring_content on_tstring_end # throw away second-dot and later
on_ignored_nl def UNK on_lparen time on_rparen on_ignored_nl on_ivar on_period call on_lparen time on_rparen on_nl end on_nl end on_nl on_ignored_nl class ## Dynamically defined in #initialize # def format(time) # end
define_singleton_method on_lparen on_symbeg format on_comma method on_lparen on_symbeg UNK on_rparen on_rparen on_nl define_singleton_method on_lparen on_symbeg call on_comma method on_lparen on_symbeg # :float
nsec_s on_op time on_period nsec on_period to_s on_nl nsec_s on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen on_int on_op nsec_s on_period UNK # 10.015 secs for 10_000_000 times call on MacBookAir
time on_period UNK on_period to_s on_nl end on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP # integer (or float?)
