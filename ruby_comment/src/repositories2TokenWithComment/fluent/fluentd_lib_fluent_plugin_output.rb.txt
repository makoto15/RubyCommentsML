on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # # Fluentd # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. #
UNK on_symbeg UNK on_comma on_label on_symbeg UNK on_comma on_label true on_comma on_label false on_comma on_label false on_comma on_label true do # `<buffer>` and `<secondary>` sections are available only when '#format' and '#write' are implemented
config_param on_symbeg UNK on_comma on_symbeg time on_comma on_label on_int on_nl config_param on_symbeg UNK on_comma on_symbeg bool on_comma on_label false config_param # range size to be used: `time.to_i / @timekey`
config_param on_symbeg UNK on_comma on_symbeg bool on_comma on_label false config_param on_symbeg UNK on_comma on_symbeg string on_comma on_label on_const on_period now # These are for #extract_placeholders
config_param on_symbeg UNK on_comma on_symbeg string on_comma on_label on_const on_period now on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_ignored_nl UNK # default is localtime
on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl config_param on_symbeg UNK on_comma on_symbeg bool on_comma on_label nil on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end # e.g., "-0700" or "Asia/Tokyo"
on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label on_lbracket on_symbeg UNK on_comma on_symbeg UNK # change default by buffer_plugin.persistent?
config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label nil on_comma on_label on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl config_param on_symbeg UNK on_comma # 72hours == 17 times with exponential backoff (not to change default behavior)
on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label on_lbracket on_symbeg UNK on_comma on_symbeg UNK # exponential backoff sequence will be initialized at the time of this threshold
config_param on_symbeg UNK on_comma on_symbeg time on_comma on_label on_int on_comma on_label on_tstring_beg on_tstring_content on_tstring_end on_nl config_param on_symbeg UNK on_comma on_symbeg ### Periodic -> fixed :retry_wait ### Exponential backoff: k is number of retry times # c: constant factor, @retry_wait # b: base factor, @retry_exponential_backoff_base # k: times # total retry time: c + c * b^1 + (...) + c*b^k = c*b^(k+1) - 1
end on_nl UNK on_symbeg UNK on_comma on_label false on_comma on_label false do on_ignored_nl end on_nl end on_nl on_ignored_nl def UNK # dummy to detect invalid specification for here
end on_nl end on_nl on_ignored_nl def UNK on_lparen tag on_comma es on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl # dummy to detect invalid specification for here
raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_nl false on_nl end on_nl on_ignored_nl def UNK # standard msgpack_event_stream chunk will be used if this method is not implemented in plugin subclass
false on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl true on_nl end on_nl # To indicate custom format method (#format) returns msgpack binary or not. # If #format returns msgpack binary, override this method to return true.
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl true on_nl end on_nl on_ignored_nl def UNK on_nl true # Compatibility for existing plugins
true on_nl end on_nl on_ignored_nl def UNK on_nl true on_nl end on_nl on_ignored_nl def UNK on_nl false on_nl end on_nl # override this method to return false only when all of these are true: # * plugin has both implementation for buffered and non-buffered methods # * plugin is expected to work as non-buffered plugin if no `<buffer>` sections specified
true on_nl end on_nl on_ignored_nl def UNK on_nl false on_nl end on_nl on_ignored_nl on_const on_op on_const on_period new on_lparen on_symbeg # override this method to decide which is used of `write` or `try_write` if both are implemented
on_const on_op on_const on_period new on_lparen on_symbeg thread on_comma on_symbeg next_clock on_comma on_symbeg mutex on_comma on_symbeg UNK on_rparen on_nl on_const # Internal states
UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg chunk_keys on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg # for tests
UNK on_symbeg UNK on_ignored_nl def UNK on_nl super on_nl on_ivar on_op on_const on_period new on_nl on_ivar on_op false on_nl on_ivar # output_enqueue_thread_waiting: for test of output.rb itself
on_ignored_nl def UNK on_nl super on_nl on_ivar on_op on_const on_period new on_nl on_ivar on_op false on_nl on_ivar on_op false on_nl # if true, error flush will be retried even if under_plugin_development is true
on_ivar on_op on_int on_nl on_ivar on_op on_int on_nl on_ivar on_op on_int on_nl on_ivar on_op on_int on_nl on_ivar on_op on_int on_nl # TODO: well organized counters
if implement? on_lparen on_symbeg synchronous on_rparen on_nl if implement? on_lparen on_symbeg buffered on_rparen on_op implement? on_lparen on_symbeg delayed_commit on_rparen on_nl # How to process events is decided here at once, but it will be decided in delayed way on #configure & #start
else on_ignored_nl on_ivar on_op false on_nl end on_nl else on_ignored_nl on_ivar on_op true on_nl end on_nl on_ivar on_op implement? on_lparen # do #configure or #start to determine this for full-featured plugins
on_ignored_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil on_nl on_ivar on_op nil # decided later
if implement? on_lparen on_symbeg synchronous on_rparen on_nl if on_op implement? on_lparen on_symbeg buffered on_rparen on_op on_op implement? on_lparen on_symbeg delayed_commit # no buffer sections
on_ivar on_op true on_nl else on_ignored_nl on_ivar on_op nil on_nl end on_nl end on_nl else on_ivar on_op true on_nl end # secondary plugin always works as buffered plugin without buffer instance
on_ivar on_op nil on_nl end on_nl end on_nl else on_ivar on_op true on_nl end on_nl end on_nl on_ignored_nl if on_ivar # @buffering.nil? shows that enabling buffering or not will be decided in lazy way in #start
on_ivar on_op true on_nl end on_nl end on_nl on_ignored_nl if on_ivar on_nl if on_op on_ivar on_op on_op on_ivar on_period nil? # buffered or delayed_commit is supported by `unless` of first line in this method
on_ivar on_op on_ivar on_period chunk_keys on_period UNK on_nl on_ivar on_op on_op on_op on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # When @buffering.nil?, @buffer_config was initialized with default value for all parameters. # If so, this configuration MUST success.
on_ivar on_op on_op on_ivar on_op on_ivar on_period empty? on_nl on_ignored_nl on_ivar on_op on_ivar on_period UNK on_nl if on_ivar on_op on_symbeg # no chunk keys or only tags (chunking can be done without iterating event stream)
end on_nl elsif on_op on_ivar on_op on_op on_ivar on_period UNK on_nl UNK on_op on_const on_period UNK on_lparen on_ivar on_period class # flush_at_shutdown is true in default for on-memory buffer
end on_nl UNK on_op conf on_period UNK on_lparen on_label on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period first on_nl on_ivar on_op on_const on_period # primary plugin type
on_ivar on_op nil on_nl end on_nl end on_nl on_ignored_nl if on_ivar on_nl m on_op UNK on_lparen on_symbeg UNK on_rparen on_nl # it's not started, so terminate will be enough # At here, this plugin works as non-buffered plugin. # Un-assign @buffer not to show buffering metrics (e.g., in_monitor_agent)
m on_op UNK on_lparen on_symbeg UNK on_rparen on_nl UNK on_period UNK do on_ignored_nl UNK on_lparen on_symbeg UNK on_comma m on_rparen # !@buffering
on_ivar on_op false on_nl on_ivar on_op on_const on_period new on_nl on_ivar on_op false on_nl on_ignored_nl on_ivar on_op on_lbracket on_rbracket on_nl # mainly for test: detect enqueue works as code below: # @output.interrupt_flushes # # emits # @output.enqueue_thread_wait
on_ivar on_op false on_nl if on_ivar on_op on_ivar on_period UNK on_nl on_ivar on_period UNK on_nl on_ivar on_period UNK on_nl end # Need to ensure to stop enqueueing ... after #shutdown, we cannot write any data
on_ivar on_period UNK if on_ivar on_nl on_ignored_nl if on_ivar on_op on_ivar on_nl on_ivar on_period UNK on_nl on_ignored_nl on_ivar on_op false # rollback regardless with @delayed_commit, because secondary may do it
state on_period mutex on_period synchronize on_lbrace on_ignored_nl if state on_period thread on_op state on_period thread on_period UNK on_nl state on_period # to wakeup thread and make it to stop by itself
UNK feature on_nl when on_symbeg synchronous then false on_nl when on_symbeg buffered then false on_nl when on_symbeg delayed_commit then false # for plugins written in v0.12 styles
def UNK on_lparen str on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_lparen str on_rparen on_nl on_const on_period each do on_op # it's not validated to use timekey larger than 1 day
def UNK on_lparen str on_rparen on_ignored_nl parts on_op on_lbracket on_rbracket on_nl str on_period UNK on_lparen on_const on_rparen on_period UNK on_lparen # -1 means whole tag
parts on_op on_lbracket on_rbracket on_nl str on_period UNK on_lparen on_const on_rparen on_period UNK on_lparen on_op on_symbeg first on_rparen on_period each # [["tag"],["tag[0]"]]
def UNK on_lparen str on_comma chunk on_rparen on_ignored_nl metadata on_op if chunk on_period is_a? on_lparen on_const on_op on_const on_op on_const # TODO: optimize this code
chunk on_nl end on_nl if metadata on_period empty? on_nl str on_period UNK on_lparen on_const on_rparen on_lbrace on_ignored_nl if UNK on_nl # For existing plugins. Old plugin passes Chunk.metadata instead of Chunk
if on_ivar on_ivar on_lbracket str on_rbracket on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_comma str on_rparen on_nl rvalue on_op # strftime formatting
on_ivar on_lbracket str on_rbracket on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_comma str on_rparen on_nl rvalue on_op on_ivar on_lbracket # this section MUST be earlier than rest to use raw 'str'
if on_ivar on_nl if str on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl rvalue on_op rvalue on_period UNK on_lparen on_tstring_beg # ${tag}, ${tag[0]}, ${tag[1]}, ... , ${tag[-2]}, ${tag[-1]}
if on_op on_ivar on_period empty? on_op metadata on_period UNK on_nl hash on_op on_lbrace on_tstring_beg on_tstring_content on_tstring_end on_op on_tstring_beg on_tstring_content on_tstring_end # ${a_chunk_key}, ...
on_ivar on_period each do on_op key on_op on_ignored_nl hash on_lbracket on_tstring_beg on_tstring_content on_embexpr_beg key on_embexpr_end on_tstring_content on_tstring_end on_rbracket on_op metadata # not to erase this wrongly
if on_ivar on_nl UNK on_lparen tag on_comma es on_rparen on_nl else on_ignored_nl UNK on_lparen tag on_comma es on_rparen on_nl end # actually this method will be overwritten by #configure
on_ivar on_period synchronize on_lbrace on_ivar on_op on_int on_rbrace on_nl raise on_nl end on_nl end on_nl on_ignored_nl def metadata on_lparen tag # TODO: separate number of errors into emit errors and write/flush errors
def metadata on_lparen tag on_comma time on_comma record on_rparen on_ignored_nl on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg tag on_period class # TODO: optimize this code
on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg tag on_period class on_embexpr_end on_tstring_end unless tag on_period nil? on_op tag on_period is_a? # this arguments are ordered in output plugin's rule # Metadata 's argument order is different from this one (timekey, tag, variables)
UNK on_const on_period new on_lparen on_symbeg timekey on_comma on_symbeg tag on_comma on_symbeg UNK on_rparen on_period new on_nl end on_nl on_ignored_nl # for tests
if on_ivar on_period empty? on_nl if on_op on_ivar on_op on_op on_ivar on_nl on_ivar on_period metadata on_lparen on_rparen on_nl elsif on_ivar # timekey is int from epoch, and `timekey - timekey % 60` is assumed to mach with 0s of each minutes. # it's wrong if timezone is configured as one which supports leap second, but it's very rare and # we can ignore it (especially in production systems).
raise on_nl end on_nl log on_period trace on_tstring_beg on_tstring_content on_tstring_end on_nl sleep on_int on_nl end on_nl log on_period debug on_tstring_beg # to break infinite loop to exit Fluentd process
end on_nl raise unless on_ivar on_period UNK on_nl UNK on_nl else on_ignored_nl raise on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_period UNK on_embexpr_end # ignore any errors
def UNK on_lparen tag on_comma es on_comma on_label false on_rparen on_ignored_nl meta_and_data on_op on_lbrace on_rbrace on_nl records on_op on_int on_nl # metadata_and_data is a Hash of: # (standard format) metadata => event stream # (custom format) metadata => array of formatted event # For standard format, formatting should be done for whole event stream, but # "whole event stream" may be a split of "es" here when it's bigger than chunk_limit_size. # `@buffer.write` will do this splitting. # For custom format, formatting will be done here. Custom formatting always requires # iteration of event stream, and it should be done just once even if total event stream size # is bigger than chunk_limit_size because of performance.
if UNK on_nl log on_period warn on_tstring_beg on_tstring_content on_tstring_end on_comma on_label dump_unique_id_hex on_lparen chunk_id on_rparen on_nl else on_ignored_nl log on_period # success to flush chunks in retries
def UNK on_lparen chunk_id on_comma on_label true on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl on_ivar on_period UNK on_lbrace on_op info # update_retry parameter is for preventing busy loop by async write # We will remove this parameter by re-design retry_state management between threads.
on_ivar on_period synchronize do on_ignored_nl on_ivar on_period UNK on_lbrace on_op info on_op info on_period chunk_id on_op chunk_id on_rbrace on_nl end # This API is to rollback chunks explicitly from plugins. # 3rd party plugins can depend it on automatic rollback of #try_rollback_write
if on_ivar on_period UNK on_lparen chunk_id on_rparen on_nl on_ivar on_period synchronize on_lbrace on_ivar on_op on_int on_rbrace on_nl if UNK on_nl # returns true if chunk was rollbacked as expected # false if chunk was already flushed and couldn't be rollbacked unexpectedly # in many cases, false can be just ignored
on_ivar on_op on_const on_period new on_lparen chunk on_period unique_id on_comma on_const on_period now on_comma self on_period UNK on_rparen on_nl end # delayed_commit_timeout for secondary is configured in <buffer> of primary (<secondary> don't get <buffer>)
chunk_id on_op chunk on_period unique_id on_nl UNK on_op dump_unique_id_hex on_lparen chunk_id on_rparen on_nl log on_period trace on_tstring_beg on_tstring_content on_tstring_end on_comma # output plugin without delayed purge
if on_ivar on_period delayed_commit on_nl log on_period warn on_tstring_beg on_tstring_content on_tstring_end on_comma on_label e on_nl log on_period warn_backtrace on_nl backup_chunk # Call secondary output directly without retry update. # In this case, delayed commit causes inconsistent state in dequeued chunks so async output in secondary is not allowed for now.
on_ignored_nl if on_ivar on_period UNK on_nl if error on_nl records on_op on_ivar on_period UNK on_nl msg on_op on_tstring_beg on_tstring_content on_tstring_end # @retry exists
on_ivar on_op on_lparen on_ivar on_op on_int on_rparen on_op on_ivar on_period UNK on_nl state on_op on_ivar on_lbracket on_ivar on_rbracket on_nl state # Without locks: it is rough but enough to select "next" writer selection
state on_period next_clock on_op on_int on_nl state on_period UNK on_period UNK on_nl else on_ignored_nl log on_period warn on_tstring_beg on_tstring_content on_tstring_end # "run"/"sleep"/"aborting" or false(successfully stop) or nil(killed by exception)
def UNK on_nl on_ivar on_op true on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period synchronize do on_ignored_nl on_ivar on_op # only for tests of output plugin
def UNK on_nl on_ivar on_period synchronize do on_ignored_nl on_ivar on_op false on_nl on_ivar on_op true on_nl end on_nl require on_tstring_beg # only for tests of output plugin
def UNK on_nl on_ivar on_period each do on_op state on_op on_ignored_nl state on_period mutex on_period synchronize on_lbrace on_ignored_nl if state # only for tests of output plugin
on_ivar on_period UNK on_lbrace on_op metadata on_comma chunk on_op chunk on_period UNK on_op UNK on_op UNK on_rbrace on_nl end on_nl # This block should be done by integer values. # If both of flush_interval & flush_thread_interval are 1s, expected actual flush timing is 1.5s. # If we use integered values for this comparison, expected actual flush timing is 1.0s.
log on_period error on_tstring_beg on_tstring_content on_tstring_end on_comma on_label e on_nl log on_period UNK on_nl raise on_nl end on_nl end on_nl # normal errors are rescued by inner begin-rescue clause.
while on_ivar on_nl UNK on_op on_const on_op on_const on_period now on_nl UNK on_op nil on_nl on_ignored_nl on_ivar on_period synchronize do # This thread don't use `thread_current_running?` because this thread should run in `before_shutdown` phase
interval on_op UNK on_period UNK on_op on_const on_period now on_period UNK on_nl state on_period next_clock on_op on_const on_op on_const on_period # next_flush_time uses flush_thread_interval or flush_thread_burst_interval (or retrying)
state on_period next_clock on_op on_const on_op on_const on_period now on_op interval on_nl UNK on_ignored_nl state on_period mutex on_period UNK on_nl # TODO: if secondary && delayed-commit, next_flush_time will be much longer than expected # because @retry still exists (#commit_write is not called yet in #try_flush) # @retry should be cleared if delayed commit is enabled? Or any other solution?
log on_period error on_tstring_beg on_tstring_content on_tstring_end on_comma on_label e on_nl log on_period UNK on_nl raise on_nl UNK on_ignored_nl state on_period # normal errors are rescued by output plugins in #try_flush # so this rescue section is for critical & unrecoverable errors
on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op on_ivar on_comma # Respect original name # https://github.com/fluent/fluentd/blob/45c7b75ba77763eaf87136864d4942c4e0c5bfcd/lib/fluent/plugin/in_monitor_agent.rb#L284
