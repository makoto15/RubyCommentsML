on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content # # Fluentd # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. #
desc on_tstring_beg on_tstring_content on_tstring_end on_nl config_param on_symbeg UNK on_comma on_symbeg time on_comma on_label on_int on_nl desc on_tstring_beg on_tstring_content on_tstring_end on_nl # When the program deletes log file and re-creates log file with same filename after passed refresh_interval, # in_tail may raise a pos_file related error. This is a known issue but there is no such program on production. # If we find such program / application, we will fix the problem.
if on_ivar on_nl if on_ivar on_period UNK on_lparen on_ivar on_rparen on_op on_op UNK on_nl UNK on_op on_ivar on_lbracket on_ivar on_rbracket # TODO: Use plugin_root_dir and storage plugin to store positions if available
on_ivar on_op UNK on_lparen on_label parser_config on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_ivar on_period UNK on_period UNK on_rparen on_nl end # parser is already created by parser helper
UNK on_lparen on_ivar on_period UNK on_comma on_label true on_comma on_label false on_rparen on_nl on_ivar on_period close if on_ivar on_nl on_ignored_nl # during shutdown phase, don't close io. It should be done in close after all threads are stopped. See close.
UNK on_nl end on_nl on_ignored_nl def UNK on_nl date on_op on_const on_op on_const on_period UNK on_nl paths on_op on_lbracket on_rbracket # close file handles after all threads stopped (in #close of thread plugin helper)
paths on_op path on_nl end on_nl on_rbrace on_nl UNK on_op on_ivar on_period UNK on_lbrace on_op path on_op on_ignored_nl path on_op # When file is not created yet, Dir.glob returns an empty array. So just add when path is static.
def UNK on_nl UNK on_op UNK on_nl UNK on_op on_ivar on_period UNK on_nl on_ignored_nl log on_period UNK on_lbrace on_tstring_beg on_tstring_content # in_tail with '*' path doesn't check rotation file equality at refresh phase. # So you should not use '*' path when your logs will be rotated by another tool. # It will cause log duplication after updated watch files. # In such case, you should separate log directory and specify two paths in path parameter. # e.g. path /path/to/dir/*,/path/to/rotated_logs/target_file
def UNK on_lparen path on_comma pe on_rparen on_ignored_nl log on_period UNK on_lparen on_tstring_beg on_tstring_content on_embexpr_beg path on_embexpr_end on_tstring_content on_embexpr_beg on_ivar # refresh_watchers calls @tails.keys so we don't use stop_watcher -> start_watcher sequence for safety.
def UNK on_lparen tw on_comma UNK on_op true on_rparen on_ignored_nl tw on_period UNK on_period each do on_op watcher on_op on_ignored_nl # TailWatcher#close is called by another thread at shutdown phase. # It causes 'can't modify string; temporarily locked' error in IOHandler # so adding close_io argument to avoid this problem. # At shutdown, IOHandler's io will be released automatically after detached the event loop
UNK on_lparen on_symbeg UNK on_comma on_ivar on_comma on_label false on_rparen do on_ignored_nl UNK on_lparen tw on_rparen on_nl end on_nl end # Call event_loop_attach/event_loop_detach is high-cost for short-live object. # If this has a problem with large number of files, use @_event_loop directly instead of timer_execute.
def UNK on_lparen lines on_comma tail_watcher on_rparen on_ignored_nl es on_op on_ivar on_period call on_lparen lines on_comma tail_watcher on_rparen on_nl unless # @return true if no error or unrecoverable error happens in emit action. false if got BufferOverflowError
return true on_nl end on_nl end on_nl on_ignored_nl return true on_nl end on_nl on_ignored_nl def UNK on_lparen line on_comma es # ignore non BufferQueueLimitError errors because in_tail can't recover. Engine shows logs and backtraces.
on_ivar on_period UNK on_lparen line on_rparen on_lbrace on_op time on_comma record on_op on_ignored_nl if time on_op record on_nl record on_lbracket # remove \n
def UNK on_lparen lines on_comma tail_watcher on_rparen on_ignored_nl lb on_op tail_watcher on_period line_buffer_timer_flusher on_period UNK on_nl es on_op on_const on_op # No need to check if line_buffer_timer_flusher is nil, since line_buffer_timer_flusher should exist
attr_reader on_symbeg UNK on_nl on_ignored_nl def tag on_nl on_ivar on_op on_ivar on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content # This is used for removing position entry from PositionFile
stat on_op nil on_nl end on_nl on_ignored_nl on_ivar on_period on_notify on_lparen stat on_rparen if on_ivar on_nl on_ivar on_period on_notify on_lparen # moved or deleted
fsize on_op stat on_period UNK on_nl inode on_op stat on_period UNK on_nl on_ignored_nl UNK on_op on_ivar on_period read_inode on_nl if # first time
on_ivar on_period update on_lparen inode on_comma on_int on_rparen if fsize on_op on_ivar on_period UNK on_nl UNK UNK on_op on_int on_nl # rotated file has the same inode number with the last file. # assuming following situation: # a) file was once renamed and backed, or # b) symlink or hardlink to the same file is recreated # in either case of a and b, seek to the saved position # c) file was once renamed, truncated and then backed # in this case, consider it truncated
on_ivar on_period update on_lparen inode on_comma on_int on_rparen on_nl else on_ignored_nl UNK on_op on_ivar on_op on_int on_op fsize on_nl on_ivar # this is FilePositionEntry and fluentd once started. # read data from the head of the rotated file. # logs never duplicate because this file is a rotated new file.
UNK on_op on_ivar on_op on_int on_op fsize on_nl on_ivar on_period update on_lparen inode on_comma UNK on_rparen on_nl end on_nl on_ivar # this is MemoryPositionEntry or this is the first time fluentd started. # seek to the end of the any files. # logs may duplicate without this seek because it's not sure the file is # existent file or rotated new file.
on_ivar on_period UNK on_lparen on_int on_rparen on_nl on_ivar on_period close on_nl UNK on_op on_ivar on_period UNK on_ivar on_period update on_lparen # truncated
on_ivar on_period update on_lparen inode on_comma on_int on_rparen on_nl else UNK on_op true on_nl on_ivar on_period on_notify on_nl end on_nl # There is no previous file. Reuse TailWatcher
UNK on_op true on_nl on_ivar on_period on_notify on_nl end on_nl else on_ivar on_op nil on_nl UNK on_op true on_nl end # file is rotated and new file found
on_ivar on_period on_notify on_nl end on_nl else on_ivar on_op nil on_nl UNK on_op true on_nl end on_nl on_ignored_nl if UNK # Handle the old log file before renewing TailWatcher [fluentd#1055]
on_ivar on_op nil on_nl UNK on_op true on_nl end on_nl on_ignored_nl if UNK on_nl on_ivar on_period call on_lparen on_ivar on_comma # file is rotated and new file not found # Clear RotateHandler to avoid duplicated file watch in same path.
UNK on_op on_const on_period new on_nl UNK on_period update on_lparen pe on_period read_inode on_comma pe on_period UNK on_rparen on_nl on_ivar # Use MemoryPositionEntry for rotated file temporary
end on_nl on_ignored_nl class on_const on_nl def initialize on_lparen from_encoding on_comma encoding on_rparen on_ignored_nl on_ivar on_op from_encoding on_nl on_ivar on_op # This pe will be updated in on_rotate after TailWatcher is initialized
UNK on_op UNK on_period encoding on_nl UNK on_period UNK on_lparen from_encoding on_rparen on_nl on_ivar on_op UNK on_nl UNK on_period UNK # Although "chunk" is most likely transient besides String#force_encoding itself # won't affect the actual content of it, it is also probable that "chunk" is # a reused buffer and changing its encoding causes some problems on the caller side. # # Actually, the caller here is specific and "chunk" comes from IO#partial with # the second argument, which the function always returns as a return value. # # Feeding a string that has its encoding attribute set to any double-byte or # quad-byte encoding to IO#readpartial as the second arguments results in an # assertion failure on Ruby < 2.4.0 for unknown reasons.
UNK on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl if on_ivar on_nl UNK # Thus the encoding needs to be reverted back here
on_ivar on_period UNK on_nl UNK on_op on_ivar on_period UNK on_lparen on_int on_comma UNK on_op on_int on_rparen on_nl on_ivar on_op on_ivar # Using freeze and slice is faster than slice! # See https://github.com/fluent/fluentd/pull/2527
UNK on_op true on_nl UNK on_nl end on_nl end on_nl rescue on_const on_nl end on_nl end on_nl on_ignored_nl unless on_ivar # not to use too much memory in case the file is very large
on_ivar on_op UNK on_nl end on_nl on_ignored_nl def on_notify on_lparen stat on_rparen on_ignored_nl if stat on_period nil? on_nl inode on_op # first
