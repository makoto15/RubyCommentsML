on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end # # Fluentd # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. #
on_ignored_nl on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_int on_op on_int on_const on_op on_int on_op on_int on_op on_int # A record size is larger than chunk size limit
on_const on_op on_int on_op on_int on_op on_int on_ignored_nl on_const on_op UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl config_param # 8MB
on_ignored_nl on_const on_op UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl config_param on_symbeg UNK on_comma on_symbeg size on_comma on_label # 512MB, same with v0.12 (BufferedOutput + buf_memory: 64 x 8MB)
on_ignored_nl config_param on_symbeg UNK on_comma on_symbeg size on_comma on_label on_const on_nl config_param on_symbeg UNK on_comma on_symbeg size on_comma on_label on_const # TODO: system total buffer limit size in bytes by SystemConfig
config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label nil on_nl on_ignored_nl config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label nil # If user specify this value and (chunk_size * queue_length) is smaller than total_size, # then total_size is automatically configured to that value
config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label nil on_nl on_ignored_nl config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label on_const # optional new limitations
config_param on_symbeg UNK on_comma on_symbeg UNK on_comma on_label on_const on_nl on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl config_param on_symbeg UNK on_comma # if chunk size (or records) is 95% or more after #write, then that chunk will be enqueued
return on_op on_int on_nl elsif UNK on_period nil? return on_int on_nl end on_nl v1_sorted_keys on_op UNK on_period keys on_period UNK # v2 is non-nil
return on_int on_nl end on_nl v1_sorted_keys on_op UNK on_period keys on_period UNK on_nl UNK on_op UNK on_period keys on_period UNK # v1 is non-nil
v1_sorted_keys on_op UNK on_period keys on_period UNK on_nl UNK on_op UNK on_period keys on_period UNK on_nl if v1_sorted_keys on_op UNK # both of v1 and v2 are non-nil
UNK on_nl elsif a return on_int on_nl else return on_op on_int on_nl end on_nl end on_nl on_ignored_nl on_int on_nl end # same value (including both are nil)
return on_int on_nl else return on_op on_int on_nl end on_nl end on_nl on_ignored_nl on_int on_nl end on_nl end on_nl on_ignored_nl # b is nil
return on_op on_int on_nl end on_nl end on_nl on_ignored_nl on_int on_nl end on_nl end on_nl on_ignored_nl def on_op on_lparen UNK # a is nil (but b is non-nil)
if timekey on_op timekey2 if tag on_op tag2 on_nl UNK on_lparen variables on_comma UNK on_rparen on_nl elsif tag on_period nil? # One has value in a field, but another doesn't have value in same field # This case occurs very rarely
if tag on_op tag2 on_nl UNK on_lparen variables on_comma UNK on_rparen on_nl elsif tag on_period nil? on_nl on_op on_int on_nl # including the case of nil == nil
on_lparen timekey on_op timekey2 on_op on_int on_rparen on_period UNK on_op on_lparen tag on_op tag2 on_op on_int on_rparen on_period UNK on_op # objects have values in same field pairs (comparison with non-nil and nil doesn't occur here)
on_lparen tag on_op tag2 on_op on_int on_rparen on_period UNK on_op on_ignored_nl UNK on_lparen variables on_comma UNK on_rparen on_nl end on_nl # if `a <=> b` is nil, then both are nil
def UNK on_nl timekey on_period object_id on_nl end unless on_const on_period UNK on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_comma # This is an optimization code. Current Struct's implementation is comparing all data. # https://github.com/ruby/ruby/blob/0623e2b7cc621b1733a760b72af246b06c30cf96/struct.c#L1200-L1203 # Actually this overhead is very small but this class is generated *per chunk* (and used in hash object). # This means that this class is one of the most called object in Fluentd. # See https://github.com/fluent/fluentd/pull/2560 # But, this optimization has a side effect on Windows due to differing object_id. # This difference causes flood of buffer files. # So, this optimization should be enabled on non-Windows platform.
UNK on_symbeg UNK on_comma on_symbeg UNK on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_nl # for tests
on_ivar on_op on_lbracket on_rbracket on_ivar on_op on_lbrace on_rbrace on_ivar on_op on_lbrace on_rbrace on_ivar on_op on_lbrace on_rbrace on_ignored_nl on_ivar on_op on_ivar #=> Hash (metadata -> chunk) : not flushed yet
on_ivar on_op on_lbrace on_rbrace on_ivar on_op on_lbrace on_rbrace on_ivar on_op on_lbrace on_rbrace on_ignored_nl on_ivar on_op on_ivar on_op on_int on_nl on_ivar #=> Array (chunks) : already flushed (not written)
on_ivar on_op on_lbrace on_rbrace on_ivar on_op on_lbrace on_rbrace on_ignored_nl on_ivar on_op on_ivar on_op on_int on_nl on_ivar on_op on_const on_period UNK #=> Hash (unique_id -> chunk): already written (not purged)
on_ivar on_op on_lbrace on_rbrace on_ignored_nl on_ivar on_op on_ivar on_op on_int on_nl on_ivar on_op on_const on_period UNK on_lparen on_int on_rparen on_nl # metadata => int (number of queued chunks)
on_ignored_nl on_ivar on_op on_ivar on_op on_int on_nl on_ivar on_op on_const on_period UNK on_lparen on_int on_rparen on_nl on_ivar on_op on_const on_period # metadata => int (number of dequeued chunks)
on_ignored_nl def UNK on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_lparen metadata on_rparen on_ignored_nl ## TODO: for back pressure feature # def used?(ratio) # @total_limit_size * ratio > @stage_size + @queue_size # end
raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_lparen metadata on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg # return {}, []
def UNK on_lparen UNK on_comma on_label nil on_comma on_label nil on_comma on_label false on_rparen on_ignored_nl return if UNK on_period size # metadata MUST have consistent object_id for each variation # data MUST be Array of serialized events, or EventStream # metadata_and_data MUST be a hash of { metadata => data }
UNK on_op on_lbracket on_rbracket on_nl UNK on_op on_lbrace on_rbrace on_nl on_ignored_nl begin on_ignored_nl UNK on_period keys on_period UNK on_period each # metadata => [chunk, chunk, ...]
UNK on_period keys on_period UNK on_period each do on_op metadata on_op on_ignored_nl data on_op UNK on_lbracket metadata on_rbracket on_nl UNK # sort metadata to get lock of chunks in same order with other threads
operated_chunks on_op chunk on_nl if chunk on_period UNK on_nl UNK on_lbracket chunk on_rbracket on_op adding_bytesize on_nl elsif chunk on_period unstaged? # add lock to prevent to be committed/rollbacked from other threads
UNK on_lbracket chunk on_rbracket on_op adding_bytesize on_nl elsif chunk on_period unstaged? on_nl UNK on_lbracket metadata on_rbracket on_op on_lbracket on_rbracket on_nl # # https://github.com/fluent/fluentd/issues/2712 # write_once is supposed to write to a chunk only once # but this block **may** run multiple times from write_step_by_step and previous write may be rollbacked # So we should be counting the stage_size only for the last successful write #
on_ignored_nl first_chunk on_op operated_chunks on_period UNK on_nl begin on_ignored_nl first_chunk on_period UNK on_nl if UNK on_op first_chunk on_period unstaged? on_op # Now, this thread acquires many locks of chunks... getting buffer-global lock causes dead lock. # Any operations needs buffer-global lock (including enqueueing) should be done after releasing locks.
begin on_ignored_nl first_chunk on_period UNK on_nl if UNK on_op first_chunk on_period unstaged? on_op chunk_size_full? on_lparen first_chunk on_rparen on_nl UNK on_op # Following commits for other chunks also can finish successfully if the first commit operation # finishes without any exceptions. # In most cases, #commit just requires very small disk spaces, so major failure reason are # permission errors, disk failures and other permanent(fatal) errors.
operated_chunks on_period each do on_op chunk on_op on_ignored_nl begin on_ignored_nl chunk on_period UNK on_nl if UNK on_op chunk on_period unstaged? # Buffer plugin estimates there's no serious error cause: will commit for all chunks eigher way
on_ignored_nl UNK on_period each do on_op chunk on_comma bytesize on_op on_ignored_nl chunk on_period synchronize do on_ignored_nl synchronize on_lbrace on_ivar on_op # All locks about chunks are released.
UNK on_period each do on_op chunk on_comma bytesize on_op on_ignored_nl chunk on_period synchronize do on_ignored_nl synchronize on_lbrace on_ivar on_op bytesize # # Now update the stage, stage_size with proper locking # FIX FOR stage_size miscomputation - https://github.com/fluent/fluentd/issues/2712 #
u on_period metadata on_period seq on_op on_int on_nl synchronize on_lbrace on_ignored_nl on_ivar on_lbracket m on_rbracket on_op u on_period UNK on_nl # `u.metadata.seq` and `m.seq` can be different but Buffer#enqueue_chunk expect them to be the same value
end on_nl end on_nl on_ignored_nl operated_chunks on_period UNK if errors on_period empty? on_nl on_ignored_nl if errors on_period size on_op on_int # previously staged chunk is already enqueued, closed or purged. # no problem.
if chunk on_period unstaged? on_nl chunk on_period UNK rescue nil end on_nl chunk on_period UNK rescue nil end on_nl end # nothing possible to do for #rollback failure
end on_nl chunk on_period UNK rescue nil end on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl synchronize on_lbrace on_ivar # to prevent leakage of unstaged chunks
end on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl synchronize on_lbrace on_ivar on_period size on_rbrace on_op on_ivar on_nl end # this may raise ThreadError for chunks already committed
on_ivar on_op chunk on_nl on_ivar on_lbracket metadata on_rbracket on_op on_ivar on_period UNK on_lparen metadata on_comma on_int on_rparen on_op on_int on_nl # metadata.seq should be 0 for counting @queued_num
on_ivar on_op chunk on_nl on_ivar on_lbracket metadata on_rbracket on_op on_ivar on_period UNK on_lparen metadata on_comma on_int on_rparen on_op on_int on_nl # metadata.seq should be 0 for counting @queued_num
def UNK on_lparen UNK on_op false on_rparen on_ignored_nl log on_period on_trace on_lbrace log on_period trace on_tstring_beg on_tstring_content on_tstring_end on_comma on_label # At flush_at_shutdown, all staged chunks should be enqueued for buffer flush. Set true to force_enqueue for it.
chunk on_op on_ivar on_lbracket metadata on_rbracket on_nl UNK unless chunk on_nl UNK on_op UNK metadata on_comma chunk on_nl enqueue_chunk on_lparen # NOTE: The following line might cause data race depending on Ruby implementations except CRuby # cf. https://github.com/fluent/fluentd/pull/1721#discussion_r146170251
return nil unless chunk on_nl on_ignored_nl on_ivar on_lbracket chunk on_period UNK on_rbracket on_op chunk on_nl on_ivar on_lbracket chunk on_period metadata # this buffer is dequeued by other thread just before "synchronize" in this thread
on_ivar on_lbracket chunk on_period metadata on_rbracket on_op on_int on_nl on_ivar on_lbracket chunk on_period metadata on_rbracket on_op on_int on_nl log on_period # BUG if nil, 0 or subzero
on_ivar on_period UNK on_lparen chunk on_rparen on_nl log on_period trace on_tstring_beg on_tstring_content on_tstring_end on_comma on_label self on_period object_id on_comma on_label # already purged by other thread
on_ivar on_lbracket chunk on_period metadata on_rbracket on_op on_int on_nl end on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen chunk_id # BUG if nil
on_ignored_nl metadata on_op chunk on_period metadata on_nl log on_period on_trace on_lbrace log on_period trace on_tstring_beg on_tstring_content on_tstring_end on_comma on_label self # purged by other threads
on_ignored_nl def UNK on_lparen metadata on_comma data on_comma on_label nil on_comma on_label nil on_comma on_op UNK on_rparen on_ignored_nl return if # write once into a chunk # 1. append whole data into existing chunk # 2. commit it & return unless chunk_size_over? # 3. enqueue existing chunk & retry whole method if chunk was not empty # 4. go to step_by_step writing
raise on_const unless chunk on_period UNK on_nl on_ignored_nl UNK on_op chunk on_period empty? on_nl on_ignored_nl UNK on_op chunk on_period bytesize # retry this method if chunk is already queued (between getting chunk and entering critical section)
enqueue_chunk_before_retry on_op UNK on_nl raise on_const on_nl end on_nl else on_ignored_nl UNK on_op UNK on_nl end on_nl rescue on_nl chunk # Event streams should be appended into a chunk at once # as far as possible, to improve performance of formatting. # Event stream may be a MessagePackEventStream. We don't want to split it into # 2 or more chunks (except for a case that the event stream is larger than chunk limit).
UNK on_lparen metadata on_comma data on_comma format on_comma on_int on_comma on_op UNK on_rparen on_nl end on_nl rescue on_const on_nl enqueue_chunk # try step-by-step appending if data can't be stored into existing a chunk in non-bulk mode # # 1/10 size of original event stream (splits_count == 10) seems enough small # to try emitting events into existing chunk. # it does not matter to split event stream into very small splits, because chunks have less # overhead to write data many times (even about file buffer chunks).
on_ignored_nl on_ignored_nl def UNK on_lparen metadata on_comma data on_comma format on_comma splits_count on_comma on_op UNK on_rparen on_ignored_nl UNK on_op on_lbracket # EventStream can be split into many streams # because (es1 + es2).to_msgpack_stream == es1.to_msgpack_stream + es2.to_msgpack_stream
on_ignored_nl def UNK on_lparen metadata on_comma data on_comma format on_comma splits_count on_comma on_op UNK on_rparen on_ignored_nl UNK on_op on_lbracket on_rbracket # 1. split event streams into many (10 -> 100 -> 1000 -> ...) chunks # 2. append splits into the staged chunks as much as possible # 3. create unstaged chunk and append rest splits -> repeat it for all splits
UNK on_op false on_nl UNK on_op on_lbracket on_rbracket on_nl modified_metadata on_op metadata on_nl UNK on_op UNK on_lparen on_rparen UNK on_ignored_nl # This method will append events into the staged chunk at first. # Then, will generate chunks not staged (not queued) to append rest data.
modified_metadata on_op modified_metadata on_period UNK on_nl UNK on_lparen modified_metadata on_rparen on_nl else on_ignored_nl synchronize on_lbrace on_ivar on_lbracket modified_metadata on_rbracket on_op # Staging new chunk here is bad idea: # Recovering whole state including newly staged chunks is much harder than current implementation.
chunk on_period rollback on_nl on_ignored_nl if split on_period size on_op on_int on_op UNK on_op on_int on_nl UNK on_op format on_op # split size is larger than difference between size_full? and size_over?
raise on_nl end on_nl on_ignored_nl UNK on_period call on_lparen chunk on_comma chunk on_period bytesize on_op UNK on_rparen on_nl end on_nl # unstaged chunk will leak unless purge it
