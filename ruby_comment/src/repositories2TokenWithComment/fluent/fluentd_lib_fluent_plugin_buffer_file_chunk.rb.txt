on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl # # Fluentd # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. #
on_ignored_nl on_ignored_nl on_ignored_nl UNK on_symbeg path on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_comma path on_comma UNK on_comma ### buffer path user specified : /path/to/directory/user_specified_prefix.*.log ### buffer chunk path : /path/to/directory/user_specified_prefix.b513b61c9791029c2513b61c9791029c2.log ### buffer chunk metadata path : /path/to/directory/user_specified_prefix.b513b61c9791029c2513b61c9791029c2.log.meta
on_ignored_nl on_ignored_nl UNK on_symbeg path on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_comma path on_comma UNK on_comma on_label # NOTE: Old style buffer path of time sliced output plugins had a part of key: prefix.20150414.b513b61...suffix # But this part is not used now for any purpose. (Now metadata is used instead.)
on_ignored_nl UNK on_symbeg path on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen UNK on_comma path on_comma UNK on_comma on_label nil # state: b/q - 'b'(on stage, compatible with v0.12), 'q'(enqueued) # path_prefix: path prefix string, ended with '.' # path_suffix: path suffix string, like '.log' (or any other user specified)
on_ignored_nl on_ivar on_op on_ivar on_period pos on_nl on_ivar on_op on_ivar on_nl on_ivar on_op on_ivar on_nl on_ivar on_op on_ivar on_op on_int # this should be at first: of course, this operation may fail
on_ignored_nl begin on_ignored_nl file_rename on_lparen on_ivar on_comma on_ivar on_comma new_chunk_path on_comma UNK on_lparen new_io on_rparen UNK on_ivar on_op new_io on_rbrace # re-write metadata w/ finalized records
raise on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_embexpr_beg e on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end on_nl else on_ignored_nl raise # In this point, restore buffer state is hard because previous `file_rename` failed by resource problem. # Retry is one possible approach but it may cause livelock under limited resources or high load environment. # So we ignore such errors for now and log better message instead. # "Too many open files" should be fixed by proper buffer configuration and system setting.
raise on_tstring_beg on_tstring_content on_embexpr_beg on_ivar on_embexpr_end on_tstring_content on_embexpr_beg e on_embexpr_end on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end on_nl else on_ignored_nl raise # See above
if size on_op on_int on_nl on_const on_period UNK on_lparen on_ivar on_comma on_ivar on_rparen on_nl end on_nl end on_nl on_ignored_nl def # meta may be missing if chunk is queued at first
UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_op on_symbeg UNK on_op on_symbeg UNK on_nl else on_ignored_nl on_symbeg UNK on_nl end on_nl end # //n switch means explicit 'ASCII-8BIT' pattern
on_symbeg UNK on_nl end on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen path on_comma UNK on_rparen on_ignored_nl pos on_op # files which matches to glob of buffer file pattern # it includes files which are created by out_file
path on_op on_tstring_beg on_tstring_content on_embexpr_beg chunk_id on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen # for unexpected cases (ex: users rename files while opened by fluentd)
def self on_period UNK on_lparen path on_rparen on_ignored_nl if UNK on_tstring_content UNK on_op path UNK UNK on_period UNK on_lparen UNK # used only for queued v0.12 buffer path
UNK UNK on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_period UNK UNK on_op UNK on_op UNK on_period to_i on_lparen on_int # //n switch means explicit 'ASCII-8BIT' pattern
data on_op on_const on_op on_const on_period UNK on_lparen on_label true on_rparen on_period UNK on_lparen UNK on_rparen on_period read rescue UNK # old type of restore
on_ivar on_op chunk on_period UNK on_period to_i on_nl on_ignored_nl on_ivar on_period UNK on_op nil on_nl on_ivar on_period UNK on_op nil # birthtime isn't supported on Windows (and Travis?)
raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg path on_embexpr_end on_tstring_content on_embexpr_beg e on_embexpr_end on_tstring_end on_nl end on_nl begin on_ignored_nl on_ivar on_op # Here assumes "Too many open files" like recoverable error so raising BufferOverflowError. # If other cases are possible, we will change erorr handling with proper classes.
on_ivar on_period close rescue nil on_nl on_const on_period UNK on_lparen on_ivar on_rparen rescue nil on_nl on_ignored_nl if on_ivar on_nl on_ivar # This case is easier than enqueued!. Just removing pre-create buffer file
on_ivar on_period close rescue nil on_nl on_const on_period UNK on_lparen on_ivar on_rparen rescue nil on_nl end on_nl on_ignored_nl raise on_const # ensure to unlink when #write_metadata fails
raise on_const on_comma on_tstring_beg on_tstring_content on_embexpr_beg path on_embexpr_end on_tstring_content on_embexpr_beg e on_embexpr_end on_tstring_end on_nl end on_nl on_ignored_nl on_ivar on_op on_symbeg # Same as @chunk case. See above
on_ivar on_op on_int on_nl on_ivar on_op on_int on_nl end on_nl on_ignored_nl def UNK on_lparen path on_rparen on_ignored_nl on_ivar on_op path # must be 0
if on_const on_period UNK on_lparen on_ivar on_rparen on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end if on_const on_period size on_lparen on_ivar # staging buffer chunk without metadata is classic buffer chunk file # and it should be enqueued immediately
on_ivar on_op on_const on_period open on_lparen on_ivar on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ivar on_period set_encoding on_lparen on_const on_op on_const # classic buffer chunk - read only chunk
UNK nil on_nl end on_nl on_ignored_nl if chunk on_period UNK on_lparen on_int on_comma on_int on_rparen on_op on_const on_nl size on_op # size of BUFFER_HEADER (2) + size of data size(4)
