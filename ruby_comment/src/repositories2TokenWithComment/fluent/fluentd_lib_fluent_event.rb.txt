on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl class on_const on_nl UNK on_const # # Fluentd # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. #
def dup on_nl UNK on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def size on_nl UNK on_const on_comma on_tstring_beg # dup does deep copy for event stream
def on_op on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen on_const on_rparen on_op UNK on_period to_msgpack_stream on_op UNK on_period to_msgpack_stream # for tests
class on_const on_op on_const on_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def dup # EventStream from entries: Array of [time, record] # # Use this class for many events data with a tag # and its representation is [ [time, record], [time, record], .. ]
class on_const on_op on_const on_nl def UNK on_lparen UNK on_op on_lbracket on_rbracket on_comma UNK on_op on_lbracket on_rbracket on_rparen on_ignored_nl on_ivar # EventStream from entries: numbers of pairs of time and record. # # This class can handle many events more efficiently than ArrayEventStream # because this class generate less objects than ArrayEventStream. # # Use this class as below, in loop of data-enumeration: # 1. initialize blank stream: # streams[tag] ||= MultiEventStream.new # 2. add events # stream[tag].add(time, record)
on_ignored_nl def UNK on_lparen UNK on_comma UNK on_op nil on_comma size on_op on_int on_comma on_label nil on_comma on_label nil on_rparen # https://github.com/msgpack/msgpack-ruby/issues/119
def UNK on_lparen UNK on_comma UNK on_op nil on_comma size on_op on_int on_comma on_label nil on_comma on_label nil on_rparen on_ignored_nl # Keep cached_unpacker argument for existing plugins
UNK if on_ivar on_op on_int on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl def # @size is unbelievable always when @size == 0 # If the number of events is really zero, unpacking events takes very short time.
on_ivar on_op on_ivar on_period size on_nl end on_nl on_ignored_nl def slice on_lparen index on_comma num on_rparen on_ignored_nl UNK on_nl on_const # @size should be updated always right after unpack. # The real size of unpacked objects are correct, rather than given size.
def slice on_lparen index on_comma num on_rparen on_ignored_nl UNK on_nl on_const on_period new on_lparen on_ivar on_period slice on_lparen index on_comma # This method returns MultiEventStream, because there are no reason # to surve binary serialized by msgpack.
on_ivar on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl def UNK on_lparen UNK on_comma UNK on_op nil # time_int is always ignored because @data is always packed binary in this class
on_ivar on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_nl UNK if on_ivar on_nl on_ivar on_op on_ivar on_op UNK # time_int is always ignored because @data is always packed binary in this class
def each on_lparen on_label nil on_comma on_op block on_rparen on_ignored_nl UNK UNK on_op UNK on_op on_ignored_nl on_lparen UNK on_op on_const # chunk.extend(ChunkEventStreamer) # => chunk.each{|time, record| ... }
UNK on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # time_int is always ignored because data is already packed and written in chunk
