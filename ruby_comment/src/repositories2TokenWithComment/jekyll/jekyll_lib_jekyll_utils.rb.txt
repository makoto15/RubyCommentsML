on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK UNK on_nl autoload on_symbeg on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl autoload on_symbeg # frozen_string_literal: true
on_const on_op UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content on_tstring_end on_period UNK on_nl on_const on_op on_const on_period # Constants for use in #slugify
def UNK on_lparen slug on_rparen on_ignored_nl slug on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK on_lparen on_op on_symbeg UNK # Takes a slug and turns it into a simple title.
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_lparen UNK on_period UNK on_comma UNK on_rparen on_nl end on_nl on_ignored_nl # Non-destructive version of deep_merge_hashes! See that method. # # Returns the merged hashes.
def UNK on_lparen target on_comma overwrite on_rparen on_ignored_nl UNK on_lparen target on_comma overwrite on_rparen on_nl UNK on_lparen target on_comma overwrite # Merges a master hash with another hash, recursively. # # master_hash - the "parent" hash whose values will be overridden # other_hash - the other hash whose values will be persisted after the merge # # This code was lovingly stolen from some random gem: # http://gemjack.com/gems/tartan-0.1.1/classes/Hash.html # # Thanks to whoever made it.
def UNK on_lparen hash on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_op on_lbracket on_rbracket on_nl value on_op UNK on_lparen hash # Read array from the supplied hash favouring the singular key # and then the plural key, and handling any nil entries. # # hash - the hash to read from # singular_key - the singular key # plural_key - the plural key # # Returns an array
def UNK on_lparen hash on_rparen on_ignored_nl UNK on_lparen hash on_rparen UNK on_op key on_op key on_period UNK UNK key UNK # Apply #to_sym to all keys in the hash # # hash - the hash to which to apply this transformation # # Returns a new hash with symbolized keys
def UNK on_lparen hash on_rparen on_ignored_nl UNK on_lparen hash on_rparen UNK on_op key on_op key on_period UNK UNK key UNK # Apply #to_s to all keys in the Hash # # hash - the hash to which to apply this transformation # # Returns a new hash with stringified keys
def UNK on_lparen UNK on_comma UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen on_period UNK # Parse a date/time and throw an error if invalid # # input - the date/time to parse # msg - (optional) the error message to show the user # # Returns the parsed date if successful, throws a FatalException # if not
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_op on_symbeg UNK on_rparen # Determines whether a given file has # # Returns true if the YAML front matter is present. # rubocop: disable Naming/PredicateName
def UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK if UNK on_period UNK on_op UNK on_period UNK on_nl on_ignored_nl UNK on_period # Determine whether the given content string contains Liquid Tags or Vaiables # # Returns true is the string contains sequences of `{%` or `{{`
on_ignored_nl def UNK on_lparen string on_comma UNK UNK on_comma UNK UNK on_rparen on_ignored_nl mode on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK # rubocop: enable Naming/PredicateName
def UNK on_lparen string on_comma UNK UNK on_comma UNK UNK on_rparen on_ignored_nl mode on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK UNK # Slugify a filename or title. # # string - the filename or title to slugify # mode - how string is slugified # cased - whether to replace all uppercase letters with their # lowercase counterparts # # When mode is "none", return the given string. # # When mode is "raw", return the given string, # with every sequence of spaces characters replaced with a hyphen. # # When mode is "default" or nil, non-alphabetic characters are # replaced with a hyphen too. # # When mode is "pretty", some non-alphabetic characters (._~!$&'()+,;=@) # are not replaced with hyphen. # # When mode is "ascii", some everything else except ASCII characters # a-z (lowercase), A-Z (uppercase) and 0-9 (numbers) are not replaced with hyphen. # # When mode is "latin", the input string is first preprocessed so that # any letters with accents are replaced with the plain letter. Afterwards, # it follows the "default" mode of operation. # # If cased is true, all uppercase letters in the result string are # replaced with their lowercase counterparts. # # Examples: # slugify("The _config.yml file") # # => "the-config-yml-file" # # slugify("The _config.yml file", "pretty") # # => "the-_config.yml-file" # # slugify("The _config.yml file", "pretty", true) # # => "The-_config.yml file" # # slugify("The _config.yml file", "ascii") # # => "the-config-yml-file" # # slugify("The _config.yml file", "latin") # # => "the-config-yml-file" # # Returns the slugified string.
if mode on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_period UNK on_period UNK on_op on_symbeg UNK if on_const on_period UNK on_period # Drop accent marks from latin characters. Everything else turns to ?
slug on_period UNK on_lparen UNK on_tstring_content UNK on_comma on_tstring_beg on_tstring_end on_rparen on_nl on_ignored_nl slug on_period UNK UNK UNK on_nl on_const # Remove leading/trailing hyphen
def UNK on_lparen template on_comma UNK on_rparen on_ignored_nl template on_op template on_period UNK on_nl on_ignored_nl UNK UNK on_nl when on_symbeg # Add an appropriate suffix to template so that it matches the specified # permalink style. # # template - permalink template without trailing slash or file extension # permalink_style - permalink style, either built-in or custom # # The returned permalink template will use the same ending style as # specified in permalink_style. For example, if permalink_style contains a # trailing slash (or is :pretty, which indirectly has a trailing slash), # then so will the returned template. If permalink_style has a trailing # ":output_ext" (or is :none, :date, or :ordinal) then so will the returned # template. Otherwise, template will be returned without modification. # # Examples: # add_permalink_suffix("/:basename", :pretty) # # => "/:basename/" # # add_permalink_suffix("/:basename", :date) # # => "/:basename:output_ext" # # add_permalink_suffix("/:basename", "/:year/:month/:title/") # # => "/:basename/" # # add_permalink_suffix("/:basename", "/:year/:month/:title") # # => "/:basename" # # Returns the updated permalink template
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op UNK on_rparen on_ignored_nl UNK on_lbracket on_rbracket UNK on_const on_period UNK on_lparen # Work the same way as Dir.glob but seperating the input into two parts # ('dir' + '/' + 'pattern') to make sure the first part('dir') does not act # as a pattern. # # For example, Dir.glob("path[/*") always returns an empty array, # because the method fails to find the closing pattern to '[' which is ']' # # Examples: # safe_glob("path[", "*") # # => ["path[/file1", "path[/file2"] # # safe_glob("path", "*", File::FNM_DOTMATCH) # # => ["path/.", "path/..", "path/file1"] # # safe_glob("path", ["**", "*"]) # # => ["path[/file1", "path[/folder/file2"] # # dir - the dir where glob will be executed under # (the dir will be included to each result) # patterns - the patterns (or the pattern) which will be applied under the dir # flags - the flags which will be applied to the pattern # # Returns matched pathes
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl merged on_op on_lparen UNK on_op UNK on_period UNK on_op UNK UNK on_rparen # Returns merged option hash for File.read of self.site (if exists) # and a given param
def UNK on_lparen string on_comma UNK on_tstring_beg on_tstring_content on_tstring_end on_rparen on_ignored_nl UNK on_op on_ignored_nl UNK mode on_nl when on_tstring_beg on_tstring_content # Replace each character sequence with a hyphen. # # See Utils#slugify for a description of the character sequence specified # by each mode.
on_const on_nl when on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_nl UNK on_ignored_nl on_const on_nl end on_nl on_ignored_nl string on_period UNK on_lparen # "._~!$&'()+,;=@" is human readable (not URI-escaped) in URL # and is allowed in both extN and NTFS.
on_const on_nl UNK on_ignored_nl on_const on_nl end on_nl on_ignored_nl string on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl # For web servers not being able to handle Unicode, the safe # method is to ditch anything else but latin letters and numeric # digits.
string on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl end on_nl end on_nl EMP EMP EMP # Strip according to the mode
