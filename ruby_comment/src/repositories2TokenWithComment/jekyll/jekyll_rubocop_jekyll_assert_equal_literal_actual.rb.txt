on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_period UNK on_nl on_ignored_nl on_const on_op UNK on_words_sep on_tstring_content on_words_sep # Checks for `assert_equal(exp, act, msg = nil)` calls containing literal values as # second argument. The second argument should ideally be a method called on the tested # instance. # # @example # # bad # assert_equal @foo.bar, "foobar" # assert_equal @alpha.beta, { "foo" => "bar", "lorem" => "ipsum" } # assert_equal @alpha.omega, ["foobar", "lipsum"] # # # good # assert_equal "foobar", @foo.bar # # assert_equal( # { "foo" => "bar", "lorem" => "ipsum" }, # @alpha.beta # ) # # assert_equal( # ["foobar", "lipsum"], # @alpha.omega # ) #
def UNK on_lparen node on_rparen on_ignored_nl node on_op on_lparen UNK on_lparen node on_rparen on_op UNK on_lparen node on_rparen on_rparen on_nl # This is not implement using a NodePattern because it seems # to not be able to match against an explicit (nil) sexp
UNK on_nl on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_embexpr_beg second_expression on_embexpr_end on_tstring_content on_ignored_sp on_tstring_content on_embexpr_beg first_expression on_embexpr_end on_tstring_content on_ignored_sp on_tstring_content UNK end # fold long lines independent of Rubocop configuration for better readability
