on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma #!/usr/bin/env ruby # frozen_string_literal: true # # The Ruby documentation for #sort_by describes what's called a Schwartzian transform: # # > A more efficient technique is to cache the sort keys (modification times in this case) # > before the sort. Perl users often call this approach a Schwartzian transform, after # > Randal Schwartz. We construct a temporary array, where each element is an array # > containing our sort key along with the filename. We sort this array, and then extract # > the filename from the result. # > This is exactly what sort_by does internally. # # The well-documented efficiency of sort_by is a good reason to use it. However, when a property # does not exist on an item being sorted, it can cause issues (no nil's allowed!) # In Jekyll::Filters#sort_input, we extract the property in each iteration of #sort, # which is quite inefficient! How inefficient? This benchmark will tell you just how, and how much # it can be improved by using the Schwartzian transform. Thanks, Randall!
UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK UNK UNK on_comma on_op UNK # Before we test efficiency, do they produce the same output?
UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content # First, test with a property only a handful of documents have.
UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP # Next, test with a property they all have.
