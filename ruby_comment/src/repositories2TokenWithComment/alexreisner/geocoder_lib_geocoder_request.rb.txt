def UNK on_nl UNK on_op on_const on_period UNK on_lparen UNK on_comma UNK UNK on_rparen on_period UNK on_nl end on_nl on_ignored_nl # The location() method is vulnerable to trivial IP spoofing. # Don't use it in authorization/authentication code, or any # other security-sensitive application. Use safe_location # instead.
def UNK on_nl UNK on_op on_const on_period UNK on_lparen ip on_comma UNK UNK on_rparen on_period UNK on_nl end on_nl on_ignored_nl # This safe_location() protects you from trivial IP spoofing. # For requests that go through a proxy that you haven't # whitelisted as trusted in your Rack config, you will get the # location for the IP of the last untrusted proxy in the chain, # not the original client IP. You WILL NOT get the location # corresponding to the original client IP for any request sent # through a non-whitelisted proxy.
on_const on_op UNK on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_tstring_beg on_tstring_content # There's a whole zoo of nonstandard headers added by various # proxy softwares to indicate original client IP. # ANY of these can be trivially spoofed! # (except REMOTE_ADDR, which should by set by your server, # and is included at the end as a fallback. # Order does matter: we're following the convention established in # ActionDispatch::RemoteIp::GetIp::calculate_ip() # https://github.com/rails/rails/blob/master/actionpack/lib/action_dispatch/middleware/remote_ip.rb # where the forwarded_for headers, possibly containing lists, # are arbitrarily preferred over headers expected to contain a # single address.
on_const on_period UNK UNK on_op UNK on_op on_ignored_nl if UNK on_period UNK UNK on_nl addrs on_op UNK on_lparen UNK UNK # We could use a more sophisticated IP-guessing algorithm here, # in which we'd try to resolve the use of different headers by # different proxies. The idea is that by comparing IPs repeated # in different headers, you can sometimes decide which header # was used by a proxy further along in the chain, and thus # prefer the headers used earlier. However, the gains might not # be worth the performance tradeoff, since this method is likely # to be called on every request in a lot of applications.
def UNK on_lparen ip_addresses on_rparen on_ignored_nl ip_addresses on_period UNK UNK on_op ip on_op UNK on_lparen ip on_rparen UNK on_nl end # use Rack's trusted_proxy?() method to filter out IPs that have # been configured as trusted; includes private ranges by # default. (we don't want every lookup to return the location # of our own proxy/load balancer)
if ip on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op UNK on_nl ip on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # IPv4
UNK UNK on_op ip on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_nl UNK on_period UNK on_period UNK on_nl UNK on_ignored_nl # IPv6 bracket notation
UNK on_ignored_nl ip on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen ip_addresses on_rparen on_ignored_nl UNK on_op UNK # IPv6 bare notation
