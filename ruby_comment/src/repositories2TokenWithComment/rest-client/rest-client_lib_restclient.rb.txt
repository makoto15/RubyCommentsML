UNK on_const on_nl on_ignored_nl def self on_period UNK on_lparen url on_comma headers on_op on_lbrace on_rbrace on_comma on_op block on_rparen on_ignored_nl # This module's static methods are the entry point for using the REST client. # # # GET # xml = RestClient.get 'http://example.com/resource' # jpg = RestClient.get 'http://example.com/resource', :accept => 'image/jpg' # # # authentication and SSL # RestClient.get 'https://user:password@example.com/private/resource' # # # POST or PUT with a hash sends parameters as a urlencoded form body # RestClient.post 'http://example.com/resource', :param1 => 'one' # # # nest hash parameters # RestClient.post 'http://example.com/resource', :nested => { :param1 => 'one' } # # # POST and PUT with raw payloads # RestClient.post 'http://example.com/resource', 'the post body', :content_type => 'text/plain' # RestClient.post 'http://example.com/resource.xml', xml_doc # RestClient.put 'http://example.com/resource.pdf', File.read('my.pdf'), :content_type => 'application/pdf' # # # DELETE # RestClient.delete 'http://example.com/resource' # # # retrieve the response http code and headers # res = RestClient.get 'http://example.com/some.jpg' # res.code # => 200 # res.headers[:content_type] # => 'image/jpg' # # # HEAD # RestClient.head('http://example.com').headers # # To use with a proxy, just set RestClient.proxy to the proper http proxy: # # RestClient.proxy = "http://proxy.example.com/" # # Or inherit the proxy from the environment: # # RestClient.proxy = ENV['http_proxy'] # # For live tests of RestClient, try using http://rest-test.heroku.com, which echoes back information about the rest call: # # >> RestClient.put 'http://rest-test.heroku.com/resource', :foo => 'baz' # => "PUT http://rest-test.heroku.com/resource with a 7 byte payload, content type application/x-www-form-urlencoded {\"foo\"=>\"baz\"}" #
def self on_period UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_rparen on_ignored_nl # A global proxy URL to use for all requests. This can be overridden on a # per-request basis by passing `:proxy` to RestClient::Request.
def self on_period UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def self on_period UNK UNK on_nl on_cvar on_op # Return whether RestClient.proxy was set explicitly. We use this to # differentiate between no value being set and a value explicitly set to nil. # # @return [Boolean] #
def self on_period UNK UNK on_nl on_cvar on_op UNK UNK on_nl end on_nl on_ignored_nl def self on_period UNK param on_nl # Setup the log for RestClient calls. # Value should be a logger but can can be stdout, stderr, or a filename. # You can also configure logging by the environment variable RESTCLIENT_LOG.
def self on_period UNK param on_nl UNK param on_nl UNK param on_period UNK on_const on_nl UNK param on_op on_tstring_beg on_tstring_content # Create a log that respond to << like a logger # param can be 'stdout', 'stderr', a string (then we will log to that file) or a logger (then we return it)
on_cvar on_op on_cvar on_nl end on_nl on_ignored_nl on_cvar on_op UNK UNK on_nl on_ignored_nl def self on_period UNK on_op UNK on_nl # :nodoc:
def self on_period UNK on_op UNK on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_nl on_cvar # Add a Proc to be called before each request in executed. # The proc parameters will be the http request and the request params.
def self on_period UNK on_nl on_cvar on_op UNK UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_cvar on_nl end # Reset the procs to be called before each request is executed.
on_cvar on_nl end on_nl on_ignored_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # :nodoc:
