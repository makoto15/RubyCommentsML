require on_tstring_beg on_tstring_content on_tstring_end on_nl rescue on_const on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl UNK on_const on_nl UNK # Use mime/types/columnar if available, for reduced memory usage
UNK on_const on_nl on_ignored_nl UNK on_symbeg method on_comma on_symbeg uri on_comma on_symbeg url on_comma on_symbeg headers on_comma on_symbeg payload on_comma # This class is used internally by RestClient to send the request, but you can also # call it directly if you'd like to use a method not supported by the # main API. For example: # # RestClient::Request.execute(:method => :head, :url => 'http://example.com') # # Mandatory parameters: # * :method # * :url # Optional parameters (have a look at ssl and/or uri for some explanations): # * :headers a hash containing the request headers # * :cookies may be a Hash{String/Symbol => String} of cookie values, an # Array<HTTP::Cookie>, or an HTTP::CookieJar containing cookies. These # will be added to a cookie jar before the request is sent. # * :user and :password for basic auth, will be replaced by a user/password available in the :url # * :block_response call the provided block with the HTTPResponse as parameter # * :raw_response return a low-level RawResponse instead of a Response # * :log Set the log for this request only, overriding RestClient.log, if # any. # * :stream_log_percent (Only relevant with :raw_response => true) Customize # the interval at which download progress is logged. Defaults to every # 10% complete. # * :max_redirects maximum number of redirections (default to 10) # * :proxy An HTTP proxy URI to use for this request. Any value here # (including nil) will override RestClient.proxy. # * :verify_ssl enable ssl verification, possible values are constants from # OpenSSL::SSL::VERIFY_*, defaults to OpenSSL::SSL::VERIFY_PEER # * :read_timeout and :open_timeout are how long to wait for a response and # to open a connection, in seconds. Pass nil to disable the timeout. # * :timeout can be used to set both timeouts # * :ssl_client_cert, :ssl_client_key, :ssl_ca_file, :ssl_ca_path, # :ssl_cert_store, :ssl_verify_callback, :ssl_verify_callback_warnings # * :ssl_version specifies the SSL version for the underlying Net::HTTP connection # * :ssl_ciphers sets SSL ciphers for the connection. See # OpenSSL::SSL::SSLContext#ciphers= # * :before_execution_proc a Proc to call before executing the request. This # proc, like procs from RestClient.before_execution_procs, will be # called with the HTTP request and request params.
UNK on_symbeg UNK on_nl on_ignored_nl def self on_period UNK on_lparen args on_comma on_op block on_rparen on_ignored_nl new on_lparen args on_rparen # An array of previous redirection responses
on_ivar on_op UNK on_lparen on_ivar on_comma on_ivar on_comma args on_rparen on_nl on_ignored_nl on_ivar on_op on_const on_period UNK on_lparen args on_lbracket # process cookie arguments found in headers or args
on_ivar on_lbracket on_symbeg verify_ssl on_rbracket on_op on_const on_op on_const on_op on_const on_nl else on_ignored_nl on_ivar on_lbracket on_symbeg verify_ssl on_rbracket on_op # interpret :verify_ssl => true as VERIFY_PEER
on_ivar on_lbracket on_symbeg verify_ssl on_rbracket on_op UNK on_nl end on_nl else on_ignored_nl on_ivar on_lbracket on_symbeg verify_ssl on_rbracket on_op on_const on_op # otherwise pass through any truthy values
on_ivar on_lbracket on_symbeg verify_ssl on_rbracket on_op on_const on_op on_const on_op on_const on_nl end on_nl else on_ignored_nl on_ivar on_lbracket on_symbeg verify_ssl # interpret all falsy :verify_ssl values as VERIFY_NONE
on_ivar on_lbracket on_symbeg verify_ssl on_rbracket on_op on_const on_op on_const on_op on_const on_nl end on_nl on_ignored_nl on_const on_period each do on_op # if :verify_ssl was not passed, default to VERIFY_PEER
if UNK on_nl on_ignored_nl if on_op UNK on_op on_op UNK on_op on_op on_ivar on_period include? on_lparen on_symbeg cert_store on_rparen on_nl # Set some other default SSL options, but only if we have an HTTPS URI.
if on_op UNK on_op on_op UNK on_op on_op on_ivar on_period include? on_lparen on_symbeg cert_store on_rparen on_nl on_ivar on_lbracket on_symbeg cert_store # If there's no CA file, CA path, or cert store provided, use default
UNK uri on_comma UNK on_lparen method on_rparen on_period new on_lparen uri on_comma UNK on_rparen on_comma payload on_comma on_op block on_nl # With 2.0.0+, net/http accepts URI objects in requests and handles wrapping # IPv6 addresses in [] for use in the Host request header.
def verify_ssl on_nl on_ivar on_period UNK on_lparen on_symbeg verify_ssl on_rparen on_nl end on_nl on_const on_period each do on_op key on_op # SSL-related options
def UNK on_nl uri on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen url on_comma # Return true if the request URI will use HTTPS. # # @return [Boolean] #
def UNK on_lparen url on_comma headers on_rparen on_ignored_nl url_params on_op nil on_nl on_ignored_nl headers on_period UNK do on_op key on_comma # Extract the query parameters and append them to the url # # Look through the headers hash for a :params option (case-insensitive, # may be string or symbol). If present and the value is a Hash or # RestClient::ParamsArray, *delete* the key/value pair from the headers # hash and encode the value into a query string. Append this query string # to the URL and return the resulting URL. # # @param [String] url # @param [Hash] headers An options/headers hash to process. Mutation # warning: the params key may be removed if present! # # @return [String] resulting url with query string #
headers on_period UNK do on_op key on_comma value on_op on_ignored_nl if key on_period to_s on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end # find and extract/remove "params" key if the value is a Hash/ParamsArray
if url_params on_op on_op url_params on_period UNK on_nl UNK on_op on_const on_op on_const on_period UNK on_lparen url_params on_rparen on_nl on_ignored_nl # build resulting URL with query string
def cookies on_nl UNK on_op on_lbrace on_rbrace on_nl on_ignored_nl on_ivar on_period cookies on_lparen uri on_rparen on_period each do on_op UNK # Render a hash of key => value pairs for cookies in the Request#cookie_jar # that are valid for the Request#uri. This will not necessarily include all # cookies if there are duplicate keys. It's safer to use the cookie_jar # directly if that's a concern. # # @see Request#cookie_jar # # @return [Hash] #
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl return nil if UNK on_period UNK on_nl on_ignored_nl UNK # @return [HTTP::CookieJar]
def UNK on_nl return nil if UNK on_period UNK on_nl on_ignored_nl UNK on_op UNK on_period cookies on_lparen url on_rparen on_nl # Render a Cookie HTTP request header from the contents of the @cookie_jar, # or nil if the jar is empty. # # @see Request#cookie_jar # # @return [String, nil] #
def UNK on_lparen uri on_comma headers on_comma args on_rparen on_ignored_nl on_ignored_nl if headers on_lbracket on_symbeg cookies on_rbracket on_op args on_lbracket # Process cookies passed as hash or as HTTP::CookieJar. For backwards # compatibility, these may be passed as a :cookies option masquerading # inside the headers hash. To avoid confusion, if :cookies is passed in # both headers and Request#initialize, raise an error. # # :cookies may be a: # - Hash{String/Symbol => String} # - Array<HTTP::Cookie> # - HTTP::CookieJar # # Passing as a hash: # Keys may be symbols or strings. Values must be strings. # Infer the domain name from the request URI and allow subdomains (as # though '.example.com' had been set in a Set-Cookie header). Assume a # path of '/'. # # RestClient::Request.new(url: 'http://example.com', method: :get, # :cookies => {:foo => 'Value', 'bar' => '123'} # ) # # results in cookies as though set from the server by: # Set-Cookie: foo=Value; Domain=.example.com; Path=/ # Set-Cookie: bar=123; Domain=.example.com; Path=/ # # which yields a client cookie header of: # Cookie: foo=Value; bar=123 # # Passing as HTTP::CookieJar, which will be passed through directly: # # jar = HTTP::CookieJar.new # jar.add(HTTP::Cookie.new('foo', 'Value', domain: 'example.com', # path: '/', for_domain: false)) # # RestClient::Request.new(..., :cookies => jar) # # @param [URI::HTTP] uri The URI for the request. This will be used to # infer the domain name for cookies passed as strings in a hash. To avoid # this implicit behavior, pass a full cookie jar or use HTTP::Cookie hash # values. # @param [Hash] headers The headers hash from which to pull the :cookies # option. MUTATION NOTE: This key will be deleted from the hash if # present. # @param [Hash] args The options passed to Request#initialize. This hash # will be used as another potential source for the :cookies key. # These args will not be mutated. # # @return [HTTP::CookieJar] A cookie jar containing the parsed cookies. #
if headers on_lbracket on_symbeg cookies on_rbracket on_op args on_lbracket on_symbeg cookies on_rbracket on_nl raise on_const on_period new on_lparen on_ignored_nl on_tstring_beg # Avoid ambiguity in whether options from headers or options from # Request#initialize should take precedence by raising ArgumentError when # both are present. Prior versions of rest-client claimed to give # precedence to init options, but actually gave precedence to headers. # Avoid that mess by erroring out instead.
if UNK on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl return UNK on_period UNK on_nl end on_nl on_ignored_nl UNK on_op # return copy of cookie jar as is
UNK on_op on_const on_op on_const on_period new on_nl on_ignored_nl on_lparen UNK on_op on_lbracket on_rbracket on_rparen on_period each do on_op key # convert cookies hash into a CookieJar
if key on_period is_a? on_lparen on_const on_op on_const on_rparen on_nl if val on_nl raise on_const on_period new on_lparen on_tstring_beg on_tstring_content # Support for Array<HTTP::Cookie> mode: # If key is a cookie object, add it to the jar directly and assert that # there is no separate val.
UNK on_period UNK on_lparen on_const on_op on_const on_period new on_lparen key on_comma val on_comma UNK uri on_period hostname on_period UNK # assume implicit domain from the request URI, and set for_domain to # permit subdomains
def UNK on_lparen UNK on_rparen on_ignored_nl headers on_op UNK on_lparen UNK on_rparen on_period UNK on_lparen UNK on_lparen UNK on_rparen on_rparen # Generate headers for use by a request. Header keys will be stringified # using `#stringify_headers` to normalize them as capitalized strings. # # The final headers consist of: # - default headers from #default_headers # - user_headers provided here # - headers from the payload object (e.g. Content-Type, Content-Lenth) # - cookie headers from #make_cookie_header # # BUG: stringify_headers does not alter the capitalization of headers that # are passed as strings, it only normalizes those passed as symbols. This # behavior will probably remain for a while for compatibility, but it means # that the warnings that attempt to detect accidental header overrides may # not always work. # https://github.com/rest-client/rest-client/issues/599 # # @param [Hash] user_headers User-provided headers to include # # @return [Hash<String, String>] A hash of HTTP headers => values #
if on_ivar on_nl UNK on_op on_ivar on_period headers on_nl on_ignored_nl UNK on_period UNK do on_op key on_comma val on_op on_ignored_nl # override headers from the payload (e.g. Content-Type, Content-Length)
UNK on_period UNK do on_op key on_comma val on_op on_ignored_nl if headers on_period include? on_lparen key on_rparen on_op headers on_lbracket # Warn the user if we override any headers that were previously # present. This usually indicates that rest-client was passed # conflicting information, e.g. if it was asked to render a payload as # x-www-form-urlencoded but a Content-Type application/json was # also supplied by the user.
cookies on_op UNK on_nl if cookies on_op on_op cookies on_period UNK on_nl if headers on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl # merge in cookies
def UNK on_nl if UNK on_lparen on_ivar on_rparen on_nl if on_ivar on_nl on_const on_period UNK on_lparen on_ivar on_rparen on_nl else # The proxy URI for this request. If `:proxy` was provided on this request, # use it over `RestClient.proxy`. # # Return false if a proxy was explicitly set and is falsy. # # @return [URI, false, nil] #
on_const on_op on_const on_period new on_lparen hostname on_comma port on_rparen on_nl UNK on_op p_uri on_nl on_const on_op on_const on_period new # no proxy set
on_const on_op on_const on_period new on_lparen hostname on_comma port on_comma nil on_comma nil on_comma nil on_comma nil on_rparen on_nl else # proxy explicitly set to none
def UNK on_lparen url on_rparen on_ignored_nl url on_op on_tstring_beg on_tstring_content on_tstring_end on_op url unless url on_period UNK on_lparen UNK on_tstring_content # Normalize a URL by adding a protocol if none is present. # # If the string has no HTTP-like scheme (i.e. scheme followed by '//'), a # scheme of 'http' will be added. This mimics the behavior of browsers and # user agents like cURL. # # @param [String] url A URL string. # # @return [String] #
def self on_period UNK on_nl cert_store on_op on_const on_op on_const on_op on_const on_period new on_nl cert_store on_period UNK on_nl on_ignored_nl # Return a certificate store that can be used to validate certificates with # the system certificate authorities. This will probably not do anything on # OS X, which monkey patches OpenSSL in terrible ways to insert its own # validation. On most *nix platforms, this will add the system certifcates # using OpenSSL::X509::Store#set_default_paths. On Windows, this will use # RestClient::Windows::RootCerts to look up the CAs trusted by the system. # # @return [OpenSSL::X509::Store] #
if on_const on_op on_const on_period UNK on_nl on_const on_op on_const on_op on_const on_period UNK on_period UNK on_period UNK on_period each # set_default_paths() doesn't do anything on Windows, so look up # certificates using the win32 API.
raise unless err on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl end on_nl on_ignored_nl cert_store on_nl end # ignore duplicate certs
def log on_nl on_ivar on_op on_const on_period log on_nl end on_nl on_ignored_nl def UNK on_nl return unless log on_nl on_ignored_nl # Default to the global logger if there's not a request-specific one
def UNK headers on_nl headers on_period UNK on_lparen on_lbrace on_rbrace on_rparen do on_op UNK on_comma on_lparen key on_comma value on_rparen # Return a hash of headers whose keys are capitalized strings # # BUG: stringify_headers does not fix the capitalization of headers that # are already Strings. Leaving this behavior as is for now for # backwards compatibility. # https://github.com/rest-client/rest-client/issues/599 #
if value on_period is_a? on_const on_nl UNK on_op value on_nl else on_ignored_nl UNK on_op value on_period to_s on_period UNK on_tstring_beg # Accept can be composed of several comma-separated values
def UNK on_nl on_lbrace on_ignored_nl on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_symbeg UNK on_op on_const on_op on_const on_period # Default headers set by RestClient. In addition to these headers, servers # will receive headers set by Net::HTTP, such as Accept-Encoding and Host. # # @return [Hash<Symbol, String>]
def UNK on_lparen url on_rparen on_ignored_nl uri on_op on_const on_period UNK on_lparen url on_rparen on_nl on_ignored_nl if uri on_period hostname # Parse the `@url` string into a URI object and save it as # `@uri`. Also save any basic auth user or password as @user and @password. # If no auth info was passed, check for credentials in a Netrc file. # # @param [String] url A URL string. # # @return [URI] # # @raise URI::InvalidURIError on invalid URIs #
def UNK on_lparen method on_rparen on_ignored_nl raise on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen unless method on_nl method on_period # Parse a method and return a normalized string version. # # Raise ArgumentError if the method is falsy, but otherwise do no # validation. # # @param method [String, Symbol] # # @return [String] # # @see net_http_request_class #
UNK on_op false on_nl on_ignored_nl UNK req on_nl on_ignored_nl net on_op UNK on_lparen uri on_period hostname on_comma uri on_period port # We set this to true in the net/http block so that we can distinguish # read_timeout from open_timeout. Now that we only support Ruby 2.0+, # this is only needed for Timeout exceptions thrown outside of Net::HTTP.
if UNK on_nl net on_period UNK on_op UNK on_nl on_ignored_nl if on_const on_op on_const on_period UNK on_nl net on_period cert_store # We no longer rely on net.verify_callback for the main SSL verification # because it's not well supported on all platforms (see comments below). # But do allow users to set one if they want.
if on_const on_op on_const on_period UNK on_nl net on_period cert_store on_op on_const on_op on_const on_op on_const on_period new on_nl end # Hilariously, jruby only calls the callback when cert_store is set to # something, so make sure to set one. # https://github.com/jruby/jruby/issues/597
tempfile on_op UNK on_lparen http_response on_rparen on_nl else on_ignored_nl http_response on_period UNK on_nl end on_nl http_response on_nl on_rbrace on_nl UNK # fetch body into tempfile
http_response on_period UNK on_nl end on_nl http_response on_nl on_rbrace on_nl UNK on_lparen res on_comma UNK on_comma tempfile on_comma on_op block # fetch body
if UNK on_nl raise on_const on_op on_const on_op on_const on_period new on_lparen nil on_comma err on_rparen on_nl else on_ignored_nl raise # handling for non-Net::HTTP timeouts
on_ignored_nl if UNK on_period UNK on_period include? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl raise on_const on_period new on_lparen UNK on_period # TODO: deprecate and remove RestClient::SSLCertificateNotVerified and just # pass through OpenSSL::SSL::SSLError directly. # # Exceptions in verify_callback are ignored [1], and jruby doesn't support # it at all [2]. RestClient has to catch OpenSSL::SSL::SSLError and either # re-throw it as is, or throw SSLCertificateNotVerified based on the # contents of the message field of the original exception. # # The client has to handle OpenSSL::SSL::SSLError exceptions anyway, so # we shouldn't make them handle both OpenSSL and RestClient exceptions. # # [1] https://github.com/ruby/ruby/blob/89e70fe8e7/ext/openssl/ossl.c#L238 # [2] https://github.com/jruby/jruby/issues/597
UNK on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_period UNK on_nl on_ignored_nl size on_op on_int on_nl # Taken from Chef, which as in turn... # Stolen from http://www.ruby-forum.com/topic/166423 # Kudos to _why!
def UNK on_lparen res on_comma UNK on_comma tempfile on_op nil on_comma on_op block on_rparen on_ignored_nl if on_ivar on_nl unless tempfile # @param res The Net::HTTP response object # @param start_time [Time] Time of request start
def UNK on_lparen ext on_rparen on_ignored_nl unless ext on_op UNK on_tstring_content UNK on_nl return ext on_nl end on_nl on_ignored_nl UNK # Given a MIME type or file extension, return either a MIME type or, if # none is found, the input unchanged. # # >> maybe_convert_extension('json') # => 'application/json' # # >> maybe_convert_extension('unknown') # => 'unknown' # # >> maybe_convert_extension('application/xml') # => 'application/xml' # # @param ext [String] # # @return [String] #
return ext on_nl end on_nl on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_lparen ext on_rparen on_nl if UNK on_period # Don't look up strings unless they look like they could be a file # extension known to mime-types. # # There currently isn't any API public way to look up extensions # directly out of MIME::Types, but the type_for() method only strips # off after a period anyway.
