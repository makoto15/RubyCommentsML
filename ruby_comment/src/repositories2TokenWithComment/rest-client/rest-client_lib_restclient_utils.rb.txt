UNK on_const on_nl on_ignored_nl def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_lbracket UNK UNK on_rbracket on_nl # Various utility methods
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_lbracket UNK UNK on_rbracket on_nl UNK nil UNK UNK # Return encoding from an HTTP header hash. # # We use the RFC 7231 specification and do not impose a default encoding on # text. This differs from the older RFC 2616 behavior, which specifies # using ISO-8859-1 for text/* content types without a charset. # # Strings will use the default encoding when this method returns nil. This # default is likely to be UTF-8 for Ruby >= 2.0 # # @param headers [Hash<Symbol,String>] # # @return [String, nil] Return the string encoding or nil if no header is # found. # # @example # >> get_encoding_from_headers({:content_type => 'text/plain; charset=UTF-8'}) # => "UTF-8" #
if on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_comma UNK on_op UNK on_lparen UNK on_rparen on_nl on_ignored_nl # TODO: remove this hack once we drop support for Ruby 2.0
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen # Parse a Content-Type like header. # # Return the main content-type and a hash of params. # # @param [String] line # @return [Array(String, Hash)] #
def self on_period UNK on_lparen s on_rparen on_ignored_nl UNK UNK on_lparen UNK on_comma s on_rparen UNK UNK on_nl on_ignored_nl UNK # Parse semi-colon separated, potentially quoted header string iteratively. # # @private # # @deprecated This method is deprecated and only exists to support Ruby # 2.0, which is not supported by HTTP::Accept. # # @todo remove this method when dropping support for Ruby 2.0 #
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_rparen on_nl UNK # Parse a Content-Type like header. # # Return the main content-type and a hash of options. # # This method was ported directly from Python's cgi.parse_header(). It # probably doesn't read or perform particularly well in ruby. # https://github.com/python/cpython/blob/3.4/Lib/cgi.py#L301-L331 # # @param [String] line # @return [Array(String, Hash)] # # @deprecated This method is deprecated and only exists to support Ruby # 2.0, which is not supported by HTTP::Accept. # # @todo remove this method when dropping support for Ruby 2.0 #
def self on_period UNK on_lparen object on_rparen on_ignored_nl UNK on_lparen object on_comma UNK on_rparen on_period UNK UNK on_op k on_comma # Serialize a ruby object into HTTP query string parameters. # # There is no standard for doing this, so we choose our own slightly # idiosyncratic format. The output closely matches the format understood by # Rails, Rack, and PHP. # # If you don't want handling of complex objects and only want to handle # simple flat hashes, you may want to use `URI.encode_www_form` instead, # which implements HTML5-compliant URL encoded form data. # # @param [Hash,ParamsArray] object The object to serialize # # @return [String] A string appropriate for use as an HTTP query string # # @see {flatten_params} # # @see URI.encode_www_form # # @see See also Object#to_query in ActiveSupport # @see http://php.net/manual/en/function.http-build-query.php # http_build_query in PHP # @see See also Rack::Utils.build_nested_query in Rack # # Notable differences from the ActiveSupport implementation: # # - Empty hash and empty array are treated the same as nil instead of being # omitted entirely from the output. Rather than disappearing, they will # appear to be nil instead. # # It's most common to pass a Hash as the object to serialize, but you can # also use a ParamsArray if you want to be able to pass the same key with # multiple values and not use the rack/rails array convention. # # @since 2.0.0 # # @example Simple hashes # >> encode_query_string({foo: 123, bar: 456}) # => 'foo=123&bar=456' # # @example Simple arrays # >> encode_query_string({foo: [1,2,3]}) # => 'foo[]=1&foo[]=2&foo[]=3' # # @example Nested hashes # >> encode_query_string({outer: {foo: 123, bar: 456}}) # => 'outer[foo]=123&outer[bar]=456' # # @example Deeply nesting # >> encode_query_string({coords: [{x: 1, y: 0}, {x: 2}, {x: 3}]}) # => 'coords[][x]=1&coords[][y]=0&coords[][x]=2&coords[][x]=3' # # @example Null and empty values # >> encode_query_string({string: '', empty: nil, list: [], hash: {}}) # => 'string=&empty&list&hash' # # @example Nested nulls # >> encode_query_string({foo: {string: '', empty: nil}}) # => 'foo[string]=&foo[empty]' # # @example Multiple fields with the same name using ParamsArray # >> encode_query_string(RestClient::ParamsArray.new([[:foo, 1], [:foo, 2], [:foo, 3]])) # => 'foo=1&foo=2&foo=3' # # @example Nested ParamsArray # >> encode_query_string({foo: RestClient::ParamsArray.new([[:a, 1], [:a, 2]])}) # => 'foo[a]=1&foo[a]=2' # # >> encode_query_string(RestClient::ParamsArray.new([[:foo, {a: 1}], [:foo, {a: 2}]])) # => 'foo[a]=1&foo[a]=2' #
def self on_period UNK on_lparen object on_comma UNK on_op UNK on_comma parent_key on_op nil on_rparen on_ignored_nl UNK object on_period UNK # Transform deeply nested param containers into a flat array of [key, # value] pairs. # # @example # >> flatten_params({key1: {key2: 123}}) # => [["key1[key2]", 123]] # # @example # >> flatten_params({key1: {key2: 123, arr: [1,2,3]}}) # => [["key1[key2]", 123], ["key1[arr][]", 1], ["key1[arr][]", 2], ["key1[arr][]", 3]] # # @param object [Hash, ParamsArray] The container to flatten # @param uri_escape [Boolean] Whether to URI escape keys and values # @param parent_key [String] Should not be passed (used for recursion) #
if object on_period UNK on_op parent_key on_nl UNK on_lbracket on_lbracket parent_key on_comma nil on_rbracket on_rbracket on_nl end on_nl on_ignored_nl object # transform empty collections into nil, where possible
object on_period UNK on_lparen on_lbracket on_rbracket on_rparen UNK on_op UNK on_comma UNK on_op on_ignored_nl if object on_period UNK on_lparen on_const # This is essentially .map(), but we need to do += for nested containers
k on_op nil on_nl v on_op UNK on_nl UNK on_ignored_nl k on_comma v on_op UNK on_nl k on_op UNK on_lparen # item is already the value
k on_comma v on_op UNK on_nl k on_op UNK on_lparen k on_period UNK on_rparen if UNK on_nl end on_nl on_ignored_nl # item is a key, value pair
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen on_nl end on_nl end on_nl end # Encode string for safe transport by URI or form encoding. This uses a CGI # style escape, which transforms ` ` into `+` and various special # characters into percent encoded forms. # # This calls URI.encode_www_form_component for the implementation. The only # difference between this and CGI.escape is that it does not escape `*`. # http://stackoverflow.com/questions/25085992/ # # @see URI.encode_www_form_component #
