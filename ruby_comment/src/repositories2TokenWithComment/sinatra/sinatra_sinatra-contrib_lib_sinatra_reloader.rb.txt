UNK on_const on_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_period new on_lparen on_symbeg type on_comma on_symbeg representation # = Sinatra::Reloader # # Extension to reload modified files. Useful during development, # since it will automatically require files defining routes, filters, # error handlers and inline templates, with every incoming request, # but only if they have been updated. # # == Usage # # === Classic Application # # To enable the reloader in a classic application all you need to do is # require it: # # require "sinatra" # require "sinatra/reloader" if development? # # # Your classic application code goes here... # # === Modular Application # # To enable the reloader in a modular application all you need to do is # require it, and then, register it: # # require "sinatra/base" # require "sinatra/reloader" # # class MyApp < Sinatra::Base # configure :development do # register Sinatra::Reloader # end # # # Your modular application code goes here... # end # # == Using the Reloader in Other Environments # # By default, the reloader is only enabled for the development # environment. Similar to registering the reloader in a modular # application, a classic application requires manually enabling the # extension for it to be available in a non-development environment. # # require "sinatra" # require "sinatra/reloader" # # configure :production do # enable :reloader # end # # == Changing the Reloading Policy # # You can refine the reloading policy with +also_reload+ and # +dont_reload+, to customize which files should, and should not, be # reloaded, respectively. You can also use +after_reload+ to execute a # block after any file being reloaded. # # === Classic Application # # Simply call the methods: # # require "sinatra" # require "sinatra/reloader" if development? # # also_reload '/path/to/some/file' # dont_reload '/path/to/other/file' # after_reload do # puts 'reloaded' # end # # # Your classic application code goes here... # # === Modular Application # # Call the methods inside the +configure+ block: # # require "sinatra/base" # require "sinatra/reloader" # # class MyApp < Sinatra::Base # configure :development do # register Sinatra::Reloader # also_reload '/path/to/some/file' # dont_reload '/path/to/other/file' # after_reload do # puts 'reloaded' # end # end # # # Your modular application code goes here... # end #
UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_period new on_lparen on_symbeg type on_comma on_symbeg representation on_rparen on_nl end on_nl # Watches a file so it can tell when it has been updated, and what # elements does it contain.
UNK on_const on_op on_const on_period new on_lparen on_symbeg type on_comma on_symbeg representation on_rparen on_nl end on_nl on_ignored_nl UNK on_const on_nl # Represents an element of a Sinatra application that may need to # be reloaded. An element could be: # * a route # * a filter # * an error handler # * a middleware # * inline templates # # Its +representation+ attribute is there to allow to identify the # element within an application, that is, to match it with its # Sinatra's internal representation.
UNK on_const on_nl on_ivar on_op on_const on_period new on_lbrace on_op UNK on_comma UNK on_op UNK on_lbracket UNK on_rbracket on_op new # Collection of file +Watcher+ that can be associated with a # Sinatra application. That way, we can know which files belong # to a given application and which files have been modified. It # also provides a mechanism to inform a Watcher of the elements # defined in the file being watched and if its changes should be # ignored.
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_lbracket UNK on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar # Returns the +List+ for the application +app+.
def UNK on_nl on_ivar on_op on_const on_period new UNK on_op UNK on_comma UNK on_op on_ignored_nl UNK on_lbracket UNK on_rbracket on_op # Creates a new +List+ instance.
def UNK on_lparen path on_comma element on_rparen on_ignored_nl UNK on_lparen path on_rparen on_period UNK on_op element on_nl end on_nl on_ignored_nl # Lets the +Watcher+ for the file located at +path+ know that the # +element+ is defined there, and adds the +Watcher+ to the +List+, # if it isn't already there.
def UNK on_lparen path on_rparen on_ignored_nl UNK on_lparen path on_rparen on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen path # Tells the +Watcher+ for the file located at +path+ to ignore # the file changes, and adds the +Watcher+ to the +List+, if # it isn't already there.
def UNK on_lparen path on_rparen on_ignored_nl on_ivar on_lbracket on_const on_period UNK on_lparen path on_rparen on_rbracket on_nl end on_nl UNK UNK # Adds a +Watcher+ for the file located at +path+ to the # +List+, if it isn't already there.
def UNK on_nl on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_period UNK on_lparen on_op on_symbeg UNK # Returns an array with all the watchers in the +List+.
def UNK on_nl UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl end on_nl end on_nl on_ignored_nl UNK on_symbeg path # Returns an array with all the watchers in the +List+ that # have been updated.
def UNK on_lparen path on_rparen on_ignored_nl on_ivar on_op nil on_nl on_ivar on_comma on_ivar on_op path on_comma on_lbracket on_rbracket on_nl UNK # Creates a new +Watcher+ instance for the file located at +path+.
def UNK on_nl on_op UNK on_op on_op UNK on_op UNK on_op on_const on_period UNK on_lparen path on_rparen on_nl end on_nl # Indicates whether or not the file being watched has been modified.
def UNK on_nl on_ivar on_op on_const on_period UNK on_lparen path on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_period # Updates the mtime of the file being watched.
def UNK on_nl UNK on_period UNK on_lbrace on_op element on_op element on_period type on_op on_symbeg UNK on_rbrace on_nl end on_nl # Indicates whether or not the file being watched has inline # templates.
def UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_op on_op on_ivar on_nl end on_nl on_ignored_nl # Informs that the modifications to the file being watched # should be ignored.
def UNK on_nl on_op on_op on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl on_op on_const on_period UNK on_lparen path on_rparen # Indicates whether or not the modifications to the file being # watched should be ignored.
def UNK on_nl on_op on_const on_period UNK on_lparen path on_rparen on_nl end on_nl end on_nl on_ignored_nl on_const on_op on_const on_period # Indicates whether or not the file being watched has been removed.
UNK on_op on_lbracket on_rbracket on_nl def UNK on_lparen on_op block on_rparen on_ignored_nl UNK on_op block on_nl end on_nl on_ignored_nl def # Allow a block to be executed after any file being reloaded
def self on_period UNK on_lparen klass on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl UNK if on_ivar on_lbracket klass on_rbracket on_nl # When the extension is registered it extends the Sinatra application # +klass+ with the modules +BaseMethods+ and +ExtensionMethods+ and # defines a before filter to +perform+ the reload of the modified files.
def self on_period UNK on_lparen klass on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_lparen klass on_rparen on_period UNK on_period each # Reloads the modified files, adding, updating and removing the # needed elements.
UNK on_const on_nl def UNK on_lparen on_op UNK on_rparen on_ignored_nl if UNK on_period UNK on_nl super UNK UNK on_nl UNK # Contains the methods defined in Sinatra::Base that are overridden.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl if UNK on_period UNK on_nl super UNK UNK on_nl UNK on_ignored_nl super on_nl # Protects Sinatra::Base.run! from being called more than once.
def UNK on_lparen verb on_comma path on_comma block on_comma on_op UNK on_rparen on_ignored_nl source_location on_op block on_period UNK on_lparen on_symbeg # Does everything Sinatra::Base#route does, but it also tells the # +Watcher::List+ for the Sinatra application to watch the defined # route. # # Note: We are using #compile! so we don't interfere with extensions # changing #route.
def UNK on_lparen file on_op nil on_rparen on_ignored_nl file on_op on_lparen file on_period UNK on_op file on_op UNK on_rparen on_op # Does everything Sinatra::Base#inline_templates= does, but it also # tells the +Watcher::List+ for the Sinatra application to watch the # inline templates in +file+ or the file who made the call to this # method.
def UNK on_lparen UNK on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl path on_op caller_files on_lbracket on_int on_rbracket on_op on_const # Does everything Sinatra::Base#use does, but it also tells the # +Watcher::List+ for the Sinatra application to watch the middleware # being used.
def UNK on_lparen type on_comma path on_op nil on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl source_location on_op block on_period # Does everything Sinatra::Base#add_filter does, but it also tells # the +Watcher::List+ for the Sinatra application to watch the defined # filter.
def UNK on_lparen on_op UNK on_comma on_op block on_rparen on_ignored_nl path on_op caller_files on_lbracket on_int on_rbracket on_op on_const on_period UNK # Does everything Sinatra::Base#error does, but it also tells the # +Watcher::List+ for the Sinatra application to watch the defined # error handler.
def UNK on_lparen on_op UNK on_comma on_op block on_rparen on_ignored_nl UNK on_nl result on_op super on_nl UNK on_nl result on_nl # Does everything Sinatra::Base#register does, but it also lets the # reloader know that an extension is being registered, because the # elements defined in its +registered+ method need a special treatment.
def UNK on_lparen UNK on_rparen on_ignored_nl result on_op super on_nl UNK on_period UNK on_const on_op on_const on_nl result on_nl end # Does everything Sinatra::Base#register does and then registers the # reloader in the +subclass+.
UNK on_const on_nl def UNK on_lparen element on_rparen on_ignored_nl UNK element on_period type on_nl UNK on_symbeg UNK UNK on_ignored_nl verb # Contains the methods that the extension adds to the Sinatra application.
def UNK on_lparen element on_rparen on_ignored_nl UNK element on_period type on_nl UNK on_symbeg UNK UNK on_ignored_nl verb on_op element on_period # Removes the +element+ from the Sinatra application.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl on_const on_lbracket on_op UNK on_rbracket on_period each on_lbrace on_op path on_op on_const on_op # Indicates with a +glob+ which files should be reloaded if they # have been modified. It can be called several times.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl on_const on_lbracket on_op UNK on_rbracket on_period each on_lbrace on_op path on_op on_const on_op # Indicates with a +glob+ which files should not be reloaded even if # they have been modified. It can be called several times.
def UNK UNK on_ivar on_op nil UNK end on_nl on_ignored_nl def UNK on_nl on_ivar on_op caller_files on_lbracket on_int on_rbracket on_nl # attr_reader :register_path warn on -w (private attribute)
def UNK on_nl on_ivar on_op caller_files on_lbracket on_int on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op nil on_nl # Indicates an extesion is being registered.
def UNK on_nl on_ivar on_op nil on_nl end on_nl on_ignored_nl def UNK on_nl on_op UNK on_period UNK on_nl end on_nl # Indicates the extesion has already been registered.
def UNK on_nl on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def watch_element on_lparen path on_comma type on_comma representation on_op # Indicates whether or not an extension is being registered.
def watch_element on_lparen path on_comma type on_comma representation on_op nil on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_period UNK on_lparen # Builds a Watcher::Element from +type+ and +representation+ and # tells the Watcher::List for the current application to watch it # in the file located at +path+. # # If an extension is being registered, it also tells the list to # watch it in the file where the extension has been registered. # This prevents the duplication of the elements added by the # extension in its +registered+ method with every reload.
