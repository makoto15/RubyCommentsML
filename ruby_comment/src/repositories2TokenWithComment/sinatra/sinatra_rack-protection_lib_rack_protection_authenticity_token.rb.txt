UNK on_const on_op on_const on_nl on_const on_op UNK on_nl on_ignored_nl UNK on_symbeg UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_ignored_nl on_symbeg ## # Prevented attack:: CSRF # Supported browsers:: all # More infos:: http://en.wikipedia.org/wiki/Cross-site_request_forgery # # This middleware only accepts requests other than <tt>GET</tt>, # <tt>HEAD</tt>, <tt>OPTIONS</tt>, <tt>TRACE</tt> if their given access # token matches the token included in the session. # # It checks the <tt>X-CSRF-Token</tt> header and the <tt>POST</tt> form # data. # # Compatible with the {rack-csrf}[https://rubygems.org/gems/rack_csrf] gem. # # == Options # # [<tt>:authenticity_param</tt>] the name of the param that should contain # the token on a request. Default value: # <tt>"authenticity_token"</tt> # # == Example: Forms application # # To show what the AuthenticityToken does, this section includes a sample # program which shows two forms. One with, and one without a CSRF token # The one without CSRF token field will get a 403 Forbidden response. # # Install the gem, then run the program: # # gem install 'rack-protection' # ruby server.rb # # Here is <tt>server.rb</tt>: # # require 'rack/protection' # # app = Rack::Builder.app do # use Rack::Session::Cookie, secret: 'secret' # use Rack::Protection::AuthenticityToken # # run -> (env) do # [200, {}, [ # <<~EOS # <!DOCTYPE html> # <html lang="en"> # <head> # <meta charset="UTF-8" /> # <title>rack-protection minimal example</title> # </head> # <body> # <h1>Without Authenticity Token</h1> # <p>This takes you to <tt>Forbidden</tt></p> # <form action="" method="post"> # <input type="text" name="foo" /> # <input type="submit" /> # </form> # # <h1>With Authenticity Token</h1> # <p>This successfully takes you to back to this form.</p> # <form action="" method="post"> # <input type="hidden" name="authenticity_token" value="#{env['rack.session'][:csrf]}" /> # <input type="text" name="foo" /> # <input type="submit" /> # </form> # </body> # </html> # EOS # ]] # end # end # # Rack::Handler::WEBrick.run app # # == Example: Customize which POST parameter holds the token # # To customize the authenticity parameter for form data, use the # <tt>:authenticity_param</tt> option: # use Rack::Protection::AuthenticityToken, authenticity_param: 'your_token_param_name'
def UNK on_lparen session on_comma token on_rparen on_ignored_nl UNK UNK UNK token on_period UNK on_op token on_period UNK on_nl on_ignored_nl # Checks the client's masked token to see if it matches the # session token.
UNK UNK on_nl end on_nl on_ignored_nl on_ignored_nl UNK UNK on_lparen token on_rparen on_nl UNK token on_comma session on_nl on_ignored_nl UNK # encoded_masked_token is invalid Base64
on_ignored_nl UNK UNK on_lparen token on_rparen on_nl UNK token on_comma session on_nl on_ignored_nl UNK UNK on_lparen token on_rparen on_nl token # See if it's actually a masked token or not. We should be able # to handle any unmasked tokens that we've issued without error.
end on_nl end on_nl on_ignored_nl def UNK on_lparen token on_rparen on_ignored_nl token on_op UNK on_lparen token on_rparen on_nl UNK on_op # Token is malformed
def UNK on_lparen token on_rparen on_ignored_nl token on_op UNK on_lparen token on_rparen on_nl UNK on_op on_const on_period UNK on_lparen token # Creates a masked version of the authenticity token that varies # on each request. The masking is used to mitigate SSL attacks # like BREACH.
def UNK on_lparen masked_token on_rparen on_ignored_nl UNK on_op masked_token on_period UNK on_op UNK on_nl UNK on_op masked_token on_lbracket UNK on_op # Essentially the inverse of +mask_token+.
UNK on_op masked_token on_period UNK on_op UNK on_nl UNK on_op masked_token on_lbracket UNK on_op UNK on_rbracket on_nl UNK on_op masked_token # Split the token into the one-time pad and the encrypted # value and decrypt it
