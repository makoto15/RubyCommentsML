UNK on_const on_nl on_ignored_nl def UNK on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK UNK UNK on_comma UNK on_tstring_content # = Sinatra::ConfigFile # # <tt>Sinatra::ConfigFile</tt> is an extension that allows you to load the # application's configuration from YAML files. It automatically detects if # the files contain specific environment settings and it will use those # corresponding to the current one. # # You can access those options through +settings+ within the application. If # you try to get the value for a setting that hasn't been defined in the # config file for the current environment, you will get whatever it was set # to in the application. # # == Usage # # Once you have written your configurations to a YAML file you can tell the # extension to load them. See below for more information about how these # files are interpreted. # # For the examples, lets assume the following config.yml file: # # greeting: Welcome to my file configurable application # # === Classic Application # # require "sinatra" # require "sinatra/config_file" # # config_file 'path/to/config.yml' # # get '/' do # @greeting = settings.greeting # haml :index # end # # # The rest of your classic application code goes here... # # === Modular Application # # require "sinatra/base" # require "sinatra/config_file" # # class MyApp < Sinatra::Base # register Sinatra::ConfigFile # # config_file 'path/to/config.yml' # # get '/' do # @greeting = settings.greeting # haml :index # end # # # The rest of your modular application code goes here... # end # # === Config File Format # # In its most simple form this file is just a key-value list: # # foo: bar # something: 42 # nested: # a: 1 # b: 2 # # But it also can provide specific environment configuration. There are two # ways to do that: at the file level and at the settings level. # # At the settings level (e.g. in 'path/to/config.yml'): # # development: # foo: development # bar: bar # test: # foo: test # bar: bar # production: # foo: production # bar: bar # # Or at the file level: # # foo: # development: development # test: test # production: production # bar: bar # # In either case, <tt>settings.foo</tt> will return the environment name, and # <tt>settings.bar</tt> will return <tt>"bar"</tt>. # # If you wish to provide defaults that may be shared among all the # environments, this can be done by using a YAML alias, and then overwriting # values in environments where appropriate: # # default: &common_settings # foo: 'foo' # bar: 'bar' # # production: # <<: *common_settings # bar: 'baz' # override the default value #
def UNK on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK UNK UNK on_comma UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content # When the extension is registered sets the +environments+ setting to the # traditional environments: development, test and production.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK on_ignored_nl UNK # Loads the configuration from the YAML files whose +paths+ are passed as # arguments, filtering the settings for the current environment. Note that # these +paths+ can actually be globs.
def UNK on_lparen hash on_rparen on_ignored_nl UNK UNK on_lparen hash on_rparen UNK UNK on_lparen hash on_rparen on_nl on_ignored_nl hash on_period # Given a +hash+ containing application configuration it returns # settings applicable to the current environment. Note: It gives # precedence to environment settings defined at the root-level.
def UNK on_lparen hash on_rparen on_ignored_nl hash UNK UNK on_period UNK UNK on_op hash UNK UNK on_period UNK UNK on_op # Given a +hash+ returns the settings corresponding to the current # environment.
def UNK on_lparen hash on_rparen on_ignored_nl hash on_period UNK on_lparen on_const on_rparen on_op hash on_period UNK UNK on_op UNK on_comma # Returns true if supplied with a hash that has any recognized # +environments+ in its root keys.
