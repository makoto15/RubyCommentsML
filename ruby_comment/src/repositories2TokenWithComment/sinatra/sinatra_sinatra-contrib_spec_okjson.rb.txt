on_ignored_nl on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK UNK on_nl on_ignored_nl on_ignored_nl def UNK on_lparen s # Copyright 2011 Keith Rarick # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the "Software"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE.
on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK UNK on_nl on_ignored_nl on_ignored_nl def UNK on_lparen s on_rparen # See https://github.com/kr/okjson for updates.
UNK on_const on_nl UNK UNK on_nl on_ignored_nl on_ignored_nl def UNK on_lparen s on_rparen on_ignored_nl ts on_op UNK on_lparen s on_rparen # Some parts adapted from # http://golang.org/src/pkg/json/decode.go and # http://golang.org/src/pkg/utf8/utf8.go
def UNK on_lparen s on_rparen on_ignored_nl ts on_op UNK on_lparen s on_rparen on_nl v on_comma ts on_op UNK on_lparen ts # Decodes a json document in string s and # returns the corresponding ruby value. # String s must be valid UTF-8. If you have # a string in some other encoding, convert # it first. # # String values in the resulting structure # will be UTF-8.
def UNK on_lparen ts on_rparen on_ignored_nl if ts on_period length on_op on_int on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl # Parses a "json text" in the sense of RFC 4627. # Returns the parsed value and any trailing tokens. # Note: this is almost the same as valparse, # except that it does not accept atomic values.
def UNK on_lparen ts on_rparen on_ignored_nl if ts on_period length on_op on_int on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl # Parses a "value" in the sense of RFC 4627. # Returns the parsed value and any trailing tokens.
def UNK on_lparen ts on_rparen on_ignored_nl ts on_op eat on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma ts on_rparen on_nl obj on_op UNK # Parses an "object" in the sense of RFC 4627. # Returns the parsed value and any trailing tokens.
def UNK on_lparen ts on_rparen on_ignored_nl on_lparen typ on_comma UNK on_comma k on_rparen on_comma ts on_op ts on_lbracket on_int on_rbracket # Parses a "member" in the sense of RFC 4627. # Returns the parsed values and any trailing tokens.
def UNK on_lparen ts on_rparen on_ignored_nl ts on_op eat on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma ts on_rparen on_nl arr on_op on_lbracket # Parses an "array" in the sense of RFC 4627. # Returns the parsed value and any trailing tokens.
def UNK on_lparen s on_rparen on_ignored_nl ts on_op on_lbracket on_rbracket on_nl UNK s on_period length on_op on_int on_nl typ on_comma # Sans s and returns a list of json tokens, # excluding white space (as defined in RFC 4627).
def UNK on_lparen s on_rparen on_ignored_nl case s on_lbracket on_int on_rbracket on_nl when on_char then on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma # Scans the first token in s and # returns a 3-element list, or nil # if no such token exists. # # The first list element is one of # '{', '}', ':', ',', '[', ']', # :val, :str, and :space. # # The second element is the lexeme. # # The third element is the value of the # token for :val and :str, otherwise # it is the lexeme.
def UNK on_lparen q on_rparen on_ignored_nl q on_op q on_lbracket on_int on_op on_op on_int on_rbracket on_nl a on_op q on_period # Converts a quoted json string literal q into a UTF-8-encoded string. # The rules are different than for Ruby, so we cannot use eval. # Unquote will raise an error if q contains control characters.
r on_comma w on_op on_int on_comma on_int on_nl UNK r on_op q on_period length on_nl c on_op q on_lbracket r # allocate a big enough string
r on_op on_int on_nl end on_nl end on_nl end on_nl w on_op UNK on_lparen a on_comma w on_comma uchar on_rparen # A valid pair; consume.
a on_lbracket w on_rbracket on_op c on_nl r on_op on_int on_nl w on_op on_int on_nl end on_nl end on_nl a # Copy anything else byte-for-byte. # Valid UTF-8 will remain valid UTF-8. # Invalid UTF-8 will remain invalid UTF-8.
def UNK on_lparen a on_comma i on_comma u on_rparen on_ignored_nl case true on_nl when u on_op on_const on_nl a on_lbracket # Encodes unicode character u as UTF-8 # bytes in string a at position i. # Returns the number of bytes written.
def UNK on_lparen x on_rparen on_ignored_nl case x on_nl when on_const then UNK on_lparen x on_rparen on_nl when on_const then # Encodes x into a json text. It may contain only # Array, Hash, String, Numeric, true, false, nil. # (Note, this list excludes Symbol.) # X itself must be an Array or a Hash. # No other value can be encoded, and an error will # be raised if x contains any other value, such as # Nan, Infinity, Symbol, and Proc, or if a Hash key # is not a String. # Strings contained in x must be valid UTF-8.
if u on_op on_int on_nl t on_period print on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_lparen t on_comma u on_rparen # we add one more at the bottom of the loop
end on_nl end on_nl r on_op on_int on_nl end on_nl t on_period putc on_lparen on_char on_rparen on_nl t on_period UNK # invalid byte; skip it
def UNK on_lparen s on_comma i on_rparen on_ignored_nl UNK on_op s on_period length on_op i on_nl return on_lbracket on_const on_comma # Decodes unicode character u from UTF-8 # bytes in string s at position i. # Returns u and the number of bytes read.
if c0 on_op on_const on_nl return on_lbracket c0 on_comma on_int on_rbracket on_nl end on_nl on_ignored_nl return on_lbracket on_const on_comma on_int # 1-byte, 7-bit sequence?
return on_lbracket on_const on_comma on_int on_rbracket if c0 on_op on_const on_nl on_ignored_nl return on_lbracket on_const on_comma on_int on_rbracket if UNK # unexpected continuation byte?
return on_lbracket on_const on_comma on_int on_rbracket if UNK on_op on_int on_nl c1 on_op s on_lbracket i on_op on_int on_rbracket on_period # need continuation byte
if c0 on_op on_const on_nl u on_op on_lparen c0 on_op on_const on_rparen on_op on_int on_op on_lparen c1 on_op on_const on_rparen # 2-byte, 11-bit sequence?
return on_lbracket on_const on_comma on_int on_rbracket if UNK on_op on_int on_nl UNK on_op s on_lbracket i on_op on_int on_rbracket on_period # need second continuation byte
if c0 on_op on_const on_nl u on_op on_lparen c0 on_op on_const on_rparen on_op on_int on_op on_lparen c1 on_op on_const on_rparen # 3-byte, 16-bit sequence?
return on_lbracket on_const on_comma on_int on_rbracket if UNK on_op on_int on_nl UNK on_op s on_lbracket i on_op on_int on_rbracket on_period # need third continuation byte
if c0 on_op on_const on_nl u on_op on_lparen c0 on_op on_const on_rparen on_op on_int on_op on_lparen c1 on_op on_const on_rparen # 4-byte, 21-bit sequence?
on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op # 1000 0000
on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op # 1100 0000
on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op # 1110 0000
on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_lparen on_int on_op # 1111 0000
on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_lparen on_int on_op on_int on_rparen on_op # 1111 1000
on_const on_op on_int on_const on_op on_int on_const on_op on_int on_const on_op on_lparen on_int on_op on_int on_rparen on_op on_int on_nl on_const # 0011 1111
on_const on_op on_int on_const on_op on_int on_const on_op on_lparen on_int on_op on_int on_rparen on_op on_int on_nl on_const on_op on_lparen on_int # 0001 1111
on_const on_op on_int on_const on_op on_lparen on_int on_op on_int on_rparen on_op on_int on_nl on_const on_op on_lparen on_int on_op on_int on_rparen # 0000 1111
on_const on_op on_lparen on_int on_op on_int on_rparen on_op on_int on_nl on_const on_op on_lparen on_int on_op on_int on_rparen on_op on_int on_nl # 0000 0111
on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_const on_op on_int on_nl # unicode "replacement char"
