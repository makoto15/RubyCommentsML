on_ignored_nl UNK UNK UNK UNK on_nl UNK UNK UNK UNK on_nl UNK UNK UNK UNK on_nl on_ignored_nl UNK on_const on_nl # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK UNK on_ignored_nl UNK UNK UNK on_comma on_label UNK UNK on_nl end on_nl # Rescuable module adds support for easier exception handling.
def UNK on_lparen on_op UNK on_comma on_label UNK on_comma on_op UNK on_rparen on_ignored_nl UNK UNK on_nl if UNK on_nl UNK # Rescue exceptions raised in controller actions. # # <tt>rescue_from</tt> receives a series of exception classes or class # names, and a trailing <tt>:with</tt> option with the name of a method # or a Proc object to be called to handle them. Alternatively a block can # be given. # # Handlers that take one argument will be called with the exception, so # that the exception can be inspected when dealing with it. # # Handlers are inherited. They are searched from right to left, from # bottom to top, and up the hierarchy. The handler of the first class for # which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if # any. # # class ApplicationController < ActionController::Base # rescue_from User::NotAuthorized, with: :deny_access # self defined exception # rescue_from ActiveRecord::RecordInvalid, with: :show_errors # # rescue_from 'MyAppError::Base' do |exception| # render xml: exception, status: 500 # end # # private # def deny_access # ... # end # # def show_errors(exception) # exception.record.new_record? ? ... # end # end # # Exceptions raised inside exception handlers are not propagated up.
self on_period UNK on_op UNK UNK UNK on_comma UNK UNK UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen # Put the new handler at the end because the list is read in reverse.
def UNK on_lparen exception on_comma on_label self on_comma on_label UNK UNK on_rparen on_ignored_nl UNK on_op exception on_nl on_ignored_nl if UNK # Matches an exception to a handler based on the exception class. # # If no handler matches the exception, check for a handler matching the # (optional) exception.cause. If no handler matches the exception or its # cause, this returns +nil+, so you can deal with unhandled exceptions. # Be sure to re-raise unhandled exceptions if this is what you expect. # # begin # … # rescue => exception # rescue_with_handler(exception) || raise # end # # Returns the exception if it was handled and +nil+ if it was not.
UNK UNK on_op UNK on_lparen exception on_rparen on_nl UNK on_const on_nl UNK on_op UNK on_period UNK on_lparen UNK on_rparen on_nl #:nodoc:
UNK on_comma UNK on_op UNK on_period UNK on_period UNK UNK on_op class_or_name on_comma UNK on_op on_ignored_nl if klass on_op UNK # Handlers are in order of declaration but the most recently declared # is the highest priority match, so we search for matching handlers # in reverse.
UNK class_or_name on_nl UNK on_const on_nl class_or_name on_period UNK on_nl end on_nl else on_ignored_nl class_or_name on_nl end on_nl end on_nl # Try a lexical lookup first since we support # # class Super # rescue_from 'Error', with: … # end # # class Sub # class Error < StandardError; end # end # # so an Error raised in Sub will hit the 'Error' handler.
def UNK on_lparen exception on_rparen on_ignored_nl self on_period UNK on_period UNK exception on_comma on_label self on_nl end on_nl on_ignored_nl def # Delegates to the class method, but uses the instance as the subject for # rescue_from handlers (method calls, instance_exec blocks).
def UNK on_lparen exception on_rparen self on_period UNK on_period UNK exception on_comma on_label self on_nl end on_nl end on_nl end # Internal handler lookup. Delegates to class method. Some libraries call # this directly, so keeping it around for compatibility.
self on_period UNK on_period UNK exception on_comma on_label self on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP #:nodoc:
