on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK do on_ignored_nl UNK on_const on_op on_const on_nl UNK on_symbeg UNK on_comma on_label # Callbacks are code hooks that are run at key points in an object's life cycle. # The typical use case is to have a base class define a set of callbacks # relevant to the other functionality it supplies, so that subclasses can # install callbacks that enhance or modify the base functionality without # needing to override or redefine methods of the base class. # # Mixing in this module allows you to define the events in the object's # life cycle that will support callbacks (via +ClassMethods.define_callbacks+), # set the instance methods, procs, or callback objects to be called (via # +ClassMethods.set_callback+), and run the installed callbacks at the # appropriate times (via +run_callbacks+). # # By default callbacks are halted by throwing +:abort+. # See +ClassMethods.define_callbacks+ for details. # # Three kinds of callbacks are supported: before callbacks, run before a # certain event; after callbacks, run after the event; and around callbacks, # blocks that surround the event, triggering it when they yield. Callback code # can be contained in instance methods, procs or lambdas, or callback objects # that respond to certain predetermined methods. See +ClassMethods.set_callback+ # for details. # # class Record # include ActiveSupport::Callbacks # define_callbacks :save # # def save # run_callbacks :save do # puts "- save" # end # end # end # # class PersonRecord < Record # set_callback :save, :before, :saving_message # def saving_message # puts "saving..." # end # # set_callback :save, :after do |object| # puts "saved" # end # end # # person = PersonRecord.new # person.save # # Output: # saving... # - save # saved
def UNK on_lparen kind on_rparen on_ignored_nl callbacks on_op UNK on_lbracket kind on_period UNK on_rbracket on_nl on_ignored_nl if callbacks on_period UNK # Runs the callbacks for the given event. # # Calls the before and around callbacks in the order they were set, yields # the block (if given one), and then runs the after callbacks in reverse # order. # # If the callback chain was halted, returns +false+. Otherwise returns the # result of the block, +nil+ if no callbacks have been set, or +true+ # if callbacks have been set but no block is given. # # run_callbacks :save do # save # end # #-- # # As this method is used in many places, and often wraps large portions of # user code, it has an additional design goal of minimizing its impact on # the visible call stack. An exception from inside a :before or :after # callback can be as noisy as it likes -- but when control has passed # smoothly through and into the supplied block, we want as little evidence # as possible that we were here.
if next_sequence on_period UNK on_nl next_sequence on_period UNK on_lparen env on_rparen on_nl env on_period value on_op on_op env on_period halted # Common case: no 'around' callbacks defined
def UNK on_lparen filter on_rparen on_ignored_nl end on_nl on_ignored_nl UNK on_const class on_const on_nl def UNK on_lparen on_op block on_rparen # A hook invoked every time a before callback is halted. # This can be overridden in ActiveSupport::Callbacks implementors in order # to provide better debugging/logging.
class on_const on_nl def UNK on_lparen on_op block on_rparen on_ignored_nl on_ivar on_op block on_nl end on_nl def call on_lparen target # :nodoc:
def self on_period build on_lparen chain on_comma filter on_comma kind on_comma options on_rparen on_ignored_nl if filter on_period UNK on_lparen on_const #:nodoc:#
def UNK on_lparen callback_sequence on_rparen on_ignored_nl user_conditions on_op UNK on_nl user_callback on_op on_const on_period build on_lparen on_ivar on_comma self on_rparen # Wraps code with filter
class on_const def UNK on_lparen target on_comma method on_comma arguments on_comma block on_rparen on_ignored_nl on_ivar on_op target on_nl on_ivar on_op # A future invocation of user-supplied code (either as a callback, # or a condition filter).
def UNK on_lparen target on_comma method on_comma arguments on_comma block on_rparen on_ignored_nl on_ivar on_op target on_nl on_ivar on_op method on_nl # :nodoc:
def UNK on_lparen target on_comma value on_comma block on_rparen on_ignored_nl UNK on_op on_ivar on_period UNK on_lbrace on_op arg on_op on_ignored_nl # Return the parts needed to make this call, with the given # input values. # # Returns an array of the form: # # [target, block, method, *arguments] # # This array can be used as such: # # target.send(method, *arguments, &block) # # The actual invocation is left up to the caller to minimize # call stack pollution.
UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK do on_op target on_comma value on_comma on_op block on_op on_ignored_nl target # target, block, method, *arguments = result # target.send(method, *arguments, &block)
def UNK on_nl UNK do on_op target on_comma value on_comma on_op block on_op on_ignored_nl target on_comma block on_comma method on_comma # Return a lambda that will make this call when given the input # values.
def UNK on_nl UNK do on_op target on_comma value on_comma on_op block on_op on_ignored_nl target on_comma block on_comma method on_comma # Return a lambda that will make this call when given the input # values, but then return the boolean inverse of that result.
def self on_period build on_lparen filter on_comma callback on_rparen on_ignored_nl UNK filter on_nl when on_const on_nl new on_lparen nil on_comma # Filters support: # # Symbols:: A method to call. # Procs:: A proc to call with the object. # Objects:: An object with a <tt>before_foo</tt> method on it to call. # # All of these objects are converted into a CallTemplate and handled # the same after this point.
class on_const def UNK on_lparen UNK on_op nil on_comma UNK on_op nil on_comma user_conditions on_op nil on_rparen on_ignored_nl on_ivar on_op # Execute before and after filters in a sequence instead of # chaining them with nested lambda calls, see: # https://github.com/rails/rails/issues/18011
def UNK on_lparen UNK on_op nil on_comma UNK on_op nil on_comma user_conditions on_op nil on_rparen on_ignored_nl on_ivar on_op UNK on_nl # :nodoc:
UNK on_const on_nl on_ignored_nl UNK on_symbeg name on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen name on_comma UNK on_rparen on_ignored_nl #:nodoc:#
type on_op on_const on_period UNK on_lparen filters on_period UNK on_rparen on_op filters on_period UNK on_op on_symbeg before on_nl options on_op # :nodoc:
def UNK on_lparen name on_rparen on_lparen on_lbracket self on_rbracket on_op on_const on_op on_const on_period UNK on_lparen self on_rparen on_rparen on_period # This is used internally to append, prepend and skip callbacks to the # CallbackChain.
on_lparen on_lbracket self on_rbracket on_op on_const on_op on_const on_period UNK on_lparen self on_rparen on_rparen on_period UNK do on_op target on_op #:nodoc:
def UNK on_lparen name on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl type on_comma filters on_comma options on_op UNK on_lparen # Install a callback for the given event. # # set_callback :save, :before, :before_method # set_callback :save, :after, :after_method, if: :condition # set_callback :save, :around, ->(r, block) { stuff; result = block.call; stuff } # # The second argument indicates whether the callback is to be run +:before+, # +:after+, or +:around+ the event. If omitted, +:before+ is assumed. This # means the first example above can also be written as: # # set_callback :save, :before_method # # The callback can be specified as a symbol naming an instance method; as a # proc, lambda, or block; or as an object that responds to a certain method # determined by the <tt>:scope</tt> argument to +define_callbacks+. # # If a proc, lambda, or block is given, its body is evaluated in the context # of the current object. It can also optionally accept the current object as # an argument. # # Before and around callbacks are called in the order that they are set; # after callbacks are called in the reverse order. # # Around callbacks can access the return value from the event, if it # wasn't halted, from the +yield+ call. # # ===== Options # # * <tt>:if</tt> - A symbol or an array of symbols, each naming an instance # method or a proc; the callback will be called only when they all return # a true value. # # If a proc is given, its body is evaluated in the context of the # current object. It can also optionally accept the current object as # an argument. # * <tt>:unless</tt> - A symbol or an array of symbols, each naming an # instance method or a proc; the callback will be called only when they # all return a false value. # # If a proc is given, its body is evaluated in the context of the # current object. It can also optionally accept the current object as # an argument. # * <tt>:prepend</tt> - If +true+, the callback will be prepended to the # existing chain rather than appended.
def UNK on_lparen name on_comma on_op UNK on_comma on_op block on_rparen on_ignored_nl type on_comma filters on_comma options on_op UNK on_lparen # Skip a previously set callback. Like +set_callback+, <tt>:if</tt> or # <tt>:unless</tt> options may be passed in order to control when the # callback is skipped. # # class Writer < Person # skip_callback :validate, :before, :check_membership, if: -> { age > 18 } # end # # An <tt>ArgumentError</tt> will be raised if the callback has not # already been set (unless the <tt>:raise</tt> option is set to <tt>false</tt>).
def UNK on_lparen name on_rparen on_ignored_nl callbacks on_op UNK name on_nl on_ignored_nl on_const on_op on_const on_period UNK on_lparen self on_rparen # Remove all set callbacks for the given event.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl options on_op UNK on_period UNK on_nl on_ignored_nl UNK on_period each do on_op name # Define sets of events in the object life cycle that support callbacks. # # define_callbacks :validate # define_callbacks :initialize, :save, :destroy # # ===== Options # # * <tt>:terminator</tt> - Determines when a before filter will halt the # callback chain, preventing following before and around callbacks from # being called and the event from being triggered. # This should be a lambda to be executed. # The current object and the result lambda of the callback will be provided # to the terminator lambda. # # define_callbacks :validate, terminator: ->(target, result_lambda) { result_lambda.call == false } # # In this example, if any before validate callbacks returns +false+, # any successive before and around callback is not executed. # # The default terminator halts the chain when a callback throws +:abort+. # # * <tt>:skip_after_callbacks_if_terminated</tt> - Determines if after # callbacks should be terminated by the <tt>:terminator</tt> option. By # default after callbacks are executed no matter if callback chain was # terminated or not. This option has no effect if <tt>:terminator</tt> # option is set to +nil+. # # * <tt>:scope</tt> - Indicates which methods should be executed when an # object is used as a callback. # # class Audit # def before(caller) # puts 'Audit: before is called' # end # # def before_save(caller) # puts 'Audit: before_save is called' # end # end # # class Account # include ActiveSupport::Callbacks # # define_callbacks :save # set_callback :save, :before, Audit.new # # def save # run_callbacks :save do # puts 'save in main' # end # end # end # # In the above case whenever you save an account the method # <tt>Audit#before</tt> will be called. On the other hand # # define_callbacks :save, scope: [:kind, :name] # # would trigger <tt>Audit#before_save</tt> instead. That's constructed # by calling <tt>#{kind}_#{name}</tt> on the given instance. In this # case "kind" is "before" and "name" is "save". In this context +:kind+ # and +:name+ have special meanings: +:kind+ refers to the kind of # callback (before/after/around) and +:name+ refers to the method on # which callbacks are being defined. # # A declaration like # # define_callbacks :save, scope: [:name] # # would call <tt>Audit#save</tt>. # # ===== Notes # # +names+ passed to +define_callbacks+ must not end with # <tt>!</tt>, <tt>?</tt> or <tt>=</tt>. # # Calling +define_callbacks+ multiple times with the same +names+ will # overwrite previous callbacks registered with +set_callback+.
UNK on_lbracket name on_period UNK on_rbracket on_nl end on_nl on_ignored_nl def set_callbacks on_lparen name on_comma callbacks on_rparen self on_period UNK # :nodoc:
self on_period UNK on_op UNK on_period UNK on_lparen name on_period UNK on_op callbacks on_rparen on_nl end on_nl end on_nl end # :nodoc:
