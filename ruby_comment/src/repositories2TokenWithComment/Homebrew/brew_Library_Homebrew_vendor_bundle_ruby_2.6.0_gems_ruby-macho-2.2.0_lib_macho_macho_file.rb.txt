class on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_symbeg filename on_nl on_ignored_nl UNK on_symbeg options on_nl on_ignored_nl UNK on_symbeg endianness # Represents a Mach-O file, which contains a header and load commands # as well as binary executable instructions. Mach-O binaries are # architecture specific. # @see https://en.wikipedia.org/wiki/Mach-O # @see FatFile
UNK on_symbeg filename on_nl on_ignored_nl UNK on_symbeg options on_nl on_ignored_nl UNK on_symbeg endianness on_nl on_ignored_nl UNK on_symbeg header on_nl on_ignored_nl # @return [String, nil] the filename loaded from, or nil if loaded from a binary # string
UNK on_symbeg options on_nl on_ignored_nl UNK on_symbeg endianness on_nl on_ignored_nl UNK on_symbeg header on_nl on_ignored_nl UNK on_symbeg load_commands on_nl on_ignored_nl # @return [Hash] any parser options that the instance was created with
UNK on_symbeg endianness on_nl on_ignored_nl UNK on_symbeg header on_nl on_ignored_nl UNK on_symbeg load_commands on_nl on_ignored_nl def UNK on_period UNK on_lparen # @return [Symbol] the endianness of the file, :big or :little
UNK on_symbeg header on_nl on_ignored_nl UNK on_symbeg load_commands on_nl on_ignored_nl def UNK on_period UNK on_lparen UNK on_comma on_op opts on_rparen # @return [Headers::MachHeader] if the Mach-O is 32-bit # @return [Headers::MachHeader64] if the Mach-O is 64-bit
UNK on_symbeg load_commands on_nl on_ignored_nl def UNK on_period UNK on_lparen UNK on_comma on_op opts on_rparen on_ignored_nl UNK on_op UNK on_nl # @return [Array<LoadCommands::LoadCommand>] an array of the file's load # commands # @note load commands are provided in order of ascending offset.
def UNK on_period UNK on_lparen UNK on_comma on_op opts on_rparen on_ignored_nl UNK on_op UNK on_nl UNK on_period UNK on_lparen UNK # Creates a new instance from a binary string. # @param bin [String] a binary string containing raw Mach-O data # @param opts [Hash] options to control the parser with # @option opts [Boolean] :permissive whether to ignore unknown load commands # @return [MachOFile] a new MachOFile
def UNK on_lparen filename on_comma on_op opts on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg UNK filename UNK on_tstring_content on_tstring_end unless on_const # Creates a new instance from data read from the given filename. # @param filename [String] the Mach-O file to load from # @param opts [Hash] options to control the parser with # @option opts [Boolean] :permissive whether to ignore unknown load commands # @raise [ArgumentError] if the given file does not exist
def UNK on_lparen UNK on_comma opts on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op opts on_nl on_ivar on_op UNK on_nl # Initializes a new MachOFile instance from a binary string with the given options. # @see MachO::MachOFile.new_from_bin # @api private
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl UNK on_symbeg header on_comma on_symbeg magic on_comma on_symbeg ncmds on_comma on_symbeg sizeofcmds # The file's raw Mach-O data. # @return [String] the raw Mach-O data
UNK on_symbeg header on_comma on_symbeg magic on_comma on_symbeg ncmds on_comma on_symbeg sizeofcmds on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_ignored_nl # @!method magic # @return (see MachO::Headers::MachHeader#magic) # @!method ncmds # @return (see MachO::Headers::MachHeader#ncmds) # @!method sizeofcmds # @return (see MachO::Headers::MachHeader#sizeofcmds) # @!method flags # @return (see MachO::Headers::MachHeader#flags) # @!method object? # @return (see MachO::Headers::MachHeader#object?) # @!method executable? # @return (see MachO::Headers::MachHeader#executable?) # @!method fvmlib? # @return (see MachO::Headers::MachHeader#fvmlib?) # @!method core? # @return (see MachO::Headers::MachHeader#core?) # @!method preload? # @return (see MachO::Headers::MachHeader#preload?) # @!method dylib? # @return (see MachO::Headers::MachHeader#dylib?) # @!method dylinker? # @return (see MachO::Headers::MachHeader#dylinker?) # @!method bundle? # @return (see MachO::Headers::MachHeader#bundle?) # @!method dsym? # @return (see MachO::Headers::MachHeader#dsym?) # @!method kext? # @return (see MachO::Headers::MachHeader#kext?) # @!method magic32? # @return (see MachO::Headers::MachHeader#magic32?) # @!method magic64? # @return (see MachO::Headers::MachHeader#magic64?) # @!method alignment # @return (see MachO::Headers::MachHeader#alignment)
def UNK on_nl on_const on_op on_const on_lbracket magic on_rbracket on_nl end on_nl on_ignored_nl def filetype on_nl on_const on_op on_const on_lbracket # @return [String] a string representation of the file's magic number
def filetype on_nl on_const on_op on_const on_lbracket header on_period filetype on_rbracket on_nl end on_nl on_ignored_nl def cputype on_nl on_const on_op # @return [Symbol] a string representation of the Mach-O's filetype
def cputype on_nl on_const on_op on_const on_lbracket header on_period cputype on_rbracket on_nl end on_nl on_ignored_nl def cpusubtype on_nl on_const on_op # @return [Symbol] a symbol representation of the Mach-O's CPU type
def cpusubtype on_nl on_const on_op on_const on_lbracket header on_period cputype on_rbracket on_lbracket header on_period cpusubtype on_rbracket on_nl end on_nl on_ignored_nl # @return [Symbol] a symbol representation of the Mach-O's CPU subtype
def command on_lparen UNK on_rparen on_ignored_nl load_commands on_period UNK on_lbrace on_op lc on_op lc on_period UNK on_op UNK on_period UNK # All load commands of a given name. # @example # file.command("LC_LOAD_DYLIB") # file[:LC_LOAD_DYLIB] # @param [String, Symbol] name the load command ID # @return [Array<LoadCommands::LoadCommand>] an array of load commands # corresponding to `name`
def UNK on_lparen offset on_comma lc on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_op on_const # Inserts a load command at the given offset. # @param offset [Integer] the offset to insert at # @param lc [LoadCommands::LoadCommand] the load command to insert # @param options [Hash] # @option options [Boolean] :repopulate (true) whether or not to repopulate # the instance fields # @raise [OffsetInsertionError] if the offset is not in the load command region # @raise [HeaderPadError] if the new command exceeds the header pad buffer # @note Calling this method with an arbitrary offset in the load command # region **will leave the object in an inconsistent state**.
UNK on_lparen ncmds on_op on_int on_rparen on_nl UNK on_lparen new_sizeofcmds on_rparen on_nl on_ignored_nl on_ivar on_period UNK on_lparen offset on_comma cmd_raw # update Mach-O header fields to account for inserted load command
def UNK on_lparen old_lc on_comma new_lc on_rparen on_ignored_nl UNK on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen # Replace a load command with another command in the Mach-O, preserving location. # @param old_lc [LoadCommands::LoadCommand] the load command being replaced # @param new_lc [LoadCommands::LoadCommand] the load command being added # @return [void] # @raise [HeaderPadError] if the new command exceeds the header pad buffer # @see #insert_command # @note This is public, but methods like {#dylib_id=} should be preferred.
def UNK on_lparen lc on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_lparen header on_period class on_period bytesize on_op sizeofcmds # Appends a new load command to the Mach-O. # @param lc [LoadCommands::LoadCommand] the load command being added # @param options [Hash] # @option options [Boolean] :repopulate (true) whether or not to repopulate # the instance fields # @return [void] # @see #insert_command # @note This is public, but methods like {#add_rpath} should be preferred. # Setting `repopulate` to false **will leave the instance in an # inconsistent state** unless {#populate_fields} is called **immediately** # afterwards.
def UNK on_lparen lc on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl on_ivar on_period UNK on_lparen lc on_period UNK on_period offset # Delete a load command from the Mach-O. # @param lc [LoadCommands::LoadCommand] the load command being deleted # @param options [Hash] # @option options [Boolean] :repopulate (true) whether or not to repopulate # the instance fields # @return [void] # @note This is public, but methods like {#delete_rpath} should be preferred. # Setting `repopulate` to false **will leave the instance in an # inconsistent state** unless {#populate_fields} is called **immediately** # afterwards.
UNK on_lparen ncmds on_op on_int on_rparen on_nl UNK on_lparen sizeofcmds on_op lc on_period cmdsize on_rparen on_nl on_ignored_nl on_ivar on_period UNK # update Mach-O header fields to account for deleted load command
on_ivar on_period UNK on_lparen header on_period class on_period bytesize on_op sizeofcmds on_op lc on_period cmdsize on_comma on_const on_period UNK on_lparen # pad the space after the load commands to preserve offsets
def populate_fields on_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl load_commands on_period UNK # Populate the instance's fields with the raw Mach-O data. # @return [void] # @note This method is public, but should (almost) never need to be called. # The exception to this rule is when methods like {#add_command} and # {#delete_command} have been called with `repopulate = false`.
def UNK on_nl load_commands on_period UNK on_lbrace on_op lc on_op on_const on_op on_const on_period UNK on_lparen lc on_period UNK on_rparen # All load commands responsible for loading dylibs. # @return [Array<LoadCommands::DylibCommand>] an array of DylibCommands
def UNK on_nl if UNK on_nl command on_lparen on_symbeg on_const on_rparen on_nl UNK on_ignored_nl command on_lparen on_symbeg on_const on_rparen on_nl # All segment load commands in the Mach-O. # @return [Array<LoadCommands::SegmentCommand>] if the Mach-O is 32-bit # @return [Array<LoadCommands::SegmentCommand64>] if the Mach-O is 64-bit
def UNK on_nl UNK on_int if UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content on_tstring_end on_period UNK on_lparen cputype on_rparen # The segment alignment for the Mach-O. Guesses conservatively. # @return [Integer] the alignment, as a power of 2 # @note This is **not** the same as {#alignment}! # @note See `get_align` and `get_align_64` in `cctools/misc/lipo.c`
UNK on_int if UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content on_tstring_end on_period UNK on_lparen cputype on_rparen on_nl UNK on_int # special cases: 12 for x86/64/PPC/PP64, 14 for ARM/ARM64
align on_op UNK on_op on_int on_op on_int on_nl UNK on_period UNK on_period UNK UNK on_op UNK on_op on_ignored_nl align on_op # start with the smallest alignment, and work our way up
def UNK on_nl UNK unless UNK on_nl on_ignored_nl UNK on_op command on_lparen on_symbeg on_const on_rparen on_period UNK on_nl on_ignored_nl UNK # The Mach-O's dylib ID, or `nil` if not a dylib. # @example # file.dylib_id # => 'libBar.dylib' # @return [String, nil] the Mach-O's dylib ID
def UNK on_lparen UNK on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end unless UNK on_period # Changes the Mach-O's dylib ID to `new_id`. Does nothing if not a dylib. # @example # file.change_dylib_id("libFoo.dylib") # @param new_id [String] the dylib's new ID # @param _options [Hash] # @return [void] # @raise [ArgumentError] if `new_id` is not a String # @note `_options` is currently unused and is provided for signature # compatibility with {MachO::FatFile#change_dylib_id}
def UNK on_nl UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_lparen on_op on_symbeg to_s on_rparen on_period UNK # All shared libraries linked to the Mach-O. # @return [Array<String>] an array of all shared libraries
UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_lparen on_op on_symbeg to_s on_rparen on_period UNK on_nl end on_nl # Some linkers produce multiple `LC_LOAD_DYLIB` load commands for the same # library, but at this point we're really only interested in a list of # unique libraries this Mach-O file links to, thus: `uniq`. (This is also # for consistency with `FatFile` that merges this list across all archs.)
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl old_lc on_op UNK on_period UNK on_lbrace on_op # Changes the shared library `old_name` to `new_name` # @example # file.change_install_name("abc.dylib", "def.dylib") # @param old_name [String] the shared library's old name # @param new_name [String] the shared library's new name # @param _options [Hash] # @return [void] # @raise [DylibUnknownError] if no shared library has the old name # @note `_options` is currently unused and is provided for signature # compatibility with {MachO::FatFile#change_install_name}
def UNK on_nl command on_lparen on_symbeg on_const on_rparen on_period UNK on_lparen on_op on_symbeg path on_rparen on_period UNK on_lparen on_op on_symbeg # All runtime paths searched by the dynamic linker for the Mach-O. # @return [Array<String>] an array of all runtime paths
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl old_lc on_op command on_lparen on_symbeg on_const on_rparen # Changes the runtime path `old_path` to `new_path` # @example # file.change_rpath("/usr/lib", "/usr/local/lib") # @param old_path [String] the old runtime path # @param new_path [String] the new runtime path # @param _options [Hash] # @return [void] # @raise [RpathUnknownError] if no such old runtime path exists # @raise [RpathExistsError] if the new runtime path already exists # @note `_options` is currently unused and is provided for signature # compatibility with {MachO::FatFile#change_rpath}
def UNK on_lparen path on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl raise on_const on_comma path if UNK on_period UNK on_lparen # Add the given runtime path to the Mach-O. # @example # file.rpaths # => ["/lib"] # file.add_rpath("/usr/lib") # file.rpaths # => ["/lib", "/usr/lib"] # @param path [String] the new runtime path # @param _options [Hash] # @return [void] # @raise [RpathExistsError] if the runtime path already exists # @note `_options` is currently unused and is provided for signature # compatibility with {MachO::FatFile#add_rpath}
def UNK on_lparen path on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op command on_lparen on_symbeg on_const on_rparen on_period UNK # Delete the given runtime path from the Mach-O. # @example # file.rpaths # => ["/lib"] # file.delete_rpath("/lib") # file.rpaths # => [] # @param path [String] the runtime path to delete # @param _options [Hash] # @return void # @raise [RpathUnknownError] if no such runtime path exists # @note `_options` is currently unused and is provided for signature # compatibility with {MachO::FatFile#delete_rpath}
UNK on_period UNK on_lbrace on_op UNK on_op UNK on_lparen UNK on_comma on_symbeg UNK on_op UNK on_rparen on_rbrace on_nl on_ignored_nl populate_fields # delete the commands in reverse order, offset descending. this # allows us to defer (expensive) field population until the very end
def UNK on_lparen filename on_rparen on_ignored_nl on_const on_period UNK on_lparen filename on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace on_op UNK on_op # Write all Mach-O data to the given filename. # @param filename [String] the file to write to # @return [void]
def UNK on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end if on_ivar on_period UNK on_nl on_ignored_nl on_const on_period UNK on_lparen on_ivar # Write all Mach-O data to the file used to initialize the instance. # @return [void] # @raise [MachOError] if the instance was initialized without a file # @note Overwrites all data in the file!
def UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op header on_period UNK on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op load_commands on_period # @return [Hash] a hash representation of this {MachOFile}
def UNK on_nl raise on_const if on_ivar on_period UNK on_op on_int on_nl on_ignored_nl magic on_op UNK on_nl UNK on_op on_const # The file's Mach-O header structure. # @return [Headers::MachHeader] if the Mach-O is 32-bit # @return [Headers::MachHeader64] if the Mach-O is 64-bit # @raise [TruncatedFileError] if the file is too small to have a valid header # @api private
raise on_const if on_ivar on_period UNK on_op on_int on_nl on_ignored_nl magic on_op UNK on_nl UNK on_op on_const on_period UNK on_lparen # the smallest Mach-O header is 28 bytes
def UNK on_nl magic on_op on_ivar on_lbracket on_int on_op on_int on_rbracket on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period UNK # Read just the file's magic number and check its validity. # @return [Integer] the magic # @raise [MagicError] if the magic is not valid Mach-O magic # @raise [FatBinaryError] if the magic is for a Fat file # @api private
def UNK on_lparen cputype on_rparen on_ignored_nl raise on_const on_comma cputype unless on_const on_op on_const on_period UNK on_lparen cputype on_rparen on_nl # Check the file's CPU type. # @param cputype [Integer] the CPU type # @raise [CPUTypeError] if the CPU type is unknown # @api private
def UNK on_lparen cputype on_comma cpusubtype on_rparen on_ignored_nl raise on_const on_period UNK on_lparen cputype on_comma cpusubtype on_rparen unless on_const on_op # Check the file's CPU type/subtype pair. # @param cpusubtype [Integer] the CPU subtype # @raise [CPUSubtypeError] if the CPU sub-type is unknown # @api private
raise on_const on_period UNK on_lparen cputype on_comma cpusubtype on_rparen unless on_const on_op on_const on_lbracket cputype on_rbracket on_period UNK on_lparen cpusubtype # Only check sub-type w/o capability bits (see `populate_mach_header`).
def UNK on_lparen filetype on_rparen on_ignored_nl raise on_const on_comma filetype unless on_const on_op on_const on_period UNK on_lparen filetype on_rparen on_nl # Check the file's type. # @param filetype [Integer] the file type # @raise [FiletypeError] if the file type is unknown # @api private
def UNK on_nl UNK on_op options on_period UNK on_lparen on_symbeg UNK on_comma UNK on_rparen on_nl offset on_op header on_period class # All load commands in the file. # @return [Array<LoadCommands::LoadCommand>] an array of load commands # @raise [LoadCommandError] if an unknown load command is encountered # @api private
UNK on_op if on_lparen UNK on_op on_const on_op on_const on_lbracket UNK on_rbracket on_rparen on_nl on_const on_period UNK UNK on_nl UNK # If we're here, then either cmd_sym represents a valid load # command *or* we're in permissive mode.
def UNK on_nl offset on_op on_ivar on_period UNK on_nl on_ignored_nl UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_period # The low file offset (offset to first section data). # @return [Integer] the offset # @api private
def UNK on_lparen ncmds on_rparen on_ignored_nl fmt on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma endianness on_rparen on_nl UNK # Updates the number of load commands in the raw data. # @param ncmds [Integer] the new number of commands # @return [void] # @api private
def UNK on_lparen UNK on_rparen on_ignored_nl fmt on_op on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma endianness on_rparen on_nl UNK # Updates the size of all load commands in the raw data. # @param size [Integer] the new size, in bytes # @return [void] # @api private
