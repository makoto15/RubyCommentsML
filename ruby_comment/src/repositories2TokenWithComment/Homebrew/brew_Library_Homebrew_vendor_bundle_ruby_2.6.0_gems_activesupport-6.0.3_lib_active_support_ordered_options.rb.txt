on_ignored_nl UNK UNK UNK UNK on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK UNK UNK on_comma UNK # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK UNK UNK on_comma UNK on_op UNK UNK UNK on_ignored_nl def on_op on_lparen UNK on_comma # Usually key value pairs are handled something like this: # # h = {} # h[:boy] = 'John' # h[:girl] = 'Mary' # h[:boy] # => 'John' # h[:girl] # => 'Mary' # h[:dog] # => nil # # Using +OrderedOptions+, the above code could be reduced to: # # h = ActiveSupport::OrderedOptions.new # h.boy = 'John' # h.girl = 'Mary' # h.boy # => 'John' # h.girl # => 'Mary' # h.dog # => nil # # To raise an exception when the value is blank, append a # bang to the key name, like: # # h.dog! # => raises KeyError: :dog is blank #
UNK UNK UNK on_ignored_nl def on_op on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_lparen UNK on_period UNK on_comma UNK on_rparen # preserve the original #[] method
on_ignored_nl def on_op on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_lparen UNK on_period UNK on_comma UNK on_rparen on_nl end on_nl # make it protected
UNK on_const on_op on_const on_nl def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl UNK UNK on_period UNK on_lparen on_const on_rparen # +InheritableOptions+ provides a constructor to build an +OrderedOptions+ # hash inherited from another hash. # # Use this if you already have some hash and you want to create a new one based on it. # # h = ActiveSupport::InheritableOptions.new({ girl: 'Mary', boy: 'John' }) # h.girl # => 'Mary' # h.boy # => 'John'
UNK on_lparen on_rparen UNK on_op UNK on_comma UNK on_op UNK on_period UNK on_lparen UNK on_rparen UNK on_nl UNK UNK on_nl # use the faster _get when dealing with OrderedOptions
