UNK on_const on_op on_const on_nl on_ignored_nl on_ignored_nl on_const on_op on_lbracket on_rbracket on_nl on_const on_op on_const on_period UNK on_nl on_const on_op # @!visibility private # @!macro internal_implementation_note
on_ignored_nl on_const on_op on_lbracket on_rbracket on_nl on_const on_op on_const on_period UNK on_nl on_const on_op UNK UNK UNK on_op UNK on_nl # Each thread has a (lazily initialized) array of thread-local variable values # Each time a new thread-local var is created, we allocate an "index" for it # For example, if the allocated index is 1, that means slot #1 in EVERY # thread's thread-local array will be used for the value of that TLV # # The good thing about using a per-THREAD structure to hold values, rather # than a per-TLV structure, is that no synchronization is needed when # reading and writing those values (since the structure is only ever # accessed by a single thread) # # Of course, when a TLV is GC'd, 1) we need to recover its index for use # by other new TLVs (otherwise the thread-local arrays could get bigger # and bigger with time), and 2) we need to null out all the references # held in the now-unused slots (both to avoid blocking GC of those objects, # and also to prevent "stale" values from being passed on to a new TLV # when the index is reused) # Because we need to null out freed slots, we need to keep references to # ALL the thread-local arrays -- ARRAYS is for that # But when a Thread is GC'd, we need to drop the reference to its thread-local # array, so we don't leak memory
on_const on_op on_lbracket on_rbracket on_nl on_const on_op on_const on_period UNK on_nl on_const on_op UNK UNK UNK on_op UNK on_nl on_const # @!visibility private
UNK on_op UNK on_nl on_const on_op on_const on_period UNK on_nl on_const on_op on_const on_period UNK UNK on_ignored_nl UNK UNK on_nl # used as a hash set # noinspection RubyClassVariableUsageInspection
on_const on_period UNK UNK on_op array on_op on_ignored_nl array on_lbracket UNK on_rbracket on_op UNK on_nl end on_nl end on_nl UNK # The cost of GC'ing a TLV is linear in the number of threads using TLVs # But that is natural! More threads means more storage is used per TLV # So naturally more CPU time is required to free more storage
on_const on_period UNK on_lparen UNK on_rparen on_nl end on_nl end on_nl end on_nl end on_nl on_ignored_nl UNK on_symbeg on_const on_comma # The thread which used this thread-local array is now gone # So don't hold onto a reference to the array (thus blocking GC)
def value on_nl if on_lparen array on_op UNK on_rparen on_nl value on_op array on_lbracket on_ivar on_rbracket on_nl if value on_period # @!macro thread_local_var_method_get
def UNK on_lparen value on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_nl UNK on_lparen array on_op UNK on_lparen UNK on_rparen # @!macro thread_local_var_method_set
UNK on_lparen array on_op UNK on_lparen UNK on_rparen on_rparen on_nl array on_op UNK on_lparen on_lbracket on_rbracket on_comma UNK on_rparen on_nl # We could keep the thread-local arrays in a hash, keyed by Thread # But why? That would require locking # Using Ruby's built-in thread-local storage is faster
def UNK on_nl on_ivar on_op on_const on_period UNK UNK on_ignored_nl on_const on_period UNK on_op UNK on_ignored_nl UNK on_op UNK on_nl # @!visibility private # noinspection RubyClassVariableUsageInspection
def UNK on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK on_const on_period UNK on_lbracket on_symbeg UNK on_comma UNK on_rbracket UNK # @!visibility private
UNK UNK on_const on_period UNK on_lbracket on_symbeg UNK on_comma UNK on_rbracket UNK on_nl end on_nl on_ignored_nl def UNK on_period UNK # avoid error: can't be called from trap context
def UNK on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK on_const on_period UNK on_lbracket on_symbeg UNK on_comma UNK on_rbracket UNK # @!visibility private
UNK UNK on_const on_period UNK on_lbracket on_symbeg UNK on_comma UNK on_rbracket UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl if # avoid error: can't be called from trap context
def UNK on_lparen thread on_rparen on_ignored_nl if on_lparen array on_op UNK on_lparen thread on_rparen on_rparen on_nl value on_op array on_lbracket # This exists only for use in testing # @!visibility private
def UNK on_nl if on_ivar on_nl UNK UNK UNK UNK on_nl else on_ignored_nl on_ivar on_nl end on_nl end on_nl end # @!visibility private
