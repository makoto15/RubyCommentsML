on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const UNK on_const on_nl on_const UNK UNK UNK UNK # frozen_string_literal: true
UNK on_const UNK on_const on_nl on_const UNK UNK UNK UNK on_nl on_ignored_nl on_ignored_nl UNK UNK UNK UNK UNK on_nl UNK # This cop identifies uses of `Range#include?`, which iterates over each # item in a `Range` to see if a specified item is there. In contrast, # `Range#cover?` simply compares the target item with the beginning and # end points of the `Range`. In a great majority of cases, this is what # is wanted. # # This cop is `Safe: false` by default because `Range#include?` and # `Range#cover?` are not equivalent behaviour. # # @example # # bad # ('a'..'z').include?('b') # => true # # # good # ('a'..'z').cover?('b') # => true # # # Example of a case where `Range#cover?` may not provide # # the desired result: # # ('a'..'z').cover?('yellow') # => true
on_ignored_nl UNK UNK UNK UNK UNK on_nl UNK UNK on_ignored_nl UNK UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK UNK on_lparen # TODO: If we traced out assignments of variables to their uses, we # might pick up on a few more instances of this issue # Right now, we only detect direct calls on a Range literal # (We don't even catch it if the Range is in double parens)
