on_ignored_nl UNK on_const on_nl on_const on_op on_const on_period UNK on_nl UNK on_symbeg on_const on_nl on_ignored_nl on_ignored_nl on_ignored_nl UNK on_symbeg UNK # frozen_string_literal: true
on_ignored_nl on_ignored_nl UNK on_symbeg UNK on_symbeg sum on_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def sum on_lparen identity on_op UNK # Enumerable#sum was added in Ruby 2.4, but it only works with Numeric elements # when we omit an identity.
on_ignored_nl UNK on_symbeg UNK on_symbeg sum on_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def sum on_lparen identity on_op UNK UNK # :stopdoc:
UNK on_symbeg UNK on_symbeg sum on_nl UNK on_symbeg UNK on_nl on_ignored_nl on_ignored_nl def sum on_lparen identity on_op UNK UNK on_op # We can't use Refinements here because Refinements with Module which will be prepended # doesn't work well https://bugs.ruby-lang.org/issues/13446
on_ignored_nl def sum on_lparen identity on_op UNK UNK on_op UNK on_rparen on_ignored_nl if identity on_nl UNK on_lparen identity UNK on_op # :startdoc:
def sum on_lparen identity on_op UNK UNK on_op UNK on_rparen on_ignored_nl if identity on_nl UNK on_lparen identity UNK on_op UNK # Calculates a sum from the elements. # # payments.sum { |p| p.price * p.tax_rate } # payments.sum(&:price) # # The latter is a shortcut for: # # payments.inject(0) { |sum, p| sum + p.price } # # It can also calculate the sum without the use of a block. # # [5, 15, 10].sum # => 30 # ['foo', 'bar'].sum # => "foobar" # [[1, 2], [3, 1, 5]].sum # => [1, 2, 3, 1, 5] # # The default sum of an empty list is zero. You can override this default: # # [].sum(Payment.new(0)) { |i| i.amount } # => Payment.new(0)
def UNK on_nl if UNK on_nl result on_op on_lbrace on_rbrace on_nl UNK on_lbrace on_op elem on_op result UNK UNK on_lparen # Convert an enumerable to a hash keying it by the block return value. # # people.index_by(&:login) # # => { "nextangle" => <Person ...>, "chade-" => <Person ...>, ...} # # people.index_by { |person| "#{person.first_name} #{person.last_name}" } # # => { "Chade- Fowlersburg-e" => <Person ...>, "David Heinemeier Hansson" => <Person ...>, ...}
def UNK on_lparen UNK on_op on_const on_rparen on_ignored_nl if UNK on_nl result on_op on_lbrace on_rbrace on_nl UNK on_lbrace on_op elem # Convert an enumerable to a hash keying it with the enumerable items and with the values returned in the block. # # post = Post.new(title: "hey there", body: "what's up?") # # %i( title body ).index_with { |attr_name| post.public_send(attr_name) } # # => { title: "hey there", body: "what's up?" }
def UNK on_nl UNK on_op on_int on_nl if UNK on_nl UNK UNK on_op element on_op on_ignored_nl UNK on_op on_int if # Returns +true+ if the enumerable has more than 1 element. Functionally # equivalent to <tt>enum.to_a.size > 1</tt>. Can be called with a block too, # much like any?, so <tt>people.many? { |p| p.age > 26 }</tt> returns +true+ # if more than one person is over 26.
def UNK on_lparen on_op elements on_rparen on_ignored_nl UNK on_period UNK on_lparen on_op elements on_rparen on_nl end on_nl on_ignored_nl def UNK # Returns a new array that includes the passed elements. # # [ 1, 2, 3 ].including(4, 5) # # => [ 1, 2, 3, 4, 5 ] # # ["David", "Rafael"].including %w[ Aaron Todd ] # # => ["David", "Rafael", "Aaron", "Todd"]
def UNK on_lparen UNK on_rparen on_ignored_nl on_op UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen on_op elements # The negative of the <tt>Enumerable#include?</tt>. Returns +true+ if the # collection does not include the object.
def UNK on_lparen on_op elements on_rparen on_ignored_nl elements on_period UNK on_lparen on_int on_rparen on_nl UNK on_lbrace on_op element on_op elements # Returns a copy of the enumerable excluding the specified elements. # # ["David", "Rafael", "Aaron", "Todd"].excluding "Aaron", "Todd" # # => ["David", "Rafael"] # # ["David", "Rafael", "Aaron", "Todd"].excluding %w[ Aaron Todd ] # # => ["David", "Rafael"] # # {foo: 1, bar: 2, baz: 3}.excluding :bar # # => {foo: 1, baz: 3}
def UNK on_lparen on_op elements on_rparen on_ignored_nl UNK on_lparen on_op elements on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen on_op # Alias for #excluding.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl if UNK on_period UNK on_nl UNK on_lbrace on_op element on_op UNK on_period UNK # Convert an enumerable to an array based on the given key. # # [{ name: "David" }, { name: "Rafael" }, { name: "Aaron" }].pluck(:name) # # => ["David", "Rafael", "Aaron"] # # [{ id: 1, name: "David" }, { id: 2, name: "Rafael" }].pluck(:id, :name) # # => [[1, "David"], [2, "Rafael"]]
def sum on_lparen identity on_op UNK on_rparen on_ignored_nl if UNK on_op on_op on_lparen first on_period UNK on_lparen on_const on_rparen on_op #:nodoc: # Optimize range sum to use arithmetic progression if a block is not given and # we have a range of numeric values.
UNK on_const on_period UNK on_lbrace on_ignored_nl UNK on_const UNK on_ignored_nl UNK on_symbeg UNK on_symbeg sum on_nl end on_nl on_rbrace on_nl # Using Refinements here in order not to expose our internal method
def sum on_lparen UNK on_op UNK UNK on_op UNK on_rparen on_ignored_nl if UNK on_period UNK on_lparen on_const on_rparen on_op first #:nodoc: # Array#sum was added in Ruby 2.4 but it only works with Numeric elements.
