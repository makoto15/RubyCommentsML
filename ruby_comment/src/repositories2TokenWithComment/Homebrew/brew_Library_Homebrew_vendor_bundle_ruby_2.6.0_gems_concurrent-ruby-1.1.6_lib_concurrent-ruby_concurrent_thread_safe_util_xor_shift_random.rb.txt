UNK on_const on_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK on_const on_nl UNK UNK on_nl on_const on_op on_const on_op on_int on_nl # @!visibility private
UNK on_const on_nl on_ignored_nl UNK on_const on_nl UNK UNK on_nl on_const on_op on_const on_op on_int on_nl on_ignored_nl UNK UNK on_nl # @!visibility private
UNK on_const on_nl UNK UNK on_nl on_const on_op on_const on_op on_int on_nl on_ignored_nl UNK UNK on_nl on_const UNK UNK UNK # A xorshift random number (positive +Fixnum+s) generator, provides # reasonably cheap way to generate thread local random numbers without # contending for the global +Kernel.rand+. # # Usage: # x = XorShiftRandom.get # uses Kernel.rand to generate an initial seed # while true # if (x = XorShiftRandom.xorshift).odd? # thread-localy generate a next random number # do_something_at_random # end # end
UNK UNK on_nl on_const UNK UNK UNK on_const UNK on_op on_int end on_nl on_ignored_nl UNK on_int UNK UNK on_op on_int # Generates an initial non-zero positive +Fixnum+ via +Kernel.rand+.
end on_nl on_ignored_nl UNK on_int UNK UNK on_op on_int on_nl UNK UNK UNK x UNK on_ignored_nl x on_op x on_op # 0 can't be xorshifted
UNK on_int UNK UNK on_op on_int on_nl UNK UNK UNK x UNK on_ignored_nl x on_op x on_op on_int on_nl x # xorshift based on: http://www.jstatsoft.org/v08/i14/paper
UNK UNK UNK x UNK on_ignored_nl x on_op x on_op on_int on_nl x on_op UNK x on_op on_int UNK on_op # using the "yˆ=y>>a; yˆ=y<<b; yˆ=y>>c;" transform with the (a,b,c) tuple with values (3,1,14) to minimise Bignum overflows
x on_op x on_op on_int on_nl end on_nl UNK on_ignored_nl UNK UNK UNK x UNK on_ignored_nl x on_op x on_op # cut-off Bignum overflow
UNK UNK UNK x UNK on_ignored_nl x on_op x on_op on_int on_nl x on_op UNK x on_op on_int UNK on_op # using the "yˆ=y>>a; yˆ=y<<b; yˆ=y>>c;" transform with the (a,b,c) tuple with values (1,1,54) to minimise Bignum overflows
x on_op x on_op on_int on_nl end on_nl end on_nl end on_nl end on_nl end on_nl end on_nl EMP EMP # cut-off Bignum overflow
