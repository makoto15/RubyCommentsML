on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period freeze on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period freeze on_nl on_const on_op on_qwords_beg on_words_sep # locale-specific directories have the form language[_territory][.codeset][@modifier]
on_const on_op on_lparen on_const on_op on_lbracket on_ignored_nl on_const on_comma on_ignored_nl on_rbracket on_period UNK on_period UNK on_rparen on_period freeze on_nl on_const # Keep relatively in sync with # https://github.com/Homebrew/install/blob/master/install
on_const on_op on_qwords_beg on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep # These paths relative to the keg's share directory should always be real # directories in the prefix, never symlinks.
def self on_period UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period map # Given an array of kegs, this method will try to find some other kegs # that depend on them. If it does, it returns: # # - some kegs in the passed array that have installed dependents # - some installed dependents of those kegs. # # If it doesn't, it returns nil. # # Note that nil will be returned if the only installed dependents # in the passed kegs are other kegs in the array. # # For efficiency, we don't bother trying to get complete data.
f on_op keg on_period UNK on_nl UNK on_op f on_nl on_lbracket f on_period name on_comma f on_period tap on_rbracket on_nl # First, attempt to resolve the keg to a formula # to get up-to-date name and tap information.
on_lbracket keg on_period name on_comma keg on_period UNK on_period tap on_rbracket on_nl end on_nl on_ignored_nl UNK on_op on_const on_period new # If the formula for the keg can't be found, # fall back to the information in the tab.
UNK on_op on_const on_period UNK on_op UNK on_nl on_ignored_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_op UNK # Don't include dependencies of kegs that were in the given array.
def self on_period UNK on_lparen path on_rparen on_ignored_nl path on_op path on_period realpath on_nl UNK path on_period UNK on_nl return # if path is a file in a keg then this will return the containing Keg object
end on_nl raise on_const on_comma on_tstring_beg on_embexpr_beg path on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def self on_period UNK on_nl # realpath() prevents root? failing
UNK on_nl end on_nl on_ignored_nl if tap on_nl UNK on_op UNK on_op tap on_period UNK on_nl on_const on_period UNK UNK # If the formula can't be found, just ignore aliases for now.
next if a on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl on_ignored_nl alias_symlink on_op UNK on_op a on_nl if alias_symlink # versioned aliases are handled below
next unless dst on_period symlink? on_op src on_op dst on_period resolved_path on_nl on_ignored_nl if mode on_period dry_run on_nl puts dst # check whether the file to be unlinked is from the current keg first
dir on_op path on_op on_tstring_beg on_tstring_content on_tstring_end on_nl dir on_period directory? on_op dir on_period children on_period UNK on_lbrace on_op f # Check for non completion functions (i.e. files not started with an underscore), # since those can be checked separately
link_dir on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma mode on_rparen on_lbrace on_symbeg mkpath on_rbrace on_nl link_dir on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma mode # yeah indeed, you have to force anything you need in the main tree into # these dirs REMEMBER that *NOT* everything needs to be in the main tree
when on_regexp_beg on_tstring_content on_regexp_end then on_symbeg mkpath on_nl when on_regexp_beg on_tstring_content on_regexp_end then on_symbeg mkpath on_nl when on_regexp_beg on_tstring_content on_regexp_end # all icons subfolders should also mkpath
when on_regexp_beg on_tstring_content on_regexp_end then on_symbeg mkpath on_nl when on_regexp_beg on_tstring_content on_regexp_end then on_symbeg mkpath on_nl when on_op on_const then # Lua, Lua51, Lua53 all need the same handling.
when on_tstring_beg on_tstring_content on_tstring_end then on_symbeg mkpath on_nl when on_tstring_beg on_tstring_content on_tstring_end then on_symbeg mkpath on_nl when on_tstring_beg on_tstring_content on_tstring_end # pkg-config database gets explicitly created
when on_tstring_beg on_tstring_content on_tstring_end then on_symbeg mkpath on_nl when on_tstring_beg on_tstring_content on_tstring_end then on_symbeg mkpath on_nl when on_regexp_beg on_tstring_content on_regexp_end # cmake database gets explicitly created
when on_tstring_beg on_tstring_content on_tstring_end then on_symbeg mkpath on_nl when on_regexp_beg on_tstring_content on_regexp_end then on_symbeg mkpath on_nl when on_tstring_beg on_tstring_content on_tstring_end # lib/language folders also get explicitly created
else on_symbeg UNK on_nl end on_nl end on_nl on_ignored_nl link_dir on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma mode on_rparen do on_op relative_path # Everything else is symlinked to the cellar
if relative_path on_period to_s on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl on_symbeg mkpath on_nl else on_ignored_nl on_symbeg UNK on_nl # Frameworks contain symlinks pointing into a subdir, so we have to use # the :link strategy. However, for Foo.framework and # Foo.framework/Versions we have to use :mkpath so that multiple formulae # can link their versions into it and `brew [un]link` works.
on_ignored_nl UNK on_ignored_nl UNK on_op src on_period UNK on_nl rescue on_const on_op on_const on_nl dst on_period unlink unless mode on_period # src itself may be a symlink, so check lstat to ensure we are dealing with # a directory, and not a symlink pointing at a directory (which needs to be # treated as a file). In other words, we only want to resolve one symlink.
dst on_period unlink unless mode on_period dry_run on_nl return on_nl end on_nl on_ignored_nl return unless UNK on_period directory? on_nl on_ignored_nl # dst is a broken symlink, so remove it.
if mode on_period dry_run on_op mode on_period UNK on_nl if dst on_period symlink? on_nl puts on_tstring_beg on_embexpr_beg dst on_embexpr_end on_tstring_content # cf. git-clean -n: list files to delete, don't really link or delete
if mode on_period dry_run on_nl puts dst on_nl return on_nl end on_nl on_ignored_nl dst on_period delete if mode on_period UNK # list all link targets
def link_dir on_lparen UNK on_comma mode on_rparen on_ignored_nl root on_op path on_op UNK on_nl return unless root on_period exist? on_nl # symlinks the contents of path+relative_dir recursively into #{HOMEBREW_PREFIX}/relative_dir
on_const on_period prune if on_qwords_beg on_tstring_content on_words_sep on_tstring_content on_tstring_end on_period include? on_lparen src on_period UNK on_rparen on_op src on_period to_s # Don't link pyc or pyo files because Python overwrites these # cached object files and next time brew wants to link, the # file is in the way.
on_ignored_nl make_relative_symlink dst on_comma src on_comma mode on_nl dst on_period UNK on_nl else on_ignored_nl make_relative_symlink dst on_comma src on_comma mode # skip historical local 'dir' files
next if dst on_period directory? on_op on_op dst on_period symlink? on_nl on_ignored_nl on_const on_period prune if src on_period UNK on_op # if the dst dir already exists, then great! walk the rest of the tree tho
on_const on_period prune if src on_period UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl case UNK src on_period relative_path_from on_lparen root # no need to put .app bundles in the path, the user can just use # spotlight, or the open command and actual mac apps use an equivalent
