on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK UNK # frozen_string_literal: true
UNK UNK on_lparen string on_comma UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_comma on_label UNK on_rparen on_ignored_nl string on_op string on_period UNK # Replaces non-ASCII characters with an ASCII approximation, or if none # exists, a replacement character which defaults to "?". # # transliterate('Ærøskøbing') # # => "AEroskobing" # # Default approximations are provided for Western/Latin characters, # e.g, "ø", "ñ", "é", "ß", etc. # # This method is I18n aware, so you can set up custom approximations for a # locale. This can be useful, for example, to transliterate German's "ü" # and "ö" to "ue" and "oe", or to add support for transliterating Russian # to ASCII. # # In order to make your custom transliterations available, you must set # them as the <tt>i18n.transliterate.rule</tt> i18n key: # # # Store the transliterations in locales/de.yml # i18n: # transliterate: # rule: # ü: "ue" # ö: "oe" # # # Or set them using Ruby # I18n.backend.store_translations(:de, i18n: { # transliterate: { # rule: { # 'ü' => 'ue', # 'ö' => 'oe' # } # } # }) # # The value for <tt>i18n.transliterate.rule</tt> can be a simple Hash that # maps characters to ASCII approximations as shown above, or, for more # complex requirements, a Proc: # # I18n.backend.store_translations(:de, i18n: { # transliterate: { # rule: ->(string) { MyTransliterator.transliterate(string) } # } # }) # # Now you can have different transliterations for each locale: # # transliterate('Jürgen', locale: :en) # # => "Jurgen" # # transliterate('Jürgen', locale: :de) # # => "Juergen" # # Transliteration is restricted to UTF-8, US-ASCII and GB18030 strings # Other encodings will raise an ArgumentError.
string on_period UNK on_lparen on_const on_op on_const on_rparen UNK string on_period encoding on_op on_const on_op on_const on_nl on_ignored_nl string on_period # US-ASCII is a subset of UTF-8 so we'll force encoding as UTF-8 if # US-ASCII is given. This way we can let tidy_bytes handle the string # in the same way as we do for UTF-8
string on_period UNK on_lparen on_const on_op on_const on_comma on_label UNK UNK on_comma on_label UNK UNK on_rparen UNK string on_period encoding # GB18030 is Unicode compatible but is not a direct mapping so needs to be # transcoded. Using invalid/undef :replace will result in loss of data in # the event of invalid characters, but since tidy_bytes will replace # invalid/undef with a "?" we're safe to do the same beforehand
UNK on_period UNK on_lparen UNK on_comma on_label UNK UNK on_comma on_label UNK UNK on_rparen UNK UNK on_op UNK on_period encoding # Restore the string encoding of the input if it was not UTF-8. # Apply invalid/undef :replace as tidy_bytes does
UNK UNK on_lparen string on_comma on_label on_tstring_beg on_tstring_content on_tstring_end on_comma on_label UNK on_comma on_label UNK on_rparen on_ignored_nl parameterized_string on_op UNK # Replaces special characters in a string so that it may be used as part of # a 'pretty' URL. # # parameterize("Donald E. Knuth") # => "donald-e-knuth" # parameterize("^très|Jolie-- ") # => "tres-jolie" # # To use a custom separator, override the +separator+ argument. # # parameterize("Donald E. Knuth", separator: '_') # => "donald_e_knuth" # parameterize("^très|Jolie__ ", separator: '_') # => "tres_jolie" # # To preserve the case of the characters in a string, use the +preserve_case+ argument. # # parameterize("Donald E. Knuth", preserve_case: true) # => "Donald-E-Knuth" # parameterize("^très|Jolie-- ", preserve_case: true) # => "tres-Jolie" # # It preserves dashes and underscores unless they are used as separators: # # parameterize("^très|Jolie__ ") # => "tres-jolie__" # parameterize("^très|Jolie-- ", separator: "_") # => "tres_jolie--" # parameterize("^très_Jolie-- ", separator: ".") # => "tres_jolie--" # # If the optional parameter +locale+ is specified, # the word will be parameterized as a word of that language. # By default, this parameter is set to <tt>nil</tt> and it will use # the configured <tt>I18n.locale<tt>.
parameterized_string on_op UNK on_lparen string on_comma on_label UNK on_rparen on_nl on_ignored_nl parameterized_string on_period UNK on_lparen UNK on_tstring_content UNK on_comma separator # Replace accented chars with their ASCII equivalents.
parameterized_string on_period UNK on_lparen UNK on_tstring_content UNK on_comma separator on_rparen on_nl on_ignored_nl UNK separator on_period UNK on_op separator on_period UNK # Turn unwanted chars into the separator.
parameterized_string on_period UNK on_lparen UNK on_comma separator on_rparen on_nl parameterized_string on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_end on_rparen on_nl end # No more than one of the separator in a row.
parameterized_string on_period UNK on_lparen UNK on_comma on_tstring_beg on_tstring_end on_rparen on_nl end on_nl on_ignored_nl parameterized_string on_period UNK UNK UNK on_nl parameterized_string # Remove leading/trailing separator.
