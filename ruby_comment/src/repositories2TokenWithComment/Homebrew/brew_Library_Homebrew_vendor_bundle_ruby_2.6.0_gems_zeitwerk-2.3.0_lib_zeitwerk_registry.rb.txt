on_ignored_nl UNK on_const on_nl UNK on_const UNK on_op UNK on_nl UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl # frozen_string_literal: true
UNK on_op UNK on_nl UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl UNK # :nodoc: all
UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl # Keeps track of all loaders. Useful to broadcast messages and to prevent # them from being garbage collected. # # @private # @return [<Zeitwerk::Loader>]
UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen loader on_rparen # Registers loaders created with `for_gem` to make the method idempotent # in case of reload. # # @private # @return [{String => Zeitwerk::Loader}]
UNK UNK UNK on_nl on_ignored_nl UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen loader on_rparen on_ignored_nl UNK on_op loader on_nl # Maps real paths to the loaders responsible for them. # # This information is used by our decorated `Kernel#require` to be able to # invoke callbacks and autovivify modules. # # @private # @return [{String => Zeitwerk::Loader}]
UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen loader on_rparen on_ignored_nl UNK on_op loader on_nl end on_nl on_ignored_nl def UNK # This hash table addresses an edge case in which an autoload is ignored. # # For example, let's suppose we want to autoload in a gem like this: # # # lib/my_gem.rb # loader = Zeitwerk::Loader.new # loader.push_dir(__dir__) # loader.setup # # module MyGem # end # # if you require "my_gem", as Bundler would do, this happens while setting # up autoloads: # # 1. Object.autoload?(:MyGem) returns `nil` because the autoload for # the constant is issued by Zeitwerk while the same file is being # required. # 2. The constant `MyGem` is undefined while setup runs. # # Therefore, a directory `lib/my_gem` would autovivify a module according to # the existing information. But that would be wrong. # # To overcome this fundamental limitation, we keep track of the constant # paths that are in this situation ---in the example above, "MyGem"--- and # take this collection into account for the autovivification logic. # # Note that you cannot generally address this by moving the setup code # below the constant definition, because we want libraries to be able to # use managed constants in the module body: # # module MyGem # include MyConcern # end # # @private # @return [{String => (String, Zeitwerk::Loader)}]
def UNK on_lparen loader on_rparen on_ignored_nl UNK on_op loader on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK # Registers a loader. # # @private # @param loader [Zeitwerk::Loader] # @return [void]
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lbracket UNK on_rbracket on_op UNK on_ignored_nl on_const on_period UNK on_period UNK UNK on_op # This method returns always a loader, the same instance for the same root # file. That is how Zeitwerk::Loader.for_gem is idempotent. # # @private # @param root_file [String] # @return [Zeitwerk::Loader]
def UNK on_lparen loader on_comma realpath on_rparen on_ignored_nl UNK on_lbracket realpath on_rbracket on_op loader on_nl end on_nl on_ignored_nl def UNK # @private # @param loader [Zeitwerk::Loader] # @param realpath [String] # @return [void]
def UNK on_lparen realpath on_rparen on_ignored_nl UNK on_period UNK on_lparen realpath on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # @private # @param realpath [String] # @return [void]
def UNK on_lparen UNK on_comma realpath on_comma loader on_rparen on_ignored_nl UNK on_lbracket UNK on_rbracket on_op on_lbracket realpath on_comma loader on_rbracket # @private # @param cpath [String] # @param realpath [String] # @param loader [Zeitwerk::Loader] # @return [void]
def UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK on_op UNK on_lbracket UNK on_rbracket on_nl UNK on_period UNK on_nl end on_nl # @private # @param cpath [String] # @return [String, nil]
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lbracket UNK on_rbracket on_nl end on_nl on_ignored_nl def UNK on_lparen loader on_rparen on_ignored_nl # @private # @param path [String] # @return [Zeitwerk::Loader, nil]
def UNK on_lparen loader on_rparen on_ignored_nl UNK on_period UNK UNK on_op UNK on_comma UNK on_op UNK on_op loader UNK on_nl # @private # @param loader [Zeitwerk::Loader] # @return [void]
