on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_const on_op UNK UNK UNK # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op UNK UNK UNK UNK UNK UNK on_nl on_ignored_nl UNK UNK on_lparen node on_rparen # Checks for opportunities to use `expect { ... }.to output`. # # @example # # bad # $stdout = StringIO.new # my_app.print_report # $stdout = STDOUT # expect($stdout.string).to eq('Hello World') # # # good # expect { my_app.print_report }.to output('Hello World').to_stdout
UNK UNK UNK on_op on_op node on_nl UNK on_op UNK UNK UNK on_op on_op UNK UNK on_nl UNK UNK UNK # rubocop:disable InternalAffairs/NodeDestructuring
UNK on_op UNK UNK UNK on_op on_op UNK UNK on_nl UNK UNK UNK on_period UNK on_lparen UNK UNK UNK on_rparen # rubocop:enable InternalAffairs/NodeDestructuring
UNK UNK on_lparen node on_rparen on_ignored_nl UNK UNK UNK node on_period UNK on_op UNK on_lparen node on_rparen on_nl UNK UNK # Detect if we are inside the scope of a single example # # We want to encourage using `expect { ... }.to output` so # we only care about situations where you would replace with # an expectation. Therefore, assignments to stderr or stdout # within a `before(:all)` or otherwise outside of an example # don't matter.
