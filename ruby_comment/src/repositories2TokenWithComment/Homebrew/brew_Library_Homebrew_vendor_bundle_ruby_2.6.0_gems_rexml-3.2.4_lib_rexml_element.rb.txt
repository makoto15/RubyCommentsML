require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl # frozen_string_literal: false
UNK on_op on_lbrace on_rbrace on_nl on_ignored_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end # An implementation note about namespaces: # As we parse, when we find namespaces we put them in a hash and assign # them a unique ID. We then convert the namespace prefix for the node # to the unique ID. This makes namespace lookup much faster for the # cost of extra memory use. We save the namespace prefix for the # context node and convert it back when we write it.
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end UNK on_ignored_nl UNK on_symbeg attributes on_comma # Represents a tagged XML element. Elements are characterized by # having children, attributes, and names, and can themselves be # children.
on_ignored_nl UNK on_symbeg attributes on_comma on_symbeg UNK on_nl UNK on_symbeg context on_nl on_ignored_nl def UNK on_lparen arg on_op on_const on_comma # The default name
UNK on_symbeg attributes on_comma on_symbeg UNK on_nl UNK on_symbeg context on_nl on_ignored_nl def UNK on_lparen arg on_op on_const on_comma parent # Mechanisms for accessing attributes and child elements of this # element.
UNK on_symbeg context on_nl on_ignored_nl def UNK on_lparen arg on_op on_const on_comma parent on_op nil on_comma context on_op nil on_rparen # The context holds information about the processing environment, such as # whitespace handling.
def UNK on_lparen arg on_op on_const on_comma parent on_op nil on_comma context on_op nil on_rparen on_ignored_nl UNK on_lparen parent on_rparen # Constructor # arg:: # if not supplied, will be set to the default value. # If a String, the name of this object will be set to the argument. # If an Element, the object will be shallowly cloned; name, # attributes, and namespaces will be copied. Children will +not+ be # copied. # parent:: # if supplied, must be a Parent, and will be used as # the parent of this object. # context:: # If supplied, must be a hash containing context items. Context items # include: # * <tt>:respect_whitespace</tt> the value of this is :+all+ or an array of # strings being the names of the elements to respect # whitespace for. Defaults to :+all+. # * <tt>:compress_whitespace</tt> the value can be :+all+ or an array of # strings being the names of the elements to ignore whitespace on. # Overrides :+respect_whitespace+. # * <tt>:ignore_whitespace_nodes</tt> the value can be :+all+ or an array # of strings being the names of the elements in which to ignore # whitespace-only nodes. If this is set, Text nodes which contain only # whitespace will not be added to the document tree. # * <tt>:raw</tt> can be :+all+, or an array of strings being the names of # the elements to process in raw mode. In raw mode, special # characters in text is not converted to or from entities.
def UNK on_nl self on_period UNK on_period new self on_nl end on_nl on_ignored_nl def UNK on_nl parent on_period nil? on_op # Creates a shallow copy of self. # d = Document.new "<a><b/><b/><c><d/></c></a>" # new_a = d.root.clone # puts new_a # => "<a/>"
def UNK on_nl parent on_period nil? on_op self on_op parent on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl return # Evaluates to the root node of the document that this element # belongs to. If this element doesn't belong to a document, but does # belong to another Element, the parent's root will be returned, until the # earliest ancestor is found. # # Note that this is not the same as the document element. # In the following example, <a> is the document element, and the root # node is the parent node of the document element. You may ask yourself # why the root node is useful: consider the doctype and XML declaration, # and any processing instructions before the document element... they # are children of the root node, or siblings of the document element. # The only time this isn't true is when an Element is created that is # not part of any Document. In this case, the ancestor that has no # parent acts as the root node. # d = Document.new '<a><b><c/></b></a>' # a = d[1] ; c = a[1][1] # d.root_node == d # TRUE # a.root_node # namely, d # c.root_node # again, d
def document on_nl UNK on_op UNK on_nl UNK on_period parent if UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar # Evaluates to the document to which this element belongs, or nil if this # element doesn't belong to a document.
def UNK on_nl on_ivar on_op nil on_nl if on_ivar on_nl if on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl on_ivar on_op on_lparen # Evaluates to +true+ if whitespace is respected for this element. This # is the case if: # 1. Neither :+respect_whitespace+ nor :+compress_whitespace+ has any value # 2. The context has :+respect_whitespace+ set to :+all+ or # an array containing the name of this element, and # :+compress_whitespace+ isn't set to :+all+ or an array containing the # name of this element. # The evaluation is tested against +expanded_name+, and so is namespace # sensitive.
def raw on_nl on_ivar on_op on_lparen on_ivar and on_ivar on_lbracket on_symbeg raw on_rbracket and on_ignored_nl on_lparen on_ivar on_lbracket on_symbeg raw # Evaluates to +true+ if raw mode is set for this element. This # is the case if the context has :+raw+ set to :+all+ or # an array containing the name of this element. # # The evaluation is tested against +expanded_name+, and so is namespace # sensitive.
on_ignored_nl on_ignored_nl def prefixes on_nl prefixes on_op on_lbracket on_rbracket on_nl prefixes on_op parent on_period prefixes if parent on_nl prefixes on_op #once :whitespace, :raw, :ignore_whitespace_nodes
on_ignored_nl def prefixes on_nl prefixes on_op on_lbracket on_rbracket on_nl prefixes on_op parent on_period prefixes if parent on_nl prefixes on_op attributes ################################################# # Namespaces # #################################################
def prefixes on_nl prefixes on_op on_lbracket on_rbracket on_nl prefixes on_op parent on_period prefixes if parent on_nl prefixes on_op attributes on_period # Evaluates to an +Array+ containing the prefixes (names) of all defined # namespaces at this context node. # doc = Document.new("<a xmlns:x='1' xmlns:y='2'><b/><c xmlns:z='3'/></a>") # doc.elements['//b'].prefixes # -> ['x', 'y']
def namespace on_lparen prefix on_op nil on_rparen on_ignored_nl if prefix on_period nil? on_nl prefix on_op prefix on_lparen on_rparen on_nl end # Evaluates to the URI for a prefix, or the empty string if no such # namespace is declared for this element. Evaluates recursively for # ancestors. Returns the default namespace, if there is one. # prefix:: # the prefix to search for. If not supplied, returns the default # namespace if one exists # Returns:: # the namespace URI as a String, or nil if no such namespace # exists. If the namespace is undefined, returns an empty string # doc = Document.new("<a xmlns='1' xmlns:y='2'><b/><c xmlns:z='3'/></a>") # b = doc.elements['//b'] # b.namespace # -> '1' # b.namespace("y") # -> '2'
def UNK on_lparen prefix on_comma UNK on_op nil on_rparen on_ignored_nl unless UNK on_nl on_ivar on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op # Adds a namespace to this element. # prefix:: # the prefix string, or the namespace URI if +uri+ is not # supplied # uri:: # the namespace URI. May be nil, in which +prefix+ is used as # the URI # Evaluates to: this Element # a = Element.new("a") # a.add_namespace("xmlns:foo", "bar" ) # a.add_namespace("foo", "bar") # shorthand for previous line # a.add_namespace("twiddle") # puts a #-> <a xmlns:foo='bar' xmlns='twiddle'/>
def UNK namespace on_op on_tstring_beg on_tstring_content on_tstring_end on_nl namespace on_op on_tstring_beg on_tstring_content on_embexpr_beg namespace on_embexpr_end on_tstring_end unless namespace on_op on_tstring_beg # Removes a namespace from this node. This only works if the namespace is # actually declared in this node. If no argument is passed, deletes the # default namespace. # # Evaluates to: this element # doc = Document.new "<a xmlns:foo='bar' xmlns='twiddle'/>" # doc.root.delete_namespace # puts doc # -> <a xmlns:foo='bar'/> # doc.root.delete_namespace 'foo' # puts doc # -> <a/>
on_ignored_nl def UNK element on_comma UNK on_op nil on_nl UNK on_tstring_beg on_tstring_content on_tstring_end if element on_period nil? on_nl el on_op ################################################# # Elements # #################################################
def UNK element on_comma UNK on_op nil on_nl UNK on_tstring_beg on_tstring_content on_tstring_end if element on_period nil? on_nl el on_op on_ivar # Adds a child to this element, optionally setting attributes in # the element. # element:: # optional. If Element, the element is added. # Otherwise, a new Element is constructed with the argument (see # Element.initialize). # attrs:: # If supplied, must be a Hash containing String name,value # pairs, which will be used to set the attributes of the new Element. # Returns:: the Element that was added # el = doc.add_element 'my-tag' # el = doc.add_element 'my-tag', {'attr1'=>'val1', 'attr2'=>'val2'} # el = Element.new 'my-tag' # doc.add_element el
def UNK element on_nl on_ivar on_period delete element on_nl end on_nl on_ignored_nl def UNK on_nl on_op on_ivar on_period UNK on_nl # Deletes a child element. # element:: # Must be an +Element+, +String+, or +Integer+. If Element, # the element is removed. If String, the element is found (via XPath) # and removed. <em>This means that any parent can remove any # descendant.<em> If Integer, the Element indexed by that number will be # removed. # Returns:: the element that was removed. # doc.delete_element "/a/b/c[@id='4']" # doc.delete_element doc.elements["//k"] # doc.delete_element 1
def UNK on_nl on_op on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen key on_comma value on_op nil on_comma # Evaluates to +true+ if this element has at least one child Element # doc = Document.new "<a><b/><c>Text</c></a>" # doc.root.has_elements # -> true # doc.elements["/a/b"].has_elements # -> false # doc.elements["/a/c"].has_elements # -> false
def UNK on_lparen key on_comma value on_op nil on_comma max on_op on_int on_comma name on_op nil on_comma on_op block on_rparen # Iterates through the child elements, yielding for each Element that # has a particular attribute set. # key:: # the name of the attribute to search for # value:: # the value of the attribute # max:: # (optional) causes this method to return after yielding # for this number of matching children # name:: # (optional) if supplied, this is an XPath that filters # the children to check. # # doc = Document.new "<a><b @id='1'/><c @id='2'/><d @id='1'/><e/></a>" # # Yields b, c, d # doc.root.each_element_with_attribute( 'id' ) {|e| p e} # # Yields b, d # doc.root.each_element_with_attribute( 'id', '1' ) {|e| p e} # # Yields b # doc.root.each_element_with_attribute( 'id', '1', 1 ) {|e| p e} # # Yields d # doc.root.each_element_with_attribute( 'id', '1', 0, 'd' ) {|e| p e}
UNK on_lparen UNK on_lbrace on_op child on_op on_ignored_nl if value on_period nil? on_nl child on_period attributes on_lbracket key on_rbracket on_op # :yields: Element
def UNK on_lparen text on_op nil on_comma max on_op on_int on_comma name on_op nil on_comma on_op block on_rparen UNK on_lparen # Iterates through the children, yielding for each Element that # has a particular text set. # text:: # the text to search for. If nil, or not supplied, will iterate # over all +Element+ children that contain at least one +Text+ node. # max:: # (optional) causes this method to return after yielding # for this number of matching children # name:: # (optional) if supplied, this is an XPath that filters # the children to check. # # doc = Document.new '<a><b>b</b><c>b</c><d>d</d><e/></a>' # # Yields b, c, d # doc.each_element_with_text {|e|p e} # # Yields b, c # doc.each_element_with_text('b'){|e|p e} # # Yields b # doc.each_element_with_text('b', 1){|e|p e} # # Yields d # doc.each_element_with_text(nil, 0, 'd'){|e|p e}
UNK on_lparen UNK on_lbrace on_op child on_op on_ignored_nl if text on_period nil? on_nl child on_period UNK on_nl else on_ignored_nl child # :yields: Element
def UNK on_lparen xpath on_op nil on_comma on_op block on_rparen on_ivar on_period each on_lparen xpath on_comma on_op block on_rparen on_nl # Synonym for Element.elements.each
on_ivar on_period each on_lparen xpath on_comma on_op block on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen xpath on_rparen on_ignored_nl on_ivar # :yields: Element
def UNK on_lparen xpath on_rparen on_ignored_nl on_ivar on_period UNK on_lparen xpath on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl element # Synonym for Element.to_a # This is a little slower than calling elements.each directly. # xpath:: any XPath by which to search for elements in the tree # Returns:: an array of Elements that match the supplied path
def UNK on_nl element on_op UNK on_nl element on_op element on_period UNK UNK element on_period nil? or element on_period kind_of? # Returns the next sibling that is an element, or nil if there is # no Element sibling after this one # doc = Document.new '<a><b/>text<c/></a>' # doc.root.elements['b'].next_element #-> <c/> # doc.root.elements['c'].next_element #-> nil
def UNK on_nl element on_op UNK on_nl element on_op element on_period UNK UNK element on_period nil? or element on_period kind_of? # Returns the previous sibling that is an element, or nil if there is # no Element sibling prior to this one # doc = Document.new '<a><b/>text<c/></a>' # doc.root.elements['c'].previous_element #-> <b/> # doc.root.elements['b'].previous_element #-> nil
on_ignored_nl def UNK on_nl UNK text on_lparen on_rparen on_period nil? on_nl end on_nl on_ignored_nl def text on_lparen UNK on_op nil ################################################# # Text # #################################################
def UNK on_nl UNK text on_lparen on_rparen on_period nil? on_nl end on_nl on_ignored_nl def text on_lparen UNK on_op nil on_rparen # Evaluates to +true+ if this element has at least one Text child
def text on_lparen UNK on_op nil on_rparen on_ignored_nl rv on_op UNK on_lparen UNK on_rparen on_nl return rv on_period value unless # A convenience method which returns the String value of the _first_ # child text element, if one exists, and +nil+ otherwise. # # <em>Note that an element may have multiple Text elements, perhaps # separated by other children</em>. Be aware that this method only returns # the first Text node. # # This method returns the +value+ of the first text child node, which # ignores the +raw+ setting, so always returns normalized text. See # the Text::value documentation. # # doc = Document.new "<p>some text <b>this is bold!</b> more text</p>" # # The element 'p' has two text elements, "some text " and " more text". # doc.root.text #-> "some text "
def UNK UNK on_op nil on_nl rv on_op nil on_nl if UNK on_nl element on_op on_ivar on_lbracket UNK on_rbracket on_nl # Returns the first child Text node, if any, or +nil+ otherwise. # This method returns the actual +Text+ node, rather than the String content. # doc = Document.new "<p>some text <b>this is bold!</b> more text</p>" # # The element 'p' has two text elements, "some text " and " more text". # doc.root.get_text.value #-> "some text "
def UNK on_lparen text on_rparen on_ignored_nl if text on_period kind_of? on_const on_nl text on_op on_const on_period new on_lparen text on_comma # Sets the first Text child of this object. See text() for a # discussion about Text children. # # If a Text child already exists, the child is replaced by this # content. This means that Text content can be deleted by calling # this method with a nil argument. In this case, the next Text # child becomes the first Text child. In no case is the order of # any siblings disturbed. # text:: # If a String, a new Text child is created and added to # this Element as the first Text child. If Text, the text is set # as the first Child element. If nil, then any existing first Text # child is removed. # Returns:: this Element. # doc = Document.new '<a><b/></a>' # doc.root.text = 'Sean' #-> '<a><b/>Sean</a>' # doc.root.text = 'Elliott' #-> '<a><b/>Elliott</a>' # doc.root.add_element 'c' #-> '<a><b/>Elliott<c/></a>' # doc.root.text = 'Russell' #-> '<a><b/>Russell<c/></a>' # doc.root.text = nil #-> '<a><b/><c/></a>'
def UNK on_lparen text on_rparen on_ignored_nl if text on_period kind_of? on_const on_nl if on_ivar on_lbracket on_op on_int on_rbracket on_period kind_of? # A helper method to add a Text child. Actual Text instances can # be added with regular Parent methods, such as add() and <<() # text:: # if a String, a new Text instance is created and added # to the parent. If Text, the object is added directly. # Returns:: this Element # e = Element.new('a') #-> <e/> # e.add_text 'foo' #-> <e>foo</e> # e.add_text Text.new(' bar') #-> <e>foo bar</e> # Note that at the end of this example, the branch has <b>3</b> nodes; the 'e' # element and <b>2</b> Text node children.
on_ignored_nl def on_op on_lparen UNK on_rparen on_ignored_nl UNK UNK on_nl UNK on_const on_nl attributes on_lbracket UNK on_rbracket on_nl UNK on_const ################################################# # Attributes # #################################################
def on_op on_lparen UNK on_rparen on_ignored_nl UNK UNK on_nl UNK on_const on_nl attributes on_lbracket UNK on_rbracket on_nl UNK on_const on_nl # Fetches an attribute value or a child. # # If String or Symbol is specified, it's treated as attribute # name. Attribute value as String or +nil+ is returned. This case # is shortcut of +attributes[name]+. # # If Integer is specified, it's treated as the index of # child. It returns Nth child. # # doc = REXML::Document.new("<a attr='1'><b/><c/></a>") # doc.root["attr"] # => "1" # doc.root.attributes["attr"] # => "1" # doc.root[1] # => <c/>
return nil unless on_lparen namespaces on_lbracket prefix on_rbracket on_op namespaces on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_rparen on_nl on_ignored_nl attributes on_period # now check that prefix'es namespace is not the same as the # default namespace
def UNK on_nl return on_op on_ivar on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen key on_comma value on_op nil # Evaluates to +true+ if this element has any attributes set, false # otherwise.
def UNK on_lparen key on_comma value on_op nil on_rparen on_ignored_nl if key on_period kind_of? on_const on_nl on_ivar on_op key on_nl # Adds an attribute to this element, overwriting any existing attribute # by the same name. # key:: # can be either an Attribute or a String. If an Attribute, # the attribute is added to the list of Element attributes. If String, # the argument is used as the name of the new attribute, and the value # parameter must be supplied. # value:: # Required if +key+ is a String, and ignored if the first argument is # an Attribute. This is a String, and is used as the value # of the new Attribute. This should be the unnormalized value of the # attribute (without entities). # Returns:: the Attribute added # e = Element.new 'e' # e.add_attribute( 'a', 'b' ) #-> <e a='b'/> # e.add_attribute( 'x:a', 'c' ) #-> <e a='b' x:a='c'/> # e.add_attribute Attribute.new('b', 'd') #-> <e a='b' x:a='c' b='d'/>
def UNK UNK on_nl if UNK on_period kind_of? on_const on_nl UNK on_period UNK on_lbrace on_op key on_comma value on_op on_ivar # Add multiple attributes to this element. # hash:: is either a hash, or array of arrays # el.add_attributes( {"name1"=>"value1", "name2"=>"value2"} ) # el.add_attributes( [ ["name1","value1"], ["name2"=>"value2"] ] )
def UNK on_lparen key on_rparen on_ignored_nl attr on_op on_ivar on_period get_attribute on_lparen key on_rparen on_nl attr on_period remove unless attr # Removes an attribute # key:: # either an Attribute or a String. In either case, the # attribute is found by matching the attribute name to the argument, # and then removed. If no attribute is found, no action is taken. # Returns:: # the attribute removed, or nil if this Element did not contain # a matching attribute # e = Element.new('E') # e.add_attribute( 'name', 'Sean' ) #-> <E name='Sean'/> # r = e.add_attribute( 'sur:name', 'Russell' ) #-> <E name='Sean' sur:name='Russell'/> # e.delete_attribute( 'name' ) #-> <E sur:name='Russell'/> # e.delete_attribute( r ) #-> <E/>
on_ignored_nl def UNK on_nl find_all on_lbrace on_op child on_op child on_period kind_of? on_const on_rbrace on_period UNK on_nl end on_nl on_ignored_nl ################################################# # Other Utilities # #################################################
def UNK on_nl find_all on_lbrace on_op child on_op child on_period kind_of? on_const on_rbrace on_period UNK on_nl end on_nl on_ignored_nl def # Get an array of all CData children. # IMMUTABLE
def UNK on_nl find_all on_lbrace on_op child on_op child on_period kind_of? on_const on_rbrace on_period UNK on_nl end on_nl on_ignored_nl def # Get an array of all Comment children. # IMMUTABLE
def UNK on_nl find_all on_lbrace on_op child on_op child on_period kind_of? on_const on_rbrace on_period UNK on_nl end on_nl on_ignored_nl def # Get an array of all Instruction children. # IMMUTABLE
def UNK on_nl find_all on_lbrace on_op child on_op child on_period kind_of? on_const on_rbrace on_period UNK on_nl end on_nl on_ignored_nl def # Get an array of all Text children. # IMMUTABLE
def UNK on_lparen UNK on_op UNK on_comma UNK on_op on_op on_int on_comma UNK on_op false on_comma UNK on_op false on_rparen # == DEPRECATED # See REXML::Formatters # # Writes out this element, and recursively, all children. # output:: # output an object which supports '<< string'; this is where the # document will be written. # indent:: # An integer. If -1, no indenting will be used; otherwise, the # indentation will be this number of spaces, and children will be # indented an additional amount. Defaults to -1 # transitive:: # If transitive is true and indent is >= 0, then the output will be # pretty-printed in such a way that the added whitespace does not affect # the parse tree of the document # ie_hack:: # This hack inserts a space before the /> on empty tags to address # a limitation of Internet Explorer. Defaults to false # # out = '' # doc.write( out ) #-> doc is written to the string 'out' # doc.write( $stdout ) #-> doc written to the console
def UNK on_lparen UNK on_comma max on_op on_int on_comma name on_op nil on_rparen on_ignored_nl UNK on_op on_int on_nl on_ivar on_period # A private helper method
on_ignored_nl UNK on_const on_nl UNK on_const on_nl def UNK parent on_nl on_ivar on_op parent on_nl end on_nl on_ignored_nl def on_op ######################################################################## # ELEMENTS # ########################################################################
UNK on_const on_nl UNK on_const on_nl def UNK parent on_nl on_ivar on_op parent on_nl end on_nl on_ignored_nl def on_op on_lparen # A class which provides filtering of children for Elements, and # XPath search support. You are expected to only encounter this class as # the <tt>element.elements</tt> object. Therefore, you are # _not_ expected to instantiate this yourself.
def UNK parent on_nl on_ivar on_op parent on_nl end on_nl on_ignored_nl def on_op on_lparen index on_comma name on_op nil on_rparen # Constructor # parent:: the parent Element
def on_op on_lparen index on_comma name on_op nil on_rparen on_ignored_nl if index on_period kind_of? on_const on_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg # Fetches a child element. Filters only Element children, regardless of # the XPath match. # index:: # the search parameter. This is either an Integer, which # will be used to find the index'th child Element, or an XPath, # which will be used to search for the Element. <em>Because # of the nature of XPath searches, any element in the connected XML # document can be fetched through any other element.</em> <b>The # Integer index is 1-based, not 0-based.</b> This means that the first # child element is at index 1, not 0, and the +n+th element is at index # +n+, not <tt>n-1</tt>. This is because XPath indexes element children # starting from 1, not 0, and the indexes should be the same. # name:: # optional, and only used in the first argument is an # Integer. In that case, the index'th child Element that has the # supplied name will be returned. Note again that the indexes start at 1. # Returns:: the first matching Element, or nil if no child matched # doc = Document.new '<a><b/><c id="1"/><c id="2"/><d/></a>' # doc.root.elements[1] #-> <b/> # doc.root.elements['c'] #-> <c id="1"/> # doc.root.elements[2,'c'] #-> <c id="2"/>
end on_nl end on_nl on_ignored_nl def on_op on_lparen index on_comma element on_rparen on_ignored_nl UNK on_op self on_lbracket index on_rbracket on_nl #{ |element| # return element if element.kind_of? Element #} #return nil
def on_op on_lparen index on_comma element on_rparen on_ignored_nl UNK on_op self on_lbracket index on_rbracket on_nl if UNK on_period nil? on_nl # Sets an element, replacing any previous matching element. If no # existing element is found ,the element is added. # index:: Used to find a matching element to replace. See [](). # element:: # The element to replace the existing element with # the previous element # Returns:: nil if no previous element was found. # # doc = Document.new '<a/>' # doc.root.elements[10] = Element.new('b') #-> <a><b/></a> # doc.root.elements[1] #-> <b/> # doc.root.elements[1] = Element.new('c') #-> <a><c/></a> # doc.root.elements['c'] = Element.new('d') #-> <a><d/></a>
def UNK on_nl on_ivar on_period UNK on_lbrace on_op child on_op child on_period kind_of? on_const on_rbrace on_period nil? on_nl end on_nl # Returns +true+ if there are no +Element+ children, +false+ otherwise
def index element on_nl rv on_op on_int on_nl UNK on_op on_ivar on_period UNK do on_op child on_op on_ignored_nl child on_period # Returns the index of the supplied child (starting at 1), or -1 if # the element is not a child # element:: an +Element+ child
def delete element on_nl if element on_period kind_of? on_const on_nl on_ivar on_period delete element on_nl else on_ignored_nl el on_op self # Deletes a child Element # element:: # Either an Element, which is removed directly; an # xpath, where the first matching child is removed; or an Integer, # where the n'th Element is removed. # Returns:: the removed child # doc = Document.new '<a><b/><c/><c id="1"/></a>' # b = doc.root.elements[1] # doc.root.elements.delete b #-> <a><c/><c id="1"/></a> # doc.elements.delete("a/c[@id='1']") #-> <a><c/></a> # doc.root.elements.delete 1 #-> <a/>
def UNK on_lparen xpath on_rparen on_ignored_nl rv on_op on_lbracket on_rbracket on_nl on_const on_op each on_lparen on_ivar on_comma xpath on_rparen on_lbrace # Removes multiple elements. Filters for Element children, regardless of # XPath matching. # xpath:: all elements matching this String path are removed. # Returns:: an Array of Elements that have been removed # doc = Document.new '<a><c/><c/><c/><c/></a>' # deleted = doc.elements.delete_all 'a/c' #-> [<c/>, <c/>, <c/>, <c/>]
def add element on_op nil on_nl if element on_period nil? on_nl on_const on_period new on_lparen on_tstring_beg on_tstring_end on_comma self on_comma # Adds an element # element:: # if supplied, is either an Element, String, or # Source (see Element.initialize). If not supplied or nil, a # new, default Element will be constructed # Returns:: the added Element # a = Element.new('a') # a.elements.add(Element.new('b')) #-> <a><b/></a> # a.elements.add('c') #-> <a><b/><c/></a>
def each on_lparen xpath on_op nil on_rparen on_ignored_nl on_const on_op each on_lparen on_ivar on_comma xpath on_rparen on_lbrace on_op e on_op # Iterates through all of the child Elements, optionally filtering # them by a given XPath # xpath:: # optional. If supplied, this is a String XPath, and is used to # filter the children, so that only matching children are yielded. Note # that XPaths are automatically filtered for Elements, so that # non-Element children will not be yielded # doc = Document.new '<a><b/><c/><d/>sean<b/><c/><d/></a>' # doc.root.elements.each {|e|p e} #-> Yields b, c, d, b, c, d elements # doc.root.elements.each('b') {|e|p e} #-> Yields b, b elements # doc.root.elements.each('child::node()') {|e|p e} # #-> Yields <b/>, <c/>, <d/>, <b/>, <c/>, <d/> # XPath.each(doc.root, 'child::node()', &block) # #-> Yields <b/>, <c/>, <d/>, sean, <b/>, <c/>, <d/>
def size on_nl UNK on_op on_int on_nl on_ivar on_period each on_lbrace on_op child on_op UNK on_op on_int if child on_period # Returns the number of +Element+ children of the parent object. # doc = Document.new '<a>sean<b/>elliott<b/>russell<b/></a>' # doc.root.size #-> 6, 3 element and 3 text nodes # doc.root.elements.size #-> 3
def UNK on_lparen xpath on_op nil on_rparen on_ignored_nl rv on_op on_const on_period UNK on_lparen on_ivar on_comma xpath on_rparen on_nl return # Returns an Array of Element children. An XPath may be supplied to # filter the children. Only Element children are returned, even if the # supplied XPath matches non-Element children. # doc = Document.new '<a>sean<b/>elliott<c/></a>' # doc.root.elements.to_a #-> [ <b/>, <c/> ] # doc.root.elements.to_a("child::node()") #-> [ <b/>, <c/> ] # XPath.match(doc.root, "child::node()") #-> [ sean, <b/>, elliott, <c/> ]
def UNK name on_nl name on_op name on_lbracket on_int on_op on_op on_int on_rbracket if name on_lbracket on_int on_rbracket on_op UNK # Private helper class. Removes quotes from quoted strings
name on_nl end on_nl end on_nl on_ignored_nl on_ignored_nl UNK on_const on_op on_const on_nl def UNK element on_nl on_ivar on_op element #'
on_ignored_nl UNK on_const on_op on_const on_nl def UNK element on_nl on_ivar on_op element on_nl end on_nl on_ignored_nl def on_op on_lparen ######################################################################## # ATTRIBUTES # ########################################################################
UNK on_const on_op on_const on_nl def UNK element on_nl on_ivar on_op element on_nl end on_nl on_ignored_nl def on_op on_lparen name # A class that defines the set of Attributes of an Element and provides # operations for accessing elements in that set.
def UNK element on_nl on_ivar on_op element on_nl end on_nl on_ignored_nl def on_op on_lparen name on_rparen on_ignored_nl attr on_op get_attribute # Constructor # element:: the Element of which this is an Attribute
def on_op on_lparen name on_rparen on_ignored_nl attr on_op get_attribute on_lparen name on_rparen on_nl return attr on_period value unless attr on_period # Fetches an attribute value. If you want to get the Attribute itself, # use get_attribute() # name:: an XPath attribute name. Namespaces are relevant here. # Returns:: # the String value of the matching attribute, or +nil+ if no # matching attribute was found. This is the unnormalized value # (with entities expanded). # # doc = Document.new "<a foo:att='1' bar:att='2' att='&lt;'/>" # doc.root.attributes['att'] #-> '<' # doc.root.attributes['bar:att'] #-> '2'
def UNK on_nl UNK on_op on_int on_nl each_attribute on_lbrace UNK on_op on_int on_rbrace on_nl UNK on_nl end on_nl UNK on_symbeg # Returns the number of attributes the owning Element contains. # doc = Document "<a x='1' y='2' foo:x='3'/>" # doc.root.attributes.length #-> 3
def each_attribute return UNK on_lparen UNK on_rparen unless UNK on_nl UNK do on_op UNK on_op on_ignored_nl if UNK on_period kind_of? # Iterates over the attributes of an Element. Yields actual Attribute # nodes, not String values. # # doc = Document.new '<a x="1" y="2"/>' # doc.root.attributes.each_attribute {|attr| # p attr.expanded_name+" => "+attr.value # }
return UNK on_lparen UNK on_rparen unless UNK on_nl UNK do on_op UNK on_op on_ignored_nl if UNK on_period kind_of? on_const on_nl # :yields: attribute
def each on_nl return UNK on_lparen UNK on_rparen unless UNK on_nl each_attribute do on_op attr on_op on_ignored_nl yield on_lbracket attr # Iterates over each attribute of an Element, yielding the expanded name # and value as a pair of Strings. # # doc = Document.new '<a x="1" y="2"/>' # doc.root.attributes.each {|name, value| p name+" => "+value }
def get_attribute on_lparen name on_rparen on_ignored_nl attr on_op UNK on_lparen name on_comma nil on_rparen on_nl if attr on_period nil? on_nl # Fetches an attribute # name:: # the name by which to search for the attribute. Can be a # <tt>prefix:name</tt> namespace name. # Returns:: The first matching attribute, or nil if there was none. This # value is an Attribute node, not the String value of the attribute. # doc = Document.new '<a x:foo="1" foo="2" bar="3"/>' # doc.root.attributes.get_attribute("foo").value #-> "2" # doc.root.attributes.get_attribute("x:foo").value #-> "1"
name on_op on_const on_op on_const on_nl prefix on_comma UNK on_op UNK on_comma UNK on_nl if prefix on_nl attr on_op UNK # Look for prefix
if attr on_op nil on_nl elsif attr on_period kind_of? on_const on_nl return attr if prefix on_op attr on_period prefix on_nl # check prefix
def on_op on_lparen name on_comma value on_rparen on_ignored_nl if value on_period nil? attr on_op get_attribute on_lparen name on_rparen on_nl delete # Sets an attribute, overwriting any existing attribute value by the # same name. Namespace is significant. # name:: the name of the attribute # value:: # (optional) If supplied, the value of the attribute. If # nil, any existing matching attribute is deleted. # Returns:: # Owning element # doc = Document.new "<a x:foo='1' foo='3'/>" # doc.root.attributes['y:foo'] = '2' # doc.root.attributes['foo'] = '4' # doc.root.attributes['x:foo'] = nil
attr on_op get_attribute on_lparen name on_rparen on_nl delete attr on_nl return on_nl end on_nl on_ignored_nl unless value on_period kind_of? on_const # Delete the named attribute
if value on_period prefix on_op on_tstring_beg on_tstring_content on_tstring_end and old_attr on_period prefix on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_op old_attr # Check for conflicting namespaces
def prefixes on_nl ns on_op on_lbracket on_rbracket on_nl each_attribute do on_op attribute on_op on_ignored_nl ns on_op attribute on_period name if # Returns an array of Strings containing all of the prefixes declared # by this set of # attributes. The array does not include the default # namespace declaration, if one exists. # doc = Document.new("<a xmlns='foo' xmlns:x='bar' xmlns:y='twee' "+ # "z='glorp' p:k='gru'/>") # prefixes = doc.root.attributes.prefixes #-> ['x', 'y']
def delete on_lparen attribute on_rparen on_ignored_nl name on_op nil on_nl prefix on_op nil on_nl if attribute on_period kind_of? on_const on_nl # Removes an attribute # attribute:: # either a String, which is the name of the attribute to remove -- # namespaces are significant here -- or the attribute to remove. # Returns:: the owning element # doc = Document.new "<a y:foo='0' x:foo='1' foo='3' z:foo='4'/>" # doc.root.attributes.delete 'foo' #-> <a y:foo='0' x:foo='1' z:foo='4'/>" # doc.root.attributes.delete 'x:foo' #-> <a y:foo='0' z:foo='4'/>" # attr = doc.root.attributes.get_attribute('y:foo') # doc.root.attributes.delete attr #-> <a z:foo='4'/>"
old on_period delete on_lparen prefix on_rparen on_nl if old on_period size on_op on_int on_nl UNK on_op nil on_nl old on_period # the supplied attribute is one of many
UNK on_lparen name on_rparen on_nl end on_nl on_ivar on_nl end on_nl on_ignored_nl def add on_lparen attribute on_rparen on_ignored_nl self on_lbracket # the supplied attribute is a top-level one
def add on_lparen attribute on_rparen on_ignored_nl self on_lbracket attribute on_period name on_rbracket on_op attribute on_nl end on_nl on_ignored_nl UNK on_symbeg # Adds an attribute, overriding any existing attribute by the # same name. Namespaces are significant. # attribute:: An Attribute
def UNK on_lparen name on_rparen on_ignored_nl rv on_op on_lbracket on_rbracket on_nl each_attribute on_lbrace on_op attribute on_op on_ignored_nl rv on_op attribute # Deletes all attributes matching a name. Namespaces are significant. # name:: # A String; all attributes that match this path will be removed # Returns:: an Array of the Attributes that were removed
def UNK on_lparen namespace on_comma name on_rparen on_ignored_nl UNK on_op nil on_nl each_attribute on_lparen on_rparen on_lbrace on_op attribute on_op on_ignored_nl # The +get_attribute_ns+ method retrieves a method by its namespace # and name. Thus it is possible to reliably identify an attribute # even if an XML processor has changed the prefix. # # Method contributed by Henrik Martensson
UNK on_op attribute if on_op UNK or on_op namespace on_period UNK or on_ignored_nl on_op attribute on_period UNK on_period index on_lparen # foo will match xmlns:foo, but only if foo isn't also an attribute
