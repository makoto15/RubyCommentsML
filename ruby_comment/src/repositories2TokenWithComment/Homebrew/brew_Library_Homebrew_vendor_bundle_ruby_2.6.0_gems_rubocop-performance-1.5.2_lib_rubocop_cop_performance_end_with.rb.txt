on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_const on_op UNK on_tstring_content UNK # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op UNK on_tstring_content UNK UNK on_tstring_content UNK on_nl on_const on_op UNK on_tstring_content UNK on_nl # This cop identifies unnecessary use of a regex where `String#end_with?` # would suffice. # # @example # # bad # 'abc'.match?(/bc\Z/) # /bc\Z/.match?('abc') # 'abc' =~ /bc\Z/ # /bc\Z/ =~ 'abc' # 'abc'.match(/bc\Z/) # /bc\Z/.match('abc') # # # good # 'abc'.end_with?('bc')
regex_str on_op UNK on_tstring_content UNK on_const UNK on_tstring_content UNK on_nl end on_nl on_ignored_nl UNK UNK on_lparen node on_rparen on_ignored_nl UNK # is this regexp 'literal' in the sense of only matching literal # chars, rather than using metachars like . and * and so on? # also, is it anchored at the end of the string?
regex_str on_op UNK on_lparen regex_str on_rparen on_nl on_ignored_nl UNK UNK on_op UNK on_op on_ignored_nl UNK on_op UNK UNK UNK on_op # drop \Z anchor
