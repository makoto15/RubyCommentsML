on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
def on_op on_lparen other on_rparen on_ignored_nl UNK on_op on_lparen UNK on_op on_const on_op other on_period UNK on_lparen on_const on_op on_const # Overriding case equality method so that it returns true for ActiveSupport::TimeWithZone instances
def UNK on_lparen month on_comma year on_op UNK on_period year on_rparen on_ignored_nl if month on_op on_int on_op on_op on_const on_period # Returns the number of days in the given month. # If no year is specified, it will use the current year.
def UNK on_lparen year on_op UNK on_period year on_rparen on_ignored_nl UNK on_lparen on_int on_comma year on_rparen on_op on_int on_nl end # Returns the number of days in the given year. # If no year is specified, it will use the current year.
def UNK on_nl on_op on_const on_period UNK on_op on_op on_const on_period UNK on_period UNK on_op on_op on_const on_period UNK on_nl # Returns <tt>Time.zone.now</tt> when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns <tt>Time.now</tt>.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK UNK on_lparen on_op UNK on_rparen if UNK on_period UNK on_op on_int on_nl # Layers additional behavior on Time.at so that ActiveSupport::TimeWithZone and DateTime # instances can be used when called with a single argument
UNK on_op UNK on_period UNK on_nl on_ignored_nl if UNK on_period UNK on_lparen on_const on_op on_const on_rparen on_op UNK on_period UNK # Time.at can be called with a time or numerical value
def UNK on_lparen UNK on_rparen on_ignored_nl parts on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK on_const on_comma on_tstring_beg # Creates a +Time+ instance from an RFC 3339 string. # # Time.rfc3339('1999-12-31T14:00:00-10:00') # => 2000-01-01 00:00:00 -1000 # # If the time or offset components are missing then an +ArgumentError+ will be raised. # # Time.rfc3339('1999-12-31') # => ArgumentError: invalid date
def UNK on_nl UNK on_op change on_lparen on_label on_int on_rparen on_period UNK on_op on_lparen UNK on_op UNK on_rparen on_nl end # Returns the number of seconds since 00:00:00. # # Time.new(2012, 8, 29, 0, 0, 0).seconds_since_midnight # => 0.0 # Time.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296.0 # Time.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399.0
def UNK on_nl UNK on_period UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl # Returns the number of seconds until 23:59:59. # # Time.new(2012, 8, 29, 0, 0, 0).seconds_until_end_of_day # => 86399 # Time.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103 # Time.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def change on_lparen options on_rparen on_ignored_nl UNK on_op options on_period fetch on_lparen # Returns the fraction of a second as a +Rational+ # # Time.new(2012, 8, 29, 0, 0, 0.5).sec_fraction # => (1/2)
def change on_lparen options on_rparen on_ignored_nl UNK on_op options on_period fetch on_lparen on_symbeg year on_comma year on_rparen on_nl UNK on_op # Returns a new Time where one or more of the elements have been changed according # to the +options+ parameter. The time options (<tt>:hour</tt>, <tt>:min</tt>, # <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly, so if only # the hour is passed, then minute, sec, usec and nsec is set to 0. If the hour # and minute is passed, then sec, usec and nsec is set to 0. The +options+ parameter # takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, # <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>, # <tt>:offset</tt>. Pass either <tt>:usec</tt> or <tt>:nsec</tt>, not both. # # Time.new(2012, 8, 29, 22, 35, 0).change(day: 1) # => Time.new(2012, 8, 1, 22, 35, 0) # Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1) # => Time.new(1981, 8, 1, 22, 35, 0) # Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => Time.new(1981, 8, 29, 0, 0, 0)
def advance on_lparen options on_rparen on_ignored_nl UNK options on_lbracket on_symbeg UNK on_rbracket on_period UNK on_nl options on_lbracket on_symbeg UNK on_rbracket # Uses Date to provide precise Time calculations for years, months, and days # according to the proleptic Gregorian calendar. The +options+ parameter # takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>, # <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>, # <tt>:seconds</tt>. # # Time.new(2015, 8, 1, 14, 35, 0).advance(seconds: 1) # => 2015-08-01 14:35:01 -0700 # Time.new(2015, 8, 1, 14, 35, 0).advance(minutes: 1) # => 2015-08-01 14:36:00 -0700 # Time.new(2015, 8, 1, 14, 35, 0).advance(hours: 1) # => 2015-08-01 15:35:00 -0700 # Time.new(2015, 8, 1, 14, 35, 0).advance(days: 1) # => 2015-08-02 14:35:00 -0700 # Time.new(2015, 8, 1, 14, 35, 0).advance(weeks: 1) # => 2015-08-08 14:35:00 -0700
def UNK on_lparen seconds on_rparen on_ignored_nl since on_lparen on_op seconds on_rparen on_nl end on_nl on_ignored_nl def since on_lparen seconds on_rparen # Returns a new Time representing the time a number of seconds ago, this is basically a wrapper around the Numeric extension
def since on_lparen seconds on_rparen on_ignored_nl UNK on_op seconds on_nl UNK on_nl UNK on_period since on_lparen seconds on_rparen on_nl end # Returns a new Time representing the time a number of seconds since the instance time
def UNK on_nl change on_lparen on_label on_int on_rparen on_nl end on_nl alias on_symbeg UNK on_symbeg UNK on_nl alias on_symbeg UNK # Returns a new Time representing the start of the day (0:00)
def middle_of_day on_nl change on_lparen on_label on_int on_rparen on_nl end on_nl alias on_symbeg UNK on_symbeg middle_of_day on_nl alias on_symbeg UNK # Returns a new Time representing the middle of the day (12:00)
def UNK on_nl change on_lparen on_ignored_nl on_label on_int on_comma on_ignored_nl on_label on_int on_comma on_ignored_nl on_label on_int on_comma on_ignored_nl on_label on_const # Returns a new Time representing the end of the day, 23:59:59.999999
def UNK on_nl change on_lparen on_label on_int on_rparen on_nl end on_nl alias on_symbeg UNK on_symbeg UNK on_nl on_ignored_nl def UNK # Returns a new Time representing the start of the hour (x:00)
def UNK on_nl change on_lparen on_ignored_nl on_label on_int on_comma on_ignored_nl on_label on_int on_comma on_ignored_nl on_label on_const on_lparen on_int on_comma on_int # Returns a new Time representing the end of the hour, x:59:59.999999
def UNK on_nl change on_lparen on_label on_int on_rparen on_nl end on_nl alias on_symbeg UNK on_symbeg UNK on_nl on_ignored_nl def UNK # Returns a new Time representing the start of the minute (x:xx:00)
def UNK on_nl change on_lparen on_ignored_nl on_label on_int on_comma on_ignored_nl on_label on_const on_lparen on_int on_comma on_int on_rparen on_nl on_rparen on_nl # Returns a new Time representing the end of the minute, x:xx:59.999999
if on_const on_op on_const on_op other on_nl other on_period since on_lparen UNK on_rparen on_nl else on_ignored_nl UNK on_lparen other on_rparen #:nodoc:
if on_const on_op on_const on_op other on_nl other on_period UNK on_lparen UNK on_rparen on_nl else on_ignored_nl UNK on_lparen other on_rparen #:nodoc:
def UNK on_lparen other on_rparen on_ignored_nl other on_op other on_period UNK if other on_period UNK on_lparen on_symbeg UNK on_rparen on_nl # Time#- can also be used to determine the number of seconds between two Time instances. # We're layering on additional behavior so that ActiveSupport::TimeWithZone instances # are coerced into values that Time#- will recognize
def UNK on_lparen other on_rparen on_ignored_nl if other on_period UNK on_op on_const on_nl UNK on_lparen other on_rparen on_nl UNK other # Layers additional behavior on Time#<=> so that DateTime and ActiveSupport::TimeWithZone instances # can be chronologically compared with a Time
if other on_period UNK on_op on_const on_nl UNK on_lparen other on_rparen on_nl UNK other on_period UNK on_lparen on_const on_rparen on_nl # we're avoiding Time#to_datetime and Time#to_time because they're expensive
def UNK on_lparen other on_rparen on_ignored_nl other on_op other on_period UNK if other on_period UNK on_lparen on_symbeg UNK on_rparen on_nl # Layers additional behavior on Time#eql? so that ActiveSupport::TimeWithZone instances # can be eql? to an equivalent Time
other on_op other on_period UNK if other on_period UNK on_lparen on_symbeg UNK on_rparen on_nl UNK on_lparen other on_rparen on_nl end # if other is an ActiveSupport::TimeWithZone, coerce a Time instance from it so we can do eql? comparison
def UNK on_lparen days on_op on_int on_rparen on_ignored_nl advance on_lparen on_label on_op days on_rparen on_nl end on_nl on_ignored_nl def UNK # Returns a new time the specified number of days ago.
def UNK on_lparen days on_op on_int on_rparen on_ignored_nl advance on_lparen on_label days on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Returns a new time the specified number of days in the future.
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl advance on_lparen on_label on_op UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Returns a new time the specified number of months ago.
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl advance on_lparen on_label UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Returns a new time the specified number of months in the future.
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl advance on_lparen on_label on_op UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Returns a new time the specified number of years ago.
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl advance on_lparen on_label UNK on_rparen on_nl end on_nl end on_nl EMP EMP # Returns a new time the specified number of years in the future.
