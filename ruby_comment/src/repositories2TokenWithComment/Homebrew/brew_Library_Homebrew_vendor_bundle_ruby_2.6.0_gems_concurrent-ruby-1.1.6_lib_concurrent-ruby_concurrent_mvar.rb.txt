UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_nl UNK on_nl on_ignored_nl on_const on_op on_op on_const on_period # An `MVar` is a synchronized single element container. They are empty or # contain one item. Taking a value from an empty `MVar` blocks, as does # putting a value into a full one. You can either think of them as blocking # queue of length one, or a special kind of mutable variable. # # On top of the fundamental `#put` and `#take` operations, we also provide a # `#mutate` that is atomic with respect to operations on the same instance. # These operations all support timeouts. # # We also support non-blocking operations `#try_put!` and `#try_take!`, a # `#set!` that ignores existing values, a `#value` that returns the value # without removing it or returns `MVar::EMPTY`, and a `#modify!` that yields # `MVar::EMPTY` if the `MVar` is empty and can be used to set `MVar::EMPTY`. # You shouldn't use these operations in the first instance. # # `MVar` is a [Dereferenceable](Dereferenceable). # # `MVar` is related to M-structures in Id, `MVar` in Haskell and `SyncVar` in Scala. # # Note that unlike the original Haskell paper, our `#take` is blocking. This is how # Haskell and Scala do it today. # # @!macro copy_options # # ## See Also # # 1. P. Barth, R. Nikhil, and Arvind. [M-Structures: Extending a parallel, non- strict, functional language with state](http://dl.acm.org/citation.cfm?id=652538). In Proceedings of the 5th # ACM Conference on Functional Programming Languages and Computer Architecture (FPCA), 1991. # # 2. S. Peyton Jones, A. Gordon, and S. Finne. [Concurrent Haskell](http://dl.acm.org/citation.cfm?id=237794). # In Proceedings of the 23rd Symposium on Principles of Programming Languages # (PoPL), 1996.
on_const on_op on_op on_const on_period new on_nl on_ignored_nl on_const on_op on_op on_const on_period new on_nl on_ignored_nl def UNK on_lparen value # Unique value that represents that an `MVar` was empty
on_const on_op on_op on_const on_period new on_nl on_ignored_nl def UNK on_lparen value on_op on_const on_comma UNK on_op UNK UNK on_rparen # Unique value that represents that an `MVar` timed out before it was able # to produce a value.
def UNK on_lparen value on_op on_const on_comma UNK on_op UNK UNK on_rparen on_ignored_nl on_ivar on_op value on_nl on_ivar on_op on_const # Create a new `MVar`, either empty or with an initial value. # # @param [Hash] opts the options controlling how the future will be processed # # @!macro deref_options
def UNK on_lparen timeout on_op UNK on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl UNK on_lparen timeout on_rparen on_nl on_ignored_nl if # Remove the value from an `MVar`, leaving it empty, and blocking if there # isn't a value. A timeout can be set to limit the time spent blocked, in # which case it returns `TIMEOUT` if the time is exceeded. # @return [Object] the value that was taken, or `TIMEOUT`
if unlocked_full? on_nl value on_op on_ivar on_nl on_ivar on_op on_const on_nl on_ivar on_period signal on_nl apply_deref_options on_lparen value on_rparen on_nl # If we timed out we'll still be empty
def UNK on_lparen timeout on_op UNK on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl UNK on_lparen timeout on_rparen on_nl on_ignored_nl if # acquires lock on the from an `MVAR`, yields the value to provided block, # and release lock. A timeout can be set to limit the time spent blocked, # in which case it returns `TIMEOUT` if the time is exceeded. # @return [Object] the value returned by the block, or `TIMEOUT`
if unlocked_full? on_nl UNK on_ivar on_nl else on_ignored_nl on_const on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen # if we timeoud out we'll still be empty
def UNK on_lparen value on_comma timeout on_op UNK on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl UNK on_lparen timeout on_rparen on_nl # Put a value into an `MVar`, blocking if there is already a value until # it is empty. A timeout can be set to limit the time spent blocked, in # which case it returns `TIMEOUT` if the time is exceeded. # @return [Object] the value that was put, or `TIMEOUT`
if unlocked_empty? on_nl on_ivar on_op value on_nl on_ivar on_period signal on_nl apply_deref_options on_lparen value on_rparen on_nl else on_ignored_nl on_const on_nl # If we timed out we won't be empty
def UNK on_lparen timeout on_op UNK on_rparen on_ignored_nl UNK on_const on_period new on_lparen UNK UNK UNK on_rparen UNK UNK on_nl # Atomically `take`, yield the value to a block for transformation, and then # `put` the transformed value. Returns the transformed value. A timeout can # be set to limit the time spent blocked, in which case it returns `TIMEOUT` # if the time is exceeded. # @return [Object] the transformed value, or `TIMEOUT`
if unlocked_full? on_nl value on_op on_ivar on_nl on_ivar on_op UNK value on_nl on_ivar on_period signal on_nl apply_deref_options on_lparen value on_rparen # If we timed out we'll still be empty
def UNK on_nl on_ivar on_period synchronize do on_ignored_nl if unlocked_full? on_nl value on_op on_ivar on_nl on_ivar on_op on_const on_nl on_ivar # Non-blocking version of `take`, that returns `EMPTY` instead of blocking.
def UNK on_lparen value on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl if unlocked_empty? on_nl on_ivar on_op value on_nl on_ivar on_period # Non-blocking version of `put`, that returns whether or not it was successful.
def UNK on_lparen value on_rparen on_ignored_nl on_ivar on_period synchronize do on_ignored_nl UNK on_op on_ivar on_nl on_ivar on_op value on_nl on_ivar # Non-blocking version of `put` that will overwrite an existing value.
def UNK on_nl UNK on_const on_period new on_lparen UNK UNK UNK on_rparen UNK UNK on_nl on_ignored_nl on_ivar on_period synchronize do # Non-blocking version of `modify` that will yield with `EMPTY` if there is no value yet.
def UNK on_nl on_ivar on_period synchronize UNK on_ivar on_op on_const UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_op UNK # Returns if the `MVar` is currently empty.
def UNK on_nl on_op UNK on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def synchronize on_lparen on_op UNK on_rparen on_ignored_nl on_ivar # Returns if the `MVar` currently contains a value.
