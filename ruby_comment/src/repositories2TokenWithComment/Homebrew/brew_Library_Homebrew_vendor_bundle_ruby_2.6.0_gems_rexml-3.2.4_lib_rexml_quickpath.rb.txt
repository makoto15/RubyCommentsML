UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl # frozen_string_literal: false
on_const on_op on_lbrace on_rbrace on_nl on_ignored_nl def on_const on_op UNK element on_comma path on_comma namespaces on_op on_const on_nl UNK on_lparen # A base Hash object to be used when initializing a # default empty namespaces set.
path on_op path on_lbracket on_int on_op on_op on_int on_rbracket on_nl return on_lbracket element on_period UNK on_period parent on_rbracket if path # match on root
UNK on_op element on_period to_a on_nl results on_op filter on_lparen UNK on_comma path on_rparen on_nl UNK on_ignored_nl results on_op filter # match on child
def on_const on_op filter elements on_comma path on_nl return elements if path on_period UNK UNK path on_op on_tstring_beg on_tstring_end UNK # Given an array of nodes it filters the array based on the path. The # result is that when this method returns, the array will contain elements # which match the path
return UNK on_lparen elements on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_backref on_rparen on_nl when on_regexp_beg on_tstring_content on_regexp_end return UNK on_lparen elements # Descendant
return UNK on_lparen elements on_comma on_backref on_comma on_backref on_rparen on_nl when on_regexp_beg on_tstring_content on_regexp_end rest on_op on_backref on_nl results on_op # Axe
rest on_op on_backref on_nl results on_op on_lbracket on_rbracket on_nl elements on_period each do on_op element on_op on_ignored_nl results on_op filter # Child
return UNK on_lparen elements on_comma on_backref on_comma on_backref on_rparen on_nl when on_const on_op on_const name on_op on_backref on_nl UNK on_op # / Function
name on_op on_backref on_nl UNK on_op on_backref on_nl rest on_op on_backref on_nl elements on_period UNK do on_op element on_op on_ignored_nl # Element name
return predicate on_lparen elements on_comma path on_rparen on_nl when on_regexp_beg on_tstring_content on_regexp_end return UNK on_lparen elements on_comma on_tstring_beg on_tstring_content on_tstring_end # Predicate
return UNK on_lparen elements on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_backref on_rparen on_nl when on_regexp_beg on_tstring_content on_regexp_end return filter on_lparen elements # Ancestor
return filter on_lparen elements on_period UNK on_lbrace on_op UNK on_op UNK on_period parent on_rbrace on_comma on_backref on_rparen on_nl when on_regexp_beg # Parent
return filter on_lparen elements on_comma on_backref on_rparen on_nl when on_regexp_beg on_tstring_content on_regexp_end results on_op on_lbracket on_rbracket on_nl elements on_period each # Self
results on_op on_lbracket on_rbracket on_nl elements on_period each do on_op element on_op on_ignored_nl results on_op filter on_lparen on_lbracket element on_rbracket # Any
end on_nl return results on_nl end on_nl return on_lbracket on_rbracket on_nl end on_nl on_ignored_nl def on_const on_op UNK on_lparen elements #if element.kind_of? Element # children = element.to_a # children.delete_if { |child| !child.kind_of?(Element) } # results |= filter( children, $' ) #end
def on_const on_op predicate on_lparen elements on_comma path on_rparen on_ignored_nl ind on_op on_int on_nl UNK on_op on_int on_nl UNK UNK # A predicate filters a node-set with respect to an axis to produce a # new node-set. For each node in the node-set to be filtered, the # PredicateExpr is evaluated with that node as the context node, with # the number of nodes in the node-set as the context size, and with the # proximity position of the node in the node-set with respect to the # axis as the context position; if PredicateExpr evaluates to true for # that node, the node is included in the new node-set; otherwise, it is # not included. # # A PredicateExpr is evaluated by evaluating the Expr and converting # the result to a boolean. If the result is a number, the result will # be converted to true if the number is equal to the context position # and will be converted to false otherwise; if the result is not a # number, then the result will be converted as if by a call to the # boolean function. Thus a location path para[3] is equivalent to # para[position()=3].
predicate on_period gsub! on_lparen on_ignored_nl on_regexp_beg on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg on_const on_embexpr_end on_regexp_end on_comma on_ignored_nl # have to change 'a [=<>] b [=<>] c' into 'a [=<>] b and b [=<>] c' #
predicate on_period gsub! on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl predicate on_period gsub! on_lparen on_regexp_beg on_tstring_content on_regexp_end # Let's do some Ruby trickery to avoid some work:
UNK on_op on_lbracket on_rbracket on_nl UNK on_op on_tstring_beg on_tstring_end on_nl UNK string UNK string on_op on_tstring_beg on_tstring_end on_nl UNK on_op # /.*?(?:\)|,)/
UNK on_op UNK on_lparen UNK on_rparen on_nl when UNK on_nl UNK on_lparen element on_comma UNK on_comma string on_rparen on_nl UNK # if depth = 1, then we start a new argument
when UNK on_nl UNK on_lparen element on_comma UNK on_comma string on_rparen on_nl UNK on_op on_tstring_beg on_tstring_end on_nl when UNK on_nl #arguments << evaluate( string[0..count] )
UNK on_lparen element on_comma UNK on_comma string on_rparen on_nl UNK on_op on_tstring_beg on_tstring_end on_nl when UNK on_nl return UNK on_nl # start a new method call
return UNK on_nl UNK on_ignored_nl UNK on_op UNK on_nl end on_nl end on_nl on_tstring_beg on_tstring_end on_nl end on_nl end on_nl # close the method call and return arguments
