on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK UNK on_nl on_ignored_nl def UNK on_lparen # frozen_string_literal: true
UNK on_const on_nl UNK UNK on_nl on_ignored_nl def UNK on_lparen word on_comma locale on_op UNK UNK on_rparen on_ignored_nl UNK on_lparen # The Inflector transforms words from singular to plural, class names to table # names, modularized class names to ones without, and class names to foreign # keys. The default inflections for pluralization, singularization, and # uncountable words are kept in inflections.rb. # # The Rails core team has stated patches for the inflections library will not # be accepted in order to avoid breaking legacy applications which may be # relying on errant inflections. If you discover an incorrect inflection and # require it for your application or wish to define rules for languages other # than English, please correct or add them yourself (explained below).
def UNK on_lparen word on_comma locale on_op UNK UNK on_rparen on_ignored_nl UNK on_lparen word on_comma inflections on_lparen locale on_rparen on_period # Returns the plural form of the word in the string. # # If passed an optional +locale+ parameter, the word will be # pluralized using rules defined for that language. By default, # this parameter is set to <tt>:en</tt>. # # pluralize('post') # => "posts" # pluralize('octopus') # => "octopi" # pluralize('sheep') # => "sheep" # pluralize('words') # => "words" # pluralize('CamelOctopus') # => "CamelOctopi" # pluralize('ley', :es) # => "leyes"
def UNK on_lparen word on_comma locale on_op UNK UNK on_rparen on_ignored_nl UNK on_lparen word on_comma inflections on_lparen locale on_rparen on_period # The reverse of #pluralize, returns the singular form of a word in a # string. # # If passed an optional +locale+ parameter, the word will be # singularized using rules defined for that language. By default, # this parameter is set to <tt>:en</tt>. # # singularize('posts') # => "post" # singularize('octopi') # => "octopus" # singularize('sheep') # => "sheep" # singularize('word') # => "word" # singularize('CamelOctopi') # => "CamelOctopus" # singularize('leyes', :es) # => "ley"
def UNK on_lparen UNK on_comma UNK on_op UNK on_rparen on_ignored_nl string on_op UNK on_period to_s on_nl if UNK on_nl string # Converts strings to UpperCamelCase. # If the +uppercase_first_letter+ parameter is set to false, then produces # lowerCamelCase. # # Also converts '/' to '::' which is useful for converting # paths to namespaces. # # camelize('active_model') # => "ActiveModel" # camelize('active_model', false) # => "activeModel" # camelize('active_model/errors') # => "ActiveModel::Errors" # camelize('active_model/errors', false) # => "activeModel::Errors" # # As a rule of thumb you can think of +camelize+ as the inverse of # #underscore, though there are cases where that does not hold: # # camelize(underscore('SSLError')) # => "SslError"
def UNK on_lparen camel_cased_word on_rparen on_ignored_nl UNK camel_cased_word UNK on_regexp_beg on_tstring_content on_regexp_end on_period UNK on_lparen camel_cased_word on_rparen on_nl word on_op # Makes an underscored, lowercase form from the expression in the string. # # Changes '::' to '/' to convert namespaces to paths. # # underscore('ActiveModel') # => "active_model" # underscore('ActiveModel::Errors') # => "active_model/errors" # # As a rule of thumb you can think of +underscore+ as the inverse of # #camelize, though there are cases where that does not hold: # # camelize(underscore('SSLError')) # => "SslError"
def UNK on_lparen UNK on_comma on_label UNK on_comma on_label UNK on_rparen on_ignored_nl result on_op UNK on_period to_s on_period UNK on_nl # Tweaks an attribute name for display to end users. # # Specifically, performs these transformations: # # * Applies human inflection rules to the argument. # * Deletes leading underscores, if any. # * Removes a "_id" suffix if present. # * Replaces underscores with spaces, if any. # * Downcases all words except acronyms. # * Capitalizes the first word. # The capitalization of the first word can be turned off by setting the # +:capitalize+ option to false (default is true). # # The trailing '_id' can be kept and capitalized by setting the # optional parameter +keep_id_suffix+ to true (default is false). # # humanize('employee_salary') # => "Employee salary" # humanize('author_id') # => "Author" # humanize('author_id', capitalize: false) # => "author" # humanize('_id') # => "Id" # humanize('author_id', keep_id_suffix: true) # => "Author Id" # # If "SSL" was defined to be an acronym: # # humanize('ssl_error') # => "SSL error" #
def UNK on_lparen string on_rparen on_ignored_nl string on_period UNK on_op on_int on_op string on_lbracket on_int on_rbracket on_period UNK on_period UNK # Converts just the first character to uppercase. # # upcase_first('what a Lovely Day') # => "What a Lovely Day" # upcase_first('w') # => "W" # upcase_first('') # => ""
def UNK on_lparen word on_comma on_label UNK on_rparen on_ignored_nl UNK on_lparen UNK on_lparen word on_rparen on_comma on_label UNK on_rparen on_period # Capitalizes all the words and replaces some characters in the string to # create a nicer looking title. +titleize+ is meant for creating pretty # output. It is not used in the Rails internals. # # The trailing '_id','Id'.. can be kept and capitalized by setting the # optional parameter +keep_id_suffix+ to true. # By default, this parameter is false. # # +titleize+ is also aliased as +titlecase+. # # titleize('man from the boondocks') # => "Man From The Boondocks" # titleize('x-men: the last stand') # => "X Men: The Last Stand" # titleize('TheManWithoutAPast') # => "The Man Without A Past" # titleize('raiders_of_the_lost_ark') # => "Raiders Of The Lost Ark" # titleize('string_ending_with_id', keep_id_suffix: true) # => "String Ending With Id"
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen UNK on_lparen UNK on_rparen on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Creates the name of a table like Rails does for models to table names. # This method uses the #pluralize method on the last word in the string. # # tableize('RawScaledScorer') # => "raw_scaled_scorers" # tableize('ham_and_egg') # => "ham_and_eggs" # tableize('fancyCategory') # => "fancy_categories"
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen UNK on_lparen UNK on_period to_s on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma # Creates a class name from a plural table name like Rails does for table # names to models. Note that this returns a string and not a Class (To # convert to an actual class follow +classify+ with #constantize). # # classify('ham_and_eggs') # => "HamAndEgg" # classify('posts') # => "Post" # # Singular names are not handled correctly: # # classify('calculus') # => "Calculu"
UNK on_lparen UNK on_lparen UNK on_period to_s on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_end on_rparen on_rparen on_rparen on_nl # strip out any leading schema name
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end # Replaces underscores with dashes in the string. # # dasherize('puni_puni') # => "puni-puni"
def UNK on_lparen path on_rparen on_ignored_nl path on_op path on_period to_s on_nl if UNK on_op path on_period UNK on_lparen on_tstring_beg # Removes the module part from the expression in the string. # # demodulize('ActiveSupport::Inflector::Inflections') # => "Inflections" # demodulize('Inflections') # => "Inflections" # demodulize('::Inflections') # => "Inflections" # demodulize('') # => "" # # See also #deconstantize.
def UNK on_lparen path on_rparen on_ignored_nl path on_period to_s on_lbracket on_int on_comma path on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen # Removes the rightmost segment from the constant expression in the string. # # deconstantize('Net::HTTP') # => "Net" # deconstantize('::Net::HTTP') # => "::Net" # deconstantize('String') # => "" # deconstantize('::String') # => "" # deconstantize('') # => "" # # See also #demodulize.
end on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_op UNK on_rparen on_ignored_nl UNK on_lparen UNK on_lparen UNK on_rparen on_rparen # implementation based on the one in facets' Module#spacename
def UNK on_lparen UNK on_comma UNK on_op UNK on_rparen on_ignored_nl UNK on_lparen UNK on_lparen UNK on_rparen on_rparen on_op on_lparen UNK # Creates a foreign key name from a class name. # +separate_class_name_and_id_with_underscore+ sets whether # the method should put '_' between the name and 'id'. # # foreign_key('Message') # => "message_id" # foreign_key('Message', false) # => "messageid" # foreign_key('Admin::Post') # => "post_id"
def UNK on_lparen camel_cased_word on_rparen on_ignored_nl names on_op camel_cased_word on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl on_const on_period # Tries to find a constant with the name specified in the argument string. # # constantize('Module') # => Module # constantize('Foo::Bar') # => Foo::Bar # # The name is assumed to be the one of a top-level constant, no matter # whether it starts with "::" or not. No lexical context is taken into # account: # # C = 'outside' # module M # C = 'inside' # C # => 'inside' # constantize('C') # => 'outside', same as ::C # end # # NameError is raised when the name is not in CamelCase or the constant is # unknown.
on_const on_period UNK on_lparen camel_cased_word on_rparen if names on_period UNK on_nl on_ignored_nl names on_period UNK if names on_period UNK on_op # Trigger a built-in NameError exception including the ill-formed constant in the message.
names on_period UNK if names on_period UNK on_op on_int on_op names on_period UNK on_period UNK on_nl on_ignored_nl names on_period UNK # Remove the first blank element in case of '::ClassName' notation.
constant on_op constant on_period UNK on_period UNK on_lparen constant on_rparen UNK on_op UNK on_comma UNK on_op on_ignored_nl UNK UNK if # Go down the ancestors to check if it is owned directly. The check # stops when we reach Object or the end of ancestors tree.
constant on_period UNK on_lparen name on_comma UNK on_rparen on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen camel_cased_word # owner is in Object, so raise
def UNK on_lparen camel_cased_word on_rparen on_ignored_nl UNK on_lparen camel_cased_word on_rparen on_nl UNK on_const on_op e on_nl UNK if e on_period # Tries to find a constant with the name specified in the argument string. # # safe_constantize('Module') # => Module # safe_constantize('Foo::Bar') # => Foo::Bar # # The name is assumed to be the one of a top-level constant, no matter # whether it starts with "::" or not. No lexical context is taken into # account: # # C = 'outside' # module M # C = 'inside' # C # => 'inside' # safe_constantize('C') # => 'outside', same as ::C # end # # +nil+ is returned when the name is not in CamelCase or the constant (or # part of it) is unknown. # # safe_constantize('blargle') # => nil # safe_constantize('UnknownModule') # => nil # safe_constantize('UnknownModule::Foo::Bar') # => nil
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_label UNK on_rparen on_nl end on_nl # Returns the suffix that should be added to a number to denote the position # in an ordered sequence such as 1st, 2nd, 3rd, 4th. # # ordinal(1) # => "st" # ordinal(2) # => "nd" # ordinal(1002) # => "nd" # ordinal(1003) # => "rd" # ordinal(-11) # => "th" # ordinal(-1021) # => "st"
def UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_label UNK on_rparen on_nl end on_nl # Turns a number into an ordinal string used to denote the position in an # ordered sequence such as 1st, 2nd, 3rd, 4th. # # ordinalize(1) # => "1st" # ordinalize(2) # => "2nd" # ordinalize(1002) # => "1002nd" # ordinalize(1003) # => "1003rd" # ordinalize(-11) # => "-11th" # ordinalize(-1021) # => "-1021st"
def UNK on_lparen camel_cased_word on_rparen on_ignored_nl UNK on_op camel_cased_word on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl on_ignored_nl UNK on_const # Mounts a regular expression, returned as a string to ease interpolation, # that will match part by part the given constant. # # const_regexp("Foo::Bar::Baz") # => "Foo(::Bar(::Baz)?)?" # const_regexp("::") # => "::"
def UNK on_lparen word on_comma UNK on_comma locale on_op UNK UNK on_rparen on_ignored_nl result on_op word on_period to_s on_period UNK # Applies inflection rules for +singularize+ and +pluralize+. # # If passed an optional +locale+ parameter, the uncountables will be # found for that locale. # # apply_inflections('post', inflections.plurals, :en) # => "posts" # apply_inflections('posts', inflections.singulars, :en) # => "post"
