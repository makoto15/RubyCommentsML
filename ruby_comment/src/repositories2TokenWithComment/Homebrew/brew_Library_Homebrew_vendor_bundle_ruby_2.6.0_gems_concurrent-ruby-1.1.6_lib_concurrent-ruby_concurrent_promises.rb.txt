module on_const on_nl on_ignored_nl on_ignored_nl module on_const on_nl UNK on_const on_nl UNK self on_nl on_ignored_nl module on_const on_nl def default_executor # {include:file:docs-source/promises-main.md}
on_ignored_nl module on_const on_nl UNK on_const on_nl UNK self on_nl on_ignored_nl module on_const on_nl def default_executor on_nl on_symbeg UNK on_nl # @!macro promises.param.default_executor # @param [Executor, :io, :fast] default_executor Instance of an executor or a name of the # global executor. Default executor propagates to chained futures unless overridden with # executor parameter or changed with {AbstractEventFuture#with_default_executor}. # # @!macro promises.param.executor # @param [Executor, :io, :fast] executor Instance of an executor or a name of the # global executor. The task is executed on it, default executor remains unchanged. # # @!macro promises.param.args # @param [Object] args arguments which are passed to the task when it's executed. # (It might be prepended with other arguments, see the @yeild section). # # @!macro promises.shortcut.on # Shortcut of {#$0_on} with default `:io` executor supplied. # @see #$0_on # # @!macro promises.shortcut.using # Shortcut of {#$0_using} with default `:io` executor supplied. # @see #$0_using # # @!macro promise.param.task-future # @yieldreturn will become result of the returned Future. # Its returned value becomes {Future#value} fulfilling it, # raised exception becomes {Future#reason} rejecting it. # # @!macro promise.param.callback # @yieldreturn is forgotten.
module on_const on_nl UNK on_const on_nl UNK self on_nl on_ignored_nl module on_const on_nl def default_executor on_nl on_symbeg UNK on_nl end # Container of all {Future}, {Event} factory methods. They are never constructed directly with # new.
def default_executor on_nl on_symbeg UNK on_nl end on_nl end on_nl on_ignored_nl include on_const on_nl on_ignored_nl def UNK on_nl UNK default_executor # @return [Executor, :io, :fast] the executor which is used when none is supplied # to a factory method. The method can be overridden in the receivers of # `include FactoryMethod`
def UNK on_nl UNK default_executor on_nl end on_nl on_ignored_nl def UNK on_lparen default_executor on_op self on_period default_executor on_rparen on_ignored_nl on_const # @!macro promises.shortcut.on # @return [ResolvableEvent]
def UNK on_lparen default_executor on_op self on_period default_executor on_rparen on_ignored_nl on_const on_period new on_lparen default_executor on_rparen on_period future on_nl end # Created resolvable event, user is responsible for resolving the event once by # {Promises::ResolvableEvent#resolve}. # # @!macro promises.param.default_executor # @return [ResolvableEvent]
def UNK on_nl UNK default_executor on_nl end on_nl on_ignored_nl def UNK on_lparen default_executor on_op self on_period default_executor on_rparen on_ignored_nl on_const # @!macro promises.shortcut.on # @return [ResolvableFuture]
def UNK on_lparen default_executor on_op self on_period default_executor on_rparen on_ignored_nl on_const on_period new on_lparen default_executor on_rparen on_period future on_nl end # Creates resolvable future, user is responsible for resolving the future once by # {Promises::ResolvableFuture#resolve}, {Promises::ResolvableFuture#fulfill}, # or {Promises::ResolvableFuture#reject} # # @!macro promises.param.default_executor # @return [ResolvableFuture]
def future on_lparen on_op args on_comma on_op task on_rparen on_ignored_nl UNK on_lparen default_executor on_comma on_op args on_comma on_op task on_rparen # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen default_executor on_comma on_op args on_comma on_op task on_rparen on_ignored_nl on_const on_period new on_lparen default_executor on_rparen on_period future # Constructs new Future which will be resolved after block is evaluated on default executor. # Evaluation begins immediately. # # @!macro promises.param.default_executor # @!macro promises.param.args # @yield [*args] to the task. # @!macro promise.param.task-future # @return [Future]
def resolved_future on_lparen fulfilled on_comma value on_comma reason on_comma default_executor on_op self on_period default_executor on_rparen on_ignored_nl on_const on_period new on_lparen # Creates resolved future with will be either fulfilled with the given value or rejection with # the given reason. # # @param [true, false] fulfilled # @param [Object] value # @param [Object] reason # @!macro promises.param.default_executor # @return [Future]
def UNK on_lparen value on_comma default_executor on_op self on_period default_executor on_rparen on_ignored_nl resolved_future true on_comma value on_comma nil on_comma default_executor # Creates resolved future with will be fulfilled with the given value. # # @!macro promises.param.default_executor # @param [Object] value # @return [Future]
def UNK on_lparen reason on_comma default_executor on_op self on_period default_executor on_rparen on_ignored_nl resolved_future false on_comma nil on_comma reason on_comma default_executor # Creates resolved future with will be rejected with the given reason. # # @!macro promises.param.default_executor # @param [Object] reason # @return [Future]
def UNK on_lparen default_executor on_op self on_period default_executor on_rparen on_ignored_nl on_const on_period new on_lparen default_executor on_rparen on_period event on_nl end # Creates resolved event. # # @!macro promises.param.default_executor # @return [Event]
def UNK on_lparen UNK on_op nil on_comma default_executor on_op self on_period default_executor on_rparen on_ignored_nl UNK UNK on_nl UNK on_const on_nl # General constructor. Behaves differently based on the argument's type. It's provided for convenience # but it's better to be explicit. # # @see rejected_future, resolved_event, fulfilled_future # @!macro promises.param.default_executor # @return [Event, Future] # # @overload make_future(nil, default_executor = self.default_executor) # @param [nil] nil # @return [Event] resolved event. # # @overload make_future(a_future, default_executor = self.default_executor) # @param [Future] a_future # @return [Future] a future which will be resolved when a_future is. # # @overload make_future(an_event, default_executor = self.default_executor) # @param [Event] an_event # @return [Event] an event which will be resolved when an_event is. # # @overload make_future(exception, default_executor = self.default_executor) # @param [Exception] exception # @return [Future] a rejected future with the exception as its reason. # # @overload make_future(value, default_executor = self.default_executor) # @param [Object] value when none of the above overloads fits # @return [Future] a fulfilled future with the value.
UNK on_nl UNK on_const on_nl UNK UNK on_comma default_executor on_nl UNK nil on_nl UNK default_executor on_nl else on_ignored_nl UNK UNK # returning wrapper would change nothing
def UNK on_lparen on_op args on_comma on_op task on_rparen on_ignored_nl UNK default_executor on_comma on_op args on_comma on_op task on_nl end # @!macro promises.shortcut.on # @return [Future, Event]
def UNK on_lparen default_executor on_comma on_op args on_comma on_op task on_rparen on_ignored_nl event on_op on_const on_period new on_lparen default_executor on_rparen # Creates new event or future which is resolved only after it is touched, # see {Concurrent::AbstractEventFuture#touch}. # # @!macro promises.param.default_executor # @overload delay_on(default_executor, *args, &task) # If task is provided it returns a {Future} representing the result of the task. # @!macro promises.param.args # @yield [*args] to the task. # @!macro promise.param.task-future # @return [Future] # @overload delay_on(default_executor) # If no task is provided, it returns an {Event} # @return [Event]
def UNK on_lparen intended_time on_comma on_op args on_comma on_op task on_rparen on_ignored_nl UNK default_executor on_comma intended_time on_comma on_op args on_comma # @!macro promises.shortcut.on # @return [Future, Event]
def UNK on_lparen default_executor on_comma intended_time on_comma on_op args on_comma on_op task on_rparen on_ignored_nl event on_op on_const on_period new on_lparen # Creates new event or future which is resolved in intended_time. # # @!macro promises.param.default_executor # @!macro promises.param.intended_time # @param [Numeric, Time] intended_time `Numeric` means to run in `intended_time` seconds. # `Time` means to run on `intended_time`. # @overload schedule_on(default_executor, intended_time, *args, &task) # If task is provided it returns a {Future} representing the result of the task. # @!macro promises.param.args # @yield [*args] to the task. # @!macro promise.param.task-future # @return [Future] # @overload schedule_on(default_executor, intended_time) # If no task is provided, it returns an {Event} # @return [Event]
def UNK on_lparen on_op futures_and_or_events on_rparen on_ignored_nl UNK default_executor on_comma on_op futures_and_or_events on_nl end on_nl on_ignored_nl def UNK on_lparen default_executor # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen default_executor on_comma on_op futures_and_or_events on_rparen on_ignored_nl on_const on_period new_blocked_by on_lparen futures_and_or_events on_comma default_executor on_rparen on_period future on_nl # Creates new future which is resolved after all futures_and_or_events are resolved. # Its value is array of zipped future values. Its reason is array of reasons for rejection. # If there is an error it rejects. # @!macro promises.event-conversion # If event is supplied, which does not have value and can be only resolved, it's # represented as `:fulfilled` with value `nil`. # # @!macro promises.param.default_executor # @param [AbstractEventFuture] futures_and_or_events # @return [Future]
def UNK on_lparen on_op futures_and_or_events on_rparen on_ignored_nl UNK default_executor on_comma on_op futures_and_or_events on_nl end on_nl on_ignored_nl def UNK on_lparen default_executor # @!macro promises.shortcut.on # @return [Event]
def UNK on_lparen default_executor on_comma on_op futures_and_or_events on_rparen on_ignored_nl on_const on_period new_blocked_by on_lparen futures_and_or_events on_comma default_executor on_rparen on_period event on_nl # Creates new event which is resolved after all futures_and_or_events are resolved. # (Future is resolved when fulfilled or rejected.) # # @!macro promises.param.default_executor # @param [AbstractEventFuture] futures_and_or_events # @return [Event]
def UNK on_lparen on_op futures_and_or_events on_rparen on_ignored_nl UNK default_executor on_comma on_op futures_and_or_events on_nl end on_nl on_ignored_nl alias_method on_symbeg UNK on_comma # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen default_executor on_comma on_op futures_and_or_events on_rparen on_ignored_nl on_const on_period new_blocked_by on_lparen futures_and_or_events on_comma default_executor on_rparen on_period future on_nl # Creates new future which is resolved after first futures_and_or_events is resolved. # Its result equals result of the first resolved future. # @!macro promises.any-touch # If resolved it does not propagate {Concurrent::AbstractEventFuture#touch}, leaving delayed # futures un-executed if they are not required any more. # @!macro promises.event-conversion # # @!macro promises.param.default_executor # @param [AbstractEventFuture] futures_and_or_events # @return [Future]
def UNK on_lparen on_op futures_and_or_events on_rparen on_ignored_nl UNK default_executor on_comma on_op futures_and_or_events on_nl end on_nl on_ignored_nl def UNK on_lparen default_executor # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen default_executor on_comma on_op futures_and_or_events on_rparen on_ignored_nl on_const on_period new_blocked_by on_lparen futures_and_or_events on_comma default_executor on_rparen on_period future on_nl # Creates new future which is resolved after first of futures_and_or_events is fulfilled. # Its result equals result of the first resolved future or if all futures_and_or_events reject, # it has reason of the last resolved future. # @!macro promises.any-touch # @!macro promises.event-conversion # # @!macro promises.param.default_executor # @param [AbstractEventFuture] futures_and_or_events # @return [Future]
def UNK on_lparen on_op futures_and_or_events on_rparen on_ignored_nl UNK default_executor on_comma on_op futures_and_or_events on_nl end on_nl on_ignored_nl def UNK on_lparen default_executor # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen default_executor on_comma on_op futures_and_or_events on_rparen on_ignored_nl on_const on_period new_blocked_by on_lparen futures_and_or_events on_comma default_executor on_rparen on_period event on_nl # Creates new event which becomes resolved after first of the futures_and_or_events resolves. # @!macro promises.any-touch # # @!macro promises.param.default_executor # @param [AbstractEventFuture] futures_and_or_events # @return [Event]
end on_nl on_ignored_nl module on_const on_nl class on_const on_nl def resolved? on_nl raise on_const on_nl end on_nl on_ignored_nl def to_sym # TODO consider adding first(count, *futures) # TODO consider adding zip_by(slice, *futures) processing futures in slices # TODO or rather a generic aggregator taking a function
class on_const on_nl def resolved? on_nl raise on_const on_nl end on_nl on_ignored_nl def to_sym on_nl raise on_const on_nl end on_nl # @!visibility private
class on_const on_op on_const on_nl def resolved? on_nl false on_nl end on_nl on_ignored_nl def to_sym on_nl on_symbeg UNK on_nl end # @!visibility private
class on_const on_op on_const on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl def resolved? on_nl true on_nl end on_nl # @!visibility private
class on_const on_op on_const on_nl def resolved? on_nl true on_nl end on_nl on_ignored_nl def to_sym on_nl on_symbeg UNK on_nl end # @!visibility private
class on_const on_op on_const on_nl on_ignored_nl def initialize on_lparen value on_rparen on_ignored_nl on_ivar on_op value on_nl end on_nl on_ignored_nl def # @!visibility private
class on_const on_op on_const on_nl def apply on_lparen args on_comma block on_rparen on_ignored_nl block on_period call on_lparen on_op value on_comma # @!visibility private
class on_const on_op on_const on_nl def initialize on_lparen reason on_rparen on_ignored_nl on_ivar on_op reason on_nl end on_nl on_ignored_nl def fulfilled? # @!visibility private
class on_const on_op on_const on_nl def initialize on_lparen value on_comma reason on_rparen on_ignored_nl super on_lparen on_rparen on_nl on_ivar on_op value # @!visibility private
on_const on_op on_const on_period new on_nl on_const on_op on_const on_period new on_nl on_const on_op on_const on_period new on_lparen nil on_rparen # @!visibility private
on_const on_op on_const on_period new on_nl on_const on_op on_const on_period new on_lparen nil on_rparen on_nl on_ignored_nl def on_const on_period to_sym # @!visibility private
on_const on_op on_const on_period new on_lparen nil on_rparen on_nl on_ignored_nl def on_const on_period to_sym on_nl on_symbeg UNK on_nl end on_nl # @!visibility private
on_ignored_nl on_ignored_nl on_ignored_nl class on_const on_op on_const on_op on_const on_nl UNK on_nl UNK on_lparen on_symbeg internal_state on_rparen on_nl private on_symbeg # @!macro promises.shortcut.event-future # @see Event#$0 # @see Future#$0
on_ignored_nl on_ignored_nl class on_const on_op on_const on_op on_const on_nl UNK on_nl UNK on_lparen on_symbeg internal_state on_rparen on_nl private on_symbeg UNK # @!macro promises.param.timeout # @param [Numeric] timeout the maximum time in second to wait.
on_ignored_nl class on_const on_op on_const on_op on_const on_nl UNK on_nl UNK on_lparen on_symbeg internal_state on_rparen on_nl private on_symbeg UNK on_comma # @!macro promises.warn.blocks # @note This function potentially blocks current thread until the Future is resolved. # Be careful it can deadlock. Try to chain instead.
class on_const on_op on_const on_op on_const on_nl UNK on_nl UNK on_lparen on_symbeg internal_state on_rparen on_nl private on_symbeg UNK on_comma on_symbeg # Common ancestor of {Event} and {Future} classes, many shared methods are defined here.
on_ignored_nl include on_const on_nl on_ignored_nl def initialize on_lparen promise on_comma default_executor on_rparen on_ignored_nl super on_lparen on_rparen on_nl on_ivar on_op on_const # @!method internal_state # @!visibility private
def state on_nl internal_state on_period to_sym on_nl end on_nl on_ignored_nl def UNK on_nl on_op internal_state on_period resolved? on_nl end on_nl # Returns its state. # @return [Symbol] # # @overload an_event.state # @return [:pending, :resolved] # @overload a_future.state # Both :fulfilled, :rejected implies :resolved. # @return [:pending, :fulfilled, :rejected]
def UNK on_nl on_op internal_state on_period resolved? on_nl end on_nl on_ignored_nl def resolved? on_nl internal_state on_period resolved? on_nl end on_nl # Is it in pending state? # @return [Boolean]
def resolved? on_nl internal_state on_period resolved? on_nl end on_nl on_ignored_nl def touch on_nl on_ivar on_period touch on_nl self on_nl end # Is it in resolved state? # @return [Boolean]
def touch on_nl on_ivar on_period touch on_nl self on_nl end on_nl on_ignored_nl on_ignored_nl def UNK on_lparen timeout on_op nil on_rparen # Propagates touch. Requests all the delayed futures, which it depends on, to be # executed. This method is called by any other method requiring resolved state, like {#wait}. # @return [self]
on_ignored_nl def UNK on_lparen timeout on_op nil on_rparen on_ignored_nl result on_op wait_until_resolved on_lparen timeout on_rparen on_nl timeout on_op result on_op # @!macro promises.touches # Calls {Concurrent::AbstractEventFuture#touch}.
def UNK on_lparen timeout on_op nil on_rparen on_ignored_nl result on_op wait_until_resolved on_lparen timeout on_rparen on_nl timeout on_op result on_op self # @!macro promises.method.wait # Wait (block the Thread) until receiver is {#resolved?}. # @!macro promises.touches # # @!macro promises.warn.blocks # @!macro promises.param.timeout # @return [self, true, false] self implies timeout was not used, true implies timeout was used # and it was resolved, false implies it was not resolved within timeout.
def default_executor on_nl on_ivar on_nl end on_nl on_ignored_nl def chain on_lparen on_op args on_comma on_op task on_rparen on_ignored_nl UNK on_ivar # Returns default executor. # @return [Executor] default executor # @see #with_default_executor # @see FactoryMethods#future_on # @see FactoryMethods#resolvable_future # @see FactoryMethods#any_fulfilled_future_on # @see similar
def chain on_lparen on_op args on_comma on_op task on_rparen on_ignored_nl UNK on_ivar on_comma on_op args on_comma on_op task on_nl end # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen executor on_comma on_op args on_comma on_op task on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_comma # Chains the task to be executed asynchronously on executor after it is resolved. # # @!macro promises.param.executor # @!macro promises.param.args # @return [Future] # @!macro promise.param.task-future # # @overload an_event.chain_on(executor, *args, &task) # @yield [*args] to the task. # @overload a_future.chain_on(executor, *args, &task) # @yield [fulfilled, value, reason, *args] to the task. # @yieldparam [true, false] fulfilled # @yieldparam [Object] value # @yieldparam [Object] reason
def to_s on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_comma super on_lbracket on_int on_op on_op on_int on_rbracket on_comma state on_nl end on_nl # @return [String] Short string representation.
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lbrace UNK on_period resolve_with internal_state on_rbrace on_nl end on_nl on_ignored_nl alias_method on_symbeg UNK # Resolves the resolvable when receiver is resolved. # # @param [Resolvable] resolvable # @return [self]
def UNK on_lparen on_op args on_comma on_op callback on_rparen on_ignored_nl UNK on_ivar on_comma on_op args on_comma on_op callback on_nl end # @!macro promises.shortcut.using # @return [self]
def UNK on_lparen on_op args on_comma on_op callback on_rparen on_ignored_nl add_callback on_symbeg UNK on_comma args on_comma callback on_nl end on_nl # Stores the callback to be executed synchronously on resolving thread after it is # resolved. # # @!macro promises.param.args # @!macro promise.param.callback # @return [self] # # @overload an_event.on_resolution!(*args, &callback) # @yield [*args] to the callback. # @overload a_future.on_resolution!(*args, &callback) # @yield [fulfilled, value, reason, *args] to the callback. # @yieldparam [true, false] fulfilled # @yieldparam [Object] value # @yieldparam [Object] reason
def UNK on_lparen executor on_comma on_op args on_comma on_op callback on_rparen on_ignored_nl add_callback on_symbeg UNK on_comma executor on_comma args on_comma # Stores the callback to be executed asynchronously on executor after it is resolved. # # @!macro promises.param.executor # @!macro promises.param.args # @!macro promise.param.callback # @return [self] # # @overload an_event.on_resolution_using(executor, *args, &callback) # @yield [*args] to the callback. # @overload a_future.on_resolution_using(executor, *args, &callback) # @yield [fulfilled, value, reason, *args] to the callback. # @yieldparam [true, false] fulfilled # @yieldparam [Object] value # @yieldparam [Object] reason
def UNK on_lparen executor on_rparen on_ignored_nl raise on_const on_nl end on_nl on_ignored_nl def resolve_with on_lparen state on_comma raise_on_reassign on_op true # @!macro promises.method.with_default_executor # Crates new object with same class with the executor set as its new default executor. # Any futures depending on it will use the new default executor. # @!macro promises.shortcut.event-future # @abstract # @return [AbstractEventFuture]
def resolve_with on_lparen state on_comma raise_on_reassign on_op true on_comma reserved on_op false on_rparen on_ignored_nl if UNK on_lparen reserved on_op on_const # @!visibility private
on_ivar on_period UNK on_lbrace on_ivar on_period UNK on_rbrace unless on_ivar on_period value on_op on_int on_nl UNK state on_nl else on_ignored_nl # go to synchronized block only if there were waiting threads
def UNK on_nl on_ivar on_period UNK on_lparen on_lbracket on_rbracket on_rparen do on_op on_lparen method on_comma args on_rparen on_comma UNK on_op # For inspection. # @!visibility private # @return [Array<AbstractPromise>]
def UNK on_nl on_ivar on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def promise on_nl on_ivar on_nl end on_nl on_ignored_nl # For inspection. # @!visibility private
def promise on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_nl promise on_period UNK on_nl end on_nl on_ignored_nl def UNK # For inspection. # @!visibility private
def UNK on_nl promise on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK on_period UNK on_nl end # For inspection. # @!visibility private
def UNK on_nl on_ivar on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def add_callback_notify_blocked on_lparen promise on_comma index on_rparen on_ignored_nl # For inspection. # @!visibility private
def add_callback_notify_blocked on_lparen promise on_comma index on_rparen on_ignored_nl add_callback on_symbeg UNK on_comma promise on_comma index on_nl end on_nl on_ignored_nl def # @!visibility private
def UNK on_lparen UNK on_rparen on_ignored_nl add_callback on_lparen on_symbeg UNK on_comma UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # @!visibility private
def UNK on_nl self on_nl end on_nl on_ignored_nl private on_nl on_ignored_nl def add_callback on_lparen method on_comma on_op args on_rparen on_ignored_nl # @!visibility private
self on_nl end on_nl on_ignored_nl private on_nl on_ignored_nl def add_callback on_lparen method on_comma on_op args on_rparen on_ignored_nl state on_op internal_state # TODO (pitr-ch 10-Dec-2018): documentation, better name if in edge
UNK state if state on_period resolved? on_nl end on_nl self on_nl end on_nl on_ignored_nl def UNK on_lparen state on_comma UNK # take back if it was resolved in the meanwhile
def wait_until_resolved on_lparen timeout on_rparen on_ignored_nl return true if resolved? on_nl on_ignored_nl touch on_nl on_ignored_nl on_ivar on_period UNK do on_ignored_nl # @return [Boolean]
on_ivar on_period UNK on_nl end on_nl end on_nl resolved? on_nl end on_nl on_ignored_nl def UNK on_lparen method on_comma state on_comma # JRuby may raise ConcurrencyError
class on_const on_op on_const on_nl on_ignored_nl alias_method on_symbeg UNK on_comma on_symbeg chain on_nl on_ignored_nl on_ignored_nl def UNK on_lparen other on_rparen # Represents an event which will happen in future (will be resolved). The event is either # pending or resolved. It should be always resolved. Use {Future} to communicate rejections and # cancellation.
def UNK on_lparen other on_rparen on_ignored_nl if other on_period is_a? on_lparen on_const on_rparen on_nl on_const on_period new_blocked_by2 on_lparen other on_comma # @!macro promises.method.zip # Creates a new event or a future which will be resolved when receiver and other are. # Returns an event if receiver and other are events, otherwise returns a future. # If just one of the parties is Future then the result # of the returned future is equal to the result of the supplied future. If both are futures # then the result is as described in {FactoryMethods#zip_futures_on}. # # @return [Future, Event]
def UNK on_lparen event_or_future on_rparen on_ignored_nl on_const on_period new_blocked_by2 on_lparen self on_comma event_or_future on_comma on_ivar on_rparen on_period event on_nl end # Creates a new event which will be resolved when the first of receiver, `event_or_future` # resolves. # # @return [Event]
def UNK on_nl event on_op on_const on_period new on_lparen on_ivar on_rparen on_period event on_nl on_const on_period new_blocked_by2 on_lparen self on_comma # Creates new event dependent on receiver which will not evaluate until touched, see {#touch}. # In other words, it inserts delay into the chain of Futures making rest of it lazy evaluated. # # @return [Event]
def UNK on_lparen intended_time on_rparen on_ignored_nl chain do on_ignored_nl event on_op on_const on_period new on_lparen on_ivar on_comma intended_time on_rparen on_period # @!macro promise.method.schedule # Creates new event dependent on receiver scheduled to execute on/in intended_time. # In time is interpreted from the moment the receiver is resolved, therefore it inserts # delay into the chain. # # @!macro promises.param.intended_time # @return [Event]
def UNK on_nl future on_op on_const on_period UNK on_nl UNK on_ignored_nl UNK on_lparen future on_rparen on_nl end on_nl on_ignored_nl def # Converts event to a future. The future is fulfilled when the event is resolved, the future may never fail. # # @return [Future]
def UNK on_nl self on_nl end on_nl on_ignored_nl def UNK on_lparen executor on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma # Returns self, since this is event # @return [Event]
def UNK on_lparen executor on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma executor on_rparen on_period event on_nl end on_nl on_ignored_nl # @!macro promises.method.with_default_executor # @return [Event]
class on_const on_op on_const on_nl on_ignored_nl def fulfilled? on_nl state on_op internal_state on_nl state on_period resolved? on_op state on_period fulfilled? # Represents a value which will become available in future. May reject with a reason instead, # e.g. when the tasks raises an exception.
def fulfilled? on_nl state on_op internal_state on_nl state on_period resolved? on_op state on_period fulfilled? on_nl end on_nl on_ignored_nl def rejected? # Is it in fulfilled state? # @return [Boolean]
def rejected? on_nl state on_op internal_state on_nl state on_period resolved? on_op on_op state on_period fulfilled? on_nl end on_nl on_ignored_nl on_ignored_nl # Is it in rejected state? # @return [Boolean]
on_ignored_nl def value on_lparen timeout on_op nil on_comma timeout_value on_op nil on_rparen on_ignored_nl if wait_until_resolved timeout on_nl internal_state on_period value # @!macro promises.warn.nil # @note Make sure returned `nil` is not confused with timeout, no value when rejected, # no reason when fulfilled, etc. # Use more exact methods if needed, like {#wait}, {#value!}, {#result}, etc.
def value on_lparen timeout on_op nil on_comma timeout_value on_op nil on_rparen on_ignored_nl if wait_until_resolved timeout on_nl internal_state on_period value on_nl # @!macro promises.method.value # Return value of the future. # @!macro promises.touches # # @!macro promises.warn.blocks # @!macro promises.warn.nil # @!macro promises.param.timeout # @!macro promises.param.timeout_value # @param [Object] timeout_value a value returned by the method when it times out # @return [Object, nil, timeout_value] the value of the Future when fulfilled, # timeout_value on timeout, # nil on rejection.
def reason on_lparen timeout on_op nil on_comma timeout_value on_op nil on_rparen on_ignored_nl if wait_until_resolved timeout on_nl internal_state on_period reason on_nl # Returns reason of future's rejection. # @!macro promises.touches # # @!macro promises.warn.blocks # @!macro promises.warn.nil # @!macro promises.param.timeout # @!macro promises.param.timeout_value # @return [Object, timeout_value] the reason, or timeout_value on timeout, or nil on fulfillment.
def result on_lparen timeout on_op nil on_rparen on_ignored_nl internal_state on_period result if wait_until_resolved timeout on_nl end on_nl on_ignored_nl def UNK # Returns triplet fulfilled?, value, reason. # @!macro promises.touches # # @!macro promises.warn.blocks # @!macro promises.param.timeout # @return [Array(Boolean, Object, Object), nil] triplet of fulfilled?, value, reason, or nil # on timeout.
def UNK on_lparen timeout on_op nil on_rparen on_ignored_nl result on_op UNK on_lparen timeout on_rparen on_nl timeout on_op result on_op self # @!macro promises.method.wait # @raise [Exception] {#reason} on rejection
def UNK on_lparen timeout on_op nil on_comma timeout_value on_op nil on_rparen on_ignored_nl if UNK timeout on_nl internal_state on_period value on_nl # @!macro promises.method.value # @return [Object, nil, timeout_value] the value of the Future when fulfilled, # or nil on rejection, # or timeout_value on timeout. # @raise [Exception] {#reason} on rejection
def UNK on_lparen on_op args on_rparen on_ignored_nl raise on_const on_op on_const on_comma on_tstring_beg on_tstring_content on_tstring_end unless rejected? on_nl raise on_const # Allows rejected Future to be risen with `raise` method. # If the reason is not an exception `Runtime.new(reason)` is returned. # # @example # raise Promises.rejected_future(StandardError.new("boom")) # raise Promises.rejected_future("or just boom") # @raise [Concurrent::Error] when raising not rejected future # @return [Exception]
def UNK on_lparen on_op args on_comma on_op task on_rparen on_ignored_nl UNK on_ivar on_comma on_op args on_comma on_op task on_nl end # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen executor on_comma on_op args on_comma on_op task on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_comma # Chains the task to be executed asynchronously on executor after it fulfills. Does not run # the task if it rejects. It will resolve though, triggering any dependent futures. # # @!macro promises.param.executor # @!macro promises.param.args # @!macro promise.param.task-future # @return [Future] # @yield [value, *args] to the task.
def UNK on_lparen on_op args on_comma on_op task on_rparen on_ignored_nl UNK on_ivar on_comma on_op args on_comma on_op task on_nl end # @!macro promises.shortcut.on # @return [Future]
def UNK on_lparen executor on_comma on_op args on_comma on_op task on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_comma # Chains the task to be executed asynchronously on executor after it rejects. Does not run # the task if it fulfills. It will resolve though, triggering any dependent futures. # # @!macro promises.param.executor # @!macro promises.param.args # @!macro promise.param.task-future # @return [Future] # @yield [reason, *args] to the task.
def UNK on_lparen other on_rparen on_ignored_nl if other on_period is_a? on_lparen on_const on_rparen on_nl on_const on_period new_blocked_by2 on_lparen self on_comma # @!macro promises.method.zip # @return [Future]
def UNK on_lparen event_or_future on_rparen on_ignored_nl on_const on_period new_blocked_by2 on_lparen self on_comma event_or_future on_comma on_ivar on_rparen on_period future on_nl end # Creates a new event which will be resolved when the first of receiver, `event_or_future` # resolves. Returning future will have value nil if event_or_future is event and resolves # first. # # @return [Future]
def UNK on_nl event on_op on_const on_period new on_lparen on_ivar on_rparen on_period event on_nl on_const on_period new_blocked_by2 on_lparen self on_comma # Creates new future dependent on receiver which will not evaluate until touched, see {#touch}. # In other words, it inserts delay into the chain of Futures making rest of it lazy evaluated. # # @return [Future]
def UNK on_lparen intended_time on_rparen on_ignored_nl chain do on_ignored_nl event on_op on_const on_period new on_lparen on_ivar on_comma intended_time on_rparen on_period # @!macro promise.method.schedule # @return [Future]
def UNK on_lparen executor on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma executor on_rparen on_period future on_nl end on_nl on_ignored_nl # @!macro promises.method.with_default_executor # @return [Future]
def UNK on_lparen UNK on_op on_int on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma UNK on_comma on_ivar on_rparen on_period future # Creates new future which will have result of the future returned by receiver. If receiver # rejects it will have its rejection. # # @param [Integer] level how many levels of futures should flatten # @return [Future]
def UNK on_nl on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_rparen on_period event on_nl end on_nl on_ignored_nl def UNK on_lparen # Creates new event which will be resolved when the returned event by receiver is. # Be careful if the receiver rejects it will just resolve since Event does not hold reason. # # @return [Event]
def UNK on_lparen on_op args on_comma on_op callback on_rparen on_ignored_nl UNK on_ivar on_comma on_op args on_comma on_op callback on_nl end # @!macro promises.shortcut.using # @return [self]
def UNK on_lparen on_op args on_comma on_op callback on_rparen on_ignored_nl add_callback on_symbeg UNK on_comma args on_comma callback on_nl end on_nl # Stores the callback to be executed synchronously on resolving thread after it is # fulfilled. Does nothing on rejection. # # @!macro promises.param.args # @!macro promise.param.callback # @return [self] # @yield [value, *args] to the callback.
def UNK on_lparen executor on_comma on_op args on_comma on_op callback on_rparen on_ignored_nl add_callback on_symbeg UNK on_comma executor on_comma args on_comma # Stores the callback to be executed asynchronously on executor after it is # fulfilled. Does nothing on rejection. # # @!macro promises.param.executor # @!macro promises.param.args # @!macro promise.param.callback # @return [self] # @yield [value, *args] to the callback.
def UNK on_lparen on_op args on_comma on_op callback on_rparen on_ignored_nl UNK on_ivar on_comma on_op args on_comma on_op callback on_nl end # @!macro promises.shortcut.using # @return [self]
def UNK on_lparen on_op args on_comma on_op callback on_rparen on_ignored_nl add_callback on_symbeg UNK on_comma args on_comma callback on_nl end on_nl # Stores the callback to be executed synchronously on resolving thread after it is # rejected. Does nothing on fulfillment. # # @!macro promises.param.args # @!macro promise.param.callback # @return [self] # @yield [reason, *args] to the callback.
def UNK on_lparen executor on_comma on_op args on_comma on_op callback on_rparen on_ignored_nl add_callback on_symbeg UNK on_comma executor on_comma args on_comma # Stores the callback to be executed asynchronously on executor after it is # rejected. Does nothing on fulfillment. # # @!macro promises.param.executor # @!macro promises.param.args # @!macro promise.param.callback # @return [self] # @yield [reason, *args] to the callback.
def UNK on_lparen run_test on_op method on_lparen on_symbeg run_test on_rparen on_rparen on_ignored_nl on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_comma # Allows to use futures as green threads. The receiver has to evaluate to a future which # represents what should be done next. It basically flattens indefinitely until non Future # values is returned which becomes result of the returned future. Any encountered exception # will become reason of the returned future. # # @return [Future] # @param [#call(value)] run_test # an object which when called returns either Future to keep running with # or nil, then the run completes with the value. # The run_test can be used to extract the Future from deeper structure, # or to distinguish Future which is a resulting value from a future # which is suppose to continue running. # @example # body = lambda do |v| # v += 1 # v < 5 ? Promises.future(v, &body) : v # end # Promises.future(0, &body).run.value! # => 5
def apply on_lparen args on_comma block on_rparen on_ignored_nl internal_state on_period apply args on_comma block on_nl end on_nl on_ignored_nl def UNK # @!visibility private
def UNK on_nl event on_op on_const on_period UNK on_nl UNK on_ignored_nl UNK on_lparen event on_rparen on_nl end on_nl on_ignored_nl def # Converts future to event which is resolved when future is resolved by fulfillment or rejection. # # @return [Event]
def UNK on_nl self on_nl end on_nl on_ignored_nl def to_s on_nl if resolved? on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_comma super # Returns self, since this is a future # @return [Future]
def to_s on_nl if resolved? on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_comma super on_lbracket on_int on_op on_op on_int on_rbracket on_comma on_lparen # @return [String] Short string representation.
module on_const on_nl include on_const on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl include on_const on_nl on_ignored_nl on_ignored_nl on_ignored_nl # Marker module of Future, Event resolved manually.
class on_const on_op on_const on_nl include on_const on_nl on_ignored_nl on_ignored_nl on_ignored_nl def resolve on_lparen raise_on_reassign on_op true on_comma reserved on_op # A Event which can be resolved by user.
on_ignored_nl on_ignored_nl def resolve on_lparen raise_on_reassign on_op true on_comma reserved on_op false on_rparen on_ignored_nl resolve_with on_const on_comma raise_on_reassign on_comma reserved # @!macro raise_on_reassign # @raise [MultipleAssignmentError] when already resolved and raise_on_reassign is true.
on_ignored_nl def resolve on_lparen raise_on_reassign on_op true on_comma reserved on_op false on_rparen on_ignored_nl resolve_with on_const on_comma raise_on_reassign on_comma reserved on_nl # @!macro promise.param.raise_on_reassign # @param [Boolean] raise_on_reassign should method raise exception if already resolved # @return [self, false] false is returner when raise_on_reassign is false and the receiver # is already resolved. #
def resolve on_lparen raise_on_reassign on_op true on_comma reserved on_op false on_rparen on_ignored_nl resolve_with on_const on_comma raise_on_reassign on_comma reserved on_nl end # Makes the event resolved, which triggers all dependent futures. # # @!macro promise.param.raise_on_reassign # @!macro promise.param.reserved # @param [true, false] reserved # Set to true if the resolvable is {#reserve}d by you, # marks resolution of reserved resolvable events and futures explicitly. # Advanced feature, ignore unless you use {Resolvable#reserve} from edge.
def UNK on_nl on_ivar on_op on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_rparen on_period event on_nl end on_nl on_ignored_nl def # Creates new event wrapping receiver, effectively hiding the resolve method. # # @return [Event]
def UNK on_lparen timeout on_op nil on_comma resolve_on_timeout on_op false on_rparen on_ignored_nl super on_lparen timeout on_rparen UNK if resolve_on_timeout on_nl # Behaves as {AbstractEventFuture#wait} but has one additional optional argument # resolve_on_timeout. # # @param [true, false] resolve_on_timeout # If it times out and the argument is true it will also resolve the event. # @return [self, true, false] # @see AbstractEventFuture#wait
on_op resolve on_lparen false on_rparen on_nl else on_ignored_nl false on_nl end on_nl end on_nl end on_nl on_ignored_nl class on_const on_op # if it fails to resolve it was resolved in the meantime # so return true as if there was no timeout
class on_const on_op on_const on_nl include on_const on_nl on_ignored_nl def resolve on_lparen fulfilled on_op true on_comma value on_op nil on_comma # A Future which can be resolved by user.
def resolve on_lparen fulfilled on_op true on_comma value on_op nil on_comma reason on_op nil on_comma raise_on_reassign on_op true on_comma reserved # Makes the future resolved with result of triplet `fulfilled?`, `value`, `reason`, # which triggers all dependent futures. # # @param [true, false] fulfilled # @param [Object] value # @param [Object] reason # @!macro promise.param.raise_on_reassign # @!macro promise.param.reserved
def UNK on_lparen value on_comma raise_on_reassign on_op true on_comma reserved on_op false on_rparen on_ignored_nl resolve_with on_const on_period new on_lparen value # Makes the future fulfilled with `value`, # which triggers all dependent futures. # # @param [Object] value # @!macro promise.param.raise_on_reassign # @!macro promise.param.reserved
def UNK on_lparen reason on_comma raise_on_reassign on_op true on_comma reserved on_op false on_rparen on_ignored_nl resolve_with on_const on_period new on_lparen reason # Makes the future rejected with `reason`, # which triggers all dependent futures. # # @param [Object] reason # @!macro promise.param.raise_on_reassign # @!macro promise.param.reserved
def evaluate_to on_lparen on_op args on_comma on_op block on_rparen on_ignored_nl promise on_period evaluate_to on_lparen on_op args on_comma block on_rparen on_nl # Evaluates the block and sets its result as future's value fulfilling, if the block raises # an exception the future rejects with it. # # @yield [*args] to the block. # @yieldreturn [Object] value # @return [self]
def UNK on_lparen on_op args on_comma on_op block on_rparen on_ignored_nl promise on_period evaluate_to on_lparen on_op args on_comma block on_rparen on_period # Evaluates the block and sets its result as future's value fulfilling, if the block raises # an exception the future rejects with it. # # @yield [*args] to the block. # @yieldreturn [Object] value # @return [self] # @raise [Exception] also raise reason on rejection.
on_ignored_nl def UNK on_lparen timeout on_op nil on_comma resolve_on_timeout on_op nil on_rparen on_ignored_nl super on_lparen timeout on_rparen UNK if resolve_on_timeout # @!macro promises.resolvable.resolve_on_timeout # @param [::Array(true, Object, nil), ::Array(false, nil, Exception), nil] resolve_on_timeout # If it times out and the argument is not nil it will also resolve the future # to the provided resolution.
def UNK on_lparen timeout on_op nil on_comma resolve_on_timeout on_op nil on_rparen on_ignored_nl super on_lparen timeout on_rparen UNK if resolve_on_timeout on_nl # Behaves as {AbstractEventFuture#wait} but has one additional optional argument # resolve_on_timeout. # # @!macro promises.resolvable.resolve_on_timeout # @return [self, true, false] # @see AbstractEventFuture#wait
on_op resolve on_lparen on_op resolve_on_timeout on_comma false on_rparen on_nl else on_ignored_nl false on_nl end on_nl end on_nl on_ignored_nl def UNK # if it fails to resolve it was resolved in the meantime # so return true as if there was no timeout
def UNK on_lparen timeout on_op nil on_comma resolve_on_timeout on_op nil on_rparen on_ignored_nl super on_lparen timeout on_rparen UNK if resolve_on_timeout on_nl # Behaves as {Future#wait!} but has one additional optional argument # resolve_on_timeout. # # @!macro promises.resolvable.resolve_on_timeout # @return [self, true, false] # @raise [Exception] {#reason} on rejection # @see Future#wait!
raise self if rejected? on_nl true on_nl end on_nl else on_ignored_nl false on_nl end on_nl end on_nl on_ignored_nl def value # if it fails to resolve it was resolved in the meantime # so return true as if there was no timeout
def value on_lparen timeout on_op nil on_comma timeout_value on_op nil on_comma resolve_on_timeout on_op nil on_rparen on_ignored_nl if wait_until_resolved timeout on_nl # Behaves as {Future#value} but has one additional optional argument # resolve_on_timeout. # # @!macro promises.resolvable.resolve_on_timeout # @return [Object, timeout_value, nil] # @see Future#value
return internal_state on_period value on_nl end on_nl end on_nl timeout_value on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen timeout # if it fails to resolve it was resolved in the meantime # so return value as if there was no timeout
def UNK on_lparen timeout on_op nil on_comma timeout_value on_op nil on_comma resolve_on_timeout on_op nil on_rparen on_ignored_nl if UNK timeout on_nl # Behaves as {Future#value!} but has one additional optional argument # resolve_on_timeout. # # @!macro promises.resolvable.resolve_on_timeout # @return [Object, timeout_value, nil] # @raise [Exception] {#reason} on rejection # @see Future#value!
raise self if rejected? on_nl return internal_state on_period value on_nl end on_nl end on_nl timeout_value on_nl end on_nl end on_nl # if it fails to resolve it was resolved in the meantime # so return value as if there was no timeout
def reason on_lparen timeout on_op nil on_comma timeout_value on_op nil on_comma resolve_on_timeout on_op nil on_rparen on_ignored_nl if wait_until_resolved timeout on_nl # Behaves as {Future#reason} but has one additional optional argument # resolve_on_timeout. # # @!macro promises.resolvable.resolve_on_timeout # @return [Exception, timeout_value, nil] # @see Future#reason
return internal_state on_period reason on_nl end on_nl end on_nl timeout_value on_nl end on_nl end on_nl on_ignored_nl def result on_lparen timeout # if it fails to resolve it was resolved in the meantime # so return value as if there was no timeout
def result on_lparen timeout on_op nil on_comma resolve_on_timeout on_op nil on_rparen on_ignored_nl if wait_until_resolved timeout on_nl internal_state on_period result on_nl # Behaves as {Future#result} but has one additional optional argument # resolve_on_timeout. # # @!macro promises.resolvable.resolve_on_timeout # @return [::Array(Boolean, Object, Exception), nil] # @see Future#result
internal_state on_period result on_nl end on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_const on_period # if it fails to resolve it was resolved in the meantime # so return value as if there was no timeout
end on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_rparen on_period future # otherwise returns nil
def UNK on_nl on_ivar on_op on_const on_period new_blocked_by1 on_lparen self on_comma on_ivar on_rparen on_period future on_nl end on_nl end on_nl # Creates new future wrapping receiver, effectively hiding the resolve method and similar. # # @return [Future]
class on_const on_op on_const on_op on_const on_nl UNK on_nl include on_const on_nl on_ignored_nl def initialize on_lparen future on_rparen on_ignored_nl super # @abstract # @private
def evaluate_to on_lparen on_op args on_comma block on_rparen on_ignored_nl resolve_with on_const on_period new on_lparen block on_period call on_lparen on_op args # @return [Future]
class on_const on_op on_const on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg new on_nl on_ignored_nl def # @abstract
class on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg new on_nl on_ignored_nl def self on_period new_blocked_by1 on_lparen UNK on_comma on_op args # @abstract
on_const on_period UNK on_lparen UNK on_comma UNK on_rparen on_nl else on_ignored_nl UNK on_op UNK on_nl end on_nl promise on_op new # TODO (pitr-ch 23-Dec-2016): use arrays when we know it will not grow (only flat adds delay)
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl on_const on_period UNK on_lparen on_const on_rparen on_lbrace on_op UNK on_op UNK on_period # for inspection only
end on_nl end on_nl on_ignored_nl def resolvable? on_lparen countdown on_comma future on_comma index on_rparen on_ignored_nl countdown on_period UNK on_nl end # if still present
def resolvable? on_lparen countdown on_comma future on_comma index on_rparen on_ignored_nl countdown on_period UNK on_nl end on_nl on_ignored_nl def process_on_blocker_resolution on_lparen # @return [true,false] if resolvable
class on_const on_op on_const on_nl def initialize on_lparen delayed on_comma blockers_count on_comma default_executor on_comma executor on_comma args on_comma on_op task # @abstract
class on_const on_op on_const on_nl def initialize on_lparen default_executor on_rparen on_ignored_nl super on_const on_period new on_lparen self on_comma default_executor on_rparen # will be immediately resolved
on_ivar on_op on_const on_period new false on_nl on_ivar on_op delayed_because on_op on_const on_period new on_nl on_ignored_nl event_or_future on_period UNK delayed # noinspection RubyArgCount
super delayed on_op on_const on_period new on_comma on_int on_op UNK on_comma on_const on_period new on_lparen self on_comma default_executor on_rparen on_nl # flat promise may result to a future having delayed futures, therefore we have to have empty stack # to be able to add new delayed futures
on_ivar on_op future on_period internal_state if index on_op on_int on_nl super future on_comma index on_nl end on_nl on_ignored_nl def on_resolvable # first blocking is future, take its result
super future on_comma index on_nl end on_nl on_ignored_nl def on_resolvable on_lparen resolved_future on_comma index on_rparen on_ignored_nl resolve_with on_ivar on_nl end # super has to be called after above to piggyback on volatile @Countdown
on_ivar on_lbracket index on_rbracket on_op future on_period internal_state super future on_comma index on_nl end on_nl on_ignored_nl def on_resolvable on_lparen resolved_future # TODO (pitr-ch 18-Dec-2016): Can we assume that array will never break under parallel access when never re-sized?
super future on_comma index on_nl end on_nl on_ignored_nl def on_resolvable on_lparen resolved_future on_comma index on_rparen on_ignored_nl UNK on_op true on_nl # has to be set before countdown in super
class on_const on_op on_const on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl on_ignored_nl private on_nl on_ignored_nl def initialize on_lparen # @abstract
countdown on_period UNK on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl on_ignored_nl def initialize on_lparen default_executor on_rparen # inlined super from BlockedPromise
