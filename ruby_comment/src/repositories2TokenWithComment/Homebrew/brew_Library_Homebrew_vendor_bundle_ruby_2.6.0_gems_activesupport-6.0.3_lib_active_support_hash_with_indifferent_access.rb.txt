on_ignored_nl UNK UNK UNK UNK on_nl UNK UNK UNK UNK on_nl UNK UNK UNK UNK on_nl on_ignored_nl UNK on_const on_nl # frozen_string_literal: true
class on_const on_op on_const on_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl dup on_nl end on_nl # Implements a hash where keys <tt>:foo</tt> and <tt>"foo"</tt> are considered # to be the same. # # rgb = ActiveSupport::HashWithIndifferentAccess.new # # rgb[:black] = '#000000' # rgb[:black] # => '#000000' # rgb['black'] # => '#000000' # # rgb['white'] = '#FFFFFF' # rgb[:white] # => '#FFFFFF' # rgb['white'] # => '#FFFFFF' # # Internally symbols are mapped to strings when used as keys in the entire # writing interface (calling <tt>[]=</tt>, <tt>merge</tt>, etc). This # mapping belongs to the public interface. For example, given: # # hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1) # # You are guaranteed that the key is returned as a string: # # hash.keys # => ["a"] # # Technically other types of keys are accepted: # # hash = ActiveSupport::HashWithIndifferentAccess.new(a: 1) # hash[0] = 0 # hash # => {"a"=>1, 0=>0} # # but this class is intended for use cases where strings or symbols are the # expected keys and it is convenient to understand both as the same. For # example the +params+ hash in Ruby on Rails. # # Note that core extensions define <tt>Hash#with_indifferent_access</tt>: # # rgb = { black: '#000000', white: '#FFFFFF' }.with_indifferent_access # # which may be handy. # # To access this class outside of Rails, require the core extension with: # # require "active_support/core_ext/hash/indifferent_access" # # which will, in turn, require this file.
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl dup on_nl end on_nl on_ignored_nl def UNK on_nl self # Returns +true+ so that <tt>Array#extract_options!</tt> finds members of # this class.
def on_op on_lparen key on_comma value on_rparen on_ignored_nl UNK on_lparen convert_key on_lparen key on_rparen on_comma UNK on_lparen value on_comma UNK # Assigns a new value to the hash: # # hash = ActiveSupport::HashWithIndifferentAccess.new # hash[:key] = 'value' # # This value can be later fetched using either +:key+ or <tt>'key'</tt>.
def UNK on_lparen other_hash on_rparen on_ignored_nl if other_hash on_period UNK on_const on_nl super on_lparen other_hash on_rparen on_nl UNK on_ignored_nl other_hash # Updates the receiver in-place, merging in the hash passed as argument: # # hash_1 = ActiveSupport::HashWithIndifferentAccess.new # hash_1[:key] = 'value' # # hash_2 = ActiveSupport::HashWithIndifferentAccess.new # hash_2[:key] = 'New Value!' # # hash_1.update(hash_2) # => {"key"=>"New Value!"} # # The argument can be either an # <tt>ActiveSupport::HashWithIndifferentAccess</tt> or a regular +Hash+. # In either case the merge respects the semantics of indifferent access. # # If the argument is a regular hash with keys +:key+ and +"key"+ only one # of the values end up in the receiver, but which one is unspecified. # # When given a block, the value for duplicated keys will be determined # by the result of invoking the block with the duplicated key, the value # in the receiver, and the value in +other_hash+. The rules for duplicated # keys follow the semantics of indifferent access: # # hash_1[:key] = 10 # hash_2['key'] = 12 # hash_1.update(hash_2) { |key, old, new| old + new } # => {"key"=>22}
def UNK on_lparen key on_rparen on_ignored_nl super on_lparen convert_key on_lparen key on_rparen on_rparen on_nl end on_nl on_ignored_nl alias_method on_symbeg UNK # Checks the hash for a key matching the argument passed in: # # hash = ActiveSupport::HashWithIndifferentAccess.new # hash['key'] = 'value' # hash.key?(:key) # => true # hash.key?('key') # => true
def on_op on_lparen key on_rparen on_ignored_nl super on_lparen convert_key on_lparen key on_rparen on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Same as <tt>Hash#[]</tt> where the key passed as argument can be # either a string or a symbol: # # counters = ActiveSupport::HashWithIndifferentAccess.new # counters[:foo] = 1 # # counters['foo'] # => 1 # counters[:foo] # => 1 # counters[:zoo] # => nil
def UNK on_lparen key on_rparen on_ignored_nl super on_lparen convert_key on_lparen key on_rparen on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Same as <tt>Hash#assoc</tt> where the key passed as argument can be # either a string or a symbol: # # counters = ActiveSupport::HashWithIndifferentAccess.new # counters[:foo] = 1 # # counters.assoc('foo') # => ["foo", 1] # counters.assoc(:foo) # => ["foo", 1] # counters.assoc(:zoo) # => nil
def UNK on_lparen key on_comma on_op UNK on_rparen on_ignored_nl super on_lparen convert_key on_lparen key on_rparen on_comma on_op UNK on_rparen on_nl # Same as <tt>Hash#fetch</tt> where the key passed as argument can be # either a string or a symbol: # # counters = ActiveSupport::HashWithIndifferentAccess.new # counters[:foo] = 1 # # counters.fetch('foo') # => 1 # counters.fetch(:bar, 0) # => 0 # counters.fetch(:bar) { |key| 0 } # => 0 # counters.fetch(:zoo) # => KeyError: key not found: "zoo"
def UNK on_lparen on_op args on_rparen on_ignored_nl args on_lbracket UNK on_rbracket on_op convert_key on_lparen args on_lbracket UNK on_rbracket on_rparen if # Same as <tt>Hash#dig</tt> where the key passed as argument can be # either a string or a symbol: # # counters = ActiveSupport::HashWithIndifferentAccess.new # counters[:foo] = { bar: 1 } # # counters.dig('foo', 'bar') # => 1 # counters.dig(:foo, :bar) # => 1 # counters.dig(:zoo) # => nil
def default on_lparen on_op args on_rparen on_ignored_nl super on_lparen on_op args on_period UNK on_lbrace on_op UNK on_op convert_key on_lparen UNK # Same as <tt>Hash#default</tt> where the key passed as argument can be # either a string or a symbol: # # hash = ActiveSupport::HashWithIndifferentAccess.new(1) # hash.default # => 1 # # hash = ActiveSupport::HashWithIndifferentAccess.new { |hash, key| key } # hash.default # => nil # hash.default('foo') # => 'foo' # hash.default(:foo) # => 'foo'
def UNK on_lparen on_op keys on_rparen on_ignored_nl super on_lparen on_op keys on_period UNK on_lbrace on_op key on_op convert_key on_lparen key # Returns an array of the values at the specified indices: # # hash = ActiveSupport::HashWithIndifferentAccess.new # hash[:a] = 'x' # hash[:b] = 'y' # hash.values_at('a', 'b') # => ["x", "y"]
def UNK on_lparen on_op UNK on_comma on_op block on_rparen on_ignored_nl super on_lparen on_op UNK on_period UNK on_lbrace on_op key on_op # Returns an array of the values at the specified indices, but also # raises an exception when one of the keys can't be found. # # hash = ActiveSupport::HashWithIndifferentAccess.new # hash[:a] = 'x' # hash[:b] = 'y' # hash.fetch_values('a', 'b') # => ["x", "y"] # hash.fetch_values('a', 'c') { |key| 'z' } # => ["x", "z"] # hash.fetch_values('a', 'c') # => KeyError: key not found: "c"
def dup on_nl self on_period class on_period new on_lparen self on_rparen on_period tap UNK on_op UNK on_op on_ignored_nl UNK on_lparen # Returns a shallow copy of the hash. # # hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } }) # dup = hash.dup # dup[:a][:c] = 'c' # # hash[:a][:c] # => "c" # dup[:a][:c] # => "c"
def UNK on_lparen hash on_comma on_op block on_rparen on_ignored_nl dup on_period UNK on_lparen hash on_comma on_op block on_rparen on_nl end # This method has the same semantics of +update+, except it does not # modify the receiver but rather returns a new hash with indifferent # access with the result of the merge.
def UNK on_lparen other_hash on_rparen on_ignored_nl super on_lparen self on_period class on_period new on_lparen other_hash on_rparen on_rparen on_nl end on_nl # Like +merge+ but the other way around: Merges the receiver into the # argument and returns a new hash with indifferent access as result: # # hash = ActiveSupport::HashWithIndifferentAccess.new # hash['a'] = nil # hash.reverse_merge(a: 0, b: 1) # => {"a"=>nil, "b"=>1}
def UNK on_lparen other_hash on_rparen on_ignored_nl super on_lparen self on_period class on_period new on_lparen other_hash on_rparen on_rparen on_nl end on_nl # Same semantics as +reverse_merge+ but modifies the receiver in-place.
def UNK on_lparen other_hash on_rparen on_ignored_nl super on_lparen self on_period class on_period new on_lparen other_hash on_rparen on_rparen on_nl end on_nl # Replaces the contents of this hash with other_hash. # # h = { "a" => 100, "b" => 200 } # h.replace({ "c" => 300, "d" => 400 }) # => {"c"=>300, "d"=>400}
def UNK on_lparen key on_rparen on_ignored_nl super on_lparen convert_key on_lparen key on_rparen on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Removes the specified key from the hash.
def to_hash on_nl UNK on_op on_const on_period new on_nl UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK UNK on_op key on_comma # Convert to a regular hash with string keys.
key on_period UNK on_lparen on_const on_rparen on_op key on_period UNK on_op key on_nl end on_nl on_ignored_nl def UNK on_lparen value # :doc:
if value on_period UNK on_const on_nl if UNK on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg to_hash on_nl value on_period to_hash on_nl # :doc:
if default_proc on_nl UNK on_period default_proc on_op default_proc on_period dup on_nl UNK on_ignored_nl UNK on_period default on_op default on_nl end # :doc:
on_ignored_nl on_const on_op on_const on_op on_const on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # :stopdoc:
