require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl # frozen_string_literal: false
UNK on_const on_op on_const on_nl UNK on_const on_nl on_const on_op on_lbracket on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg # Represents text nodes in an XML document
on_const on_op on_lbracket on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg on_tstring_content on_regexp_end on_comma on_regexp_beg # The order in which the substitutions occur
on_const on_op on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg # Characters which are substituted in written strings
UNK on_symbeg raw on_nl on_ignored_nl on_const on_op on_regexp_beg on_tstring_content on_embexpr_beg on_const on_op on_const on_embexpr_end on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg # If +raw+ is true, then REXML leaves the value alone
def UNK on_lparen arg on_comma UNK on_op false on_comma parent on_op nil on_comma raw on_op nil on_comma on_ignored_nl entity_filter on_op # Constructor # +arg+ if a String, the content is set to the String. If a Text, # the object is shallowly cloned. # # +respect_whitespace+ (boolean, false) if true, whitespace is # respected # # +parent+ (nil) if this is a Parent object, the parent # will be set to this. # # +raw+ (nil) This argument can be given three values. # If true, then the value of used to construct this object is expected to # contain no unescaped XML markup, and REXML will not change the text. If # this value is false, the string may contain any characters, and REXML will # escape any and all defined entities whose values are contained in the # text. If this value is nil (the default), then the raw value of the # parent will be used as the raw value for this node. If there is no raw # value for the parent, and no value is supplied, the default is false. # Use this field if you have entities defined for some text, and you don't # want REXML to escape that text in output. # Text.new( "<&", false, nil, false ) #-> "&lt;&amp;" # Text.new( "&lt;&amp;", false, nil, false ) #-> "&amp;lt;&amp;amp;" # Text.new( "<&", false, nil, true ) #-> Parse exception # Text.new( "&lt;&amp;", false, nil, true ) #-> "&lt;&amp;" # # Assume that the entity "s" is defined to be "sean" # # and that the entity "r" is defined to be "russell" # Text.new( "sean russell" ) #-> "&s; &r;" # Text.new( "sean russell", false, nil, true ) #-> "sean russell" # # +entity_filter+ (nil) This can be an array of entities to match in the # supplied text. This argument is only useful if +raw+ is set to false. # Text.new( "sean russell", false, nil, false, ["s"] ) #-> "&s; russell" # Text.new( "sean russell", false, nil, true, ["s"] ) #-> "sean russell" # In the last example, the +entity_filter+ argument is ignored. # # +illegal+ INTERNAL USE ONLY
def on_const on_period UNK string on_comma UNK on_comma doctype on_nl on_ignored_nl if string on_op on_const on_nl if on_const on_period UNK # check for illegal characters
if string on_op on_const on_nl if on_const on_period UNK on_symbeg UNK on_nl string on_period UNK on_period UNK UNK on_op c # illegal anywhere
string on_period UNK on_lparen UNK on_rparen UNK on_ignored_nl if on_backref on_lbracket on_op on_int on_rbracket on_op on_char on_nl raise on_tstring_beg on_tstring_content # context sensitive
end on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK # FIXME: below can't work but this needs API change. # elsif @parent and $3 and !SUBSTITUTES.include?($1) # if !doctype or !doctype.entities.has_key?($3) # raise "Undeclared entity '#{$1}' in raw string \"#{string}\"" # end
def on_op on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Appends text to this text node. The text is appended in the +raw+ mode # of this text node. # # +returns+ the text itself to enable method chain like # 'text << "XXX" << "YYY"'.
def on_op on_lparen UNK on_rparen on_ignored_nl UNK on_lparen on_rparen on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def doctype on_nl # +other+ a String or a Text # +returns+ the result of (to_s <=> arg.to_s)
def UNK on_nl return on_ivar if on_ivar on_nl on_ivar on_op on_const on_op UNK on_lparen on_ivar on_comma doctype on_comma on_ivar on_rparen # Returns the string value of this text node. This string is always # escaped, meaning that it is a valid XML text node string, and all # entities that can be escaped, have been inserted. This method respects # the entity filter set in the constructor. # # # Assume that the entity "s" is defined to be "sean", and that the # # entity "r" is defined to be "russell" # t = Text.new( "< & sean russell", false, nil, false, ['s'] ) # t.to_s #-> "&lt; &amp; &s; russell" # t = Text.new( "< & &s; russell", false, nil, false ) # t.to_s #-> "&lt; &amp; &s; russell" # u = Text.new( "sean russell", false, nil, true ) # u.to_s #-> "sean russell"
def UNK on_nl on_ivar on_op on_const on_op UNK on_lparen on_ivar on_comma doctype on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Returns the string value of this text. This is the text without # entities, as it might be used programmatically, or printed to the # console. This ignores the 'raw' attribute setting, and any # entity_filter. # # # Assume that the entity "s" is defined to be "sean", and that the # # entity "r" is defined to be "russell" # t = Text.new( "< & sean russell", false, nil, false, ['s'] ) # t.value #-> "< & sean russell" # t = Text.new( "< & &s; russell", false, nil, false ) # t.value #-> "< & sean russell" # u = Text.new( "sean russell", false, nil, true ) # u.value #-> "sean russell"
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_period gsub on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Sets the contents of this text node. This expects the text to be # unnormalized. It returns self. # # e = Element.new( "a" ) # e.add_text( "foo" ) # <a>foo</a> # e[0].value = "bar" # <a>bar</a> # e[0].value = "<a>" # <a>&lt;a&gt;</a>
return string if string on_period UNK on_op UNK on_nl UNK on_op string on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma UNK # Recursively wrap string at width.
if UNK UNK on_ignored_nl return on_tstring_beg on_tstring_content on_tstring_end on_op string on_lbracket on_int on_comma UNK on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_op # Position in string with last ' ' before cutoff
def UNK on_lparen UNK on_comma UNK on_op on_op on_int on_comma UNK on_op false on_comma UNK on_op false on_rparen on_ignored_nl on_const # == DEPRECATED # See REXML::Formatters #
def UNK on_nl UNK on_op on_ivar on_period UNK on_nl UNK on_op on_tstring_beg on_tstring_content on_tstring_end on_nl return UNK on_nl end on_nl # FIXME # This probably won't work properly
def UNK UNK on_comma input on_nl copy on_op input on_period UNK on_nl copy on_period gsub! on_lparen on_const on_lbracket on_int on_rbracket # Writes out text, substituting special characters beforehand. # +out+ A String, IO, or any other object supporting <<( String ) # +input+ the text to substitute and the write out # # z=utf8.unpack("U*") # ascOut="" # z.each{|r| # if r < 0x100 # ascOut.concat(r.chr) # else # ascOut.concat(sprintf("&#x%x;", r)) # end # } # puts ascOut
copy on_period gsub! on_lparen on_const on_lbracket on_int on_rbracket on_comma on_const on_lbracket on_int on_rbracket on_rparen on_nl copy on_period gsub! on_lparen on_const # Doing it like this rather than in a loop improves the speed
def on_const on_op UNK on_lparen input on_comma illegal on_op nil on_rparen on_ignored_nl copy on_op input on_period UNK on_nl on_ignored_nl if # Reads text, substituting entities
UNK on_op on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_end if UNK on_lbracket on_int on_rbracket on_op on_char on_nl on_lbracket on_const on_lparen UNK #m='0' if m==''
def on_const on_op UNK on_lparen input on_comma doctype on_op nil on_comma entity_filter on_op nil on_rparen on_ignored_nl copy on_op input on_period # Escapes all possible entities
copy on_op copy on_period gsub on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl if doctype on_nl doctype on_period # Doing it like this rather than in a loop improves the speed #copy = copy.gsub( EREFERENCE, '&amp;' )
doctype on_period UNK on_period UNK UNK on_op entity on_op on_ignored_nl copy on_op copy on_period gsub on_lparen entity on_period UNK on_comma # Replace all ampersands that aren't part of an entity
on_const on_op on_const on_period UNK UNK on_op entity on_op on_ignored_nl copy on_op copy on_period gsub on_lparen entity on_period UNK on_comma # Replace all ampersands that aren't part of an entity
def on_const on_op UNK on_lparen string on_comma doctype on_op nil on_comma UNK on_op nil on_comma illegal on_op nil on_rparen on_ignored_nl # Unescapes all possible entities
