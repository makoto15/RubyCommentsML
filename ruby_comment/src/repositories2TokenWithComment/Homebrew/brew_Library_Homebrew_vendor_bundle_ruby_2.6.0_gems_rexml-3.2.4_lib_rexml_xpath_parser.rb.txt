on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content # frozen_string_literal: false
def dclone on_nl UNK on_nl end on_nl end on_nl class on_const on_nl def dclone on_semicolon self on_semicolon end on_nl end # provides a unified +clone+ operation, for REXML::XPathParser # to use across multiple Object types
def dclone on_semicolon self on_semicolon end on_nl end on_nl class on_const on_nl def dclone on_semicolon self on_semicolon end on_nl end # provides a unified +clone+ operation, for REXML::XPathParser # to use across multiple Object types
def dclone on_semicolon self on_semicolon end on_nl end on_nl class on_const on_nl def dclone on_semicolon self on_semicolon end on_nl end # provides a unified +clone+ operation, for REXML::XPathParser # to use across multiple Object types
def dclone on_semicolon self on_semicolon end on_nl end on_nl class on_const on_nl def dclone on_nl UNK on_op self on_period UNK # provides a unified +clone+ operation, for REXML::XPathParser # to use across multiple Object types
def dclone on_nl UNK on_op self on_period UNK on_nl UNK on_period UNK on_nl self on_period each on_lbrace on_op UNK on_op # provides a unified +clone+ operation, for REXML::XPathParser # to use across multiple Object+ types
class on_const on_nl UNK on_const on_nl on_const on_op UNK on_tstring_content UNK on_nl on_ignored_nl on_const on_op on_lparen on_const on_lbracket on_tstring_beg on_tstring_content # You don't want to use this class. Really. Use XPath, which is a wrapper # for this class. Believe me. You don't want to poke around in here. # There is strange, dark magic at work in this code. Beware. Go back! Go # back while you still can!
def first on_lparen path_stack on_comma node on_rparen on_ignored_nl return nil if path on_period size on_op on_int on_nl on_ignored_nl case path # Performs a depth-first (document order) XPath search, and returns the # first match. This is the fastest, lightest way to return a single result. # # FIXME: This method is incomplete!
return first on_lparen path on_lbracket on_int on_op on_op on_int on_rbracket on_comma node on_rparen on_nl when on_symbeg child on_nl UNK UNK # do nothing
unnode on_lparen result on_rparen on_nl else on_ignored_nl on_lbracket result on_rbracket on_nl end on_nl end on_nl on_ignored_nl UNK on_nl def UNK # nodeset
def UNK on_lparen node on_comma prefix on_rparen on_ignored_nl if on_ivar on_nl return on_ivar on_lbracket prefix on_rbracket on_op on_tstring_beg on_tstring_end on_nl # Returns a String namespace for a node, given a prefix # The rules are: # # 1. Use the supplied namespace mapping first. # 2. If no mapping was supplied, use the context node to look up the namespace
def expr on_lparen path_stack on_comma nodeset on_comma context on_op nil on_rparen on_ignored_nl enter on_lparen on_symbeg expr on_comma path_stack on_comma nodeset # Expr takes a stack of path elements and a set of nodes (either a Parent # or an Array and returns an Array of matching nodes
nodeset on_period each do on_op node on_op on_ignored_nl raw_node on_op node on_period raw_node on_nl new_nodeset on_op on_lbracket on_rbracket on_nl while # new_nodes = {}
new_nodeset on_op on_const on_period new on_lparen raw_node on_comma on_ignored_nl on_label new_nodeset on_period size on_op on_int on_rparen on_nl end on_nl nodesets # next if new_nodes.key?(node)
end on_nl nodesets on_op new_nodeset unless new_nodeset on_period empty? on_nl end on_nl nodesets on_nl end on_nl when on_symbeg UNK on_nl # new_nodes[node] = true
nodeset on_period each do on_op node on_op on_ignored_nl raw_node on_op node on_period raw_node on_nl next unless raw_node on_period node_type on_op # new_nodes = {}
while raw_node on_period parent on_nl raw_node on_op raw_node on_period parent on_nl new_nodeset on_op on_const on_period new on_lparen raw_node on_comma on_ignored_nl # new_nodes[node] = true
new_nodeset on_op on_const on_period new on_lparen raw_node on_comma on_ignored_nl on_label new_nodeset on_period size on_op on_int on_rparen on_nl end on_nl nodesets # next if new_nodes.key?(node)
end on_nl nodesets on_op new_nodeset unless new_nodeset on_period empty? on_nl end on_nl nodesets on_nl end on_nl when on_symbeg UNK on_nl # new_nodes[node] = true
return nodeset on_nl UNK on_ignored_nl leave on_lparen on_symbeg expr on_comma path_stack on_comma nodeset on_rparen if on_ivar on_nl end on_nl on_ignored_nl # while
UNK on_op path_stack on_period shift on_period dclone on_nl nodesets on_op UNK on_lparen UNK on_comma nodesets on_rparen on_nl end on_nl if # :predicate
new_nodeset on_op on_const on_period new on_lparen node on_comma on_label new_nodeset on_period size on_op on_int on_rparen on_nl end on_nl new_nodeset on_nl # TODO: Remove duplicated
ns on_op UNK on_lparen raw_node on_comma prefix on_rparen on_nl raw_node on_period name on_op name and raw_node on_period namespace on_op ns # FIXME: This DOUBLES the time XPath searches take
ns on_op UNK on_lparen raw_node on_comma prefix on_rparen on_nl raw_node on_period name on_op name and raw_node on_period namespace on_op ns # FIXME: This DOUBLES the time XPath searches take
ns on_op UNK on_lparen raw_node on_period element on_comma prefix on_rparen on_nl raw_node on_period name on_op name and raw_node on_period namespace # FIXME: This DOUBLES the time XPath searches take
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl UNK on_op on_lbracket on_rbracket on_nl UNK on_period each on_lbrace on_op node on_op # Reorders an array of nodes so that they are in document order # It tries to do this efficiently. # # FIXME: I need to get rid of this, but the issue is that most of the XPath # interpreter functions as a filter, which means that we lose context going # in and out of function calls. If I knew what the index of the nodes was, # I wouldn't have to do this. Maybe add a document IDX for each node? # Problems with mutable documents. Or, rewrite everything.
def UNK on_lparen node on_rparen on_ignored_nl UNK on_op on_lbracket on_rbracket on_nl parent on_op node on_period parent on_nl while parent on_nl # Builds a nodeset of all of the preceding nodes of the supplied node, # in reverse document order # preceding:: includes every element in the document that precedes this node, # except for ancestors
end on_nl while psn and psn on_period kind_of? on_const and psn on_period children on_period size on_op on_int on_nl psn on_op #psn = preceding_node_of( node.parent )
case node_type on_nl when on_symbeg element on_nl nodesets on_op raw_node on_period children on_period collect on_period UNK do on_op UNK on_comma # trace(:child, node_type, node)
else on_ignored_nl new_nodeset on_op on_const on_period new on_lparen child on_comma on_label new_nodeset on_period size on_op on_int on_rparen on_nl end on_nl # Ignore
set1 on_period UNK on_lparen set2 on_rparen on_period UNK do on_op UNK on_comma UNK on_op on_ignored_nl UNK on_op on_const on_period string # If both objects to be compared are node-sets, then the # comparison will be true if and only if there is a node in the # first node-set and a node in the second node-set such that the # result of performing the comparison on the string-values of # the two nodes is true.
if set1 on_period kind_of? on_const on_nl a on_op set1 on_nl b on_op set2 on_nl else on_ignored_nl a on_op set2 on_nl # If one is nodeset and other is number, compare number to each item # in nodeset s.t. number op number(string(item)) # If one is nodeset and other is string, compare string to each item # in nodeset s.t. string op string(item) # If one is nodeset and other is boolean, compare boolean to each item # in nodeset s.t. boolean op boolean(item)
compare on_lparen set1 on_comma op on_comma set2 on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl # If neither is nodeset, # If op is = or != # If either boolean, convert to boolean # If either number, convert to number # Else, convert to string # Else # Convert both to numbers and compare
class on_const on_nl UNK on_symbeg raw_node on_comma on_symbeg context on_nl def UNK on_lparen node on_comma context on_op nil on_rparen on_ignored_nl # @private
