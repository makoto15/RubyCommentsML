UNK on_const on_op on_op on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_lparen on_symbeg reference on_rparen on_nl UNK on_symbeg reference # An atomic reference which maintains an object reference along with a mark bit # that can be updated atomically. # # @see http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicMarkableReference.html # java.util.concurrent.atomic.AtomicMarkableReference
def UNK on_lparen UNK on_comma new_val on_comma UNK on_comma new_mark on_rparen on_ignored_nl UNK on_op reference on_nl UNK on_comma UNK on_op # Atomically sets the value and mark to the given updated value and # mark given both: # - the current value == the expected value && # - the current mark == the expected mark # # @param [Object] expected_val the expected value # @param [Object] new_val the new value # @param [Boolean] expected_mark the expected mark # @param [Boolean] new_mark the new mark # # @return [Boolean] `true` if successful. A `false` return indicates # that the actual value was not equal to the expected value or the # actual mark was not equal to the expected mark
UNK on_op reference on_nl UNK on_comma UNK on_op UNK on_nl on_ignored_nl UNK UNK UNK UNK on_op UNK on_nl on_ignored_nl UNK # Memoize a valid reference to the current AtomicReference for # later comparison.
UNK UNK UNK UNK on_op UNK on_nl on_ignored_nl UNK UNK UNK UNK on_const on_nl UNK UNK UNK UNK on_op UNK # Ensure that that the expected marks match.
UNK UNK UNK UNK on_op UNK on_nl UNK on_ignored_nl UNK UNK UNK UNK UNK UNK UNK on_nl end on_nl on_ignored_nl # If the object is a numeric, we need to ensure we are comparing # the numerical values
UNK UNK UNK UNK UNK UNK UNK on_nl end on_nl on_ignored_nl UNK on_op immutable_array on_lparen new_val on_comma new_mark on_rparen on_nl # Otherwise, we need to ensure we are comparing the object identity. # Theoretically, this could be incorrect if a user monkey-patched # `Object#equal?`, but they should know that they are playing with # fire at that point.
def UNK on_nl reference on_nl end on_nl on_ignored_nl def UNK on_nl reference UNK UNK UNK on_nl end on_nl on_ignored_nl def # Gets the current reference and marked values. # # @return [Array] the current reference and marked values
def UNK on_nl reference UNK UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl reference UNK UNK UNK on_nl end # Gets the current value of the reference # # @return [Object] the current value of the reference
def UNK on_nl reference UNK UNK UNK on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def # Gets the current marked value # # @return [Boolean] the current marked value
def UNK on_lparen new_val on_comma new_mark on_rparen on_ignored_nl UNK UNK reference on_op immutable_array on_lparen new_val on_comma new_mark on_rparen on_nl end # _Unconditionally_ sets to the given value of both the reference and # the mark. # # @param [Object] new_val the new value # @param [Boolean] new_mark the new mark # # @return [Array] both the new value and the new mark
def UNK on_nl UNK UNK on_ignored_nl old_val on_comma old_mark on_op reference on_nl new_val on_comma new_mark on_op UNK old_val on_comma old_mark # Pass the current value and marked state to the given block, replacing it # with the block's results. May retry if the value changes during the # block's execution. # # @yield [Object] Calculate a new value and marked state for the atomic # reference using given (old) value and (old) marked # @yieldparam [Object] old_val the starting value of the atomic reference # @yieldparam [Boolean] old_mark the starting state of marked # # @return [Array] the new value and new mark
def UNK on_nl old_val on_comma old_mark on_op reference on_nl new_val on_comma new_mark on_op UNK old_val on_comma old_mark on_nl on_ignored_nl UNK # Pass the current value to the given block, replacing it # with the block's result. Raise an exception if the update # fails. # # @yield [Object] Calculate a new value and marked state for the atomic # reference using given (old) value and (old) marked # @yieldparam [Object] old_val the starting value of the atomic reference # @yieldparam [Boolean] old_mark the starting state of marked # # @return [Array] the new value and marked state # # @raise [Concurrent::ConcurrentUpdateError] if the update fails
def UNK on_nl old_val on_comma old_mark on_op reference on_nl new_val on_comma new_mark on_op UNK old_val on_comma old_mark on_nl on_ignored_nl UNK # Pass the current value to the given block, replacing it with the # block's result. Simply return nil if update fails. # # @yield [Object] Calculate a new value and marked state for the atomic # reference using given (old) value and (old) marked # @yieldparam [Object] old_val the starting value of the atomic reference # @yieldparam [Boolean] old_mark the starting state of marked # # @return [Array] the new value and marked state, or nil if # the update failed
