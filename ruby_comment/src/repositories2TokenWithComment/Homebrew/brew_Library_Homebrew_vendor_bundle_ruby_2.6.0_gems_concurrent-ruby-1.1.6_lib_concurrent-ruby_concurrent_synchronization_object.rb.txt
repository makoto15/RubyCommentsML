on_const on_op UNK on_ignored_nl UNK on_const on_period UNK on_nl on_const on_nl UNK on_const on_period UNK on_nl on_const on_nl UNK on_const # @!visibility private # @!macro internal_implementation_note
UNK on_const on_op on_const on_nl on_ignored_nl on_ignored_nl def UNK on_nl UNK on_nl UNK on_nl end on_nl on_ignored_nl def self on_period # Abstract object providing final, volatile, ans CAS extensions to build other concurrent abstractions. # - final instance variables see {Object.safe_initialization!} # - volatile instance variables see {Object.attr_volatile} # - volatile instance variables see {Object.attr_atomic}
on_ignored_nl on_ignored_nl def UNK on_nl UNK on_nl UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_nl UNK UNK UNK # TODO make it a module if possible
on_ignored_nl def UNK on_nl UNK on_nl UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_nl UNK UNK UNK on_nl # @!method self.attr_volatile(*names) # Creates methods for reading and writing (as `attr_accessor` does) to a instance variable with # volatile (Java) semantic. The instance variable should be accessed only through generated methods. # # @param [::Array<Symbol>] names of the instance variables to be volatile # @return [::Array<Symbol>] names of defined method names
def UNK on_nl UNK on_nl UNK on_nl end on_nl on_ignored_nl def self on_period UNK on_nl UNK UNK UNK on_nl on_ignored_nl # Has to be called by children.
def self on_period UNK on_nl UNK UNK UNK on_nl on_ignored_nl def self on_period UNK on_lparen on_op UNK on_comma on_op UNK # By calling this method on a class, it and all its children are marked to be constructed safely. Meaning that # all writes (ivar initializations) are made visible to all readers of newly constructed object. It ensures # same behaviour as Java's final fields. # @example # class AClass < Concurrent::Synchronization::Object # safe_initialization! # # def initialize # @AFinalValue = 'value' # published safely, does not have to be synchronized # end # end # @return [true]
UNK UNK UNK on_nl on_ignored_nl def self on_period UNK on_lparen on_op UNK on_comma on_op UNK on_rparen on_ignored_nl object on_op UNK # define only once, and not again in children
def self on_period UNK on_lparen on_op UNK on_comma on_op UNK on_rparen on_ignored_nl object on_op UNK on_lparen on_op UNK on_comma on_op # @!visibility private
def self on_period UNK on_nl on_ivar on_op UNK UNK UNK on_ivar on_nl on_ivar on_op on_lparen UNK on_period UNK on_lparen on_symbeg # @return [true, false] if this class is safely initialized.
def self on_period UNK on_nl on_const on_period UNK UNK on_ignored_nl def self on_period UNK on_lparen on_op UNK on_comma on_op UNK # For testing purposes, quite slow. Injects assert code to new method which will raise if class instance contains # any instance variables with CamelCase names and isn't {.safe_initialization?}. # @raise when offend found # @return [true]
def self on_period UNK on_lparen on_op UNK on_rparen on_ignored_nl on_ivar on_op UNK UNK on_nl on_ivar on_op UNK on_nl UNK on_nl # Creates methods for reading and writing to a instance variable with # volatile (Java) semantic as {.attr_volatile} does. # The instance variable should be accessed oly through generated methods. # This method generates following methods: `value`, `value=(new_value) #=> new_value`, # `swap_value(new_value) #=> old_value`, # `compare_and_set_value(expected, value) #=> true || false`, `update_value(&block)`. # @param [::Array<Symbol>] names of the instance variables to be volatile with CAS. # @return [::Array<Symbol>] names of defined method names. # @!macro attr_atomic # @!method $1 # @return [Object] The $1. # @!method $1=(new_$1) # Set the $1. # @return [Object] new_$1. # @!method swap_$1(new_$1) # Set the $1 to new_$1 and return the old $1. # @return [Object] old $1 # @!method compare_and_set_$1(expected_$1, new_$1) # Sets the $1 to new_$1 if the current $1 is expected_$1 # @return [true, false] # @!method update_$1(&block) # Updates the $1 using the block. # @yield [Object] Calculate a new $1 using given (old) $1 # @yieldparam [Object] old $1 # @return [Object] new $1
def self on_period UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl on_ivar on_op UNK UNK on_nl on_lparen on_lparen UNK on_period UNK # @param [true, false] inherited should inherited volatile with CAS fields be returned? # @return [::Array<Symbol>] Returns defined volatile with CAS fields on this class.
def self on_period UNK on_lparen name on_rparen on_ignored_nl UNK on_period UNK name on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def # @return [true, false] is the attribute with name atomic?
