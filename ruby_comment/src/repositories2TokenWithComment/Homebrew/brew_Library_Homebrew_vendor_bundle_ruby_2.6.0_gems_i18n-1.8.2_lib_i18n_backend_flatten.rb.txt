on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl on_const on_op UNK UNK UNK on_nl on_const on_op UNK UNK # frozen_string_literal: true
UNK on_const on_nl on_const on_op UNK UNK UNK on_nl on_const on_op UNK UNK UNK on_nl on_ignored_nl def UNK on_period UNK # This module contains several helpers to assist flattening translations. # You may want to flatten translations for: # # 1) speed up lookups, as in the Memoize backend; # 2) In case you want to store translations in a data store, as in ActiveRecord backend; # # You can check both backends above for some examples. # This module also keeps all links in a hash so they can be properly resolved when flattened.
def UNK on_period UNK on_lparen locale on_comma key on_comma UNK on_comma separator on_rparen on_ignored_nl UNK on_op on_lbracket UNK on_comma key # normalize_keys the flatten way. This method is significantly faster # and creates way less objects than the one at I18n.normalize_keys. # It also handles escaping the translation keys.
def UNK on_period UNK on_lparen key on_rparen key on_period UNK on_period UNK on_lparen on_const on_comma on_const on_rparen on_nl end on_nl # Receives a string and escape the default separator.
key on_period UNK on_period UNK on_lparen on_const on_comma on_const on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen locale on_comma key #:nodoc:
def UNK on_lparen locale on_comma key on_comma UNK on_comma separator on_rparen on_ignored_nl key on_op on_const on_op on_const on_op on_const on_period # Shortcut to I18n::Backend::Flatten.normalize_flat_keys # and then resolve_links.
def links on_nl UNK on_op on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen hash on_comma UNK on_comma UNK # Store flattened links.
def UNK on_lparen hash on_comma UNK on_comma UNK on_op UNK on_comma on_op UNK on_rparen on_ignored_nl hash on_period UNK UNK on_op # Flatten keys for nested Hashes by chaining up keys: # # >> { "a" => { "b" => { "c" => "d", "e" => "f" }, "g" => "h" }, "i" => "j"}.wind # => { "a.b.c" => "d", "a.b.e" => "f", "a.g" => "h", "i" => "j" } #
def UNK on_lparen locale on_comma UNK on_comma UNK on_comma UNK on_rparen on_ignored_nl hash on_op UNK UNK on_nl UNK on_lparen UNK # Receives a hash of translations (where the key is a locale and # the value is another hash) and return a hash with all # translations flattened. # # Nested hashes are included in the flattened hash just if subtree # is true and Symbols are automatically stored as links.
links on_lbracket locale on_rbracket on_period UNK UNK on_op UNK on_comma UNK on_op on_ignored_nl UNK on_lbracket UNK on_comma UNK on_rbracket if #:nodoc:
on_const on_op on_const on_op on_const on_period UNK on_lparen key on_rparen on_nl end on_nl on_ignored_nl end on_nl end on_nl end on_nl #:nodoc:
