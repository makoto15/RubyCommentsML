UNK on_const on_nl on_ignored_nl on_const on_op UNK on_ignored_nl UNK on_const on_period UNK on_nl on_const on_nl UNK on_const on_period UNK on_nl # @!visibility private
on_const on_op UNK on_ignored_nl UNK on_const on_period UNK on_nl on_const on_nl UNK on_const on_period UNK on_nl require on_tstring_beg on_tstring_content on_tstring_end # @!visibility private
on_const on_nl UNK on_const on_period UNK on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_nl UNK on_const on_period UNK on_op on_const # noinspection RubyResolve
UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl # `Concurrent::Map` is a hash-like object and should have much better performance # characteristics, especially under high concurrency, than `Concurrent::Hash`. # However, `Concurrent::Map `is not strictly semantically equivalent to a ruby `Hash` # -- for instance, it does not necessarily retain ordering by insertion time as `Hash` # does. For most uses it should do fine though, and we recommend you consider # `Concurrent::Map` instead of `Concurrent::Hash` for your concurrency-safe hash needs.
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op # @!macro map.atomic_method # This method is atomic.
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK # @!macro map.atomic_method_with_block # This method is atomic. # @note Atomic methods taking a block do not allow the `self` instance # to be used within the block. Doing so will cause a deadlock.
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen # @!method compute_if_absent(key) # Compute and store new value for key if the key is absent. # @param [Object] key # @yield new value # @yieldreturn [Object] new value # @return [Object] new value or current value # @!macro map.atomic_method_with_block
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl # @!method compute_if_present(key) # Compute and store new value for key if the key is present. # @param [Object] key # @yield new value # @yieldparam old_value [Object] # @yieldreturn [Object, nil] new value, when nil the key is removed # @return [Object, nil] new value or nil # @!macro map.atomic_method_with_block
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl if # @!method compute(key) # Compute and store new value for key. # @param [Object] key # @yield compute new value from old one # @yieldparam old_value [Object, nil] old_value, or nil when key is absent # @yieldreturn [Object, nil] new value, when nil the key is removed # @return [Object, nil] new value or nil # @!macro map.atomic_method_with_block
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl if options # @!method merge_pair(key, value) # If the key is absent, the value is stored, otherwise new value is # computed with a block. # @param [Object] key # @param [Object] value # @yield compute new value from old one # @yieldparam old_value [Object] old value # @yieldreturn [Object, nil] new value, when nil the key is removed # @return [Object, nil] new value or nil # @!macro map.atomic_method_with_block
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl if options on_period # @!method replace_pair(key, old_value, new_value) # Replaces old_value with new_value if key exists and current value # matches old_value # @param [Object] key # @param [Object] old_value # @param [Object] new_value # @return [true, false] true if replaced # @!macro map.atomic_method
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl if options on_period UNK # @!method replace_if_exists(key, new_value) # Replaces current value with new_value if key exists # @param [Object] key # @param [Object] new_value # @return [Object, nil] old value or nil # @!macro map.atomic_method
on_ignored_nl on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl if options on_period UNK on_lparen # @!method get_and_set(key, value) # Get the current value under key and set new value. # @param [Object] key # @param [Object] value # @return [Object, nil] old value or nil when the key was absent # @!macro map.atomic_method
on_ignored_nl on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl if options on_period UNK on_lparen on_op # @!method delete(key) # Delete key and its value. # @param [Object] key # @return [Object, nil] old value or nil when the key was absent # @!macro map.atomic_method
on_ignored_nl on_ignored_nl def UNK on_lparen options on_op UNK on_comma on_op UNK on_rparen on_ignored_nl if options on_period UNK on_lparen on_op on_const # @!method delete_pair(key, value) # Delete pair and its value if current value equals the provided value. # @param [Object] key # @param [Object] value # @return [true, false] true if deleted # @!macro map.atomic_method
def on_op on_lparen key on_rparen on_ignored_nl if value on_op UNK value on_nl UNK UNK on_op UNK on_op value on_op on_const # Get a value with key # @param [Object] key # @return [Object] the value
value on_nl UNK UNK on_op UNK on_op value on_op on_const on_op on_lparen value on_op UNK on_lparen key on_comma on_const on_rparen # non-falsy value is an existing mapping, return it right away
UNK UNK on_op UNK on_op value on_op on_const on_op on_lparen value on_op UNK on_lparen key on_comma on_const on_rparen on_rparen on_nl # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value # would be returned) # note: nil == value check is not technically necessary
UNK on_symbeg UNK on_comma on_symbeg on_op on_nl on_ignored_nl def UNK on_lparen key on_comma default_value on_op on_const on_rparen on_ignored_nl if on_const # TODO (pitr-ch 30-Oct-2018): doc
def UNK on_lparen key on_comma default_value on_op on_const on_rparen on_ignored_nl if on_const on_op on_lparen value on_op UNK on_lparen key on_comma # Get a value with key, or default_value when key is absent, # or fail when no default_value is given. # @param [Object] key # @param [Object] default_value # @yield default value for a key # @yieldparam key [Object] # @yieldreturn [Object] default value # @return [Object] the value or default value # @raise [KeyError] when key is missing and no default_value is provided # @!macro map_method_not_atomic # @note The "fetch-then-act" methods of `Map` are not atomic. `Map` is intended # to be use as a concurrency primitive with strong happens-before # guarantees. It is not intended to be used as a high-level abstraction # supporting complex operations. All read and write operations are # thread safe, but no guarantees are made regarding race conditions # between the fetch operation and yielding to the block. Additionally, # this method does not support recursion. This is due to internal # constraints that are very unlikely to change in the near future.
def UNK on_lparen key on_comma default_value on_op on_const on_rparen on_ignored_nl UNK on_lparen key on_rparen UNK on_ignored_nl UNK on_lparen key on_comma # Fetch value with key, or store default value when key is absent, # or fail when no default_value is given. This is a two step operation, # therefore not atomic. The store can overwrite other concurrently # stored value. # @param [Object] key # @param [Object] default_value # @yield default value for a key # @yieldparam key [Object] # @yieldreturn [Object] default value # @return [Object] the value or default value # @!macro map.atomic_method_with_block
def UNK on_lparen key on_comma value on_rparen on_ignored_nl UNK on_op UNK on_nl UNK on_op UNK on_lparen key on_rparen UNK on_ignored_nl # Insert value into map with key if key is absent in one atomic step. # @param [Object] key # @param [Object] value # @return [Object, nil] the previous value when key was present or nil when there was no key
def UNK on_lparen value on_rparen on_ignored_nl UNK UNK on_op v on_op on_ignored_nl UNK UNK if value on_period UNK on_lparen v # Is the value stored in the map. Iterates over all values. # @param [Object] value # @return [true, false]
def UNK on_nl arr on_op on_lbracket on_rbracket on_nl each_pair on_lbrace on_op k on_comma v on_op arr on_op k on_rbrace on_nl # All keys # @return [::Array<Object>] keys
def UNK on_nl arr on_op on_lbracket on_rbracket on_nl each_pair on_lbrace on_op k on_comma v on_op arr on_op v on_rbrace on_nl # All values # @return [::Array<Object>] values
def UNK on_nl each_pair on_lbrace on_op k on_comma v on_op UNK k on_rbrace on_nl end unless method_defined? on_lparen on_symbeg UNK # Iterates over each key. # @yield for each key in the map # @yieldparam key [Object] # @return [self] # @!macro map.atomic_method_with_block
def UNK on_nl each_pair on_lbrace on_op k on_comma v on_op UNK v on_rbrace on_nl end unless method_defined? on_lparen on_symbeg UNK # Iterates over each value. # @yield for each value in the map # @yieldparam value [Object] # @return [self] # @!macro map.atomic_method_with_block
def each_pair on_nl UNK UNK on_symbeg each_pair unless UNK on_nl UNK on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg # Iterates over each key value pair. # @yield for each key value pair in the map # @yieldparam key [Object] # @yieldparam value [Object] # @return [self] # @!macro map.atomic_method_with_block
def key on_lparen value on_rparen on_ignored_nl each_pair on_lbrace on_op k on_comma v on_op UNK k if v on_op value on_rbrace # Find key of a value. # @param [Object] value # @return [Object, nil] key or nil when not found
def UNK on_nl each_pair on_lbrace on_op k on_comma v on_op UNK UNK on_rbrace on_nl UNK on_nl end unless method_defined? on_lparen # Is map empty? # @return [true, false]
def UNK on_nl UNK on_op on_int on_nl each_pair on_lbrace on_op k on_comma v on_op UNK on_op on_int on_rbrace on_nl UNK # The size of map. # @return [Integer] size
def UNK on_nl UNK on_const on_comma on_tstring_beg on_tstring_content on_tstring_end if UNK on_nl UNK on_op on_lbrace on_rbrace on_nl each_pair on_lbrace on_op # @!visibility private
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_nl UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_nl # @!visibility private
def UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_comma UNK on_lbracket on_int on_op on_op on_int on_rbracket on_comma UNK on_period UNK on_comma # @!visibility private
