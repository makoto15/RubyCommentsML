on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl # Hack to load json gem first so we can overwrite its to_json.
require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl # for #to_s
on_ignored_nl UNK on_const on_nl UNK on_const def UNK on_lparen options on_op nil on_rparen on_ignored_nl if options on_period UNK on_lparen on_op #-- # The JSON gem adds a few modules to Ruby core classes containing :to_json definition, overwriting # their default behavior. That said, we need to define the basic to_json method in all of them, # otherwise they will always use to_json gem implementation, which is backwards incompatible in # several cases (for instance, the JSON implementation for Hash does not work) with inheritance # and consequently classes as ActiveSupport::OrderedHash cannot be serialized to json. # # On the other hand, we should avoid conflict with ::JSON.{generate,dump}(obj). Unfortunately, the # JSON gem's encoder relies on its own to_json implementation to encode objects. Since it always # passes a ::JSON::State object as the only argument to to_json, we can detect that and forward the # calls to the original to_json method. # # It should be noted that when using ::JSON.{generate,dump} directly, ActiveSupport's encoder is # bypassed completely. This means that as_json won't be invoked and the JSON gem will simply # ignore any options it does not natively understand. This also means that ::JSON.{generate,dump} # should give exactly the same results with or without active support.
def UNK on_lparen options on_op nil on_rparen on_ignored_nl if options on_period UNK on_lparen on_op on_const on_op on_const on_rparen on_nl UNK # :nodoc:
UNK on_lparen options on_rparen on_nl else on_ignored_nl on_const on_op on_const on_period UNK on_lparen self on_comma options on_rparen on_nl end on_nl # Called from JSON.{generate,dump}, forward it to JSON gem's to_json
on_const on_op on_const on_period UNK on_lparen self on_comma options on_rparen on_nl end on_nl end on_nl end on_nl end on_nl on_ignored_nl # to_json is being invoked directly, use ActiveSupport's encoder
if UNK on_lparen UNK UNK on_rparen on_nl UNK on_period as_json on_lparen options on_rparen on_nl else on_ignored_nl UNK on_period as_json on_lparen #:nodoc:
def as_json on_lparen options on_op nil on_rparen on_ignored_nl on_const on_lbracket UNK on_period UNK on_lparen UNK on_rparen on_rbracket on_period as_json on_lparen #:nodoc:
self on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen self on_nl end #:nodoc:
self on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen self on_nl end #:nodoc:
self on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen self on_nl end #:nodoc:
self on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen to_s on_nl end #:nodoc:
to_s on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen self on_nl end #:nodoc:
self on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen UNK on_op self #:nodoc:
def as_json on_lparen options on_op nil on_rparen UNK on_op self on_op nil on_nl end on_nl end on_nl on_ignored_nl class on_const # Encoding Infinity or NaN to JSON should return "null". The default returns # "Infinity" or "NaN" which are not valid JSON.
UNK on_op self on_op nil on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil #:nodoc:
def as_json on_lparen options on_op nil on_rparen UNK on_op to_s on_op nil on_nl end on_nl end on_nl on_ignored_nl class on_const # A BigDecimal would be naturally represented as a JSON number. Most libraries, # however, parse non-integer JSON numbers directly as floats. Clients using # those libraries would get in general a wrong number and no way to recover # other than manually inspecting the string with the JSON code itself. # # That's why a JSON string is returned. The JSON literal is not numeric, but # if the other end knows by contract that the data is supposed to be a # BigDecimal, it still has the chance to post-process the string and get the # real value.
UNK on_op to_s on_op nil on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil #:nodoc:
to_s on_nl end on_nl end on_nl on_ignored_nl UNK on_const on_nl def as_json on_lparen options on_op nil on_rparen UNK on_period as_json #:nodoc:
UNK on_period as_json on_lparen options on_rparen on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op #:nodoc:
to_s on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen to_s on_nl end #:nodoc:
to_s on_nl end on_nl end on_nl on_ignored_nl class on_const on_nl def as_json on_lparen options on_op nil on_rparen UNK UNK on_op #:nodoc:
UNK UNK on_op v on_op options on_op v on_period as_json on_lparen options on_period UNK on_rparen on_op v on_period as_json UNK #:nodoc:
UNK on_op if options on_nl if UNK on_op options on_lbracket UNK UNK on_rbracket on_nl UNK on_lparen on_op on_const on_lparen UNK #:nodoc: # create a subset of the hash by applying :only or :except
if on_const on_op on_const on_op on_const on_period UNK on_nl UNK on_lparen on_const on_op on_const on_op on_const on_period UNK on_rparen on_nl #:nodoc:
if on_const on_op on_const on_op on_const on_period UNK on_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl else on_ignored_nl UNK on_lparen #:nodoc:
if on_const on_op on_const on_op on_const on_period UNK on_nl UNK on_lparen on_const on_op on_const on_op on_const on_period UNK on_rparen on_nl #:nodoc:
def as_json on_lparen options on_op nil on_rparen on_ignored_nl to_s on_nl end on_nl end on_nl on_ignored_nl class on_const def as_json on_lparen #:nodoc:
def as_json on_lparen options on_op nil on_rparen on_ignored_nl to_s on_nl end on_nl end on_nl on_ignored_nl class on_const on_op on_const def #:nodoc:
def as_json on_lparen options on_op nil on_rparen on_ignored_nl UNK UNK UNK on_comma UNK UNK UNK on_nl end on_nl end on_nl #:nodoc:
