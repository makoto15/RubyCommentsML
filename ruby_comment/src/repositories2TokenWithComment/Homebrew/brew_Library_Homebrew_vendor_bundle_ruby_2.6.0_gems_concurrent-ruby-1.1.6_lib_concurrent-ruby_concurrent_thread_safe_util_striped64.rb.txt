UNK on_const on_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl # @!visibility private
UNK on_const on_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg UNK on_comma # @!visibility private
UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl # A Ruby port of the Doug Lea's jsr166e.Striped64 class version 1.6 # available in public domain. # # Original source code available here: # http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/Striped64.java?revision=1.6 # # Class holding common representation and mechanics for classes supporting # dynamic striping on 64bit values. # # This class maintains a lazily-initialized table of atomically updated # variables, plus an extra +base+ field. The table size is a power of two. # Indexing uses masked per-thread hash codes. Nearly all methods on this # class are private, accessed directly by subclasses. # # Table entries are of class +Cell+; a variant of AtomicLong padded to # reduce cache contention on most processors. Padding is overkill for most # Atomics because they are usually irregularly scattered in memory and thus # don't interfere much with each other. But Atomic objects residing in # arrays will tend to be placed adjacent to each other, and so will most # often share cache lines (with a huge negative performance impact) without # this precaution. # # In part because +Cell+s are relatively large, we avoid creating them until # they are needed. When there is no contention, all updates are made to the # +base+ field. Upon first contention (a failed CAS on +base+ update), the # table is initialized to size 2. The table size is doubled upon further # contention until reaching the nearest power of two greater than or equal # to the number of CPUS. Table slots remain empty (+nil+) until they are # needed. # # A single spinlock (+busy+) is used for initializing and resizing the # table, as well as populating slots with new +Cell+s. There is no need for # a blocking lock: When the lock is not available, threads try other slots # (or the base). During these retries, there is increased contention and # reduced locality, which is still better than alternatives. # # Per-thread hash codes are initialized to random values. Contention and/or # table collisions are indicated by failed CASes when performing an update # operation (see method +retry_update+). Upon a collision, if the table size # is less than the capacity, it is doubled in size unless some other thread # holds the lock. If a hashed slot is empty, and lock is available, a new # +Cell+ is created. Otherwise, if the slot exists, a CAS is tried. Retries # proceed by "double hashing", using a secondary hash (XorShift) to try to # find a free slot. # # The table size is capped because, when there are more threads than CPUs, # supposing that each thread were bound to a CPU, there would exist a # perfect hash function mapping threads to slots that eliminates collisions. # When we reach capacity, we search for this mapping by randomly varying the # hash codes of colliding threads. Because search is random, and collisions # only become known via CAS failures, convergence can be slow, and because # threads are typically not bound to CPUS forever, may not occur at all. # However, despite these limitations, observed contention rates are # typically low in these cases. # # It is possible for a +Cell+ to become unused when threads that once hashed # to it terminate, as well as in the case where doubling the table causes no # thread to hash to it under expanded mask. We do not try to detect or # remove such cells, under the assumption that for long-running instances, # observed contention levels will recur, so the cells will eventually be # needed again; and for short-lived ones, it does not matter. # # @!visibility private
UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_nl UNK # Padded variant of AtomicLong supporting only raw accesses plus CAS. # The +value+ field is placed between pads, hoping that the JVM doesn't # reorder them. # # Optimisation note: It would be possible to use a release-only # form of CAS here, if it were provided. # # @!visibility private
def self on_period UNK on_nl UNK on_op on_lparen UNK on_period UNK on_period UNK UNK on_op i on_op on_tstring_beg on_tstring_content UNK # @!visibility private
UNK on_op on_lparen UNK on_period UNK on_period UNK UNK on_op i on_op on_tstring_beg on_tstring_content UNK i UNK on_tstring_end on_period UNK # TODO: this only adds padding after the :value slot, need to find a way to add padding before the slot # TODO (pitr-ch 28-Jul-2018): the padding instance vars may not be created # hide from yardoc in a method
on_symbeg UNK on_comma on_symbeg UNK on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_rparen # Table of cells. When non-null, size is a power of 2.
on_symbeg UNK on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_rparen on_nl self on_period # Base value, used mainly when there is no contention, but also as a fallback during table initialization races. Updated via CAS.
on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_rparen on_nl self on_period UNK on_op # Spinlock (locked via CAS) used when resizing and/or creating Cells.
def UNK on_lparen x on_comma UNK on_comma UNK on_rparen hash on_op UNK on_nl collided on_op false UNK UNK on_nl if # Handles cases of updates involving initialization, resizing, # creating new Cells, and/or contention. See above for # explanation. This method suffers the usual non-modularity # problems of optimistic retry code, relying on rechecked sets of # reads. # # Arguments: # [+x+] # the value # [+hash_code+] # hash code used # [+x+] # false if CAS failed before call
hash on_op UNK on_nl collided on_op false UNK UNK on_nl if current_cells on_op cells on_nl if on_op on_lparen UNK on_op # :yields: current_value
UNK UNK on_nl if current_cells on_op cells on_nl if on_op on_lparen UNK on_op current_cells on_period UNK on_lparen hash on_rparen on_rparen # True if last slot nonempty
if UNK on_lparen on_const on_period UNK on_lparen x on_rparen on_comma hash on_rparen UNK on_nl UNK on_ignored_nl UNK end on_nl end # Try to attach new Cell
UNK on_nl UNK on_ignored_nl UNK end on_nl end on_nl UNK on_op UNK UNK on_op UNK UNK UNK on_period UNK UNK # Optimistically create and try to insert new cell
end on_nl end on_nl UNK on_op UNK UNK on_op UNK UNK UNK on_period UNK UNK on_op UNK on_op UNK UNK # Slot is now non-empty
UNK on_op UNK UNK UNK on_period UNK UNK on_op UNK on_op UNK UNK UNK on_nl UNK on_nl UNK current_cells on_period # CAS already known to fail
UNK UNK on_period UNK UNK on_op UNK on_op UNK UNK UNK on_nl UNK on_nl UNK current_cells on_period UNK on_op on_const # Continue after rehash
collided on_op false on_nl UNK collided on_op UNK on_lparen current_cells on_rparen on_nl collided on_op false on_nl UNK UNK on_ignored_nl collided # At max size or stale
UNK on_ignored_nl collided on_op UNK on_nl end on_nl hash on_op on_const on_period UNK on_lparen hash on_rparen on_nl on_ignored_nl UNK UNK # Retry with expanded table
on_const on_op on_tstring_beg UNK UNK UNK on_tstring_content on_tstring_end on_period UNK on_nl on_ignored_nl def UNK on_nl on_const on_period UNK UNK on_const # Static per-thread hash code key. Shared across all instances to # reduce Thread locals pollution and because adjustments due to # collisions in one table are likely to be appropriate for # others.
def UNK on_nl on_const on_period UNK UNK on_const UNK on_op on_const on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen # A thread-local hash code accessor. The code is initially # random, but may be set to a different value upon collisions.
def UNK on_lparen UNK on_rparen on_ignored_nl current_cells on_op cells on_nl self on_period UNK on_op UNK on_nl if current_cells on_nl current_cells # Sets base and all +cells+ to the given value.
new_cells on_op on_const on_period UNK on_lparen UNK on_rparen on_nl new_cells on_period UNK on_lparen hash on_comma on_const on_period UNK on_lparen x # Recheck under lock
new_cells on_op current_cells on_period UNK on_nl current_cells on_period UNK UNK on_op x on_comma i on_op new_cells on_period UNK on_lparen i # Recheck under lock
if on_lparen current_cells on_op cells on_rparen on_op on_op current_cells on_period UNK on_lparen i on_op current_cells on_period UNK on_lparen hash on_rparen # Recheck under lock
