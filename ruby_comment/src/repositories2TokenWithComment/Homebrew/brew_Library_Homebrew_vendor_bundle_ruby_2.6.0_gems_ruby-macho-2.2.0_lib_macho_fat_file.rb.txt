UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_symbeg filename on_nl on_ignored_nl UNK on_symbeg options on_nl on_ignored_nl UNK on_symbeg header # Represents a "Fat" file, which contains a header, a listing of available # architectures, and one or more Mach-O binaries. # @see https://en.wikipedia.org/wiki/Mach-O#Multi-architecture_binaries # @see MachOFile
UNK on_symbeg filename on_nl on_ignored_nl UNK on_symbeg options on_nl on_ignored_nl UNK on_symbeg header on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl # @return [String] the filename loaded from, or nil if loaded from a binary string
UNK on_symbeg options on_nl on_ignored_nl UNK on_symbeg header on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg machos on_nl on_ignored_nl # @return [Hash] any parser options that the instance was created with # @note Options specified in a {FatFile} trickle down into the internal {MachOFile}s.
UNK on_symbeg header on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg machos on_nl on_ignored_nl def UNK on_period UNK on_lparen # @return [Headers::FatHeader] the file's header
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg machos on_nl on_ignored_nl def UNK on_period UNK on_lparen on_op machos on_comma UNK UNK # @return [Array<Headers::FatArch>, Array<Headers::FatArch64] an array of fat architectures
UNK on_symbeg machos on_nl on_ignored_nl def UNK on_period UNK on_lparen on_op machos on_comma UNK UNK on_rparen on_ignored_nl raise on_const on_comma # @return [Array<MachOFile>] an array of Mach-O binaries
def UNK on_period UNK on_lparen on_op machos on_comma UNK UNK on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end if machos # Creates a new FatFile from the given (single-arch) Mach-Os # @param machos [Array<MachOFile>] the machos to combine # @param fat64 [Boolean] whether to use {Headers::FatArch64}s to represent each slice # @return [FatFile] a new FatFile containing the give machos # @raise [ArgumentError] if less than one Mach-O is given # @raise [FatArchOffsetOverflowError] if the Mach-Os are too big to be represented # in a 32-bit {Headers::FatArch} and `fat64` is `false`.
machos on_op machos on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl on_ignored_nl bin on_op on_op on_tstring_beg on_tstring_end on_nl on_ignored_nl bin # put the smaller alignments further forwards in fat macho, so that we do less padding
def UNK on_period UNK on_lparen bin on_comma on_op opts on_rparen on_ignored_nl UNK on_op UNK on_nl UNK on_period UNK on_lparen bin # Creates a new FatFile instance from a binary string. # @param bin [String] a binary string containing raw Mach-O data # @param opts [Hash] options to control the parser with # @note see {MachOFile#initialize} for currently valid options # @return [FatFile] a new FatFile
def UNK on_lparen filename on_comma on_op opts on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg UNK filename UNK on_tstring_content on_tstring_end UNK on_const # Creates a new FatFile from the given filename. # @param filename [String] the fat file to load from # @param opts [Hash] options to control the parser with # @note see {MachOFile#initialize} for currently valid options # @raise [ArgumentError] if the given file does not exist
def UNK on_lparen bin on_comma opts on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op opts on_nl on_ivar on_op bin on_nl # Initializes a new FatFile instance from a binary string with the given options. # @see new_from_bin # @api private
def serialize on_nl on_ivar on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK # The file's raw fat data. # @return [String] the raw fat data
UNK on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_ignored_nl on_symbeg UNK on_comma on_symbeg UNK on_comma # @!method object? # @return (see MachO::MachOFile#object?) # @!method executable? # @return (see MachO::MachOFile#executable?) # @!method fvmlib? # @return (see MachO::MachOFile#fvmlib?) # @!method core? # @return (see MachO::MachOFile#core?) # @!method preload? # @return (see MachO::MachOFile#preload?) # @!method dylib? # @return (see MachO::MachOFile#dylib?) # @!method dylinker? # @return (see MachO::MachOFile#dylinker?) # @!method bundle? # @return (see MachO::MachOFile#bundle?) # @!method dsym? # @return (see MachO::MachOFile#dsym?) # @!method kext? # @return (see MachO::MachOFile#kext?) # @!method filetype # @return (see MachO::MachOFile#filetype) # @!method dylib_id # @return (see MachO::MachOFile#dylib_id)
UNK on_symbeg header on_comma on_symbeg magic on_nl on_ignored_nl def UNK on_nl on_const on_op on_const on_lbracket magic on_rbracket on_nl end on_nl # @!method magic # @return (see MachO::Headers::FatHeader#magic)
def UNK on_nl on_const on_op on_const on_lbracket magic on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op UNK on_nl # @return [String] a string representation of the file's magic number
def UNK on_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK # Populate the instance's fields with the raw Fat Mach-O data. # @return [void] # @note This method is public, but should (almost) never need to be called.
def UNK on_nl machos on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen # All load commands responsible for loading dylibs in the file's Mach-O's. # @return [Array<LoadCommands::DylibCommand>] an array of DylibCommands
def UNK on_lparen UNK on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end UNK UNK on_period # Changes the file's dylib ID to `new_id`. If the file is not a dylib, # does nothing. # @example # file.change_dylib_id('libFoo.dylib') # @param new_id [String] the new dylib ID # @param options [Hash] # @option options [Boolean] :strict (true) if true, fail if one slice fails. # if false, fail only if all slices fail. # @return [void] # @raise [ArgumentError] if `new_id` is not a String # @see MachOFile#linked_dylibs
def UNK on_nl machos on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def # All shared libraries linked to the file's Mach-Os. # @return [Array<String>] an array of all shared libraries # @see MachOFile#linked_dylibs
machos on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # Individual architectures in a fat binary can link to different subsets # of libraries, but at this point we want to have the full picture, i.e. # the union of all libraries used by all architectures.
def UNK on_lparen UNK on_comma UNK on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl each_macho on_lparen options on_rparen do on_op macho # Changes all dependent shared library install names from `old_name` to # `new_name`. In a fat file, this changes install names in all internal # Mach-Os. # @example # file.change_install_name('/usr/lib/libFoo.dylib', '/usr/lib/libBar.dylib') # @param old_name [String] the shared library name being changed # @param new_name [String] the new name # @param options [Hash] # @option options [Boolean] :strict (true) if true, fail if one slice fails. # if false, fail only if all slices fail. # @return [void] # @see MachOFile#change_install_name
def UNK on_nl machos on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def # All runtime paths associated with the file's Mach-Os. # @return [Array<String>] an array of all runtime paths # @see MachOFile#rpaths
machos on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK # Can individual architectures have different runtime paths?
def UNK on_lparen UNK on_comma UNK on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl each_macho on_lparen options on_rparen do on_op macho # Change the runtime path `old_path` to `new_path` in the file's Mach-Os. # @param old_path [String] the old runtime path # @param new_path [String] the new runtime path # @param options [Hash] # @option options [Boolean] :strict (true) if true, fail if one slice fails. # if false, fail only if all slices fail. # @return [void] # @see MachOFile#change_rpath
def UNK on_lparen UNK on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl each_macho on_lparen options on_rparen do on_op macho on_op on_ignored_nl # Add the given runtime path to the file's Mach-Os. # @param path [String] the new runtime path # @param options [Hash] # @option options [Boolean] :strict (true) if true, fail if one slice fails. # if false, fail only if all slices fail. # @return [void] # @see MachOFile#add_rpath
def UNK on_lparen UNK on_comma options on_op on_lbrace on_rbrace on_rparen on_ignored_nl each_macho on_lparen options on_rparen do on_op macho on_op on_ignored_nl # Delete the given runtime path from the file's Mach-Os. # @param path [String] the runtime path to delete # @param options [Hash] # @option options [Boolean] :strict (true) if true, fail if one slice fails. # if false, fail only if all slices fail. # @return void # @see MachOFile#delete_rpath
def UNK on_lparen UNK on_rparen on_ignored_nl machos on_period UNK on_lbrace on_op macho on_op macho on_period UNK on_op UNK on_rbrace on_period # Extract a Mach-O with the given CPU type from the file. # @example # file.extract(:i386) # => MachO::MachOFile # @param cputype [Symbol] the CPU type of the Mach-O being extracted # @return [MachOFile, nil] the extracted Mach-O or nil if no Mach-O has the given CPU type
def UNK on_lparen filename on_rparen on_ignored_nl on_const on_period UNK on_lparen filename on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace on_op UNK on_op # Write all (fat) data to the given filename. # @param filename [String] the file to write to # @return [void]
def UNK on_nl raise on_const on_comma on_tstring_beg on_tstring_content on_tstring_end if filename on_period UNK on_nl on_ignored_nl on_const on_period UNK on_lparen on_ivar # Write all (fat) data to the file used to initialize the instance. # @return [void] # @raise [MachOError] if the instance was initialized without a file # @note Overwrites all data in the file!
def UNK on_nl on_lbrace on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op header on_period UNK on_comma on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_period # @return [Hash] a hash representation of this {FatFile}
def UNK on_nl raise on_const if on_ivar on_period size on_op on_int on_nl on_ignored_nl fh on_op on_const on_op on_const on_period UNK # Obtain the fat header from raw file data. # @return [Headers::FatHeader] the fat header # @raise [TruncatedFileError] if the file is too small to have a # valid header # @raise [MagicError] if the magic is not valid Mach-O magic # @raise [MachOBinaryError] if the magic is for a non-fat Mach-O file # @raise [JavaClassFileError] if the file is a Java classfile # @api private
raise on_const if on_ivar on_period size on_op on_int on_nl on_ignored_nl fh on_op on_const on_op on_const on_period UNK on_lparen on_symbeg UNK # the smallest fat Mach-O header is 8 bytes
raise on_const if fh on_period UNK on_op on_int on_nl on_ignored_nl fh on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op # Rationale: Java classfiles have the same magic as big-endian fat # Mach-Os. Classfiles encode their version at the same offset as # `nfat_arch` and the lowest version number is 43, so we error out # if a file claims to have over 30 internal architectures. It's # technically possible for a fat Mach-O to have over 30 architectures, # but this is extremely unlikely and in practice distinguishes the two # formats.
def UNK on_nl UNK on_op on_lbracket on_rbracket on_nl on_ignored_nl fa_klass on_op on_const on_period UNK on_lparen header on_period magic on_rparen on_op # Obtain an array of fat architectures from raw file data. # @return [Array<Headers::FatArch>] an array of fat architectures # @api private
def UNK on_nl machos on_op on_lbracket on_rbracket on_nl on_ignored_nl UNK on_period UNK do on_op arch on_op on_ignored_nl machos on_op on_const # Obtain an array of Mach-O blobs from raw file data. # @return [Array<MachOFile>] an array of Mach-Os # @api private
def repopulate_raw_machos on_nl machos on_period UNK do on_op macho on_comma UNK on_op on_ignored_nl arch on_op UNK on_lbracket UNK on_rbracket on_nl # Repopulate the raw Mach-O data with each internal Mach-O object. # @return [void] # @api private
def each_macho on_lparen options on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op options on_period UNK on_lparen on_symbeg UNK on_comma UNK on_rparen # Yield each Mach-O object in the file, rescuing and accumulating errors. # @param options [Hash] # @option options [Boolean] :strict (true) whether or not to fail loudly # with an exception if at least one Mach-O raises an exception. If false, # only raises an exception if *all* Mach-Os raise exceptions. # @raise [RecoverableModificationError] under the conditions of # the `:strict` option above. # @api private
raise UNK if UNK on_nl on_ignored_nl UNK on_op UNK on_nl end on_nl end on_nl on_ignored_nl raise UNK on_period UNK if # Strict mode: Immediately re-raise. Otherwise: Retain, check later.
raise UNK on_period UNK if UNK on_period size on_op machos on_period size on_nl end on_nl on_ignored_nl def UNK on_nl machos # Non-strict mode: Raise first error if *all* Mach-O slices failed.
def UNK on_nl machos on_period UNK on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP # Return a single-arch Mach-O that represents this fat Mach-O for purposes # of delegation. # @return [MachOFile] the Mach-O file # @api private
