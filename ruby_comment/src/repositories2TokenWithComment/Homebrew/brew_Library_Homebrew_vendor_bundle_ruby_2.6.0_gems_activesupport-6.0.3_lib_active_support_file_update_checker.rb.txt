on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl def UNK on_lparen UNK UNK UNK on_op # frozen_string_literal: true
UNK on_const on_nl def UNK on_lparen UNK UNK UNK on_op UNK UNK UNK on_op UNK on_rparen on_ignored_nl UNK UNK on_nl # FileUpdateChecker specifies the API used by Rails to watch files # and control reloading. The API depends on four methods: # # * +initialize+ which expects two parameters and one block as # described below. # # * +updated?+ which returns a boolean if there were updates in # the filesystem or not. # # * +execute+ which executes the given block on initialization # and updates the latest watched files and timestamp. # # * +execute_if_updated+ which just executes the block if it was updated. # # After initialization, a call to +execute_if_updated+ must execute # the block only if there was really a change in the filesystem. # # This class is used by Rails to reload the I18n framework whenever # they are changed upon a new request. # # i18n_reloader = ActiveSupport::FileUpdateChecker.new(paths) do # I18n.reload! # end # # ActiveSupport::Reloader.to_prepare do # i18n_reloader.execute_if_updated # end
def UNK on_lparen UNK UNK UNK on_op UNK UNK UNK on_op UNK on_rparen on_ignored_nl UNK UNK on_nl UNK on_const UNK # It accepts two parameters on initialization. The first is an array # of files and the second is an optional hash of directories. The hash must # have directories as keys and the value is an array of extensions to be # watched under that directory. # # This method must also receive a block that will be called once a path # changes. The array of files and list of directories cannot be changed # after FileUpdateChecker has been initialized.
def UNK on_nl UNK on_op UNK on_nl if on_ivar on_period UNK on_op UNK on_period UNK on_nl on_ivar on_op UNK on_nl # Check if any of the entries were updated. If so, the watched and/or # updated_at values are cached until the block is executed via +execute+ # or +execute_if_updated+.
def UNK on_nl on_ivar on_op UNK on_nl on_ivar on_op UNK on_lparen on_ivar on_rparen on_nl on_ivar on_period UNK on_nl UNK on_ignored_nl # Executes the given block and updates the latest watched files and # timestamp.
def UNK on_nl if UNK on_nl UNK if UNK on_nl UNK on_nl UNK on_nl UNK on_ignored_nl UNK on_nl end on_nl # Execute the block given if updated.
def max_mtime on_lparen UNK on_rparen on_ignored_nl UNK on_op on_const on_period UNK on_nl max_mtime on_op UNK on_nl on_ignored_nl UNK on_period UNK # This method returns the maximum mtime of the files in +paths+, or +nil+ # if the array is empty. # # Files with a mtime in the future are ignored. Such abnormal situation # can happen for example if the user changes the clock by hand. It is # healthy to consider this edge case because with mtimes in the future # reloading is not triggered.
UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK if # Time comparisons are performed with #compare_without_coercion because # AS redefines these operators in a way that is much slower and does not # bring any benefit in this particular code. # # Read t1.compare_without_coercion(t2) < 0 as t1 < t2.
UNK if UNK on_period UNK on_nl on_ignored_nl UNK on_op UNK on_period UNK UNK on_op UNK UNK UNK on_op on_ignored_nl on_tstring_beg # Freeze so changes aren't accidentally pushed
