UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl def UNK on_lparen on_rparen on_ignored_nl UNK on_lparen # Ensures passed jobs in a serialized order never running at the same time.
def UNK on_lparen executor on_comma on_op args on_comma on_op UNK on_rparen on_ignored_nl UNK UNK UNK executor on_comma args on_comma UNK # Submit a task to the executor for asynchronous processing. # # @param [Executor] executor to be used for this job # # @param [Array] args zero or more arguments to be passed to the task # # @yield the asynchronous task to perform # # @return [Boolean] `true` if the task is queued, `false` if the executor # is not running # # @raise [ArgumentError] if no task is given
def UNK on_lparen UNK on_rparen on_ignored_nl on_ignored_nl UNK UNK UNK UNK on_period UNK on_nl on_ignored_nl UNK on_op UNK on_period UNK # As {#post} but allows to submit multiple tasks at once, it's guaranteed that they will not # be interleaved by other tasks. # # @param [Array<Array(ExecutorService, Array<Object>, Proc)>] posts array of triplets where # first is a {ExecutorService}, second is array of args for task, third is a task (Proc)
on_ignored_nl UNK UNK UNK UNK on_period UNK on_nl on_ignored_nl UNK on_op UNK on_period UNK UNK on_op executor on_comma args on_comma # if can_overflow? # raise ArgumentError, 'SerializedExecution does not support thread-pools which can overflow' # end
UNK UNK on_nl UNK on_ignored_nl UNK job on_nl UNK on_op UNK on_nl UNK on_const on_comma UNK on_nl end on_nl end # TODO not the best idea to run it myself
UNK on_const on_comma UNK on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen job on_rparen on_ignored_nl job on_period # let it fail
def UNK on_lparen job on_rparen on_ignored_nl job on_period UNK on_nl UNK on_ignored_nl UNK UNK on_ignored_nl job on_op on_ivar on_period UNK # ensures next job is executed if any is stashed
UNK job UNK job on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP # TODO maybe be able to tell caching pool to just enqueue this job, because the current one end at the end # of this block
