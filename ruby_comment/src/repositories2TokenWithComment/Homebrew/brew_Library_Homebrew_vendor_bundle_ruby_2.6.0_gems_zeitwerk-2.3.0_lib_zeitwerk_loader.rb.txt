on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_tstring_beg # frozen_string_literal: true
attr_reader on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg logger on_nl on_ignored_nl attr_reader on_symbeg root_dirs on_nl on_ignored_nl # @return [String]
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg logger on_nl on_ignored_nl attr_reader on_symbeg root_dirs on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # @return [#camelize]
UNK on_symbeg logger on_nl on_ignored_nl attr_reader on_symbeg root_dirs on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # @return [#call, #debug, nil]
attr_reader on_symbeg root_dirs on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg ignored_paths on_nl on_ignored_nl # Absolute paths of the root directories. Stored in a hash to preserve # order, easily handle duplicates, and also be able to have a fast lookup, # needed for detecting nested paths. # # "/Users/fxn/blog/app/assets" => true, # "/Users/fxn/blog/app/channels" => true, # ... # # This is a private collection maintained by the loader. The public # interface for it is `push_dir` and `dirs`. # # @private # @return [{String => true}]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg ignored_paths on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # Absolute paths of files or directories that have to be preloaded. # # @private # @return [<String>]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg ignored_paths on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # Absolute paths of files, directories, or glob patterns to be totally # ignored. # # @private # @return [Set<String>]
attr_reader on_symbeg ignored_paths on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg autoloads on_nl on_ignored_nl # The actual collection of absolute file and directory names at the time the # ignored glob patterns were expanded. Computed on setup, and recomputed on # reload. # # @private # @return [Set<String>]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg autoloads on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # Absolute paths of directories or glob patterns to be collapsed. # # @private # @return [Set<String>]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg autoloads on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # The actual collection of absolute directory names at the time the collapse # glob patterns were expanded. Computed on setup, and recomputed on reload. # # @private # @return [Set<String>]
attr_reader on_symbeg autoloads on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # Maps real absolute paths for which an autoload has been set ---and not # executed--- to their corresponding parent class or module and constant # name. # # "/Users/fxn/blog/app/models/user.rb" => [Object, :User], # "/Users/fxn/blog/app/models/hotel/pricing.rb" => [Hotel, :Pricing] # ... # # @private # @return [{String => (Module, Symbol)}]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # We keep track of autoloaded directories to remove them from the registry # at the end of eager loading. # # Files are removed as they are autoloaded, but directories need to wait due # to concurrency (see why in Zeitwerk::Loader::Callbacks#on_dir_autoloaded). # # @private # @return [<String>]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg mutex on_nl on_ignored_nl # Stores metadata needed for unloading. Its entries look like this: # # "Admin::Role" => [".../admin/role.rb", [Admin, :Role]] # # The cpath as key helps implementing unloadable_cpath? The real file name # is stored in order to be able to delete it from $LOADED_FEATURES, and the # pair [Module, Symbol] is used to remove_const the constant from the class # or module object. # # If reloading is enabled, this hash is filled as constants are autoloaded # or eager loaded. Otherwise, the collection remains empty. # # @private # @return [{String => (String, (Module, Symbol))}]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg mutex on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl # Maps constant paths of namespaces to arrays of corresponding directories. # # For example, given this mapping: # # "Admin" => [ # "/Users/fxn/blog/app/controllers/admin", # "/Users/fxn/blog/app/models/admin", # ... # ] # # when `Admin` gets defined we know that it plays the role of a namespace and # that its children are spread over those directories. We'll visit them to set # up the corresponding autoloads. # # @private # @return [{String => <String>}]
attr_reader on_symbeg UNK on_nl on_ignored_nl attr_reader on_symbeg mutex on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_nl on_ivar on_op # Absolute paths of files or directories not to be eager loaded. # # @private # @return [Set<String>]
attr_reader on_symbeg mutex on_nl on_ignored_nl attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_const on_period UNK on_nl on_ignored_nl # @private # @return [Mutex]
attr_reader on_symbeg UNK on_nl on_ignored_nl def UNK on_nl on_ivar on_op on_const on_period UNK on_nl on_ignored_nl on_ivar on_op on_const on_period UNK # @private # @return [Mutex]
on_ivar on_op on_const on_period new on_nl on_ivar on_op on_const on_period new on_nl on_ivar on_op false on_nl on_ivar on_op false on_nl # TODO: find a better name for these mutexes.
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl root_dirs on_period # Sets a tag for the loader, useful for logging. # # @param tag [#to_s] # @return [void]
def UNK on_nl root_dirs on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen path on_rparen on_ignored_nl abspath on_op # Absolute paths of the root directories. This is a read-only collection, # please push here via `push_dir`. # # @return [<String>]
def UNK on_lparen path on_rparen on_ignored_nl abspath on_op on_const on_period UNK on_lparen path on_rparen on_nl if dir? on_lparen abspath on_rparen # Pushes `path` to the list of root directories. # # Raises `Zeitwerk::Error` if `path` does not exist, or if another loader in # the same process already manages that directory or one of its ascendants # or descendants. # # @param path [<String, Pathname>] # @raise [Zeitwerk::Error] # @return [void]
def UNK on_nl mutex on_period synchronize do on_ignored_nl UNK if on_ivar on_nl on_ignored_nl if on_ivar on_nl UNK on_const on_comma on_tstring_beg # You need to call this method before setup in order to be able to reload. # There is no way to undo this, either you want to reload or you don't. # # @raise [Zeitwerk::Error] # @return [void]
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_lparen on_op paths on_rparen on_ignored_nl mutex on_period synchronize do on_ignored_nl # @return [Boolean]
def UNK on_lparen on_op paths on_rparen on_ignored_nl mutex on_period synchronize do on_ignored_nl UNK on_lparen paths on_rparen on_period each do on_op # Files or directories to be preloaded instead of lazy loaded. # # @param paths [<String, Pathname, <String, Pathname>>] # @return [void]
def UNK on_lparen on_op glob_patterns on_rparen on_ignored_nl glob_patterns on_op UNK on_lparen glob_patterns on_rparen on_nl mutex on_period synchronize do on_ignored_nl UNK # Configure files, directories, or glob patterns to be totally ignored. # # @param paths [<String, Pathname, <String, Pathname>>] # @return [void]
def UNK on_lparen on_op glob_patterns on_rparen on_ignored_nl glob_patterns on_op UNK on_lparen glob_patterns on_rparen on_nl mutex on_period synchronize do on_ignored_nl UNK # Configure directories or glob patterns to be collapsed. # # @param paths [<String, Pathname, <String, Pathname>>] # @return [void]
def UNK on_nl mutex on_period synchronize do on_ignored_nl UNK if on_ivar on_nl on_ignored_nl UNK on_period each on_lbrace on_op root_dir on_op # Sets autoloads in the root namespace and preloads files, if any. # # @return [void]
def UNK on_nl mutex on_period synchronize do on_ignored_nl UNK on_op on_const on_period new on_nl on_ignored_nl autoloads on_period each do on_op # Removes loaded constants and configured autoloads. # # The objects the constants stored are no longer reachable through them. In # addition, since said objects are normally not referenced from anywhere # else, they are eligible for garbage collection, which would effectively # unload them. # # @private # @return [void]
UNK on_op on_const on_period new on_nl on_ignored_nl autoloads on_period each do on_op realpath on_comma on_lparen parent on_comma cname on_rparen on_op # We are going to keep track of the files that were required by our # autoloads to later remove them from $LOADED_FEATURES, thus making them # loadable by Kernel#require again. # # Directories are not stored in $LOADED_FEATURES, keeping track of files # is enough.
UNK on_lparen parent on_comma cname on_rparen if cdef? on_lparen parent on_comma cname on_rparen on_nl UNK on_period UNK on_lparen realpath on_rparen # Could happen if loaded with require_relative. That is unsupported, # and the constant path would escape unloadable_cpath? This is just # defensive code to clean things up as much as we are able to.
UNK on_period UNK on_lbrace on_op file on_op UNK on_period member? on_lparen file on_rparen on_rbrace on_nl end on_nl on_ignored_nl autoloads on_period # Bootsnap decorates Kernel#require to speed it up using a cache and # this optimization does not check if $LOADED_FEATURES has the file. # # To make it aware of changes, the gem defines singleton methods in # $LOADED_FEATURES: # # https://github.com/Shopify/bootsnap/blob/master/lib/bootsnap/load_path_cache/core_ext/loaded_features.rb # # Rails applications may depend on bootsnap, so for unloading to work # in that setting it is preferable that we restrict our API choice to # one of those methods.
def UNK on_nl if UNK on_nl UNK on_nl UNK on_nl UNK on_nl UNK on_nl else on_ignored_nl UNK on_const on_comma on_tstring_beg # Unloads all loaded code, and calls setup again so that the loader is able # to pick any changes in the file system. # # This method is not thread-safe, please see how this can be achieved by # client code in the README of the project. # # @raise [Zeitwerk::Error] # @return [void]
def UNK on_nl mutex on_period synchronize do on_ignored_nl UNK if on_ivar on_nl on_ignored_nl UNK on_op UNK on_period UNK on_lbrace on_op # Eager loads all files in the root directories, recursively. Files do not # need to be in `$LOAD_PATH`, absolute file names are used. Ignored files # are not eager loaded. You can opt-out specifically in specific files and # directories with `do_not_eager_load`. # # @return [void]
def UNK on_lparen on_op paths on_rparen on_ignored_nl mutex on_period synchronize on_lbrace UNK on_period UNK on_lparen UNK on_lparen paths on_rparen on_rparen # Let eager load ignore the given files or directories. The constants # defined in those files are still autoloadable. # # @param paths [<String, Pathname, <String, Pathname>>] # @return [void]
def UNK on_lparen cpath on_rparen on_ignored_nl UNK on_period UNK on_lparen cpath on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl UNK # Says if the given constant path would be unloaded on reload. This # predicate returns `false` if reloading is disabled. # # @param cpath [String] # @return [Boolean]
def UNK on_nl UNK on_period UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_op UNK on_lparen UNK # Returns an array with the constant paths that would be unloaded on reload. # This predicate returns an empty array if reloading is disabled. # # @return [<String>]
def UNK on_nl on_ivar on_op UNK on_lparen UNK on_rparen UNK UNK UNK on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen # Logs to `$stdout`, handy shortcut for debugging. # # @return [void]
def UNK on_lparen dir on_rparen on_ignored_nl dir on_op dir on_op on_tstring_beg on_tstring_content on_tstring_end on_nl ignored_paths on_period each do on_op UNK # @private # @param dir [String] # @return [Boolean]
on_ignored_nl UNK on_op self on_nl UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg mutex on_nl on_ignored_nl def UNK on_nl UNK on_op # --- Class methods ---------------------------------------------------------------------------
UNK on_symbeg UNK on_nl on_ignored_nl UNK on_symbeg mutex on_nl on_ignored_nl def UNK on_nl UNK on_op UNK on_lparen on_int on_comma on_int # @return [#call, #debug, nil]
UNK on_symbeg mutex on_nl on_ignored_nl def UNK on_nl UNK on_op UNK on_lparen on_int on_comma on_int on_rparen on_period UNK on_period path # @private # @return [Mutex]
def UNK on_nl UNK on_op UNK on_lparen on_int on_comma on_int on_rparen on_period UNK on_period path on_nl on_const on_period UNK on_lparen # This is a shortcut for # # require "zeitwerk" # loader = Zeitwerk::Loader.new # loader.tag = File.basename(__FILE__, ".rb") # loader.inflector = Zeitwerk::GemInflector.new # loader.push_dir(__dir__) # # except that this method returns the same object in subsequent calls from # the same file, in the unlikely case the gem wants to be able to reload. # # @return [Zeitwerk::Loader]
def UNK on_nl on_const on_period UNK on_period each on_lparen on_op on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # Broadcasts `eager_load` to all loaders. # # @return [void]
def UNK on_nl on_const on_period UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_period UNK on_nl end on_nl end on_nl # Returns an array with the absolute paths of the root directories of all # registered loaders. This is a read-only collection. # # @return [<String>]
on_ignored_nl def UNK on_nl root_dirs on_period UNK on_period UNK do on_op root_dir on_op on_ignored_nl on_op dir? on_lparen root_dir on_rparen on_op # -------------------------------------------------------------------------------------
def UNK on_nl root_dirs on_period UNK on_period UNK do on_op root_dir on_op on_ignored_nl on_op dir? on_lparen root_dir on_rparen on_op ignored_paths # @return [<String>]
def UNK on_lparen dir on_comma parent on_rparen on_ignored_nl UNK on_lparen dir on_rparen do on_op basename on_comma abspath on_op on_ignored_nl UNK # @param dir [String] # @param parent [Module] # @return [void]
UNK root_dirs on_period UNK on_lparen abspath on_rparen on_nl cname on_op UNK on_period UNK on_lparen basename on_comma abspath on_rparen on_period UNK # In a Rails application, `app/models/concerns` is a subdirectory of # `app/models`, but both of them are root directories. # # To resolve the ambiguity file name -> constant path this introduces, # the `app/models/concerns` directory is totally ignored as a namespace, # it counts only as root. The guard checks that.
def UNK on_lparen parent on_comma cname on_comma UNK on_rparen on_ignored_nl if autoload_path on_op UNK on_lparen parent on_comma cname on_rparen on_nl # @param parent [Module] # @param cname [Symbol] # @param subdir [String] # @return [void]
on_lparen UNK on_lbracket cpath on_rbracket on_op on_lbracket on_rbracket on_rparen on_op UNK on_nl UNK on_op cdef? on_lparen parent on_comma cname on_rparen # We do not need to issue another autoload, the existing one is enough # no matter if it is for a file or a directory. Just remember the # subdirectory has to be visited if the namespace is used.
on_lparen UNK on_lbracket cpath on_lparen parent on_comma cname on_rparen on_rbracket on_op on_lbracket on_rbracket on_rparen on_op UNK on_nl UNK on_lparen parent # First time we find this namespace, set an autoload for it.
UNK on_lparen UNK on_comma parent on_period UNK on_lparen cname on_rparen on_rparen on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen # For whatever reason the constant that corresponds to this namespace has # already been defined, we have to recurse.
def UNK on_lparen parent on_comma cname on_comma file on_rparen on_ignored_nl if autoload_path on_op UNK on_lparen parent on_comma cname on_rparen on_nl # @param parent [Module] # @param cname [Symbol] # @param file [String] # @return [void]
if ruby? on_lparen autoload_path on_rparen on_nl log on_lparen on_tstring_beg on_tstring_content on_embexpr_beg file on_embexpr_end on_tstring_content on_embexpr_beg autoload_path on_embexpr_end on_tstring_content on_tstring_end on_rparen # First autoload for a Ruby file wins, just ignore subsequent ones.
def UNK on_lparen on_label on_comma on_label on_comma on_label on_comma on_label on_rparen on_ignored_nl autoloads on_period UNK on_lparen dir on_rparen on_nl on_const # @param dir [String] directory that would have autovivified a module # @param file [String] the file where the namespace is explicitly defined # @param parent [Module] # @param cname [Symbol] # @return [void]
def UNK on_lparen parent on_comma cname on_comma abspath on_rparen on_ignored_nl realpath on_op on_const on_period realpath on_lparen abspath on_rparen on_nl parent # @param parent [Module] # @param cname [Symbol] # @param abspath [String] # @return [void]
realpath on_op on_const on_period realpath on_lparen abspath on_rparen on_nl parent on_period UNK on_lparen cname on_comma realpath on_rparen on_nl if logger # $LOADED_FEATURES stores real paths since Ruby 2.4.4. We set and save the # real path to be able to delete it from $LOADED_FEATURES on unload, and to # be able to do a lookup later in Kernel#require for manual require calls.
UNK parent on_period UNK on_lparen cname on_rparen on_nl on_const on_period UNK on_lparen cpath on_lparen parent on_comma cname on_rparen on_comma realpath # See why in the documentation of Zeitwerk::Registry.inceptions.
def UNK on_lparen parent on_comma cname on_rparen on_ignored_nl UNK on_lparen parent on_comma cname on_rparen on_op on_const on_period UNK on_lparen cpath # @param parent [Module] # @param cname [Symbol] # @return [String, nil]
if UNK on_lparen on_symbeg UNK on_rparen on_period UNK on_op on_int on_nl def UNK on_lparen parent on_comma cname on_rparen on_ignored_nl parent # The autoload? predicate takes into account the ancestor chain of the # receiver, like const_defined? and other methods in the constants API do. # # For example, given # # class A # autoload :X, "x.rb" # end # # class B < A # end # # B.autoload?(:X) returns "x.rb". # # We need a way to strictly check in parent ignoring ancestors. # # @param parent [Module] # @param cname [Symbol] # @return [String, nil]
def UNK on_nl UNK on_period each do on_op abspath on_op on_ignored_nl UNK on_lparen abspath on_rparen on_nl end on_nl end on_nl # This method is called this way because I prefer `preload` to be the method # name to configure preloads in the public interface. # # @return [void]
def UNK on_lparen abspath on_rparen on_ignored_nl if ruby? on_lparen abspath on_rparen on_nl UNK on_lparen abspath on_rparen on_nl UNK dir? on_lparen # @param abspath [String] # @return [void]
def UNK on_lparen dir on_rparen on_ignored_nl UNK on_lparen dir on_rparen do on_op UNK on_comma abspath on_op on_ignored_nl UNK on_lparen abspath # @param dir [String] # @return [void]
def UNK on_lparen file on_rparen on_ignored_nl log on_lparen on_tstring_beg on_tstring_content on_embexpr_beg file on_embexpr_end on_tstring_end on_rparen if logger on_nl UNK file # @param file [String] # @return [Boolean]
def cpath on_lparen parent on_comma cname on_rparen on_ignored_nl parent on_period UNK on_lparen on_const on_rparen on_op cname on_period UNK on_op on_tstring_beg # @param parent [Module] # @param cname [Symbol] # @return [String]
def UNK on_lparen dir on_rparen on_ignored_nl on_const on_period UNK on_lparen dir on_rparen do on_op basename on_op on_ignored_nl UNK if basename # @param dir [String] # @yieldparam path [String, String] # @return [void]
def ruby? on_lparen path on_rparen on_ignored_nl path on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl end on_nl on_ignored_nl def dir? # @param path [String] # @return [Boolean]
def dir? on_lparen path on_rparen on_ignored_nl on_const on_period UNK on_lparen path on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen paths # @param path [String] # @return [Boolean]
def UNK on_lparen paths on_rparen on_ignored_nl paths on_period UNK on_period UNK on_lbrace on_op path on_op on_const on_period UNK on_lparen path # @param paths [<String, Pathname, <String, Pathname>>] # @return [<String>]
def UNK on_lparen glob_patterns on_rparen on_ignored_nl glob_patterns on_period UNK on_lbrace on_op UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_rbrace # @param glob_patterns [<String>] # @return [<String>]
glob_patterns on_period UNK on_lbrace on_op UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_rbrace on_nl end on_nl on_ignored_nl def UNK # Note that Dir.glob works with regular file names just fine. That is, # glob patterns technically need no wildcards.
def UNK on_nl ignored_paths on_period UNK on_lparen UNK on_lparen UNK on_rparen on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl UNK # @return [void]
def UNK on_nl UNK on_period UNK on_lparen UNK on_lparen UNK on_rparen on_rparen on_nl end on_nl on_ignored_nl def log on_lparen UNK # @return [void]
def log on_lparen UNK on_rparen on_ignored_nl UNK on_op logger on_period UNK on_lparen on_symbeg UNK on_rparen on_op on_symbeg UNK on_op on_symbeg # @param message [String] # @return [void]
def UNK on_lparen parent on_comma cname on_rparen on_ignored_nl parent on_period UNK on_lparen on_symbeg UNK on_comma cname on_rparen on_nl log on_lparen # @param parent [Module] # @param cname [Symbol] # @return [void]
def UNK on_lparen parent on_comma cname on_rparen on_ignored_nl parent on_period UNK on_lparen on_symbeg UNK on_comma cname on_rparen on_nl log on_lparen # @param parent [Module] # @param cname [Symbol] # @return [void]
