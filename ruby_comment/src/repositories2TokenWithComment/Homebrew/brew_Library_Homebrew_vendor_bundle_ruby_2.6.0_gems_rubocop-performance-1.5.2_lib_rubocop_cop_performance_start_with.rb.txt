on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_const on_op UNK on_tstring_content UNK # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op UNK on_tstring_content UNK UNK on_tstring_content UNK on_nl on_const on_op UNK on_tstring_content UNK on_nl # This cop identifies unnecessary use of a regex where # `String#start_with?` would suffice. # # @example # # bad # 'abc'.match?(/\Aab/) # /\Aab/.match?('abc') # 'abc' =~ /\Aab/ # /\Aab/ =~ 'abc' # 'abc'.match(/\Aab/) # /\Aab/.match('abc') # # # good # 'abc'.start_with?('ab')
regex_str on_op UNK on_tstring_content UNK on_const UNK on_tstring_content UNK on_nl end on_nl on_ignored_nl UNK UNK on_lparen node on_rparen on_ignored_nl UNK # is this regexp 'literal' in the sense of only matching literal # chars, rather than using metachars like `.` and `*` and so on? # also, is it anchored at the start of the string? # (tricky: \s, \d, and so on are metacharacters, but other characters # escaped with a slash are just literals. LITERAL_REGEX takes all # that into account.)
regex_str on_op UNK on_lparen regex_str on_rparen on_nl on_ignored_nl UNK UNK on_op UNK on_op on_ignored_nl UNK on_op UNK UNK UNK on_op # drop \A anchor
