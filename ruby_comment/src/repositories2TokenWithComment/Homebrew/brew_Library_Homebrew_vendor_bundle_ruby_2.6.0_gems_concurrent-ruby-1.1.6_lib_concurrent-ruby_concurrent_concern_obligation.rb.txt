on_ignored_nl def UNK on_nl state on_op on_symbeg UNK on_nl end on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def # NOTE: The Dereferenceable module is going away in 2.0. In the mean time # we need it to place nicely with the synchronization layer. This means # that the including class SHOULD be synchronized and it MUST implement a # `#synchronize` method. Not doing so will lead to runtime errors.
def UNK on_nl state on_op on_symbeg UNK on_nl end on_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_nl on_ignored_nl def UNK # Has the obligation been fulfilled? # # @return [Boolean]
def UNK on_nl state on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK on_nl state on_op on_symbeg UNK on_nl end # Has the obligation been rejected? # # @return [Boolean]
def UNK on_nl state on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK on_nl state on_op on_symbeg UNK on_nl end # Is obligation completion still pending? # # @return [Boolean]
def UNK on_nl state on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_symbeg UNK on_comma on_symbeg UNK # Is the obligation still unscheduled? # # @return [Boolean]
def UNK on_nl UNK on_symbeg UNK on_comma on_symbeg UNK UNK on_period UNK state on_nl end on_nl on_ignored_nl def UNK on_nl # Has the obligation completed processing? # # @return [Boolean]
def UNK on_nl on_op UNK on_nl end on_nl on_ignored_nl def value on_lparen timeout on_op UNK on_rparen on_ignored_nl UNK timeout on_nl # Is the obligation still awaiting completion of processing? # # @return [Boolean]
def value on_lparen timeout on_op UNK on_rparen on_ignored_nl UNK timeout on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen timeout # The current value of the obligation. Will be `nil` while the state is # pending or the operation has been rejected. # # @param [Numeric] timeout the maximum time in seconds to wait. # @return [Object] see Dereferenceable#deref
def UNK on_lparen timeout on_op UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen timeout on_rparen if timeout on_op UNK on_op UNK # Wait until obligation is complete or the timeout has been reached. # # @param [Numeric] timeout the maximum time in seconds to wait. # @return [Obligation] self
def UNK on_lparen timeout on_op UNK on_rparen on_ignored_nl UNK on_lparen timeout on_rparen on_period UNK UNK UNK UNK if UNK UNK # Wait until obligation is complete or the timeout is reached. Will re-raise # any exceptions raised during processing (but will not raise an exception # on timeout). # # @param [Numeric] timeout the maximum time in seconds to wait. # @return [Obligation] self # @raise [Exception] raises the reason when rejected
def UNK on_lparen timeout on_op UNK on_rparen on_ignored_nl UNK on_lparen timeout on_rparen on_nl if UNK on_nl UNK UNK on_nl UNK # The current value of the obligation. Will be `nil` while the state is # pending or the operation has been rejected. Will re-raise any exceptions # raised during processing (but will not raise an exception on timeout). # # @param [Numeric] timeout the maximum time in seconds to wait. # @return [Object] see Dereferenceable#deref # @raise [Exception] raises the reason when rejected
def state on_nl UNK UNK on_ivar UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK on_ivar UNK on_nl end # The current state of the obligation. # # @return [Symbol] the current state
def UNK on_nl UNK UNK on_ivar UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_tstring_beg # If an exception was raised during processing this will return the # exception object. Will return `nil` when the state is pending or if # the obligation has been successfully fulfilled. # # @return [Exception] the exception raised during processing or `nil`
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end UNK UNK on_nl UNK on_period UNK on_lparen on_op UNK # @example allows Obligation to be risen # rejected_ivar = Ivar.new.fail # raise rejected_ivar
def UNK on_lparen UNK on_op UNK UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_lparen on_symbeg UNK on_comma UNK UNK # @!visibility private
def UNK on_nl on_ivar on_op on_const on_period UNK on_nl on_ivar on_op on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK # @!visibility private
def UNK on_nl on_ivar on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma value on_comma UNK on_rparen on_ignored_nl if UNK # @!visibility private
def UNK on_lparen UNK on_comma value on_comma UNK on_rparen on_ignored_nl if UNK on_nl on_ivar on_op value on_nl on_ivar on_op on_symbeg # @!visibility private
def UNK on_lparen value on_rparen on_ignored_nl UNK UNK UNK on_lparen value on_rparen UNK on_nl end on_nl on_ignored_nl def UNK on_lparen # @!visibility private
def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl UNK UNK on_ignored_nl if UNK on_period UNK on_ivar on_nl on_ivar on_op # Atomic compare and set operation # State is set to `next_state` only if `current state == expected_current`. # # @param [Symbol] next_state # @param [Symbol] expected_current # # @return [Boolean] true is state is changed, false otherwise # # @!visibility private
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK UNK on_ignored_nl UNK on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK # Executes the block within mutex if current state is included in expected_states # # @return block value if executed, false otherwise # # @!visibility private
def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_lparen value on_rparen on_ignored_nl on_ivar # Am I in the current state? # # @param [Symbol] expected The state to check against # @return [Boolean] true if in the expected state else false # # @!visibility private
def UNK on_lparen value on_rparen on_ignored_nl on_ivar on_op value on_nl end on_nl end on_nl end on_nl end on_nl EMP EMP # @!visibility private
