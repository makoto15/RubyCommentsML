UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl # frozen_string_literal: false
UNK on_const on_nl def UNK UNK on_nl on_ivar on_op on_const on_period UNK on_lparen UNK on_rparen on_nl on_ivar on_op on_lbracket on_rbracket # SAX2Parser
def UNK on_lparen on_op args on_comma on_op blok on_rparen on_ignored_nl if args on_lbracket on_int on_rbracket on_period UNK on_const on_nl if # Listen arguments: # # Symbol, Array, Block # Listen to Symbol events on Array elements # Symbol, Block # Listen to Symbol events # Array, Listener # Listen to all events on Array elements # Array, Block # Listen to :start_element events on Array elements # Listener # Listen to All events # # Symbol can be one of: :start_element, :end_element, # :start_prefix_mapping, :end_prefix_mapping, :characters, # :processing_instruction, :doctype, :attlistdecl, :elementdecl, # :entitydecl, :notationdecl, :cdata, :xmldecl, :comment # # There is an additional symbol that can be listened for: :progress. # This will be called for every event generated, passing in the current # stream position. # # Array contains regular expressions or strings which will be matched # against fully qualified element names. # # Listener must implement the methods in SAX2Listener # # Block will be passed the same arguments as a SAX2Listener method would # be, where the method name is the same as the matched Symbol. # See the SAX2Listener for more information.
procs on_op get_procs on_lparen on_symbeg UNK on_comma event on_lbracket on_int on_rbracket on_rparen on_nl listeners on_op get_listeners on_lparen on_symbeg UNK on_comma # find the observers for namespaces
event on_lbracket on_int on_rbracket on_period each on_lbrace on_op n on_comma v on_op event on_lbracket on_int on_rbracket on_lbracket n on_rbracket on_op # break out the namespace declarations # The attributes live in event[2]
procs on_period each on_lbrace on_op ob on_op ob on_period call on_lparen n on_comma v on_rparen on_rbrace if procs on_nl listeners # notify observers of namespaces
procs on_op get_procs on_lparen on_symbeg UNK on_comma event on_lbracket on_int on_rbracket on_rparen on_nl listeners on_op get_listeners on_lparen on_symbeg UNK on_comma # find the observers for start_element
procs on_period each on_lbrace on_op ob on_op ob on_period call on_lparen uri on_comma local on_comma event on_lbracket on_int on_rbracket on_comma # notify observers
procs on_op get_procs on_lparen on_symbeg UNK on_comma event on_lbracket on_int on_rbracket on_rparen on_nl listeners on_op get_listeners on_lparen on_symbeg UNK on_comma # find the observers for start_element
procs on_period each on_lbrace on_op ob on_op ob on_period call on_lparen uri on_comma local on_comma event on_lbracket on_int on_rbracket on_rparen # notify observers
procs on_op get_procs on_lparen on_symbeg UNK on_comma event on_lbracket on_int on_rbracket on_rparen on_nl listeners on_op get_listeners on_lparen on_symbeg UNK on_comma # find the observers for namespaces
procs on_period each on_lbrace on_op ob on_op ob on_period call on_lparen UNK on_rparen on_rbrace if procs on_nl listeners on_period each # notify observers of namespaces
UNK on_op event on_lbracket on_int on_rbracket on_period UNK on_nl on_ignored_nl UNK on_op UNK on_lbrace on_op match on_op on_ignored_nl if on_ivar #normalized = @parser.normalize( event[1] ) #handle( :characters, normalized )
procs on_period each on_lbrace on_op ob on_op ob on_period call on_lparen on_op UNK on_rparen on_rbrace if procs on_nl listeners on_period # notify observers
def get_procs on_lparen symbol on_comma name on_rparen on_ignored_nl UNK nil if on_ivar on_period size on_op on_int on_nl on_ivar on_period UNK # The following methods are duplicates, but it is faster than using # a helper
