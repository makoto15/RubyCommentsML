UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl UNK UNK # frozen_string_literal: false
UNK on_const on_op on_const on_nl on_ignored_nl UNK UNK UNK on_nl UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen UNK on_op # Pretty-prints an XML document. This destroys whitespace in text nodes # and will insert carriage returns and indentations. # # TODO: Add an option to print attributes on new lines
UNK UNK UNK on_nl UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen UNK on_op on_int on_comma UNK on_op UNK on_rparen # If compact is set to true, then the formatter will attempt to use as # little space as possible
UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen UNK on_op on_int on_comma UNK on_op UNK on_rparen on_ignored_nl on_ivar on_op UNK # The width of a page. Used for formatting text
def UNK on_lparen UNK on_op on_int on_comma UNK on_op UNK on_rparen on_ignored_nl on_ivar on_op UNK on_nl on_ivar on_op on_int on_nl # Create a new pretty printer. # # output:: # An object implementing '<<(String)', to which the output will be written. # indentation:: # An integer greater than 0. The indentation of each level will be # this number of spaces. If this is < 1, the behavior of this object # is undefined. Defaults to 2. # ie_hack:: # If true, the printer will insert whitespace before closing empty # tags, thereby allowing Internet Explorer's XML parser to # function. Defaults to false.
UNK on_op UNK on_nl if UNK on_nl if node on_period children on_period UNK on_lparen UNK on_rparen UNK on_op s on_comma # If compact and all children are text, and if the formatted output # is less than the specified width, then try to print everything on # one line
node on_period children on_period UNK UNK on_op child on_op on_ignored_nl UNK if child on_op node on_period children on_lbracket on_op on_int # Ok, this is a bit odd. All XML documents have an XML declaration, # but it may not write itself if the user didn't specifically add it, # either through the API or in the input document. If it doesn't write # itself, then we don't need a carriage return... which makes this # logic more complex.
