on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK UNK UNK on_comma on_label UNK on_comma on_label UNK # MessageEncryptor is a simple way to encrypt values which get stored # somewhere you don't trust. # # The cipher text and initialization vector are base64 encoded and returned # to you. # # This can be used in situations similar to the <tt>MessageVerifier</tt>, but # where you don't want users to be able to determine the value of the payload. # # len = ActiveSupport::MessageEncryptor.key_len # salt = SecureRandom.random_bytes(len) # key = ActiveSupport::KeyGenerator.new('password').generate_key(salt, len) # => "\x89\xE0\x156\xAC..." # crypt = ActiveSupport::MessageEncryptor.new(key) # => #<ActiveSupport::MessageEncryptor ...> # encrypted_data = crypt.encrypt_and_sign('my secret data') # => "NlFBTTMwOUV5UlA1QlNEN2xkY2d6eThYWWh..." # crypt.decrypt_and_verify(encrypted_data) # => "my secret data" # # === Confining messages to a specific purpose # # By default any message can be used throughout your app. But they can also be # confined to a specific +:purpose+. # # token = crypt.encrypt_and_sign("this is the chair", purpose: :login) # # Then that same purpose must be passed when verifying to get the data back out: # # crypt.decrypt_and_verify(token, purpose: :login) # => "this is the chair" # crypt.decrypt_and_verify(token, purpose: :shipping) # => nil # crypt.decrypt_and_verify(token) # => nil # # Likewise, if a message has no purpose it won't be returned when verifying with # a specific purpose. # # token = crypt.encrypt_and_sign("the conversation is lively") # crypt.decrypt_and_verify(token, purpose: :scare_tactics) # => nil # crypt.decrypt_and_verify(token) # => "the conversation is lively" # # === Making messages expire # # By default messages last forever and verifying one year from now will still # return the original value. But messages can be set to expire at a given # time with +:expires_in+ or +:expires_at+. # # crypt.encrypt_and_sign(parcel, expires_in: 1.month) # crypt.encrypt_and_sign(doowad, expires_at: Time.now.end_of_year) # # Then the messages can be verified and returned up to the expire time. # Thereafter, verifying returns +nil+. # # === Rotating keys # # MessageEncryptor also supports rotating out old configurations by falling # back to a stack of encryptors. Call +rotate+ to build and add an encryptor # so +decrypt_and_verify+ will also try the fallback. # # By default any rotated encryptors use the values of the primary # encryptor unless specified otherwise. # # You'd give your encryptor the new defaults: # # crypt = ActiveSupport::MessageEncryptor.new(@secret, cipher: "aes-256-gcm") # # Then gradually rotate the old values out by adding them as fallbacks. Any message # generated with the old values will then work until the rotation is removed. # # crypt.rotate old_secret # Fallback to an old secret instead of @secret. # crypt.rotate cipher: "aes-256-cbc" # Fallback to an old cipher instead of aes-256-gcm. # # Though if both the secret and the cipher was changed at the same time, # the above should be combined into: # # crypt.rotate old_secret, cipher: "aes-256-cbc"
if UNK on_nl on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl end on_nl on_ignored_nl #:nodoc:
def self on_period UNK on_lparen value on_rparen on_ignored_nl value on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen value on_rparen #:nodoc:
def self on_period UNK on_lparen value on_rparen on_ignored_nl value on_nl end on_nl on_ignored_nl def self on_period UNK on_lparen value on_rparen #:nodoc:
def UNK on_lparen UNK on_comma on_op UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_nl UNK on_op UNK on_period UNK # Initialize a new MessageEncryptor. +secret+ must be at least as long as # the cipher key size. For the default 'aes-256-gcm' cipher, this is 256 # bits. If you are using a user-entered secret, you can generate a suitable # key by using <tt>ActiveSupport::KeyGenerator</tt> or a similar key # derivation function. # # First additional parameter is used as the signature key for +MessageVerifier+. # This allows you to specify keys to encrypt and sign data. # # ActiveSupport::MessageEncryptor.new('secret', 'signature_secret') # # Options: # * <tt>:cipher</tt> - Cipher to use. Can be any cipher returned by # <tt>OpenSSL::Cipher.ciphers</tt>. Default is 'aes-256-gcm'. # * <tt>:digest</tt> - String of digest to use for signing. Default is # +SHA1+. Ignored when using an AEAD cipher like 'aes-256-gcm'. # * <tt>:serializer</tt> - Object serializer to use. Default is +Marshal+.
def UNK on_lparen value on_comma on_label UNK on_comma on_label UNK on_comma on_label UNK on_rparen on_ignored_nl UNK on_period UNK on_lparen UNK # Encrypt and sign a message. We need to sign the message in order to avoid # padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.
def UNK on_lparen UNK on_comma on_label UNK on_comma on_op on_rparen on_ignored_nl UNK on_lparen UNK on_period UNK on_lparen UNK on_rparen on_comma # Decrypt and verify a message. We need to verify the message in order to # avoid padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.
def self on_period UNK on_lparen cipher on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_lparen cipher on_rparen on_period UNK # Given a cipher, returns the key length of the cipher to help generate the key of desired size
UNK on_op cipher on_period UNK on_nl cipher on_period UNK on_op on_tstring_beg on_tstring_end if aead_mode? on_nl on_ignored_nl UNK on_op cipher on_period # Rely on OpenSSL for the initialization vector
UNK on_const if aead_mode? on_op on_lparen auth_tag on_period UNK on_op auth_tag on_period UNK on_period UNK on_op UNK on_rparen on_nl on_ignored_nl # Currently the OpenSSL bindings do not raise an error if auth_tag is # truncated, which would allow an attacker to easily forge it. See # https://github.com/ruby/openssl/issues/63
