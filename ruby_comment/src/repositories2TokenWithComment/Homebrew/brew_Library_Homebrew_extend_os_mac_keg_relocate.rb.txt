on_ignored_nl UNK on_const on_nl UNK on_op UNK on_nl UNK UNK on_nl on_ignored_nl def UNK on_lparen file on_comma UNK on_rparen on_ignored_nl # frozen_string_literal: true
if file on_period UNK on_op file on_period UNK on_op file on_period UNK on_nl file on_period UNK on_period UNK on_lbrace on_op # Check dynamic library linkage. Importantly, do not perform for static # libraries, which will falsely report "linkage" to themselves.
def UNK on_lparen UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_lparen UNK UNK on_comma UNK on_rparen # Detects the C++ dynamic libraries in place, scanning the dynamic links # of the files within the keg. # Note that this doesn't attempt to distinguish between libstdc++ versions, # for instance between Apple libstdc++ and GNU libstdc++
UNK if bad_name on_period start_with? on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_op on_ignored_nl on_op bad_name on_period start_with? on_lparen on_const on_period UNK # Don't fix absolute paths unless they are rooted in the build directory
if on_const on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_ignored_nl file on_period UNK on_period UNK on_lbrace on_op lib on_op lib on_period # If none of the install names reference RPATH(s), then we can safely # remove all RPATHs from the file.
file on_period UNK on_period each on_lbrace on_op UNK on_op file on_period UNK on_lparen UNK on_rparen on_rbrace on_nl end on_nl end # Note: This could probably be made more efficient by reverse-sorting # the RPATHs by offset and calling MachOFile#delete_command # with repopulate: false.
def UNK on_lparen file on_comma bad_name on_rparen on_ignored_nl if bad_name on_period start_with? on_const on_nl bad_name on_period sub on_lparen on_const on_comma # If file is a dylib or bundle itself, look for the dylib named by # bad_name relative to the lib directory, so that we can skip the more # expensive recursive search if possible.
UNK on_op on_const on_period UNK on_lparen file on_period UNK on_rparen on_nl UNK on_op file on_period UNK on_period UNK on_lparen UNK # The new dylib ID should have the same basename as the old dylib ID, not # the basename of the file itself.
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period UNK on_nl on_ignored_nl def UNK on_lparen bad_name on_rparen on_ignored_nl if on_lparen UNK on_op bad_name # Matches framework references like `XXX.framework/Versions/YYY/XXX` and # `XXX.framework/XXX`, both with or without a slash-delimited prefix.
UNK unless UNK on_period UNK on_lbracket pn on_period UNK on_period UNK on_comma pn on_period UNK on_period UNK on_rbracket on_nl on_ignored_nl # if we've already processed a file, ignore its hardlinks (which have the same dev ID and inode) # this prevents relocations from being performed on a binary more than once
on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # Don't recurse into symlinks; the man page says this is the default, but # it's wrong. -O is a BSD-grep-only option.
