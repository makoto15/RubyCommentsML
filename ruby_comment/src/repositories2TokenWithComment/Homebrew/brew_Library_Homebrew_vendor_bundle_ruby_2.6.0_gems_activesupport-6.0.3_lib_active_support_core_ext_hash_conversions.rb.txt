on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end on_nl require on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
def UNK on_lparen options on_op on_lbrace on_rbrace on_rparen on_ignored_nl require on_tstring_beg on_tstring_content on_tstring_end UNK UNK on_lparen on_const on_op on_const on_rparen # Returns a string containing an XML representation of its receiver: # # { foo: 1, bar: 2 }.to_xml # # => # # <?xml version="1.0" encoding="UTF-8"?> # # <hash> # # <foo type="integer">1</foo> # # <bar type="integer">2</bar> # # </hash> # # To do so, the method loops over the pairs and builds nodes that depend on # the _values_. Given a pair +key+, +value+: # # * If +value+ is a hash there's a recursive call with +key+ as <tt>:root</tt>. # # * If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>, # and +key+ singularized as <tt>:children</tt>. # # * If +value+ is a callable object it must expect one or two arguments. Depending # on the arity, the callable is invoked with the +options+ hash as first argument # with +key+ as <tt>:root</tt>, and +key+ singularized as second argument. The # callable can add nodes by using <tt>options[:builder]</tt>. # # {foo: lambda { |options, key| options[:builder].b(key) }}.to_xml # # => "<b>foo</b>" # # * If +value+ responds to +to_xml+ the method is invoked with +key+ as <tt>:root</tt>. # # class Foo # def to_xml(options) # options[:builder].bar 'fooing!' # end # end # # { foo: Foo.new }.to_xml(skip_instruct: true) # # => # # <hash> # # <bar>fooing!</bar> # # </hash> # # * Otherwise, a node with +key+ as tag is created with a string representation of # +value+ as text node. If +value+ is +nil+ an attribute "nil" set to "true" is added. # Unless the option <tt>:skip_types</tt> exists and is true, an attribute "type" is # added as well according to the following mapping: # # XML_TYPE_NAMES = { # "Symbol" => "symbol", # "Integer" => "integer", # "BigDecimal" => "decimal", # "Float" => "float", # "TrueClass" => "boolean", # "FalseClass" => "boolean", # "Date" => "date", # "DateTime" => "dateTime", # "Time" => "dateTime" # } # # By default the root node is "hash", but that's configurable via the <tt>:root</tt> option. # # The default XML builder is a fresh instance of <tt>Builder::XmlMarkup</tt>. You can # configure your own builder with the <tt>:builder</tt> option. The method also accepts # options like <tt>:dasherize</tt> and friends, they are forwarded to the builder.
def UNK on_lparen xml on_comma UNK on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_period UNK on_lparen xml on_comma UNK on_rparen # Returns a Hash containing a collection of pairs when the key is the node name and the value is # its content # # xml = <<-XML # <?xml version="1.0" encoding="UTF-8"?> # <hash> # <foo type="integer">1</foo> # <bar type="integer">2</bar> # </hash> # XML # # hash = Hash.from_xml(xml) # # => {"hash"=>{"foo"=>1, "bar"=>2}} # # +DisallowedType+ is raised if the XML contains attributes with <tt>type="yaml"</tt> or # <tt>type="symbol"</tt>. Use <tt>Hash.from_trusted_xml</tt> to # parse this XML. # # Custom +disallowed_types+ can also be passed in the form of an # array. # # xml = <<-XML # <?xml version="1.0" encoding="UTF-8"?> # <hash> # <foo type="integer">1</foo> # <bar type="string">"David"</bar> # </hash> # XML # # hash = Hash.from_xml(xml, ['integer']) # # => ActiveSupport::XMLConverter::DisallowedType: Disallowed type attribute: "integer" # # Note that passing custom disallowed types will override the default types, # which are Symbol and YAML.
def UNK on_lparen xml on_rparen on_ignored_nl UNK xml on_comma on_lbracket on_rbracket on_nl end on_nl end on_nl end on_nl on_ignored_nl UNK # Builds a Hash from XML just like <tt>Hash.from_xml</tt>, but also allows Symbol and YAML.
UNK on_const on_op on_const on_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_tstring_beg on_tstring_content UNK UNK on_period UNK UNK on_tstring_end # :nodoc: # Raised if the XML contains attributes with type="yaml" or # type="symbol". Read Hash#from_xml for more details.
UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK on_lparen on_const on_rparen on_op UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op UNK # Turn { files: { file: #<StringIO> } } into { files: #<StringIO> } so it is compatible with # how multipart uploaded files from HTML appear
value on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_op value on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content # { "string" => true } # No tests fail when the second term is removed.
value on_period UNK on_op value on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK # blank or nil parsed values are represented by nil
value on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_op on_op value on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_period UNK on_lparen on_op on_const on_rparen # If the type is the only element which makes it then # this still makes the value nil, except if type is # an XML node(where type['value'] is a Hash)
