on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK UNK on_nl on_ignored_nl on_const on_op UNK # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK UNK on_nl on_ignored_nl on_const on_op UNK on_tstring_content # The InterpolationCompiler module contains optimizations that can tremendously # speed up the interpolation process on the Simple backend. # # It works by defining a pre-compiled method on stored translation Strings that # already bring all the knowledge about contained interpolation variables etc. # so that the actual recurring interpolation will be very fast. # # To enable pre-compiled interpolations you can simply include the # InterpolationCompiler module to the Simple backend: # # I18n::Backend::Simple.include(I18n::Backend::InterpolationCompiler) # # Note that InterpolationCompiler does not yield meaningful results and consequently # should not be used with Ruby 1.9 (YARV) but improves performance everywhere else # (jRuby, Rubinius).
def UNK on_lparen str on_rparen on_ignored_nl str on_period UNK on_lparen on_const on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen str # tokenize("foo %{bar} baz %%{buz}") # => ["foo ", "%{bar}", " baz ", "%%{buz}"]
key on_period UNK on_period UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma string on_comma UNK on_rparen # rely on Ruby to do all the hard work :)
