on_ignored_nl on_ignored_nl UNK on_const on_nl on_ignored_nl UNK on_const on_op on_const on_nl on_ignored_nl def UNK on_lparen opts on_op UNK UNK on_comma # TODO (pitr-ch 14-Mar-2017): deprecate, Future, Promise, etc.
UNK on_const on_op on_const on_nl on_ignored_nl def UNK on_lparen opts on_op UNK UNK on_comma on_op block on_rparen on_ignored_nl UNK on_const # {include:file:docs-source/future.md} # # @!macro copy_options # # @see http://ruby-doc.org/stdlib-2.1.1/libdoc/observer/rdoc/Observable.html Ruby Observable module # @see http://clojuredocs.org/clojure_core/clojure.core/future Clojure's future function # @see http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html java.util.concurrent.Future
def UNK on_lparen opts on_op UNK UNK on_comma on_op block on_rparen on_ignored_nl UNK on_const on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end # Create a new `Future` in the `:unscheduled` state. # # @yield the asynchronous operation to perform # # @!macro executor_and_deref_options # # @option opts [object, Array] :args zero or more arguments to be passed the task # block on execution # # @raise [ArgumentError] if no block is given
def UNK on_nl UNK UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_rparen on_nl on_ivar on_period UNK UNK UNK on_lparen on_ivar # Execute an `:unscheduled` `Future`. Immediately sets the state to `:pending` and # passes the block to a new thread/thread pool for eventual execution. # Does nothing if the `Future` is in any state other than `:unscheduled`. # # @return [Future] a reference to `self` # # @example Instance and execute in separate steps # future = Concurrent::Future.new{ sleep(1); 42 } # future.state #=> :unscheduled # future.execute # future.state #=> :pending # # @example Instance and execute in one line # future = Concurrent::Future.new{ sleep(1); 42 }.execute # future.state #=> :pending
def UNK on_period UNK on_lparen opts on_op UNK UNK on_comma on_op block on_rparen on_ignored_nl on_const on_period UNK on_lparen opts on_comma # Create a new `Future` object with the given block, execute it, and return the # `:pending` object. # # @yield the asynchronous operation to perform # # @!macro executor_and_deref_options # # @option opts [object, Array] :args zero or more arguments to be passed the task # block on execution # # @raise [ArgumentError] if no block is given # # @return [Future] the newly created `Future` in the `:pending` state # # @example # future = Concurrent::Future.execute{ sleep(1); 42 } # future.state #=> :pending
def UNK on_lparen UNK on_op on_const on_comma on_op block on_rparen on_ignored_nl UNK on_lparen UNK on_comma UNK on_rparen on_nl UNK UNK # @!macro ivar_set_method
def UNK on_nl UNK UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_rparen on_nl UNK on_lparen UNK on_comma UNK on_comma on_const # Attempt to cancel the operation if it has not already processed. # The operation can only be cancelled while still `pending`. It cannot # be cancelled once it has begun processing or has completed. # # @return [Boolean] was the operation successfully cancelled.
def UNK on_nl UNK on_op on_symbeg UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen UNK # Has the operation been successfully cancelled? # # @return [Boolean]
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_lparen UNK on_rparen on_nl UNK UNK on_nl UNK on_nl UNK on_ignored_nl UNK on_nl # Wait the given number of seconds for the operation to complete. # On timeout attempt to cancel the operation. # # @param [Numeric] timeout the maximum time in seconds to wait. # @return [Boolean] true if the operation completed before the timeout # else false
