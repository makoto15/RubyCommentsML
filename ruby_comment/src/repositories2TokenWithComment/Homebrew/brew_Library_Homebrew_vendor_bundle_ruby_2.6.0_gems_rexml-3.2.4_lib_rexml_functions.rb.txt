UNK on_const on_nl UNK on_const on_nl on_cvar on_op on_lbrace on_rbrace on_nl on_cvar on_op nil on_nl on_cvar on_op on_lbrace on_rbrace on_nl # frozen_string_literal: false
UNK on_const on_nl on_cvar on_op on_lbrace on_rbrace on_nl on_cvar on_op nil on_nl on_cvar on_op on_lbrace on_rbrace on_nl on_cvar on_op on_lbrace # If you add a method, keep in mind two things: # (1) the first argument will always be a list of nodes from which to # filter. In the case of context methods (such as position), the function # should return an array with a value for each child in the array. # (2) all method calls from XML will have "-" replaced with "_". # Therefore, in XML, "local-name()" is identical (and actually becomes) # "local_name()"
def on_const on_op UNK on_lparen on_rparen on_ignored_nl on_cvar on_lbracket on_symbeg UNK on_rbracket on_nl end on_nl on_ignored_nl def on_const on_op UNK # Returns the last node of the given list of nodes.
def on_const on_op UNK on_lparen node_set on_rparen on_ignored_nl node_set on_period UNK on_nl end on_nl on_ignored_nl def on_const on_op UNK on_lparen # Returns the size of the given list of nodes.
def on_const on_op UNK on_lparen object on_rparen on_ignored_nl end on_nl on_ignored_nl def on_const on_op UNK on_lparen node_set on_op nil on_rparen # Since REXML is non-validating, this method is not implemented as it # requires a DTD
def on_const on_op UNK on_lparen node_set on_op nil on_rparen on_ignored_nl if node_set on_op nil on_nl UNK on_cvar on_lbracket on_symbeg node # Helper method.
def on_const on_op string on_lparen object on_op on_cvar on_lbracket on_symbeg node on_rbracket on_rparen on_ignored_nl if object on_period respond_to? on_lparen on_symbeg # A node-set is converted to a string by returning the string-value of the # node in the node-set that is first in document order. If the node-set is # empty, an empty string is returned. # # A number is converted to a string as follows # # NaN is converted to the string NaN # # positive zero is converted to the string 0 # # negative zero is converted to the string 0 # # positive infinity is converted to the string Infinity # # negative infinity is converted to the string -Infinity # # if the number is an integer, the number is represented in decimal form # as a Number with no decimal point and no leading zeros, preceded by a # minus sign (-) if the number is negative # # otherwise, the number is represented in decimal form as a Number # including a decimal point with at least one digit before the decimal # point and at least one digit after the decimal point, preceded by a # minus sign (-) if the number is negative; there must be no leading zeros # before the decimal point apart possibly from the one required digit # immediately before the decimal point; beyond the one required digit # after the decimal point there must be as many, but only as many, more # digits as are needed to uniquely distinguish the number from all other # IEEE 754 numeric values. # # The boolean false value is converted to the string false. The boolean # true value is converted to the string true. # # An object of a type other than the four basic types is converted to a # string in a way that is dependent on that type.
def on_const on_op UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_tstring_beg on_tstring_end on_nl UNK on_period UNK on_period UNK on_lbrace on_op # A node-set is converted to a string by # returning the concatenation of the string-value # of each of the children of the node in the # node-set that is first in document order. # If the node-set is empty, an empty string is returned.
def on_const on_op UNK on_lparen string on_comma test on_rparen on_ignored_nl string on_lparen string on_rparen on_period UNK on_lparen string on_lparen test # Fixed by Mike Stok
def on_const on_op UNK on_lparen string on_comma test on_rparen on_ignored_nl string on_lparen string on_rparen on_period UNK on_lparen string on_lparen test # Fixed by Mike Stok
def on_const on_op UNK on_lparen string on_comma test on_rparen on_ignored_nl ruby_string on_op string on_lparen string on_rparen on_nl UNK on_op ruby_string # Kouhei fixed this
def on_const on_op UNK on_lparen string on_comma test on_rparen on_ignored_nl ruby_string on_op string on_lparen string on_rparen on_nl return UNK if # Kouhei fixed this too
def on_const on_op UNK on_lparen string on_comma UNK on_comma length on_op nil on_rparen on_ignored_nl ruby_string on_op string on_lparen string on_rparen # Take equal portions of Mike Stok and Sean Russell; mix # vigorously, and pour into a tall, chilled glass. Serves 10,000.
return on_tstring_beg on_tstring_end if on_lparen on_ignored_nl ruby_length on_period UNK UNK on_ignored_nl ruby_start on_period UNK UNK on_ignored_nl ruby_start on_period UNK on_nl # Handle the special cases
ruby_start on_op UNK on_lparen ruby_start on_rparen on_op on_int on_nl ruby_length on_op UNK on_lparen ruby_length on_rparen on_nl on_ignored_nl if ruby_start on_op # Now, get the bounds. The XPath bounds are 1..length; the ruby bounds # are 0..length. Therefore, we have to offset the bounds by one.
def on_const on_op UNK on_lparen string on_rparen on_ignored_nl string on_lparen string on_rparen on_period length on_nl end on_nl on_ignored_nl def on_const # UNTESTED
def on_const on_op UNK on_lparen string on_op nil on_rparen on_ignored_nl string on_op string on_lparen on_cvar on_lbracket on_symbeg node on_rbracket on_rparen # UNTESTED
def on_const on_op UNK on_lparen string on_comma UNK on_comma UNK on_rparen on_ignored_nl UNK on_op string on_lparen UNK on_rparen on_nl UNK # This is entirely Mike Stok's beast
on_ignored_nl map on_op on_const on_period UNK on_nl on_int on_period UNK on_lparen UNK on_period length on_op on_int on_rparen on_lbrace on_op UNK # the map is our translation table. # # if a character occurs more than once in the # from string then we ignore the second & # subsequent mappings # # if a character maps to nil then we delete it # in the output. This happens if the from # string is longer than the to string # # there's nothing about - or ^ being special in # http://www.w3.org/TR/xpath#function-translate # so we don't build ranges or negated classes
def on_const on_op UNK on_lparen object on_rparen on_ignored_nl UNK UNK on_lparen object on_rparen on_nl end on_nl on_ignored_nl def on_const on_op # UNTESTED
def on_const on_op true on_lparen on_rparen on_ignored_nl true on_nl end on_nl on_ignored_nl def on_const on_op false on_lparen on_rparen on_ignored_nl false # UNTESTED
def on_const on_op false on_lparen on_rparen on_ignored_nl false on_nl end on_nl on_ignored_nl def on_const on_op UNK on_lparen UNK on_rparen on_ignored_nl # UNTESTED
def on_const on_op UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op false on_nl node on_op on_cvar on_lbracket on_symbeg node on_rbracket on_nl # UNTESTED
def on_const on_op number on_lparen object on_op on_cvar on_lbracket on_symbeg node on_rbracket on_rparen on_ignored_nl UNK object on_nl when true on_nl # a string that consists of optional whitespace followed by an optional # minus sign followed by a Number followed by whitespace is converted to # the IEEE 754 number that is nearest (according to the IEEE 754 # round-to-nearest rule) to the mathematical value represented by the # string; any other string is converted to NaN # # boolean true is converted to 1; boolean false is converted to 0 # # a node-set is first converted to a string as if by a call to the string # function and then converted in the same way as a string argument # # an object of a type other than the four basic types is converted to a # number in a way that is dependent on that type
on_const on_period UNK on_lparen on_cvar on_lbracket on_symbeg node on_rbracket on_comma name on_period to_s on_rparen on_nl end on_nl end on_nl end # TODO: Maybe, this is not XPath spec behavior. # This behavior must be reconsidered.
