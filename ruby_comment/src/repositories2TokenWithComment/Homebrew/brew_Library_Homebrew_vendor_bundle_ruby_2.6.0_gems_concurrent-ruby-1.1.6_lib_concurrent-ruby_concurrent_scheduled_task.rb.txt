UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen delay on_comma opts # `ScheduledTask` is a close relative of `Concurrent::Future` but with one # important difference: A `Future` is set to execute as soon as possible # whereas a `ScheduledTask` is set to execute after a specified delay. This # implementation is loosely based on Java's # [ScheduledExecutorService](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html). # It is a more feature-rich variant of {Concurrent.timer}. # # The *intended* schedule time of task execution is set on object construction # with the `delay` argument. The delay is a numeric (floating point or integer) # representing a number of seconds in the future. Any other value or a numeric # equal to or less than zero will result in an exception. The *actual* schedule # time of task execution is set when the `execute` method is called. # # The constructor can also be given zero or more processing options. Currently # the only supported options are those recognized by the # [Dereferenceable](Dereferenceable) module. # # The final constructor argument is a block representing the task to be performed. # If no block is given an `ArgumentError` will be raised. # # **States** # # `ScheduledTask` mixes in the [Obligation](Obligation) module thus giving it # "future" behavior. This includes the expected lifecycle states. `ScheduledTask` # has one additional state, however. While the task (block) is being executed the # state of the object will be `:processing`. This additional state is necessary # because it has implications for task cancellation. # # **Cancellation** # # A `:pending` task can be cancelled using the `#cancel` method. A task in any # other state, including `:processing`, cannot be cancelled. The `#cancel` # method returns a boolean indicating the success of the cancellation attempt. # A cancelled `ScheduledTask` cannot be restarted. It is immutable. # # **Obligation and Observation** # # The result of a `ScheduledTask` can be obtained either synchronously or # asynchronously. `ScheduledTask` mixes in both the [Obligation](Obligation) # module and the # [Observable](http://ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html) # module from the Ruby standard library. With one exception `ScheduledTask` # behaves identically to [Future](Observable) with regard to these modules. # # @!macro copy_options # # @example Basic usage # # require 'concurrent' # require 'thread' # for Queue # require 'open-uri' # for open(uri) # # class Ticker # def get_year_end_closing(symbol, year) # uri = "http://ichart.finance.yahoo.com/table.csv?s=#{symbol}&a=11&b=01&c=#{year}&d=11&e=31&f=#{year}&g=m" # data = open(uri) {|f| f.collect{|line| line.strip } } # data[1].split(',')[4].to_f # end # end # # # Future # price = Concurrent::Future.execute{ Ticker.new.get_year_end_closing('TWTR', 2013) } # price.state #=> :pending # sleep(1) # do other stuff # price.value #=> 63.65 # price.state #=> :fulfilled # # # ScheduledTask # task = Concurrent::ScheduledTask.execute(2){ Ticker.new.get_year_end_closing('INTC', 2013) } # task.state #=> :pending # sleep(3) # do other stuff # task.value #=> 25.96 # # @example Successful task execution # # task = Concurrent::ScheduledTask.new(2){ 'What does the fox say?' } # task.state #=> :unscheduled # task.execute # task.state #=> pending # # # wait for it... # sleep(3) # # task.unscheduled? #=> false # task.pending? #=> false # task.fulfilled? #=> true # task.rejected? #=> false # task.value #=> 'What does the fox say?' # # @example One line creation and execution # # task = Concurrent::ScheduledTask.new(2){ 'What does the fox say?' }.execute # task.state #=> pending # # task = Concurrent::ScheduledTask.execute(2){ 'What do you get when you multiply 6 by 9?' } # task.state #=> pending # # @example Failed task execution # # task = Concurrent::ScheduledTask.execute(2){ raise StandardError.new('Call me maybe?') } # task.pending? #=> true # # # wait for it... # sleep(3) # # task.unscheduled? #=> false # task.pending? #=> false # task.fulfilled? #=> false # task.rejected? #=> true # task.value #=> nil # task.reason #=> #<StandardError: Call me maybe?> # # @example Task execution with observation # # observer = Class.new{ # def update(time, value, reason) # puts "The task completed at #{time} with value '#{value}'" # end # }.new # # task = Concurrent::ScheduledTask.new(2){ 'What does the fox say?' } # task.add_observer(observer) # task.execute # task.pending? #=> true # # # wait for it... # sleep(3) # # #>> The task completed at 2013-11-07 12:26:09 -0500 with value 'What does the fox say?' # # @!macro monotonic_clock_warning # # @see Concurrent.timer
UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen delay on_comma opts on_op on_lbrace on_rbrace on_comma on_op UNK on_rparen on_ignored_nl UNK # The executor on which to execute the task. # @!visibility private
def UNK on_lparen delay on_comma opts on_op on_lbrace on_rbrace on_comma on_op UNK on_rparen on_ignored_nl UNK on_const on_period new on_lparen on_tstring_beg # Schedule a task for execution at a specified future time. # # @param [Float] delay the number of seconds to wait for before executing the task # # @yield the task to be performed # # @!macro executor_and_deref_options # # @option opts [object, Array] :args zero or more arguments to be passed the task # block on execution # # @raise [ArgumentError] When no block is given # @raise [ArgumentError] When given a time that is in the past
def UNK on_nl synchronize on_lbrace on_ivar on_rbrace on_nl end on_nl on_ignored_nl def UNK on_nl synchronize on_lbrace on_ivar on_rbrace on_nl end # The `delay` value given at instanciation. # # @return [Float] the initial delay.
def UNK on_nl synchronize on_lbrace on_ivar on_rbrace on_nl end on_nl on_ignored_nl def on_op on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK # The monotonic time at which the the task is scheduled to be executed. # # @return [Float] the schedule time or nil if `unscheduled`
def on_op on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl synchronize on_lbrace # Comparator which orders by schedule time. # # @!visibility private
def UNK on_nl synchronize on_lbrace UNK on_lparen on_symbeg UNK on_rparen on_rbrace on_nl end on_nl on_ignored_nl def UNK on_nl synchronize on_lbrace # Has the task been cancelled? # # @return [Boolean] true if the task is in the given state else false
def UNK on_nl synchronize on_lbrace UNK on_lparen on_symbeg UNK on_rparen on_rbrace on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK # In the task execution in progress? # # @return [Boolean] true if the task is in the given state else false
def UNK on_nl UNK UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_rparen on_nl UNK on_lparen UNK on_comma # Cancel this task and prevent it from executing. A task can only be # cancelled if it is pending or unscheduled. # # @return [Boolean] true if successfully cancelled else false
on_ivar on_period UNK on_lparen on_symbeg UNK on_comma self on_rparen on_nl UNK on_ignored_nl UNK on_nl end on_nl end on_nl on_ignored_nl def # To avoid deadlocks this call must occur outside of #synchronize # Changing the state above should prevent redundant calls
def UNK on_nl synchronize on_lbrace UNK on_lparen on_ivar on_rparen on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen delay on_rparen on_ignored_nl # Reschedule the task using the original delay and the current time. # A task can only be reset while it is `:pending`. # # @return [Boolean] true if successfully rescheduled else false
def UNK on_lparen delay on_rparen on_ignored_nl delay on_op delay on_period UNK on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end # Reschedule the task using the given delay and the current time. # A task can only be reset while it is `:pending`. # # @param [Float] delay the number of seconds to wait for before executing the task # # @return [Boolean] true if successfully rescheduled else false # # @raise [ArgumentError] When given a time that is in the past
def UNK on_nl UNK UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_rparen on_nl synchronize on_lbrace UNK on_lparen on_ivar on_rparen on_rbrace # Execute an `:unscheduled` `ScheduledTask`. Immediately sets the state to `:pending` # and starts counting down toward execution. Does nothing if the `ScheduledTask` is # in any state other than `:unscheduled`. # # @return [ScheduledTask] a reference to `self`
def self on_period UNK on_lparen delay on_comma opts on_op on_lbrace on_rbrace on_comma on_op UNK on_rparen on_ignored_nl new on_lparen delay on_comma # Create a new `ScheduledTask` object with the given block, execute it, and return the # `:pending` object. # # @param [Float] delay the number of seconds to wait for before executing the task # # @!macro executor_and_deref_options # # @return [ScheduledTask] the newly created `ScheduledTask` in the `:pending` state # # @raise [ArgumentError] if no block is given
def UNK on_nl UNK on_lparen on_ivar on_comma on_ivar on_rparen on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma # Execute the task. # # @!visibility private
def UNK on_lparen delay on_rparen on_ignored_nl on_ivar on_op delay on_nl on_ivar on_op on_const on_period UNK on_op on_ivar on_nl on_ivar on_period # Schedule the task using the given delay and the current time. # # @param [Float] delay the number of seconds to wait for before executing the task # # @return [Boolean] true if successfully rescheduled else false # # @!visibility private
def UNK on_lparen delay on_rparen on_ignored_nl UNK UNK UNK UNK on_lparen on_symbeg UNK on_rparen on_nl on_ivar on_period UNK on_lparen on_symbeg # Reschedule the task using the given delay and the current time. # A task can only be reset while it is `:pending`. # # @param [Float] delay the number of seconds to wait for before executing the task # # @return [Boolean] true if successfully rescheduled else false # # @!visibility private
