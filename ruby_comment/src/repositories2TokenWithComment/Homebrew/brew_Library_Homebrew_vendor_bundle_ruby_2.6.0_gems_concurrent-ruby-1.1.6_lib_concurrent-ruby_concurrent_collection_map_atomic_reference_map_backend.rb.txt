UNK on_const on_nl on_ignored_nl class on_const on_nl on_ignored_nl class on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl def # @!visibility private
class on_const on_nl on_ignored_nl class on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl def UNK on_lparen i on_comma # A Ruby port of the Doug Lea's jsr166e.ConcurrentHashMapV8 class version 1.59 # available in public domain. # # Original source code available here: # http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/ConcurrentHashMapV8.java?revision=1.59 # # The Ruby port skips out the +TreeBin+ (red-black trees for use in bins whose # size exceeds a threshold). # # A hash table supporting full concurrency of retrievals and high expected # concurrency for updates. However, even though all operations are # thread-safe, retrieval operations do _not_ entail locking, and there is # _not_ any support for locking the entire table in a way that prevents all # access. # # Retrieval operations generally do not block, so may overlap with update # operations. Retrievals reflect the results of the most recently _completed_ # update operations holding upon their onset. (More formally, an update # operation for a given key bears a _happens-before_ relation with any (non # +nil+) retrieval for that key reporting the updated value.) For aggregate # operations such as +clear()+, concurrent retrievals may reflect insertion or # removal of only some entries. Similarly, the +each_pair+ iterator yields # elements reflecting the state of the hash table at some point at or since # the start of the +each_pair+. Bear in mind that the results of aggregate # status methods including +size()+ and +empty?+} are typically useful only # when a map is not undergoing concurrent updates in other threads. Otherwise # the results of these methods reflect transient states that may be adequate # for monitoring or estimation purposes, but not for program control. # # The table is dynamically expanded when there are too many collisions (i.e., # keys that have distinct hash codes but fall into the same slot modulo the # table size), with the expected average effect of maintaining roughly two # bins per mapping (corresponding to a 0.75 load factor threshold for # resizing). There may be much variance around this average as mappings are # added and removed, but overall, this maintains a commonly accepted # time/space tradeoff for hash tables. However, resizing this or any other # kind of hash table may be a relatively slow operation. When possible, it is # a good idea to provide a size estimate as an optional :initial_capacity # initializer argument. An additional optional :load_factor constructor # argument provides a further means of customizing initial table capacity by # specifying the table density to be used in calculating the amount of space # to allocate for the given number of elements. Note that using many keys with # exactly the same +hash+ is a sure way to slow down performance of any hash # table. # # ## Design overview # # The primary design goal of this hash table is to maintain concurrent # readability (typically method +[]+, but also iteration and related methods) # while minimizing update contention. Secondary goals are to keep space # consumption about the same or better than plain +Hash+, and to support high # initial insertion rates on an empty table by many threads. # # Each key-value mapping is held in a +Node+. The validation-based approach # explained below leads to a lot of code sprawl because retry-control # precludes factoring into smaller methods. # # The table is lazily initialized to a power-of-two size upon the first # insertion. Each bin in the table normally contains a list of +Node+s (most # often, the list has only zero or one +Node+). Table accesses require # volatile/atomic reads, writes, and CASes. The lists of nodes within bins are # always accurately traversable under volatile reads, so long as lookups check # hash code and non-nullness of value before checking key equality. # # We use the top two bits of +Node+ hash fields for control purposes -- they # are available anyway because of addressing constraints. As explained further # below, these top bits are used as follows: # # - 00 - Normal # - 01 - Locked # - 11 - Locked and may have a thread waiting for lock # - 10 - +Node+ is a forwarding node # # The lower 28 bits of each +Node+'s hash field contain a the key's hash code, # except for forwarding nodes, for which the lower bits are zero (and so # always have hash field == +MOVED+). # # Insertion (via +[]=+ or its variants) of the first node in an empty bin is # performed by just CASing it to the bin. This is by far the most common case # for put operations under most key/hash distributions. Other update # operations (insert, delete, and replace) require locks. We do not want to # waste the space required to associate a distinct lock object with each bin, # so instead use the first node of a bin list itself as a lock. Blocking # support for these locks relies +Concurrent::ThreadSafe::Util::CheapLockable. However, we also need a # +try_lock+ construction, so we overlay these by using bits of the +Node+ # hash field for lock control (see above), and so normally use builtin # monitors only for blocking and signalling using # +cheap_wait+/+cheap_broadcast+ constructions. See +Node#try_await_lock+. # # Using the first node of a list as a lock does not by itself suffice though: # When a node is locked, any update must first validate that it is still the # first node after locking it, and retry if not. Because new nodes are always # appended to lists, once a node is first in a bin, it remains first until # deleted or the bin becomes invalidated (upon resizing). However, operations # that only conditionally update may inspect nodes until the point of update. # This is a converse of sorts to the lazy locking technique described by # Herlihy & Shavit. # # The main disadvantage of per-bin locks is that other update operations on # other nodes in a bin list protected by the same lock can stall, for example # when user +eql?+ or mapping functions take a long time. However, # statistically, under random hash codes, this is not a common problem. # Ideally, the frequency of nodes in bins follows a Poisson distribution # (http://en.wikipedia.org/wiki/Poisson_distribution) with a parameter of # about 0.5 on average, given the resizing threshold of 0.75, although with a # large variance because of resizing granularity. Ignoring variance, the # expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) / # factorial(k)). The first values are: # # - 0: 0.60653066 # - 1: 0.30326533 # - 2: 0.07581633 # - 3: 0.01263606 # - 4: 0.00157952 # - 5: 0.00015795 # - 6: 0.00001316 # - 7: 0.00000094 # - 8: 0.00000006 # - more: less than 1 in ten million # # Lock contention probability for two threads accessing distinct elements is # roughly 1 / (8 * #elements) under random hashes. # # The table is resized when occupancy exceeds a percentage threshold # (nominally, 0.75, but see below). Only a single thread performs the resize # (using field +size_control+, to arrange exclusion), but the table otherwise # remains usable for reads and updates. Resizing proceeds by transferring # bins, one by one, from the table to the next table. Because we are using # power-of-two expansion, the elements from each bin must either stay at same # index, or move with a power of two offset. We eliminate unnecessary node # creation by catching cases where old nodes can be reused because their next # fields won't change. On average, only about one-sixth of them need cloning # when a table doubles. The nodes they replace will be garbage collectable as # soon as they are no longer referenced by any reader thread that may be in # the midst of concurrently traversing table. Upon transfer, the old table bin # contains only a special forwarding node (with hash field +MOVED+) that # contains the next table as its key. On encountering a forwarding node, # access and update operations restart, using the new table. # # Each bin transfer requires its bin lock. However, unlike other cases, a # transfer can skip a bin if it fails to acquire its lock, and revisit it # later. Method +rebuild+ maintains a buffer of TRANSFER_BUFFER_SIZE bins that # have been skipped because of failure to acquire a lock, and blocks only if # none are available (i.e., only very rarely). The transfer operation must # also ensure that all accessible bins in both the old and new table are # usable by any traversal. When there are no lock acquisition failures, this # is arranged simply by proceeding from the last bin (+table.size - 1+) up # towards the first. Upon seeing a forwarding node, traversals arrange to move # to the new table without revisiting nodes. However, when any node is skipped # during a transfer, all earlier table bins may have become visible, so are # initialized with a reverse-forwarding node back to the old table until the # new ones are established. (This sometimes requires transiently locking a # forwarding node, which is possible under the above encoding.) These more # expensive mechanics trigger only when necessary. # # The traversal scheme also applies to partial traversals of # ranges of bins (via an alternate Traverser constructor) # to support partitioned aggregate operations. Also, read-only # operations give up if ever forwarded to a null table, which # provides support for shutdown-style clearing, which is also not # currently implemented. # # Lazy table initialization minimizes footprint until first use. # # The element count is maintained using a +Concurrent::ThreadSafe::Util::Adder+, # which avoids contention on updates but can encounter cache thrashing # if read too frequently during concurrent access. To avoid reading so # often, resizing is attempted either when a bin lock is # contended, or upon adding to a bin already holding two or more # nodes (checked before adding in the +x_if_absent+ methods, after # adding in others). Under uniform hash distributions, the # probability of this occurring at threshold is around 13%, # meaning that only about 1 in 8 puts check threshold (and after # resizing, many fewer do so). But this approximation has high # variance for small table sizes, so we check on any collision # for sizes <= 64. The bulk putAll operation further reduces # contention by only committing count updates upon these size # checks. # # @!visibility private
class on_const on_op on_const on_op on_const on_op on_const on_op on_const on_nl def UNK on_lparen i on_comma hash on_comma key on_comma # @!visibility private
class on_const on_nl UNK on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_symbeg hash on_comma on_symbeg value on_comma on_symbeg # Key-value entry. Nodes with a hash field of +MOVED+ are special, and do # not contain user keys or values. Otherwise, keys are never +nil+, and # +NULL+ +value+ fields indicate that a node is in the process of being # deleted or created. For purposes of read-only access, a key may be read # before a value, but can only be used after checking value to be +!= NULL+. # # @!visibility private
on_const on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_rparen on_rparen on_period UNK on_lparen on_int on_rparen # need 2 bits for ourselves # Encodings for special uses of Node hash fields. See above for explanation.
on_const on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_rparen on_rparen on_period UNK on_lparen on_int on_rparen # hash field for forwarding nodes
on_const on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_rparen on_rparen on_period UNK on_lparen on_int on_rparen # set/tested only as a bit
on_const on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op on_lparen on_tstring_beg on_tstring_content on_tstring_end on_op UNK on_rparen on_rparen on_period UNK on_lparen on_int on_rparen # both bits set/tested together
on_ignored_nl on_const on_op on_const on_op on_const on_op on_const on_op on_const on_op on_int on_op on_const on_op on_const on_op on_const on_op on_const # usable bits of normal node hash
def try_await_lock on_lparen table on_comma i on_rparen on_ignored_nl if table on_op i on_op on_int on_op i on_op table on_period size # Spins a while if +LOCKED+ bit set and this node is the first of its bin, # and then sets +WAITING+ bits on hash field and blocks (once) if they are # still set. It is OK for this method to return even if lock is not # available upon exit, which enables these simple single-wait mechanics. # # The corresponding signalling operation is performed within callers: Upon # detecting that +WAITING+ has been set when unlocking lock (via a failed # CAS from non-waiting +LOCKED+ state), unlockers acquire the # +cheap_synchronize+ lock and perform a +cheap_broadcast+.
UNK on_op on_const on_nl UNK on_op UNK on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_nl while UNK # bounds check, TODO: why are we bounds checking?
if on_lparen UNK on_op on_int on_rparen on_op on_int on_nl on_const on_period UNK else on_ignored_nl UNK on_op UNK on_op on_const on_op # spin at random
else on_ignored_nl UNK on_op UNK on_op on_const on_op on_const on_op on_const on_op on_const on_period UNK on_lparen UNK on_rparen if UNK # yield before blocking
end on_nl end on_nl end on_nl on_ignored_nl class on_op self on_nl def locked_hash? on_lparen hash on_rparen on_ignored_nl on_lparen hash on_op # possibly won race vs signaller
on_const on_op on_const on_op on_const on_nl on_const on_op on_const on_op on_const on_nl on_const on_op on_const on_op on_const on_nl on_const on_op # shorthands
on_const on_op on_int on_nl on_ignored_nl UNK on_const on_op on_const on_op on_const on_op on_const on_nl UNK on_symbeg table on_comma on_ignored_nl on_symbeg # The buffer size for skipped bins during transfers. The # value is arbitrary but should be large enough to avoid # most locking stalls during resizes.
on_ignored_nl on_symbeg size_control on_nl on_ignored_nl def UNK on_lparen UNK on_op nil on_rparen on_ignored_nl UNK on_lparen on_rparen on_nl on_ivar on_op on_const # The array of bins. Lazily initialized upon first insertion. Size is always a power of two.
on_symbeg size_control on_nl on_ignored_nl def UNK on_lparen UNK on_op nil on_rparen on_ignored_nl UNK on_lparen on_rparen on_nl on_ivar on_op on_const on_op # Table initialization and resizing control. When negative, the # table is being initialized or resized. Otherwise, when table is # null, holds the initial table size to use upon creation, or 0 # for default. After initialization, holds the next element count # value upon which to resize the table.
hash on_op key_hash on_lparen key on_rparen on_nl current_table on_op table on_op UNK on_nl while true on_nl if on_op on_lparen node # internalPut in the original CHMV8
yield node on_period key on_comma value on_nl end on_nl end while node on_op node on_period next on_nl end on_nl end # skip deleted or special nodes
else on_ignored_nl i on_op UNK on_op on_int on_nl end on_nl end on_nl self on_nl end on_nl on_ignored_nl def size on_nl # visit upper slots if present
end on_nl on_ignored_nl def UNK on_nl size on_op on_int on_nl end on_nl on_ignored_nl def UNK on_nl return self unless current_table # ignore transient negative values
def UNK on_nl return self unless current_table on_op table on_nl current_table_size on_op current_table on_period size on_nl UNK on_op i on_op # Implementation for clear. Steps through each bin, removing all nodes.
UNK on_op on_int on_nl node on_period try_await_lock on_lparen current_table on_comma i on_rparen on_nl else on_ignored_nl current_table on_period try_lock_via_hash on_lparen i # opportunistically update count
node on_period value on_op nil on_nl end while node on_op node on_period next on_nl current_table on_period volatile_set on_lparen i on_comma # recheck under lock
def UNK on_lparen key on_comma UNK on_op on_const on_comma on_op UNK on_rparen on_ignored_nl hash on_op key_hash on_lparen key on_rparen on_nl # Internal versions of the insertion methods, each a # little more complicated than the last. All have # the same basic structure: # 1. If table uninitialized, create # 2. If bin empty, try to CAS new node # 3. If bin stale, use new table # 4. Lock and validate; if valid, scan and add or update # # The others interweave other checks and/or alternative actions: # * Plain +get_and_set+ checks for and performs resize after insertion. # * compute_if_absent prescans for mapping without lock (and fails to add # if present), which also makes pre-emptive resize checks worthwhile. # # Someday when details settle down a bit more, it might be worth # some factoring to reduce sprawl.
break elsif on_const on_period locked_hash? on_lparen node_hash on_rparen on_nl try_await_lock on_lparen current_table on_comma i on_comma node on_rparen on_nl else on_ignored_nl # precheck
elsif on_const on_period locked_hash? on_lparen node_hash on_rparen on_nl try_await_lock on_lparen current_table on_comma i on_comma node on_rparen on_nl else on_ignored_nl succeeded # rules out possible existence
old_value on_op UNK on_nl if on_const on_op on_lparen node on_period value on_op yield on_lparen old_value on_rparen on_rparen on_nl current_table on_period # NULL == expected_old_value means whatever value
pure_hash on_op node on_period pure_hash on_nl else on_ignored_nl return on_const on_nl end on_nl end on_nl ensure on_ignored_nl check_for_resize if UNK # at least 2 nodes -> check for resize
node on_period try_await_lock on_lparen current_table on_comma i on_rparen on_nl end on_nl on_ignored_nl def key_hash on_lparen key on_rparen on_ignored_nl key on_period # try resizing if can't get lock
def UNK on_lparen UNK on_rparen on_ignored_nl size on_op on_int on_nl size on_op on_int while size on_op UNK on_nl size on_nl # Returns a power of two table size for the given desired capacity.
def UNK on_nl UNK current_table on_op table on_nl if on_lparen size_ctrl on_op size_control on_rparen on_op on_const on_nl on_const on_period UNK # Initializes table, using the size recorded in +size_control+.
else on_ignored_nl UNK on_lparen current_table on_comma size_ctrl on_rparen do on_ignored_nl UNK on_op size_ctrl on_op on_int on_op size_ctrl on_op on_const on_nl # lost initialization race; just spin
end on_nl end on_nl end on_nl current_table on_nl end on_nl on_ignored_nl def check_for_resize on_nl while on_lparen current_table on_op table on_rparen # 75% load factor
def check_for_resize on_nl while on_lparen current_table on_op table on_rparen on_op on_const on_op on_lparen UNK on_op current_table on_period size on_rparen on_op # If table is too small and not already resizing, creates next table and # transfers bins. Rechecks occupancy after a transfer to see if another # resize is already needed because resizings are lagging additions.
end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen current_table on_comma size_ctrl on_rparen on_ignored_nl if UNK on_lparen size_ctrl on_comma # 75% load factor
size_ctrl on_op yield end on_nl ensure on_ignored_nl self on_period size_control on_op size_ctrl on_nl end on_nl end on_nl end on_nl on_ignored_nl # recheck under lock
end on_nl ensure on_ignored_nl self on_period size_control on_op size_ctrl on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen # get new size_control
def UNK on_lparen table on_rparen on_ignored_nl old_table_size on_op table on_period size on_nl new_table on_op table on_period UNK on_nl forwarder on_op # Moves and/or copies the nodes in each bin to new table. See above for explanation.
forwarder on_op on_const on_period new on_lparen on_const on_comma new_table on_comma on_const on_rparen on_nl UNK on_op nil on_nl locked_indexes on_op nil # puts "#{old_table_size} -> #{new_table.size}"
locked_arr_idx on_op on_int on_nl bin on_op old_table_size on_op on_int on_nl i on_op bin on_nl while true on_nl if on_op on_lparen # holds bins to revisit; nil until needed
UNK unless on_lparen bin on_op on_int on_op table on_period UNK on_lparen i on_comma nil on_comma forwarder on_rparen on_op UNK on_lparen # no lock needed (or available) if bin >= 0, because we're not popping values from locked_indexes until we've run through the whole table
UNK on_nl end on_nl if bin on_op on_int on_op locked_indexes on_period size on_op on_const on_nl node on_period try_await_lock on_lparen table # swap with another bin
UNK on_nl end on_nl UNK on_op on_const on_period new on_lparen on_const on_comma table on_comma on_const on_rparen on_nl UNK unless table # no other options -- block
locked_indexes on_op i on_nl new_table on_period volatile_set on_lparen i on_comma UNK on_rparen on_nl new_table on_period volatile_set on_lparen i on_op old_table_size # recheck before adding to list
UNK on_op on_const on_period new on_lparen UNK on_op on_const on_op on_const on_comma new_table on_comma on_const on_rparen on_nl if UNK on_period # transiently use a locked forwarding node
new_table on_period volatile_set on_lparen i on_op old_table_size on_comma nil on_rparen UNK on_period volatile_set on_lparen i on_comma forwarder on_rparen on_nl UNK # kill the potential reverse forwarders
UNK on_period volatile_set on_lparen i on_comma forwarder on_rparen on_nl UNK on_period UNK on_lparen UNK on_comma on_const on_rparen on_nl true on_nl # kill the potential reverse forwarders
def UNK on_lparen table on_comma new_table on_comma i on_comma node on_comma node_hash on_comma forwarder on_rparen on_ignored_nl table on_period try_lock_via_hash on_lparen # Splits a normal bin with list headed by e into lo and hi parts; installs in given table.
UNK on_op node_hash on_op UNK on_nl UNK on_op nil on_nl UNK on_op nil on_nl UNK on_op nil on_nl current_node on_op # bit to split on
while current_node on_op current_node on_period next on_nl unless on_lparen UNK on_op current_node on_period hash on_op UNK on_rparen on_op UNK on_nl # this optimises for the lowest amount of volatile writes and objects created
