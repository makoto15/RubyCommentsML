on_ignored_nl UNK UNK on_nl UNK UNK on_lparen on_op syms on_comma on_label true on_comma on_label true on_rparen syms on_period UNK UNK # frozen_string_literal: true
UNK UNK on_nl UNK UNK on_lparen on_op syms on_comma on_label true on_comma on_label true on_rparen syms on_period UNK UNK on_op # Extends the module object with class/module and instance accessors for # class/module attributes, just like the native attr* accessors for instance # attributes, but does so on a per-thread basis. # # So the values are scoped within the Thread.current space under the class name # of the module.
UNK UNK on_lparen on_op syms on_comma on_label true on_comma on_label true on_rparen syms on_period UNK UNK on_op sym on_op on_ignored_nl # Defines a per-thread class attribute and creates class and instance reader methods. # The underlying per-thread class variable is set to +nil+, if it is not previously defined. # # module Current # thread_mattr_reader :user # end # # Current.user # => nil # Thread.current[:attr_Current_user] = "DHH" # Current.user # => "DHH" # # The attribute name must be a valid method name in Ruby. # # module Foo # thread_mattr_reader :"1_Badname" # end # # => NameError: invalid attribute name: 1_Badname # # To omit the instance reader method, pass # <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>. # # class Current # thread_mattr_reader :user, instance_reader: false # end # # Current.new.user # => NoMethodError
syms on_period UNK UNK on_op sym on_op on_ignored_nl UNK UNK on_period UNK on_lparen UNK on_tstring_content on_embexpr_beg sym on_embexpr_end UNK on_rparen # :nodoc:
UNK on_lparen UNK on_comma UNK on_comma UNK on_op UNK on_rparen on_nl on_tstring_content on_embexpr_beg sym on_embexpr_end on_tstring_content on_embexpr_beg sym on_embexpr_end on_tstring_content # The following generated method concatenates `name` because we want it # to work with inheritance via polymorphism.
UNK UNK on_lparen on_op syms on_comma on_label true on_comma on_label true on_rparen syms on_period UNK UNK on_op sym on_op on_ignored_nl # Defines a per-thread class attribute and creates a class and instance writer methods to # allow assignment to the attribute. # # module Current # thread_mattr_writer :user # end # # Current.user = "DHH" # Thread.current[:attr_Current_user] # => "DHH" # # To omit the instance writer method, pass # <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>. # # class Current # thread_mattr_writer :user, instance_writer: false # end # # Current.new.user = "DHH" # => NoMethodError
syms on_period UNK UNK on_op sym on_op on_ignored_nl UNK UNK on_period UNK on_lparen UNK on_tstring_content on_embexpr_beg sym on_embexpr_end UNK on_rparen # :nodoc:
UNK on_lparen UNK on_comma UNK on_comma UNK on_op UNK on_rparen on_nl on_tstring_content on_embexpr_beg sym on_embexpr_end on_tstring_content on_embexpr_beg sym on_embexpr_end on_tstring_content # The following generated method concatenates `name` because we want it # to work with inheritance via polymorphism.
UNK UNK on_lparen on_op syms on_comma on_label true on_comma on_label true on_comma on_label true on_rparen on_ignored_nl UNK on_lparen on_op syms # Defines both class and instance accessors for class attributes. # # class Account # thread_mattr_accessor :user # end # # Account.user = "DHH" # Account.user # => "DHH" # Account.new.user # => "DHH" # # If a subclass changes the value, the parent class' value is not changed. # Similarly, if the parent class changes the value, the value of subclasses # is not changed. # # class Customer < Account # end # # Customer.user = "Rafael" # Customer.user # => "Rafael" # Account.user # => "DHH" # # To omit the instance writer method, pass <tt>instance_writer: false</tt>. # To omit the instance reader method, pass <tt>instance_reader: false</tt>. # # class Current # thread_mattr_accessor :user, instance_writer: false, instance_reader: false # end # # Current.new.user = "DHH" # => NoMethodError # Current.new.user # => NoMethodError # # Or pass <tt>instance_accessor: false</tt>, to omit both instance methods. # # class Current # thread_mattr_accessor :user, instance_accessor: false # end # # Current.new.user = "DHH" # => NoMethodError # Current.new.user # => NoMethodError
