UNK on_const on_op on_const on_op on_const on_nl UNK on_nl on_ignored_nl def UNK on_lparen value on_rparen on_ignored_nl on_ivar on_op value on_nl # A `TVar` is a transactional variable - a single-element container that # is used as part of a transaction - see `Concurrent::atomically`. # # @!macro thread_safe_variable_comparison # # {include:file:docs-source/tvar.md}
def UNK on_lparen value on_rparen on_ignored_nl on_ivar on_op value on_nl on_ivar on_op UNK on_nl on_ivar on_op on_const on_period new on_nl # Create a new `TVar` with an initial value.
def value on_nl on_const on_op UNK do on_ignored_nl on_const on_op current on_period UNK on_lparen UNK on_rparen on_nl end on_nl end # Get the value of a `TVar`.
def UNK on_lparen value on_rparen on_ignored_nl on_const on_op UNK do on_ignored_nl on_const on_op current on_period UNK on_lparen UNK on_comma value # Set the value of a `TVar`.
def UNK on_ivar on_nl end on_nl on_ignored_nl def UNK on_lparen value on_rparen on_ivar on_op value on_nl end on_nl on_ignored_nl def # @!visibility private
on_ivar on_nl end on_nl on_ignored_nl def UNK on_lparen value on_rparen on_ivar on_op value on_nl end on_nl on_ignored_nl def UNK on_ivar # :nodoc:
def UNK on_lparen value on_rparen on_ivar on_op value on_nl end on_nl on_ignored_nl def UNK on_ivar on_nl end on_nl on_ignored_nl def # @!visibility private
on_ivar on_op value on_nl end on_nl on_ignored_nl def UNK on_ivar on_nl end on_nl on_ignored_nl def UNK on_ivar on_op UNK on_nl # :nodoc:
def UNK on_ivar on_nl end on_nl on_ignored_nl def UNK on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_ivar on_nl # @!visibility private
on_ivar on_nl end on_nl on_ignored_nl def UNK on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_ivar on_nl end on_nl # :nodoc:
def UNK on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_ivar on_nl end on_nl on_ignored_nl end on_nl on_ignored_nl def # @!visibility private
on_ivar on_op UNK on_nl end on_nl on_ignored_nl def UNK on_ivar on_nl end on_nl on_ignored_nl end on_nl on_ignored_nl def UNK on_nl # :nodoc:
def UNK on_ivar on_nl end on_nl on_ignored_nl end on_nl on_ignored_nl def UNK on_nl UNK on_const on_period new on_lparen UNK UNK # @!visibility private
on_ivar on_nl end on_nl on_ignored_nl end on_nl on_ignored_nl def UNK on_nl UNK on_const on_period new on_lparen UNK UNK UNK on_rparen # :nodoc:
def UNK on_nl UNK on_const on_period new on_lparen UNK UNK UNK on_rparen unless UNK on_nl on_ignored_nl on_ignored_nl transaction on_op on_const # Run a block that reads and writes `TVar`s as a single atomic transaction. # With respect to the value of `TVar` objects, the transaction is atomic, in # that it either happens or it does not, consistent, in that the `TVar` # objects involved will never enter an illegal state, and isolated, in that # transactions never interfere with each other. You may recognise these # properties from database transactions. # # There are some very important and unusual semantics that you must be aware of: # # * Most importantly, the block that you pass to atomically may be executed # more than once. In most cases your code should be free of # side-effects, except for via TVar. # # * If an exception escapes an atomically block it will abort the transaction. # # * It is undefined behaviour to use callcc or Fiber with atomically. # # * If you create a new thread within an atomically, it will not be part of # the transaction. Creating a thread counts as a side-effect. # # Transactions within transactions are flattened to a single transaction. # # @example # a = new TVar(100_000) # b = new TVar(100) # # Concurrent::atomically do # a.value -= 10 # b.value += 10 # end
on_ignored_nl transaction on_op on_const on_op current on_nl on_ignored_nl on_ignored_nl if transaction on_period UNK on_nl on_ignored_nl UNK on_ignored_nl on_ignored_nl UNK do # Get the current transaction
on_ignored_nl if transaction on_period UNK on_nl on_ignored_nl UNK on_ignored_nl on_ignored_nl UNK do on_ignored_nl on_ignored_nl on_ignored_nl transaction on_op on_const on_period new # Are we not already in a transaction (not nested)?
on_ignored_nl UNK on_ignored_nl on_ignored_nl UNK do on_ignored_nl on_ignored_nl on_ignored_nl transaction on_op on_const on_period new on_nl on_const on_op current on_op transaction # New transaction
on_ignored_nl UNK do on_ignored_nl on_ignored_nl on_ignored_nl transaction on_op on_const on_period new on_nl on_const on_op current on_op transaction on_nl on_ignored_nl on_ignored_nl # Retry loop
on_ignored_nl transaction on_op on_const on_period new on_nl on_const on_op current on_op transaction on_nl on_ignored_nl on_ignored_nl UNK on_ignored_nl UNK on_op UNK # Create a new transaction
on_ignored_nl UNK on_ignored_nl UNK on_op UNK on_nl UNK on_const on_op on_const on_op UNK on_nl transaction on_period UNK on_nl UNK on_op # Run the block, aborting on exceptions
on_ignored_nl if UNK on_op on_const on_op on_const on_nl if transaction on_period UNK on_nl UNK UNK on_nl end on_nl end on_nl # If we can commit, break out of the loop
on_ignored_nl on_const on_op current on_op UNK on_nl end on_nl UNK on_ignored_nl on_ignored_nl UNK on_nl end on_nl end on_nl on_ignored_nl def # Clear the current transaction
on_ignored_nl UNK on_nl end on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_const on_op on_const on_period new on_nl end on_nl # Nested transaction - flatten it and just run the block
def UNK on_nl UNK on_const on_op on_const on_period new on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_const on_op on_const # Abort a currently running transaction - see `Concurrent::atomically`.
def UNK on_nl UNK on_const on_op on_const on_period new on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_symbeg UNK on_comma # Leave a transaction without committing or aborting - see `Concurrent::atomically`.
on_ignored_nl unless on_ivar on_period UNK tvar on_nl on_ignored_nl unless tvar on_period UNK on_period UNK on_nl on_const on_op UNK on_nl end # Have we already written to this TVar?
on_ignored_nl unless tvar on_period UNK on_period UNK on_nl on_const on_op UNK on_nl end on_nl on_ignored_nl on_ignored_nl on_ivar on_period UNK do # Try to lock the TVar
on_const on_op UNK on_nl end on_nl on_ignored_nl on_ignored_nl on_ivar on_period UNK do on_op log_entry on_op on_ignored_nl if log_entry on_period tvar # Someone else is writing to this TVar - abort
on_ignored_nl on_ivar on_period UNK do on_op log_entry on_op on_ignored_nl if log_entry on_period tvar on_op tvar UNK tvar on_period UNK on_op # If we previously wrote to it, check the version hasn't changed
on_ignored_nl on_ivar UNK tvar UNK on_op value on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_nl end on_nl on_ignored_nl def # Record the value written
