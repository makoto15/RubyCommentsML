UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl def UNK # An `IVar` is like a future that you can assign. As a future is a value that # is being computed that you can wait on, an `IVar` is a value that is waiting # to be assigned, that you can wait on. `IVars` are single assignment and # deterministic. # # Then, express futures as an asynchronous computation that assigns an `IVar`. # The `IVar` becomes the primitive on which [futures](Future) and # [dataflow](Dataflow) are built. # # An `IVar` is a single-element container that is normally created empty, and # can only be set once. The I in `IVar` stands for immutable. Reading an # `IVar` normally blocks until it is set. It is safe to set and read an `IVar` # from different threads. # # If you want to have some parallel task set the value in an `IVar`, you want # a `Future`. If you want to create a graph of parallel tasks all executed # when the values they depend on are ready you want `dataflow`. `IVar` is # generally a low-level primitive. # # ## Examples # # Create, set and get an `IVar` # # ```ruby # ivar = Concurrent::IVar.new # ivar.set 14 # ivar.value #=> 14 # ivar.set 2 # would now be an error # ``` # # ## See Also # # 1. For the theory: Arvind, R. Nikhil, and K. Pingali. # [I-Structures: Data structures for parallel computing](http://dl.acm.org/citation.cfm?id=69562). # In Proceedings of Workshop on Graph Reduction, 1986. # 2. For recent application: # [DataDrivenFuture in Habanero Java from Rice](http://www.cs.rice.edu/~vs3/hjlib/doc/edu/rice/hj/api/HjDataDrivenFuture.html).
def UNK on_lparen value on_op on_const on_comma UNK on_op UNK UNK on_comma on_op block on_rparen on_ignored_nl if value on_op on_const # Create a new `IVar` in the `:pending` state with the (optional) initial value. # # @param [Object] value the initial value # @param [Hash] opts the options to create a message with # @option opts [String] :dup_on_deref (false) call `#dup` before returning # the data # @option opts [String] :freeze_on_deref (false) call `#freeze` before # returning the data # @option opts [String] :copy_on_deref (nil) call the given `Proc` passing # the internal value and returning the value returned from the proc
def UNK on_lparen observer on_op nil on_comma UNK on_op on_symbeg UNK on_comma on_op block on_rparen on_ignored_nl UNK on_const on_period new # Add an observer on this object that will receive notification on update. # # Upon completion the `IVar` will notify all observers in a thread-safe way. # The `func` method of the observer will be called with three arguments: the # `Time` at which the `Future` completed the asynchronous operation, the # final `value` (or `nil` on rejection), and the final `reason` (or `nil` on # fulfillment). # # @param [Object] observer the object that will be notified of changes # @param [Symbol] func symbol naming the method to call when this # `Observable` has changes`
def UNK on_lparen value on_op on_const on_rparen on_ignored_nl UNK on_lparen UNK on_comma value on_rparen on_nl UNK on_const UNK UNK on_lparen # @!macro ivar_set_method # Set the `IVar` to a value and wake or notify all threads waiting on it. # # @!macro ivar_set_parameters_and_exceptions # @param [Object] value the value to store in the `IVar` # @yield A block operation to use for setting the value # @raise [ArgumentError] if both a value and a block are given # @raise [Concurrent::MultipleAssignmentError] if the `IVar` has already # been set or otherwise completed # # @return [IVar] self
def UNK on_lparen reason on_op on_const on_period new on_rparen on_ignored_nl UNK on_lparen UNK on_comma nil on_comma reason on_rparen on_nl end # @!macro ivar_fail_method # Set the `IVar` to failed due to some error and wake or notify all threads waiting on it. # # @param [Object] reason for the failure # @raise [Concurrent::MultipleAssignmentError] if the `IVar` has already # been set or otherwise completed # @return [IVar] self
def UNK on_lparen value on_op on_const on_comma on_op block on_rparen on_ignored_nl UNK on_lparen value on_comma on_op block on_rparen on_nl UNK # Attempt to set the `IVar` with the given value or block. Return a # boolean indicating the success or failure of the set operation. # # @!macro ivar_set_parameters_and_exceptions # # @return [Boolean] true if the value was set else false
def UNK on_lparen value on_comma UNK on_rparen on_ignored_nl value on_op UNK if UNK on_nl UNK on_nl self on_period UNK on_op # @!visibility private
def UNK on_lparen UNK on_comma UNK on_op UNK UNK on_rparen on_ignored_nl if UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_rparen # @!visibility private
def UNK on_lparen success on_comma value on_comma reason on_rparen on_ignored_nl UNK on_lparen success on_comma value on_comma reason on_rparen on_nl UNK # @!visibility private
def UNK on_lparen success on_comma value on_comma reason on_rparen on_ignored_nl UNK UNK UNK on_lparen success on_comma value on_comma reason on_rparen # @!visibility private
def UNK on_lparen value on_comma reason on_rparen on_ignored_nl UNK on_period UNK UNK UNK on_const on_period UNK on_comma value on_comma reason # @!visibility private
def UNK on_lparen success on_comma value on_comma reason on_rparen on_ignored_nl UNK on_const if UNK on_symbeg UNK on_comma on_symbeg UNK UNK # @!visibility private
def UNK on_lparen UNK on_comma value on_rparen if on_lparen UNK on_op value on_op on_const on_rparen on_op on_lparen on_op UNK on_op # @!visibility private
if on_lparen UNK on_op value on_op on_const on_rparen on_op on_lparen on_op UNK on_op value on_op on_const on_rparen on_nl UNK on_const # :nodoc:
