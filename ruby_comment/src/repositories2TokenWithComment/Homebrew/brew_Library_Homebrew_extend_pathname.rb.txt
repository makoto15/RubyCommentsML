on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl def UNK on_nl return on_ivar # frozen_string_literal: true
stat on_op f on_period UNK on_nl UNK on_op UNK stat on_period UNK on_comma stat on_period UNK UNK on_nl unless UNK # use Pathname#lstat instead of Pathname#stat to get info of symlink itself.
unless UNK on_period UNK on_lparen UNK on_rparen on_nl on_ivar on_op stat on_period UNK on_nl UNK on_period UNK on_lparen UNK on_rparen # count hardlinks only once.
UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op UNK on_tstring_content UNK on_period UNK on_nl on_ignored_nl def UNK on_lparen on_op # Homebrew extends Ruby's `Pathname` to make our code more readable. # @see https://ruby-doc.org/stdlib-1.8.7/libdoc/pathname/rdoc/Pathname.html Ruby's Pathname API
on_const on_op UNK on_tstring_content UNK on_period UNK on_nl on_ignored_nl def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_period each do # @private
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_period each do on_op src on_op on_ignored_nl UNK src on_nl when on_const # Moves a file from the original location to the {Pathname}'s.
if src on_period UNK on_nl raise unless on_const on_period UNK on_tstring_beg on_tstring_content on_tstring_end on_comma src on_comma dst on_nl else on_ignored_nl # Use FileUtils.mv over File.rename to handle filesystem boundaries. If src # is a symlink, and its target is moved first, FileUtils.mv will fail: # https://bugs.ruby-lang.org/issues/7707 # In that case, use the system "mv" command.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_period each do on_op src on_op on_ignored_nl UNK src on_nl when on_const # Creates symlinks to sources in this folder.
UNK UNK write on_nl on_ignored_nl def write on_lparen content on_comma on_op UNK on_rparen on_ignored_nl raise on_tstring_beg on_tstring_content on_embexpr_beg self on_embexpr_end # @private
def write on_lparen content on_comma on_op UNK on_rparen on_ignored_nl raise on_tstring_beg on_tstring_content on_embexpr_beg self on_embexpr_end on_tstring_end if exist? on_nl on_ignored_nl # We assume this pathname object is a file, obviously
def UNK on_lparen content on_comma on_op UNK on_rparen on_ignored_nl raise on_tstring_beg on_tstring_content on_embexpr_beg self on_embexpr_end on_tstring_end unless exist? on_nl on_ignored_nl # Only appends to a file that is already created.
def UNK on_lparen content on_rparen on_ignored_nl UNK on_op stat if exist? on_nl on_const on_period UNK on_lparen self on_rparen do on_op # NOTE: This always overwrites.
UNK on_ignored_nl UNK on_lparen UNK on_period UNK on_comma nil on_rparen on_nl UNK on_lparen nil on_comma UNK on_period UNK on_rparen on_nl # Try to restore original file's permissions separately # atomic_write does it itself, but it actually erases # them if chown fails
UNK on_lparen UNK on_period UNK on_comma nil on_rparen on_nl UNK on_lparen nil on_comma UNK on_period UNK on_rparen on_nl UNK on_const # Set correct permissions on new file
nil on_nl end on_nl UNK on_ignored_nl UNK on_lparen UNK on_period UNK on_rparen on_nl UNK on_const on_op on_const on_comma on_const on_op # Changing file ownership failed, moving on.
UNK on_lparen UNK on_period UNK on_rparen on_nl UNK on_const on_op on_const on_comma on_const on_op on_const on_nl nil on_nl end on_nl # This operation will affect filesystem ACL's
nil on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl raise on_tstring_beg on_embexpr_beg self on_embexpr_end # Changing file permissions failed, moving on.
def UNK on_lparen UNK on_comma UNK on_rparen on_ignored_nl raise on_tstring_beg on_embexpr_beg self on_embexpr_end on_tstring_content on_tstring_end unless exist? on_nl on_ignored_nl dst # @private
UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen path on_op to_s on_rparen on_ignored_nl basename on_op on_const on_period basename on_lparen path # @private
def UNK on_lparen path on_op to_s on_rparen on_ignored_nl basename on_op on_const on_period basename on_lparen path on_rparen on_nl on_ignored_nl UNK on_op # Extended to support common double extensions
return on_tstring_beg on_tstring_end if basename on_period UNK on_lparen UNK on_tstring_content UNK on_rparen on_op on_op basename on_period UNK on_lparen on_tstring_beg on_tstring_content # Don't treat version numbers as extname.
def UNK on_nl on_const on_period basename on_lparen on_lparen path on_op to_s on_rparen on_comma UNK on_lparen path on_rparen on_rparen on_nl end # For filetypes we support, basename without extension
def UNK on_nl UNK on_nl UNK on_nl UNK on_const on_op on_const on_nl if on_lparen UNK on_op join on_lparen on_tstring_beg on_tstring_content # I don't trust the children.length == 0 check particularly, not to mention # it is slow to enumerate the whole directory just to see if it is empty, # instead rely on good ol' libc and the filesystem # @private
def UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_period UNK on_lparen basename on_rparen on_nl end on_nl on_ignored_nl def UNK # @private
def UNK on_nl UNK on_tstring_content UNK on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_lbrace on_op f on_op f on_period UNK # @private
def UNK on_nl UNK on_op dirname on_period join on_lparen UNK on_rparen on_op self on_nl end on_nl on_ignored_nl def UNK on_nl # @private
def UNK on_nl UNK on_op UNK on_nl UNK on_const on_nl false on_nl else on_ignored_nl dirname on_period join on_lparen UNK on_rparen # @private
false on_nl else on_ignored_nl dirname on_period join on_lparen UNK on_rparen on_period exist? on_nl end on_nl on_ignored_nl def UNK on_lparen src # The link target contains NUL bytes
def UNK on_lparen src on_rparen on_ignored_nl dirname on_period mkpath on_nl on_const on_period UNK on_lparen src on_period UNK on_lparen dirname on_rparen # @private
def UNK on_nl UNK on_op nil on_nl unless UNK on_nl UNK on_op stat on_period UNK on_nl on_const on_period UNK on_tstring_beg # @private
def UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma to_s on_comma on_tstring_beg on_embexpr_beg dirname on_embexpr_end on_tstring_content on_tstring_end # @private
def UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_comma to_s on_comma on_tstring_beg on_embexpr_beg # @private
def UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_period UNK on_nl if UNK on_period UNK on_nl UNK on_tstring_beg on_tstring_content on_embexpr_beg # Writes an exec script in this folder for each target pathname
join on_lparen target on_period basename on_rparen on_period write UNK on_nl on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_embexpr_beg target on_embexpr_end on_tstring_content UNK end # allow pathnames or strings
def UNK on_lparen target on_comma UNK on_rparen on_ignored_nl UNK on_op on_op on_tstring_beg on_tstring_end on_nl UNK on_period each on_lbrace on_op UNK # Writes an exec script that sets environment variables
def UNK on_lparen dst on_comma UNK on_rparen on_ignored_nl dst on_period mkpath on_nl on_const on_period UNK on_lparen on_tstring_beg on_embexpr_beg self on_embexpr_end # Writes a wrapper env script and moves all files to the dst
def UNK on_lparen UNK on_comma UNK on_comma UNK on_op on_tstring_beg on_tstring_end on_comma UNK nil on_rparen on_ignored_nl mkpath on_nl UNK on_op # Writes an exec script that invokes a Java jar
UNK on_op UNK on_period UNK on_nl UNK unless UNK on_period exist? on_nl on_ignored_nl UNK on_period UNK on_int on_nl UNK on_lparen # Some software symlinks these files (see help2man.rb)
UNK unless UNK on_period exist? on_nl on_ignored_nl UNK on_period UNK on_int on_nl UNK on_lparen UNK on_rparen on_nl end on_nl end # Some software links metafiles together, so by the time we iterate to one of them # we may have already moved it. libxml2's COPYING and Copyright are affected by this.
if on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_const on_period UNK on_lbrace on_ignored_nl def UNK on_nl super on_period UNK on_lparen # https://bugs.ruby-lang.org/issues/9915
UNK on_const on_nl UNK on_op self on_nl UNK UNK UNK on_comma UNK UNK on_nl on_ignored_nl def UNK on_nl on_ivar on_op # @private
