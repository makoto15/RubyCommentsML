on_ignored_nl UNK UNK on_nl UNK UNK on_nl UNK UNK on_nl UNK UNK on_op UNK on_nl UNK UNK UNK UNK UNK # frozen_string_literal: true
UNK UNK on_op UNK on_nl UNK UNK UNK UNK UNK on_nl on_tstring_content UNK on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl # This cop checks for inefficient searching of keys and values within # hashes. # # `Hash#keys.include?` is less efficient than `Hash#key?` because # the former allocates a new array and then performs an O(n) search # through that array, while `Hash#key?` does not allocate any array and # performs a faster O(1) search for the key. # # `Hash#values.include?` is less efficient than `Hash#value?`. While they # both perform an O(n) search through all of the values, calling `values` # allocates a new array while using `value?` does not. # # @example # # bad # { a: 1, b: 2 }.keys.include?(:a) # { a: 1, b: 2 }.keys.include?(:z) # h = { a: 1, b: 2 }; h.keys.include?(100) # # # good # { a: 1, b: 2 }.key?(:a) # { a: 1, b: 2 }.has_key?(:z) # h = { a: 1, b: 2 }; h.key?(100) # # # bad # { a: 1, b: 2 }.values.include?(2) # { a: 1, b: 2 }.values.include?('garbage') # h = { a: 1, b: 2 }; h.values.include?(nil) # # # good # { a: 1, b: 2 }.value?(2) # { a: 1, b: 2 }.has_value?('garbage') # h = { a: 1, b: 2 }; h.value?(nil) #
UNK on_period UNK on_lparen on_ignored_nl node on_period UNK on_period UNK UNK on_ignored_nl on_tstring_beg UNK UNK on_lparen node on_rparen UNK on_tstring_content # Replace `keys.include?` or `values.include?` with the appropriate # `key?`/`value?` method.
