on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const UNK UNK on_nl UNK UNK UNK UNK on_nl end # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_op on_const UNK UNK on_nl UNK UNK UNK UNK on_nl end on_nl end on_nl on_ignored_nl # A typical module looks like this: # # module M # def self.included(base) # base.extend ClassMethods # base.class_eval do # scope :disabled, -> { where(disabled: true) } # end # end # # module ClassMethods # ... # end # end # # By using <tt>ActiveSupport::Concern</tt> the above module could instead be # written as: # # require 'active_support/concern' # # module M # extend ActiveSupport::Concern # # included do # scope :disabled, -> { where(disabled: true) } # end # # class_methods do # ... # end # end # # Moreover, it gracefully handles module dependencies. Given a +Foo+ module # and a +Bar+ module which depends on the former, we would typically write the # following: # # module Foo # def self.included(base) # base.class_eval do # def self.method_injected_by_foo # ... # end # end # end # end # # module Bar # def self.included(base) # base.method_injected_by_foo # end # end # # class Host # include Foo # We need to include this dependency for Bar # include Bar # Bar is the module that Host really needs # end # # But why should +Host+ care about +Bar+'s dependencies, namely +Foo+? We # could try to hide these from +Host+ directly including +Foo+ in +Bar+: # # module Bar # include Foo # def self.included(base) # base.method_injected_by_foo # end # end # # class Host # include Bar # end # # Unfortunately this won't work, since when +Foo+ is included, its <tt>base</tt> # is the +Bar+ module, not the +Host+ class. With <tt>ActiveSupport::Concern</tt>, # module dependencies are properly resolved: # # require 'active_support/concern' # # module Foo # extend ActiveSupport::Concern # included do # def self.method_injected_by_foo # ... # end # end # end # # module Bar # extend ActiveSupport::Concern # include Foo # # included do # self.method_injected_by_foo # end # end # # class Host # include Bar # It works, now Bar takes care of its dependencies # end
UNK UNK on_nl UNK UNK UNK UNK on_nl end on_nl end on_nl on_ignored_nl UNK UNK on_period UNK on_lparen base on_rparen #:nodoc:
base on_period UNK on_lparen on_symbeg on_ivar UNK UNK UNK on_rparen on_nl end on_nl on_ignored_nl UNK UNK on_lparen base on_rparen if #:nodoc:
if base on_period UNK on_lparen on_symbeg on_ivar on_rparen on_nl base on_period UNK on_lparen on_symbeg on_ivar on_rparen on_op UNK on_nl UNK #:nodoc:
UNK UNK on_lparen base on_op UNK UNK on_op UNK on_rparen on_ignored_nl if base on_period UNK on_nl if UNK on_lparen on_symbeg # Evaluate given block in context of base class, # so that you can write class macros here. # When you define more than one +included+ block, it raises an exception.
UNK UNK on_lparen on_op UNK on_rparen on_ignored_nl UNK on_op UNK on_lparen on_symbeg on_const UNK UNK on_rparen on_op on_ignored_nl UNK on_lparen # Define class methods from given block. # You can define private class methods as well. # # module Example # extend ActiveSupport::Concern # # class_methods do # def foo; puts 'foo'; end # # private # def bar; puts 'bar'; end # end # end # # class Buzz # include Example # end # # Buzz.foo # => "foo" # Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)
