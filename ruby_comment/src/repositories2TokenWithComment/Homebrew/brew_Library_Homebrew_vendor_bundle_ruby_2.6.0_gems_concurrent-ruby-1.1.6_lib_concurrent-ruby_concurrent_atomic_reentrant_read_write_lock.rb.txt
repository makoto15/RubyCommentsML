UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl on_ignored_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_ignored_nl on_const on_op # Re-entrant read-write lock implementation # # Allows any number of concurrent readers, but only one concurrent writer # (And while the "write" lock is taken, no read locks can be obtained either. # Hence, the write lock can also be called an "exclusive" lock.) # # If another thread has taken a read lock, any thread which wants a write lock # will block until all the readers release their locks. However, once a thread # starts waiting to obtain a write lock, any additional readers that come along # will also wait (so writers are not starved). # # A thread can acquire both a read and write lock at the same time. A thread can # also acquire a read lock OR a write lock more than once. Only when the read (or # write) lock is released as many times as it was acquired, will the thread # actually let it go, allowing other threads which might have been waiting # to proceed. Therefore the lock can be upgraded by first acquiring # read lock and then write lock and that the lock can be downgraded by first # having both read and write lock a releasing just the write lock. # # If both read and write locks are acquired by the same thread, it is not strictly # necessary to release them in the same order they were acquired. In other words, # the following code is legal: # # @example # lock = Concurrent::ReentrantReadWriteLock.new # lock.acquire_write_lock # lock.acquire_read_lock # lock.release_write_lock # # At this point, the current thread is holding only a read lock, not a write # # lock. So other threads can take read locks, but not a write lock. # lock.release_read_lock # # Now the current thread is not holding either a read or write lock, so # # another thread could potentially acquire a write lock. # # This implementation was inspired by `java.util.concurrent.ReentrantReadWriteLock`. # # @example # lock = Concurrent::ReentrantReadWriteLock.new # lock.with_read_lock { data.retrieve } # lock.with_write_lock { data.modify! } # # @see http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html java.util.concurrent.ReentrantReadWriteLock
on_ignored_nl on_const on_op on_int on_nl on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_const on_nl on_const on_op on_int on_op # Implementation notes: # # A goal is to make the uncontended path for both readers/writers mutex-free # Only if there is reader-writer or writer-writer contention, should mutexes be used # Otherwise, a single CAS operation is all we need to acquire/release a lock # # Internal state is represented by a single integer ("counter"), and updated # using atomic compare-and-swap operations # When the counter is 0, the lock is free # Each thread which has one OR MORE read locks increments the counter by 1 # (and decrements by 1 when releasing the read lock) # The counter is increased by (1 << 15) for each writer waiting to acquire the # write lock, and by (1 << 29) if the write lock is taken # # Additionally, each thread uses a thread-local variable to count how many times # it has acquired a read lock, AND how many times it has acquired a write lock. # It uses a similar trick; an increment of 1 means a read lock was taken, and # an increment of (1 << 15) means a write lock was taken # This is what makes re-entrancy possible # # 2 rules are followed to ensure good liveness properties: # 1) Once a writer has queued up and is waiting for a write lock, no other thread # can take a lock without waiting # 2) When a write lock is released, readers are given the "first chance" to wake # up and acquire a read lock # Following these rules means readers and writers tend to "take turns", so neither # can starve the other, even under heavy contention
on_const on_op on_int on_nl on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_const on_nl on_const on_op on_int on_op on_lparen # @!visibility private
on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_const on_nl on_const on_op on_int on_op on_lparen on_const on_op on_const on_rparen # @!visibility private
on_const on_op on_int on_op on_const on_nl on_const on_op on_int on_op on_lparen on_const on_op on_const on_rparen on_nl on_const on_op on_const on_op # Used with @Counter: # @!visibility private
on_const on_op on_int on_op on_lparen on_const on_op on_const on_rparen on_nl on_const on_op on_const on_op on_int on_nl on_const on_op on_const on_op # @!visibility private
on_const on_op on_const on_op on_int on_nl on_const on_op on_const on_op on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_const # @!visibility private
on_const on_op on_const on_op on_const on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_const on_nl on_const on_op on_const on_op on_int # @!visibility private
on_const on_op on_int on_op on_const on_nl on_const on_op on_const on_op on_int on_nl on_const on_op on_const on_nl on_ignored_nl UNK on_nl on_ignored_nl # Used with @HeldCount: # @!visibility private
on_const on_op on_const on_op on_int on_nl on_const on_op on_const on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_rparen # @!visibility private
on_const on_op on_const on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_rparen on_nl on_ivar on_op on_const on_period new # @!visibility private
def UNK on_nl UNK on_lparen on_rparen on_nl on_ivar on_op on_const on_period new on_lparen on_int on_rparen on_ivar on_op on_const on_op on_const # Create a new `ReentrantReadWriteLock` in the unlocked state.
on_ivar on_op on_const on_op on_const on_period new on_ivar on_op on_const on_op on_const on_period new on_ivar on_op on_const on_period new on_lparen # single integer which represents lock state
on_ivar on_op on_const on_op on_const on_period new on_ivar on_op on_const on_period new on_lparen on_int on_rparen end on_nl on_ignored_nl def UNK # used to queue waiting readers
on_ivar on_op on_const on_period new on_lparen on_int on_rparen end on_nl on_ignored_nl def UNK on_nl raise on_const on_period new on_lparen on_tstring_beg # used to queue waiting writers
end on_nl on_ignored_nl def UNK on_nl raise on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_nl UNK on_nl # indicates # of R & W locks held by this thread
def UNK on_nl raise on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_nl UNK on_nl UNK on_ignored_nl UNK # Execute a block operation within a read lock. # # @yield the task to be performed within the lock. # # @return [Object] the result of the block operation. # # @raise [ArgumentError] when no block is given. # @raise [Concurrent::ResourceLimitError] if the maximum number of readers # is exceeded.
def UNK on_nl raise on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_nl UNK on_nl UNK on_ignored_nl UNK # Execute a block operation within a write lock. # # @yield the task to be performed within the lock. # # @return [Object] the result of the block operation. # # @raise [ArgumentError] when no block is given. # @raise [Concurrent::ResourceLimitError] if the maximum number of readers # is exceeded.
def UNK on_nl if on_lparen held on_op on_ivar on_period value on_rparen on_op on_int on_nl if held on_op on_const on_op on_int # Acquire a read lock. If a write lock is held by another thread, will block # until it is released. # # @return [Boolean] true if the lock is successfully acquired # # @raise [Concurrent::ResourceLimitError] if the maximum number of readers # is exceeded.
if held on_op on_const on_op on_int on_nl on_ivar on_period UNK UNK on_op c on_op c on_op on_int UNK on_nl end # If we already have a lock, there's no need to wait
on_ivar on_period UNK UNK on_op c on_op c on_op on_int UNK on_nl end on_nl on_ivar on_period value on_op held on_op # But we do need to update the counter, if we were holding a write # lock but not a read lock
if waiting_or_running_writer? on_lparen c on_rparen on_nl on_ivar on_period UNK UNK on_ignored_nl on_ivar on_period UNK if waiting_or_running_writer? on_nl end on_nl on_ignored_nl # If a writer is waiting OR running when we first queue up, we need to wait
on_ivar on_period UNK UNK on_ignored_nl on_ivar on_period UNK if waiting_or_running_writer? on_nl end on_nl on_ignored_nl UNK true on_nl c on_op on_ivar # Before going to sleep, check again with the ReadQueue mutex held
on_ignored_nl UNK true on_nl c on_op on_ivar on_period value on_nl if UNK on_lparen c on_rparen on_nl on_ivar on_period UNK UNK # Note: the above 'synchronize' block could have used #wait_until, # but that waits repeatedly in a loop, checking the wait condition # each time it wakes up (to protect against spurious wakeups) # But we are already in a loop, which is only broken when we successfully # acquire the lock! So we don't care about spurious wakeups, and would # rather not pay the extra overhead of using #wait_until
UNK true on_nl c on_op on_ivar on_period value on_nl if UNK on_lparen c on_rparen on_nl on_ivar on_period UNK UNK on_ignored_nl # After a reader has waited once, they are allowed to "barge" ahead of waiting writers # But if a writer is *running*, the reader still needs to wait (naturally)
def UNK on_nl if on_lparen held on_op on_ivar on_period value on_rparen on_op on_int on_nl if held on_op on_const on_op on_int # Try to acquire a read lock and return true if we succeed. If it cannot be # acquired immediately, return false. # # @return [Boolean] true if the lock is successfully acquired
on_ivar on_period UNK UNK on_op c on_op c on_op on_int UNK on_nl end on_nl on_ivar on_period value on_op held on_op # If we hold a write lock, but not a read lock...
def UNK on_nl held on_op on_ivar on_period value on_op on_ivar on_period value on_op on_int on_nl UNK on_op held on_op on_const # Release a previously acquired read lock. # # @return [Boolean] true if the lock is successfully released
if waiting_or_running_writer? on_lparen c on_rparen on_op UNK on_lparen c on_rparen on_op on_int on_nl on_ivar on_period UNK on_nl end on_nl UNK # If one or more writers were waiting, and we were the last reader, wake a writer up
def UNK on_nl if on_lparen held on_op on_ivar on_period value on_rparen on_op on_const on_nl on_ivar on_period value on_op held on_op # Acquire a write lock. Will block and wait for all active readers and writers. # # @return [Boolean] true if the lock is successfully acquired # # @raise [Concurrent::ResourceLimitError] if the maximum number of writers # is exceeded.
on_ivar on_period value on_op held on_op on_const on_nl return true on_nl end on_nl on_ignored_nl UNK true on_nl c on_op on_ivar # if we already have a write (exclusive) lock, there's no need to wait
if c on_op held on_nl if on_ivar on_period compare_and_set on_lparen c on_comma c on_op on_const on_rparen on_nl on_ivar on_period value # To go ahead and take the lock without waiting, there must be no writer # running right now, AND no writers who came before us still waiting to # acquire the lock # Additionally, if any read locks have been taken, we must hold all of them
if on_ivar on_period compare_and_set on_lparen c on_comma c on_op on_const on_rparen on_nl on_ivar on_period value on_op held on_op on_const on_nl # If we successfully swap the RUNNING_WRITER bit on, then we can go ahead
on_ivar on_period UNK UNK on_ignored_nl c on_op on_ivar on_period value on_nl on_ivar on_period UNK if UNK on_lparen c on_rparen on_op # Now we have successfully incremented, so no more readers will be able to increment # (they will wait instead) # However, readers OR writers could decrement right here
c on_op on_ivar on_period value on_nl on_ivar on_period UNK if UNK on_lparen c on_rparen on_op UNK on_lparen c on_rparen on_op # So we have to do another check inside the synchronized section # If a writer OR another reader is running, then go to sleep
on_ignored_nl c on_op on_ivar on_period value on_nl if on_op UNK on_lparen c on_rparen on_op on_ignored_nl UNK on_lparen c on_rparen on_op # Note: if you are thinking of replacing the above 'synchronize' block # with #wait_until, read the comment in #acquire_read_lock first!
c on_op on_ivar on_period value on_nl if on_op UNK on_lparen c on_rparen on_op on_ignored_nl UNK on_lparen c on_rparen on_op held # We just came out of a wait # If we successfully turn the RUNNING_WRITER bit on with an atomic swap, # then we are OK to stop waiting and go ahead # Otherwise go back and wait again
def UNK on_nl if on_lparen held on_op on_ivar on_period value on_rparen on_op on_const on_nl on_ivar on_period value on_op held on_op # Try to acquire a write lock and return true if we succeed. If it cannot be # acquired immediately, return false. # # @return [Boolean] true if the lock is successfully acquired
def UNK on_nl held on_op on_ivar on_period value on_op on_ivar on_period value on_op on_const on_nl UNK on_op held on_op on_const # Release a previously acquired write lock. # # @return [Boolean] true if the lock is successfully released
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl c on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_int on_nl end on_nl # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl c on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_const on_nl end on_nl # @!visibility private
def waiting_or_running_writer? on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl c on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_const on_nl end on_nl # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_const on_nl end on_nl # @!visibility private
