UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op on_int on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_int # Ruby read-write lock implementation # # Allows any number of concurrent readers, but only one concurrent writer # (And if the "write" lock is taken, any readers who come along will have to wait) # # If readers are already active when a writer comes along, the writer will wait for # all the readers to finish before going ahead. # Any additional readers that come when the writer is already waiting, will also # wait (so writers are not starved). # # This implementation is based on `java.util.concurrent.ReentrantReadWriteLock`. # # @example # lock = Concurrent::ReadWriteLock.new # lock.with_read_lock { data.retrieve } # lock.with_write_lock { data.modify! } # # @note Do **not** try to acquire the write lock while already holding a read lock # **or** try to acquire the write lock while you already have it. # This will lead to deadlock # # @see http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html java.util.concurrent.ReentrantReadWriteLock
on_const on_op on_int on_op on_int on_nl on_ignored_nl on_const on_op on_int on_op on_int on_nl on_ignored_nl on_const on_op on_const on_op on_int on_nl # @!visibility private
on_const on_op on_int on_op on_int on_nl on_ignored_nl on_const on_op on_const on_op on_int on_nl on_ignored_nl on_const on_op on_const on_op on_const on_op # @!visibility private
on_const on_op on_const on_op on_int on_nl on_ignored_nl on_const on_op on_const on_op on_const on_op on_int on_nl on_ignored_nl UNK on_nl on_ignored_nl on_ignored_nl # @!visibility private
on_const on_op on_const on_op on_const on_op on_int on_nl on_ignored_nl UNK on_nl on_ignored_nl on_ignored_nl def UNK on_nl UNK on_lparen on_rparen on_nl # @!visibility private
on_ignored_nl def UNK on_nl UNK on_lparen on_rparen on_nl on_ivar on_op on_const on_period new on_lparen on_int on_rparen on_ivar on_op on_const on_op # Implementation notes: # A goal is to make the uncontended path for both readers/writers lock-free # Only if there is reader-writer or writer-writer contention, should locks be used # Internal state is represented by a single integer ("counter"), and updated # using atomic compare-and-swap operations # When the counter is 0, the lock is free # Each reader increments the counter by 1 when acquiring a read lock # (and decrements by 1 when releasing the read lock) # The counter is increased by (1 << 15) for each writer waiting to acquire the # write lock, and by (1 << 29) if the write lock is taken
def UNK on_nl UNK on_lparen on_rparen on_nl on_ivar on_op on_const on_period new on_lparen on_int on_rparen on_ivar on_op on_const on_op on_const # Create a new `ReadWriteLock` in the unlocked state.
on_ivar on_op on_const on_op on_const on_period new on_nl on_ivar on_op on_const on_op on_const on_period new on_nl end on_nl on_ignored_nl def # single integer which represents lock state
def UNK on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_nl UNK on_nl UNK on_ignored_nl UNK # Execute a block operation within a read lock. # # @yield the task to be performed within the lock. # # @return [Object] the result of the block operation. # # @raise [ArgumentError] when no block is given. # @raise [Concurrent::ResourceLimitError] if the maximum number of readers # is exceeded.
def UNK on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_nl UNK on_nl UNK on_ignored_nl UNK # Execute a block operation within a write lock. # # @yield the task to be performed within the lock. # # @return [Object] the result of the block operation. # # @raise [ArgumentError] when no block is given. # @raise [Concurrent::ResourceLimitError] if the maximum number of readers # is exceeded.
def UNK on_nl UNK true on_nl c on_op on_ivar on_period value on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end # Acquire a read lock. If a write lock has been acquired will block until # it is released. Will not block if other read locks have been acquired. # # @return [Boolean] true if the lock is successfully acquired # # @raise [Concurrent::ResourceLimitError] if the maximum number of readers # is exceeded.
if UNK on_lparen c on_rparen on_nl on_ivar on_period UNK UNK on_op UNK UNK on_nl on_ignored_nl UNK true on_nl c on_op # If a writer is waiting when we first queue up, we need to wait
UNK true on_nl c on_op on_ivar on_period value on_nl if running_writer? on_lparen c on_rparen on_nl on_ivar on_period UNK UNK on_op # after a reader has waited once, they are allowed to "barge" ahead of waiting writers # but if a writer is *running*, the reader still needs to wait (naturally)
def UNK on_nl UNK true on_nl c on_op on_ivar on_period value on_nl if on_ivar on_period compare_and_set on_lparen c on_comma c # Release a previously acquired read lock. # # @return [Boolean] true if the lock is successfully released
if UNK on_lparen c on_rparen on_op UNK on_lparen c on_rparen on_op on_int on_nl on_ivar on_period UNK on_nl end on_nl UNK # If one or more writers were waiting, and we were the last reader, wake a writer up
def UNK on_nl UNK true on_nl c on_op on_ivar on_period value on_nl UNK on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end # Acquire a write lock. Will block and wait for all active readers and writers. # # @return [Boolean] true if the lock is successfully acquired # # @raise [Concurrent::ResourceLimitError] if the maximum number of writers # is exceeded.
UNK if on_ivar on_period compare_and_set on_lparen on_int on_comma on_const on_rparen on_nl UNK on_ivar on_period compare_and_set on_lparen c on_comma c on_op # no readers OR writers running # if we successfully swap the RUNNING_WRITER bit on, then we can go ahead
on_ivar on_period UNK UNK on_ignored_nl c on_op on_ivar on_period value on_nl on_op running_writer? on_lparen c on_rparen on_op on_op UNK on_lparen # Now we have successfully incremented, so no more readers will be able to increment # (they will wait instead) # However, readers OR writers could decrement right here, OR another writer could increment
c on_op on_ivar on_period value on_nl on_op running_writer? on_lparen c on_rparen on_op on_op UNK on_lparen c on_rparen on_nl end on_nl # So we have to do another check inside the synchronized section # If a writer OR reader is running, then go to sleep
c on_op on_ivar on_period value on_nl UNK if on_op running_writer? on_lparen c on_rparen on_op on_op UNK on_lparen c on_rparen on_op # We just came out of a wait # If we successfully turn the RUNNING_WRITER bit on with an atomic swap, # Then we are OK to stop waiting and go ahead # Otherwise go back and wait again
def UNK on_nl UNK true UNK running_writer? on_nl c on_op on_ivar on_period UNK UNK on_op UNK on_op UNK on_op on_const # Release a previously acquired write lock. # # @return [Boolean] true if the lock is successfully released
def UNK on_nl on_ivar on_period value on_op on_const on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_ivar on_period value # Queries if the write lock is held by any thread. # # @return [Boolean] true if the write lock is held else false`
def UNK on_nl UNK on_lparen on_ivar on_period value on_rparen on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen c # Queries whether any threads are waiting to acquire the read or write lock. # # @return [Boolean] true if any threads are waiting for a lock else false
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl c on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_int on_nl end on_nl # @!visibility private
def running_writer? on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl c on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_const on_nl end on_nl # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl c on_op on_const on_nl end on_nl on_ignored_nl def UNK on_lparen # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_const on_nl end on_nl # @!visibility private
def UNK on_lparen c on_op on_ivar on_period value on_rparen on_ignored_nl on_lparen c on_op on_const on_rparen on_op on_const on_nl end on_nl # @!visibility private
