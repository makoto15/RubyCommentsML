UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl # frozen_string_literal: false
UNK on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_end # = Using the Pull Parser # <em>This API is experimental, and subject to change.</em> # parser = PullParser.new( "<a>text<b att='val'/>txet</a>" ) # while parser.has_next? # res = parser.next # puts res[1]['att'] if res.start_tag? and res[0] == 'b' # end # See the PullEvent class for information on the content of the results. # The data is identical to the arguments passed for the various events to # the StreamListener API. # # Notice that: # parser = PullParser.new( "<a>BAD DOCUMENT" ) # while parser.has_next? # res = parser.next # raise res[1] if res.error? # end # # Nat Price gave me some good ideas for the API.
on_const on_op on_tstring_beg on_tstring_end on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg on_const on_embexpr_end on_embexpr_beg on_const on_embexpr_end on_tstring_content # TODO
on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg on_const on_embexpr_end on_embexpr_beg on_const on_embexpr_end on_tstring_content on_tstring_end on_nl on_const on_op # TODO
on_const on_op on_tstring_beg on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_end on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl # Just for backward compatibility. For example, kramdown uses this. # It's not used in REXML.
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_content # Entity constants
on_int on_nl end on_nl end on_nl on_ignored_nl def empty? on_nl return on_lparen on_ivar on_period empty? and on_ivar on_period empty? on_rparen # FIXME
def empty? on_nl return on_lparen on_ivar on_period empty? and on_ivar on_period empty? on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # Returns true if there are no more events
def UNK on_nl return on_op on_lparen on_ivar on_period empty? and on_ivar on_period empty? on_rparen on_nl end on_nl on_ignored_nl def UNK # Returns true if there are more events. Synonymous with !empty?
def UNK UNK on_nl on_ivar on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK depth on_op on_int on_nl # Push an event back on the head of the stream. This method # has (theoretically) infinite depth.
def UNK depth on_op on_int on_nl raise on_tstring_beg on_tstring_content on_embexpr_beg depth on_embexpr_end on_tstring_content on_tstring_end if depth on_op on_op on_int on_nl # Peek at the +depth+ event in the stack. The first element on the stack # is at depth 0. If +depth+ is -1, will parse to the end of the input # stream and return the last event, which is always :end_document. # Be aware that this causes the stream to be parsed up to the +depth+ # event, so you can effectively pre-parse the entire document (pull the # entire thing into memory) using this method.
def UNK on_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl on_ivar on_period UNK do on_op UNK on_op on_ignored_nl UNK # Returns the next event. This is a +PullEvent+ object.
on_ivar on_period UNK if on_ivar on_period buffer on_period size on_op on_int on_nl if on_ivar on_op nil on_nl UNK on_op on_ivar #STDERR.puts @source.encoding
if on_ivar on_op nil on_nl UNK on_op on_ivar on_period match on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl UNK on_op UNK on_lbracket #STDERR.puts "BUFFER = #{@source.buffer.inspect}"
UNK on_op on_ivar on_period match on_lparen on_regexp_beg on_tstring_content on_regexp_end on_rparen on_nl UNK on_op UNK on_lbracket on_int on_rbracket unless UNK on_period #@source.consume( /^\s*/um )
UNK UNK on_nl when on_const on_nl return on_lbracket on_symbeg UNK on_comma on_ivar on_period match on_lparen on_const on_comma true on_rparen on_lbracket #STDERR.puts "WORD = #{word.inspect}"
UNK on_op on_ivar on_period match on_lparen on_const on_comma true on_rparen on_lbracket on_int on_rbracket on_nl UNK on_op on_const on_period match on_lparen #STDERR.puts "XMLDECL"
if match on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_lbracket # Now we have to sort out what kind of entity reference this is
match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_lbracket on_int on_op on_op on_int on_rbracket match on_period UNK on_lparen on_int # External reference
match on_period UNK on_lparen on_int on_rparen if match on_period size on_op on_int elsif match on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content # PUBID
elsif match on_lbracket on_int on_rbracket on_op on_tstring_beg on_tstring_content on_tstring_end on_nl match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_lbracket # Chop out NDATA decl # match is [ :entity, name, SYSTEM, pubid(, ndata)? ]
match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_lbracket on_int on_op on_op on_int on_rbracket match on_lbracket on_int on_rbracket on_op # External reference
match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_lbracket on_int on_op on_op on_int on_rbracket match on_period UNK on_lparen on_int # PUBID
match on_period UNK on_lparen on_int on_rparen if match on_period size on_op on_int else on_ignored_nl match on_lbracket on_int on_rbracket on_op match # HREF
else on_ignored_nl match on_lbracket on_int on_rbracket on_op match on_lbracket on_int on_rbracket on_lbracket on_int on_op on_op on_int on_rbracket on_nl match on_period # Chop out NDATA decl # match is [ :entity, name, PUBLIC, pubid, href(, ndata)? ]
end on_nl match on_op on_tstring_beg on_tstring_content on_tstring_end if UNK on_nl return match on_nl when on_const on_nl md on_op on_ivar on_period # match is [ :entity, name, value ]
raise on_const on_op on_const on_period new on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_ivar on_rparen unless md on_nl if md on_lbracket on_int #STDERR.puts "SOURCE BUFFER = #{source.buffer}, #{source.buffer.size}"
md on_op on_ivar on_period match on_lparen on_const on_comma true on_rparen on_nl unless md on_nl raise on_const on_op on_const on_period new # Get the next tag
UNK prefix UNK prefixes on_nl unless on_ivar on_period UNK on_lbrace on_op UNK on_op UNK on_period UNK on_lparen prefix on_rparen on_rbrace # Verify that all of the prefixes have been defined
return on_lbracket on_symbeg UNK on_comma md on_lbracket on_int on_rbracket on_rbracket on_nl end on_nl UNK on_const on_op on_const on_nl raise on_nl #STDERR.puts "GOT #{md[1].inspect}" unless md[0].length == 0 #return [ :text, "" ] if md[0].length == 0 # unnormalized = Text::unnormalize( md[1], self ) # return PullEvent.new( :text, md[1], unnormalized )
def UNK on_lparen UNK on_comma entities on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl copy on_op UNK on_period UNK on_nl # Escapes all possible entities
copy on_period gsub! on_lparen on_const on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl entities on_period UNK do on_op UNK on_comma value on_op # Doing it like this rather than in a loop improves the speed
def UNK on_lparen UNK on_comma entities on_op nil on_comma UNK on_op nil on_rparen on_ignored_nl rv on_op UNK on_period UNK on_nl # Unescapes all possible entities
value on_op scanner on_lbracket on_int on_rbracket on_nl if prefix on_op on_tstring_beg on_tstring_content on_tstring_end on_nl if UNK on_op on_tstring_beg on_tstring_content on_tstring_end # quote = scanner[4]
