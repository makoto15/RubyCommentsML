require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl require_relative on_tstring_beg on_tstring_content on_tstring_end on_nl # frozen_string_literal: false
UNK on_const on_op on_const on_nl on_const on_op on_const on_period UNK on_nl on_ignored_nl def UNK on_lparen source on_op UNK on_comma UNK # Represents a full XML document, including PIs, a doctype, etc. A # Document has a single child that can be accessed by root(). # Note that if you want to have an XML declaration written for a document # you create, you must add one; REXML documents do not write a default # declaration for you. See |DECLARATION| and |write|.
on_const on_op on_const on_period UNK on_nl on_ignored_nl def UNK on_lparen source on_op UNK on_comma UNK on_op UNK UNK on_rparen on_ignored_nl # A convenient default XML declaration. If you want an XML declaration, # the easiest way to add one is mydoc << Document::DECLARATION # +DEPRECATED+ # Use: mydoc << XMLDecl.default
def UNK on_lparen source on_op UNK on_comma UNK on_op UNK UNK on_rparen on_ignored_nl on_ivar on_op on_int on_nl UNK on_lparen on_rparen # Constructor # @param source if supplied, must be a Document, String, or IO. # Documents have their context and Element attributes cloned. # Strings are expected to be valid XML documents. IOs are expected # to be sources of valid XML documents. # @param context if supplied, contains the context of the document; # this should be a Hash.
def UNK on_nl on_const on_period new self on_nl end on_nl on_ignored_nl def UNK on_nl on_tstring_beg on_tstring_end on_nl end on_nl on_ignored_nl # Should be obvious
def UNK on_nl on_tstring_beg on_tstring_end on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen child # According to the XML spec, a root node has no expanded name
end on_nl on_ignored_nl UNK on_symbeg UNK on_symbeg UNK on_nl on_ignored_nl def UNK on_lparen child on_rparen on_ignored_nl if child on_period kind_of? #d = doc_type #d ? d.name : "UNDEFINED"
def UNK on_lparen child on_rparen on_ignored_nl if child on_period kind_of? on_const on_nl if on_ivar on_lbracket on_int on_rbracket on_period kind_of? on_const # We override this, because XMLDecls and DocTypes must go at the start # of the document
UNK on_op on_ivar on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_period kind_of? on_lparen on_const on_rparen on_op UNK on_period kind_of? # Find first Element or DocType node and insert the decl right # before it. If there is no such node, just insert the child at the # end. If there is a child and it is an DocType, then replace it.
if on_ivar on_lbracket UNK on_rbracket on_period kind_of? on_const on_nl on_ivar on_lbracket UNK on_rbracket on_op child on_nl else on_ignored_nl on_ivar on_lbracket # Not null = not end of list
on_ivar on_op child on_nl end on_nl child on_period UNK on_op self on_nl else on_ignored_nl rv on_op UNK on_nl UNK on_tstring_beg # Insert at end of list
def UNK on_nl UNK on_lbracket on_int on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK UNK on_op UNK # @return the root Element of the document, or nil if this document # has no children.
end on_nl on_ignored_nl def UNK on_nl on_ivar on_period UNK UNK on_op UNK on_op UNK on_period kind_of? on_const UNK on_nl end #self #@children.find { |item| item.kind_of? Element }
def UNK on_nl on_ivar on_period UNK UNK on_op UNK on_op UNK on_period kind_of? on_const UNK on_nl end on_nl on_ignored_nl def # @return the DocType child of the document, if one exists, # and nil otherwise.
def UNK on_nl rv on_op on_ivar on_lbracket on_int on_rbracket on_nl UNK rv if rv on_period kind_of? on_const on_nl on_ivar on_period # @return the XMLDecl of this document; if no XMLDecl has been # set, the default declaration is returned.
def UNK on_nl UNK on_lparen on_rparen on_period UNK on_nl end on_nl on_ignored_nl def encoding on_nl UNK on_lparen on_rparen on_period encoding # @return the XMLDecl version of this document as a String. # If no XMLDecl has been set, returns the default version.
def encoding on_nl UNK on_lparen on_rparen on_period encoding on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_rparen on_period UNK # @return the XMLDecl encoding of this document as an # Encoding object. # If no XMLDecl has been set, returns the default encoding.
def UNK on_nl UNK on_lparen on_rparen on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op UNK on_rparen on_ignored_nl if # @return the XMLDecl standalone value of this document as a String. # If no XMLDecl has been set, returns the default setting.
def UNK on_lparen on_op UNK on_rparen on_ignored_nl if UNK on_period UNK on_op on_int UNK UNK on_lbracket on_int on_rbracket on_period UNK # :call-seq: # doc.write(output=$stdout, indent=-1, transtive=false, ie_hack=false, encoding=nil) # doc.write(options={:output => $stdout, :indent => -1, :transtive => false, :ie_hack => false, :encoding => nil}) # # Write the XML tree out, optionally with indent. This writes out the # entire XML document, including XML declarations, doctype declarations, # and processing instructions (if any are given). # # A controversial point is whether Document should always write the XML # declaration (<?xml version='1.0'?>) whether or not one is given by the # user (or source document). REXML does not write one if one was not # specified, because it adds unnecessary bandwidth to applications such # as XML-RPC. # # Accept Nth argument style and options Hash style as argument. # The recommended style is options Hash style for one or more # arguments case. # # _Examples_ # Document.new("<a><b/></a>").write # # output = "" # Document.new("<a><b/></a>").write(output) # # output = "" # Document.new("<a><b/></a>").write(:output => output, :indent => 2) # # See also the classes in the rexml/formatters package for the proper way # to change the default formatting of XML output. # # _Examples_ # # output = "" # tr = Transitive.new # tr.write(Document.new("<a><b/></a>"), output) # # output:: # output an object which supports '<< string'; this is where the # document will be written. # indent:: # An integer. If -1, no indenting will be used; otherwise, the # indentation will be twice this number of spaces, and children will be # indented an additional amount. For a value of 3, every item will be # indented 3 more levels, or 6 more spaces (2 * 3). Defaults to -1 # transitive:: # If transitive is true and indent is >= 0, then the output will be # pretty-printed in such a way that the added whitespace does not affect # the absolute *value* of the document -- that is, it leaves the value # and number of Text nodes in the document unchanged. # ie_hack:: # This hack inserts a space before the /> on empty tags to address # a limitation of Internet Explorer. Defaults to false # encoding:: # Encoding name as String. Change output encoding to specified encoding # instead of encoding in XML declaration. # Defaults to nil. It means encoding in XML declaration is used.
def on_const on_op UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_op UNK on_nl end on_nl on_ignored_nl def on_const on_op # Set the entity expansion limit. By default the limit is set to 10000. # # Deprecated. Use REXML::Security.entity_expansion_limit= instead.
def on_const on_op UNK on_nl UNK on_const on_period UNK on_nl end on_nl on_ignored_nl def on_const on_op UNK on_lparen UNK on_rparen # Get the entity expansion limit. By default the limit is set to 10000. # # Deprecated. Use REXML::Security.entity_expansion_limit= instead.
def on_const on_op UNK on_lparen UNK on_rparen on_ignored_nl on_const on_period UNK on_op UNK on_nl end on_nl on_ignored_nl def on_const on_op # Set the entity expansion limit. By default the limit is set to 10240. # # Deprecated. Use REXML::Security.entity_expansion_text_limit= instead.
def on_const on_op UNK on_nl UNK on_const on_period UNK on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_nl on_ignored_nl def UNK # Get the entity expansion limit. By default the limit is set to 10240. # # Deprecated. Use REXML::Security.entity_expansion_text_limit instead.
