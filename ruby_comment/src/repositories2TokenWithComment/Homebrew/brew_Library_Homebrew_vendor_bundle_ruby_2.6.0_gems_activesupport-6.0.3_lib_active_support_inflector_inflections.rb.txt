on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl # frozen_string_literal: true
UNK on_const on_nl on_ivar on_op on_const on_op on_const on_period UNK on_nl on_ignored_nl UNK on_const on_op on_const on_nl def UNK on_nl # A singleton instance of this class is yielded by Inflector.inflections, # which can then be used to specify additional inflection rules. If passed # an optional locale, rules for other languages can be specified. The # default locale is <tt>:en</tt>. Only rules for English are provided. # # ActiveSupport::Inflector.inflections(:en) do |inflect| # inflect.plural /^(ox)$/i, '\1\2en' # inflect.singular /^(ox)en/i, '\1' # # inflect.irregular 'octopus', 'octopi' # # inflect.uncountable 'equipment' # end # # New rules are added at the top. So in the example above, the irregular # rule for octopus will now be the first of the pluralization and # singularization rules that is runs. This guarantees that your rules run # before any of the rules that may already have been loaded.
on_ignored_nl def UNK on_nl on_ivar on_comma on_ivar on_comma on_ivar on_comma on_ivar on_comma on_ivar on_op on_lbracket on_rbracket on_comma on_lbracket on_rbracket on_comma # :nodoc:
def UNK on_lparen UNK on_rparen UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content on_tstring_end on_period UNK UNK on_op # Private, for the test suite.
UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content UNK on_tstring_content on_tstring_end on_period UNK UNK on_op scope on_op on_ignored_nl UNK on_lparen # :nodoc:
def UNK on_lparen word on_rparen on_ignored_nl on_ivar on_lbracket word on_period downcase on_rbracket on_op word on_nl UNK on_nl end on_nl on_ignored_nl # Specifies a new acronym. An acronym must be specified as it will appear # in a camelized string. An underscore string that contains the acronym # will retain the acronym when passed to +camelize+, +humanize+, or # +titleize+. A camelized string that contains the acronym will maintain # the acronym when titleized or humanized, and will convert the acronym # into a non-delimited single lowercase word when passed to +underscore+. # # acronym 'HTML' # titleize 'html' # => 'HTML' # camelize 'html' # => 'HTML' # underscore 'MyHTML' # => 'my_html' # # The acronym, however, must occur as a delimited unit and not be part of # another word for conversions to recognize it: # # acronym 'HTTP' # camelize 'my_http_delimited' # => 'MyHTTPDelimited' # camelize 'https' # => 'Https', not 'HTTPs' # underscore 'HTTPS' # => 'http_s', not 'https' # # acronym 'HTTPS' # camelize 'https' # => 'HTTPS' # underscore 'HTTPS' # => 'https' # # Note: Acronyms that are passed to +pluralize+ will no longer be # recognized, since the acronym will not occur as a delimited unit in the # pluralized result. To work around this, you must specify the pluralized # form as an acronym as well: # # acronym 'API' # camelize(pluralize('api')) # => 'Apis' # # acronym 'APIs' # camelize(pluralize('api')) # => 'APIs' # # +acronym+ may be used to specify any word that contains an acronym or # otherwise needs to maintain a non-standard capitalization. The only # restriction is that the word must begin with a capital letter. # # acronym 'RESTful' # underscore 'RESTful' # => 'restful' # underscore 'RESTfulController' # => 'restful_controller' # titleize 'RESTfulController' # => 'RESTful Controller' # camelize 'restful' # => 'RESTful' # camelize 'restful_controller' # => 'RESTfulController' # # acronym 'McDonald' # underscore 'McDonald' # => 'mcdonald' # camelize 'mcdonald' # => 'McDonald'
def plural on_lparen rule on_comma replacement on_rparen on_ignored_nl on_ivar on_period delete on_lparen rule on_rparen UNK rule on_period UNK on_lparen on_const # Specifies a new pluralization rule and its replacement. The rule can # either be a string or a regular expression. The replacement should # always be a string that may include references to the matched data from # the rule.
def singular on_lparen rule on_comma replacement on_rparen on_ignored_nl on_ivar on_period delete on_lparen rule on_rparen UNK rule on_period UNK on_lparen on_const # Specifies a new singularization rule and its replacement. The rule can # either be a string or a regular expression. The replacement should # always be a string that may include references to the matched data from # the rule.
def UNK on_lparen singular on_comma plural on_rparen on_ignored_nl on_ivar on_period delete on_lparen singular on_rparen on_nl on_ivar on_period delete on_lparen plural # Specifies a new irregular that applies to both pluralization and # singularization at the same time. This can only be used for strings, not # regular expressions. You simply pass the irregular in singular and # plural form. # # irregular 'octopus', 'octopi' # irregular 'person', 'people'
def UNK on_lparen on_op words on_rparen on_ignored_nl on_ivar on_period UNK on_lparen words on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # Specifies words that are uncountable and should not be inflected. # # uncountable 'money' # uncountable 'money', 'information' # uncountable %w( money information rice )
def UNK on_lparen rule on_comma replacement on_rparen on_ignored_nl on_ivar on_period UNK on_lparen on_lbracket rule on_comma replacement on_rbracket on_rparen on_nl end # Specifies a humanized form of a string by a regular expression rule or # by a string mapping. When using a regular expression based replacement, # the normal humanize formatting is called after the replacement. When a # string is used, the human form should be specified as desired (example: # 'The name', not 'the_name'). # # human /_cnt$/i, '\1_count' # human 'legacy_col_person_name', 'Name'
def UNK on_lparen scope on_op on_symbeg UNK on_rparen on_ignored_nl UNK scope on_nl UNK on_symbeg UNK on_nl on_ivar on_comma on_ivar on_comma # Clears the loaded inflections within a given scope (default is # <tt>:all</tt>). Give the scope as a symbol of the inflection type, the # options are: <tt>:plurals</tt>, <tt>:singulars</tt>, <tt>:uncountables</tt>, # <tt>:humans</tt>. # # clear :all # clear :plurals
def UNK on_lparen UNK on_op on_symbeg UNK on_rparen on_ignored_nl UNK UNK on_nl UNK on_const on_period UNK on_lparen UNK on_rparen on_nl # Yields a singleton instance of Inflector::Inflections so you can specify # additional inflector rules. If passed an optional locale, rules for other # languages can be specified. If not specified, defaults to <tt>:en</tt>. # Only rules for English are provided. # # ActiveSupport::Inflector.inflections(:en) do |inflect| # inflect.uncountable 'rails' # end
