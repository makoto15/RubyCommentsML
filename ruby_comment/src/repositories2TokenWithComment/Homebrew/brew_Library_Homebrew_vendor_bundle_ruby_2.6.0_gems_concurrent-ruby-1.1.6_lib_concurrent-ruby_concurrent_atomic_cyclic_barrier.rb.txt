UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl on_const on_op on_const on_period UNK on_lparen on_symbeg status on_rparen on_nl UNK on_symbeg # A synchronization aid that allows a set of threads to all wait for each # other to reach a common barrier point. # @example # barrier = Concurrent::CyclicBarrier.new(3) # jobs = Array.new(3) { |i| -> { sleep i; p done: i } } # process = -> (i) do # # waiting to start at the same time # barrier.wait # # execute job # jobs[i].call # # wait for others to finish # barrier.wait # end # threads = 2.times.map do |i| # Thread.new(i, &process) # end # # # use main as well # process.call 2 # # # here we can be sure that all jobs are processed
on_const on_op on_const on_period UNK on_lparen on_symbeg status on_rparen on_nl UNK on_symbeg on_const on_nl on_ignored_nl def UNK on_lparen parties on_comma # @!visibility private
def UNK on_lparen parties on_comma on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_period UNK parties on_nl on_const on_op on_const on_period # Create a new `CyclicBarrier` that waits for `parties` threads # # @param [Fixnum] parties the number of parties # @yield an optional block that will be executed that will be executed after # the last thread arrives and before the others are released # # @raise [ArgumentError] if `parties` is not an integer or is less than zero
def parties on_nl synchronize on_lbrace on_ivar on_rbrace on_nl end on_nl on_ignored_nl def UNK on_nl synchronize on_lbrace on_ivar on_rbrace on_nl end # @return [Fixnum] the number of threads needed to pass the barrier
def UNK on_nl synchronize on_lbrace on_ivar on_rbrace on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl synchronize # @return [Fixnum] the number of threads currently waiting on the barrier
def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl synchronize UNK on_ignored_nl on_ignored_nl UNK UNK UNK on_ivar on_period status on_op on_symbeg # Blocks on the barrier until the number of waiting threads is equal to # `parties` or until `timeout` is reached or `reset` is called # If a block has been passed to the constructor, it will be executed once by # the last arrived thread before releasing the others # @param [Fixnum] timeout the number of seconds to wait for the counter or # `nil` to block indefinitely # @return [Boolean] `true` if the `count` reaches zero else false on # `timeout` or on `reset` or if the barrier is broken
def UNK on_nl synchronize on_lbrace UNK on_ivar on_comma on_symbeg UNK on_rbrace on_nl end on_nl on_ignored_nl def UNK on_nl synchronize on_lbrace # resets the barrier to its initial state # If there is at least one waiting thread, it will be woken up, the `wait` # method will return false and the barrier will be broken # If the barrier is broken, this method restores it to the original state # # @return [nil]
def UNK on_nl synchronize on_lbrace on_ivar on_period status on_op on_symbeg UNK on_rbrace on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl def # A barrier can be broken when: # - a thread called the `reset` method while at least one other thread was waiting # - at least one thread timed out on `wait` method # # A broken barrier can be restored using `reset` it's safer to create a new one # @return [Boolean] true if the barrier is broken otherwise false
