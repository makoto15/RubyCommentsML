UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl # frozen_string_literal: false
UNK on_const on_nl UNK on_const on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_const # You don't want to use this class. Really. Use XPath, which is a wrapper # for this class. Believe me. You don't want to poke around in here. # There is strange, dark magic at work in this code. Beware. Go back! Go # back while you still can!
path on_period UNK on_lparen on_regexp_beg on_tstring_content on_regexp_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl parsed on_op on_lbracket on_rbracket on_nl on_const on_lparen # Strip ignorable spaces
def on_const path on_comma parsed on_nl path on_op path on_period lstrip on_nl if path on_lbracket on_int on_rbracket on_op on_char on_nl #LocationPath # | RelativeLocationPath # | '/' RelativeLocationPath? # | '//' RelativeLocationPath
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl def on_const path on_comma parsed on_nl UNK UNK on_ignored_nl original_path on_op path on_nl path #RelativeLocationPath # | Step # | (AXIS_NAME '::' | '@' | '') AxisSpecifier # NodeTest # Predicate # | '.' | '..' AbbreviatedStep # | RelativeLocationPath '/' Step # | RelativeLocationPath '//' Step
if path on_lbracket on_int on_rbracket on_op on_char on_nl if path on_lbracket on_int on_rbracket on_op on_char on_nl parsed on_op on_symbeg UNK # (axis or @ or <child::>) nodetest predicate > # OR > / Step # (. or ..) >
elsif path on_op on_const on_nl parsed on_op on_backref on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_period # Goto Nodetest
else on_ignored_nl parsed on_op on_symbeg UNK on_nl end on_nl on_ignored_nl n on_op on_lbracket on_rbracket on_nl path on_op on_const on_lparen path # Goto Nodetest
on_const on_op on_regexp_beg on_tstring_content UNK on_const UNK on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content UNK on_const UNK on_tstring_content on_regexp_end on_nl # Returns a 1-1 map of the nodeset # The contents of the resulting array are either: # true/false, if a positive match # String, if a name match #NodeTest # | ('*' | NCNAME ':' '*' | QNAME) NameTest # | '*' ':' NCNAME NameTest since XPath 2.0 # | NODE_TYPE '(' ')' NodeType # | PI '(' LITERAL ')' PI # | '[' expr ']' Predicate
def on_const path on_comma parsed on_nl original_path on_op path on_nl path on_op path on_period lstrip on_nl return original_path unless path # Filters the supplied nodeset on the predicate(s)
on_ignored_nl def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen # The following return arrays of true/false, a 1-1 mapping of the # supplied nodeset, except for axe(), which returns a filtered # nodeset
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen on_nl #| OrExpr S 'or' S AndExpr #| AndExpr
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen on_nl #| AndExpr S 'and' S EqualityExpr #| EqualityExpr
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen on_nl #| EqualityExpr ('=' | '!=') RelationalExpr #| RelationalExpr
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen on_nl #| RelationalExpr ('<' | '>' | '<=' | '>=') AdditiveExpr #| AdditiveExpr
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen on_nl #| AdditiveExpr ('+' | '-') MultiplicativeExpr #| MultiplicativeExpr
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen on_nl #| MultiplicativeExpr ('*' | S ('div' | 'mod') S) UnaryExpr #| UnaryExpr
def on_const path on_comma parsed on_nl path on_op on_regexp_beg on_tstring_content on_regexp_end on_nl path on_op on_backref on_nl if on_backref and on_lparen #| '-' UnaryExpr #| UnionExpr
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const on_lparen path on_comma n on_rparen on_nl #| UnionExpr '|' PathExpr #| PathExpr
def on_const path on_comma parsed on_nl path on_op path on_period lstrip on_nl n on_op on_lbracket on_rbracket on_nl rest on_op on_const #| LocationPath #| FilterExpr ('/' | '//') RelativeLocationPath
def on_const path on_comma parsed on_nl n on_op on_lbracket on_rbracket on_nl path on_op on_const on_lparen path on_comma n on_rparen on_nl #| FilterExpr Predicate #| PrimaryExpr
on_const on_op on_regexp_beg on_tstring_content UNK on_const UNK on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_nl on_const on_op on_regexp_beg on_tstring_content #| VARIABLE_REFERENCE #| '(' expr ')' #| LITERAL #| NUMBER #| FunctionCall
when on_regexp_beg on_tstring_content on_regexp_end on_nl UNK on_op on_backref on_nl UNK on_op on_backref on_nl return path if UNK on_op on_const on_nl #arry << @variables[ varname ]
path on_comma UNK on_op UNK on_lparen path on_rparen on_nl UNK on_op UNK on_lbracket on_int on_op on_op on_int on_rbracket on_nl n #/
def on_const rest on_comma parsed on_nl path on_comma arguments on_op UNK on_lparen rest on_rparen on_nl UNK on_op on_lbracket on_rbracket on_nl #| FUNCTION_NAME '(' ( expr ( ',' expr )* )? ')'
def UNK string on_nl ind on_op on_int on_nl depth on_op on_int on_nl UNK on_op string on_lbracket on_int on_comma on_int on_rbracket # get_group( '[foo]bar' ) -> ['bar', '[foo]']
