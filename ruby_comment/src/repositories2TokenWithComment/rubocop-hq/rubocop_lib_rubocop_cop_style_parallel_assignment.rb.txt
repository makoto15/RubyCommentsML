on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl def UNK on_lparen node # Checks for simple usages of parallel assignment. # This will only complain when the number of variables # being assigned matched the number of assigning variables. # # @example # # bad # a, b, c = 1, 2, 3 # a, b, c = [1, 2, 3] # # # good # one, two = *foo # a, b = foo() # a, b = b, a # # a = 1 # b = 2 # c = 3
on_ignored_nl UNK UNK UNK on_lparen lhs on_rparen on_op UNK on_lparen rhs on_rparen on_op on_ignored_nl UNK on_lparen UNK on_comma UNK on_rparen # edge case for one constant
UNK on_period UNK on_op UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen node # Account for edge cases using one variable with a comma # E.g.: `foo, = *bar`
UNK on_op UNK on_op node UNK on_period UNK on_nl on_ignored_nl on_op node on_period UNK on_op on_ignored_nl UNK on_lparen node on_rparen # Edge case for one constant
on_op node on_period UNK on_op on_ignored_nl UNK on_lparen node on_rparen on_op on_ignored_nl UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen # Account for edge case of `Constant::CONSTANT`
UNK on_op UNK on_period UNK on_lparen right_elements on_rparen on_nl on_ignored_nl UNK on_ignored_nl on_const on_period UNK on_lparen UNK on_rparen on_period UNK # arrange left_elements in an order such that no corresponding right # element refers to a left element earlier in the sequence # this can be done using an algorithm called a "topological sort" # fortunately for us, Ruby's stdlib contains an implementation
def UNK on_lparen right_elements on_rparen on_ignored_nl right_elements on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_lparen UNK on_rparen UNK on_op # Converts (send nil :something) nodes to (send (:self) :something). # This makes the sorting algorithm work for expressions such as # `self.a, self.b = b, a`.
UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_nl on_ignored_nl UNK on_symbeg UNK on_comma on_tstring_beg on_tstring_content # Helper class necessitated by silly design of TSort prior to Ruby 2.1 # Newer versions have a better API, but that doesn't help us
UNK on_comma UNK on_op on_op assignment on_nl on_ignored_nl on_ivar on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_comma UNK on_op # yield all the assignments which must come after `assignment` # (due to dependencies on the previous value of the assigned var)
def UNK on_lparen rhs on_comma lhs on_rparen on_ignored_nl UNK lhs on_period UNK on_lparen on_symbeg on_op on_rparen on_nl UNK on_lparen rhs # `lhs` is an assignment method call like `obj.attr=` or `ary[idx]=`. # Does `rhs` access the same value which is assigned by `lhs`?
UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_symbeg config on_comma on_symbeg node on_nl on_ignored_nl def UNK on_lparen node on_comma # An internal class for correcting parallel assignment
UNK on_const on_op on_const on_nl def correction on_nl UNK on_comma UNK on_op on_op node on_period parent on_nl UNK on_comma UNK # An internal class for correcting parallel assignment # protected by rescue
UNK node on_period parent on_period parent on_op UNK on_nl UNK on_op UNK on_lparen rescue_result on_rparen on_nl UNK on_ignored_nl UNK on_lparen # If the parallel assignment uses a rescue modifier and it is the # only contents of a method, then we want to make use of the # implicit begin
UNK on_const on_op on_const on_nl def correction on_nl parent on_op node on_period parent on_nl on_ignored_nl on_tstring_beg on_embexpr_beg UNK on_lparen parent # An internal class for correcting parallel assignment # guarded by if, unless, while, or until
