on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl def UNK on_lparen UNK on_op # This cop checks for duplicated instance (or singleton) method # definitions. # # @example # # # bad # # def foo # 1 # end # # def foo # 2 # end # # @example # # # bad # # def foo # 1 # end # # alias foo bar # # @example # # # good # # def foo # 1 # end # # def bar # 2 # end # # @example # # # good # # def foo # 1 # end # # alias bar foo
return if node on_period UNK on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl return if UNK on_lparen node on_rparen on_nl # if a method definition is inside an if, it is very likely # that a different definition is used depending on platform, etc.
node on_period UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_rparen UNK on_op ancestor on_op on_ignored_nl namespace on_comma # this method is quite imperfect and can be fooled # to do much better, we would need to do global analysis of the whole # codebase
node on_period UNK on_lparen on_symbeg UNK on_rparen on_period UNK UNK on_op ancestor on_op on_ignored_nl ancestor on_period method_name on_op on_symbeg UNK # DSL methods may evaluate a block in the context of a newly created # class or module # Assume that if a method definition is inside any block call which # we can't identify, it could be a DSL
