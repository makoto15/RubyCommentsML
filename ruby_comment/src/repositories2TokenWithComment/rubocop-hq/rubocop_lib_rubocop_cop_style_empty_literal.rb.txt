on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op # This cop checks for the use of a method, the result of which # would be a literal, like an empty array, hash, or string. # # @example # # bad # a = Array.new # h = Hash.new # s = String.new # # # good # a = [] # h = {} # s = ''
UNK on_op node on_period parent on_period UNK on_nl on_ignored_nl UNK on_lparen UNK UNK UNK UNK on_period UNK on_period UNK on_op # `some_method {}` is not same as `some_method Hash.new` # because the braces are interpreted as a block. We will have # to rewrite the arguments to wrap them in parenthesis.
UNK on_lparen node on_rparen on_op on_op UNK on_lparen node on_period parent on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen node # If Hash.new takes a block, it can't be changed to {}.
UNK on_op node on_period parent on_period UNK on_nl on_tstring_beg on_tstring_content UNK UNK UNK UNK on_op on_op UNK UNK on_period UNK # `some_method {}` is not same as `some_method Hash.new` # because the braces are interpreted as a block. We will have # to rewrite the arguments to wrap them in parenthesis.
