on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl on_const # Check for uses of braces or do/end around single line or # multi-line blocks. # # @example EnforcedStyle: line_count_based (default) # # bad - single line block # items.each do |item| item / 5 end # # # good - single line block # items.each { |item| item / 5 } # # # bad - multi-line block # things.map { |thing| # something = thing.some_method # process(something) # } # # # good - multi-line block # things.map do |thing| # something = thing.some_method # process(something) # end # # @example EnforcedStyle: semantic # # Prefer `do...end` over `{...}` for procedural blocks. # # # return value is used/assigned # # bad # foo = map do |x| # x # end # puts (map do |x| # x # end) # # # return value is not used out of scope # # good # map do |x| # x # end # # # Prefer `{...}` over `do...end` for functional blocks. # # # return value is not used out of scope # # bad # each { |x| # x # } # # # return value is used/assigned # # good # foo = map { |x| # x # } # map { |x| # x # }.inspect # # # The AllowBracesOnProceduralOneLiners option is ignored unless the # # EnforcedStyle is set to `semantic`. If so: # # # If the AllowBracesOnProceduralOneLiners option is unspecified, or # # set to `false` or any other falsey value, then semantic purity is # # maintained, so one-line procedural blocks must use do-end, not # # braces. # # # bad # collection.each { |element| puts element } # # # good # collection.each do |element| puts element end # # # If the AllowBracesOnProceduralOneLiners option is set to `true`, or # # any other truthy value, then one-line procedural blocks may use # # either style. (There is no setting for requiring braces on them.) # # # good # collection.each { |element| puts element } # # # also good # collection.each do |element| puts element end # # @example EnforcedStyle: braces_for_chaining # # bad # words.each do |word| # word.flip.flop # end.join("-") # # # good # words.each { |word| # word.flip.flop # }.join("-") # # @example EnforcedStyle: always_braces # # bad # words.each do |word| # word.flip.flop # end # # # good # words.each { |word| # word.flip.flop # } # # @example BracesRequiredMethods: ['sig'] # # # Methods listed in the BracesRequiredMethods list, such as 'sig' # # in this example, will require `{...}` braces. This option takes # # precedence over all other configurations except IgnoredMethods. # # # bad # sig do # params( # foo: string, # ).void # end # def bar(foo) # puts foo # end # # # good # sig { # params( # foo: string, # ).void # } # def bar(foo) # puts foo # end #
UNK on_lparen block on_rparen on_nl end on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl return if # If there are no parentheses around the arguments, then braces # and do-end have different meaning due to how they bind, so we # allow either.
def UNK on_lparen node on_comma on_op block on_rparen on_ignored_nl UNK node on_period UNK on_nl when on_symbeg block on_nl UNK node # rubocop:disable Metrics/CyclomaticComplexity
return if node on_period UNK on_nl on_ignored_nl node on_period UNK UNK on_op UNK on_op UNK on_lparen UNK on_comma on_op block # A hash which is passed as method argument may have no braces # In that case, one of the K/V pairs could contain a block node # which could change in meaning if do...end replaced {...}
on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl return UNK on_lparen node on_rparen if UNK on_lparen node on_period method_name on_rparen on_nl # rubocop:enable Metrics/CyclomaticComplexity
if node on_period parent on_period UNK on_nl UNK on_lparen node on_period parent on_rparen on_nl else on_ignored_nl node on_period parent on_period # If there are parentheses around the block, check if that # is being used.
