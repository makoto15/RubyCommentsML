on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end # This cop enforces the use of either `#alias` or `#alias_method` # depending on configuration. # It also flags uses of `alias :symbol` rather than `alias bareword`. # # @example EnforcedStyle: prefer_alias (default) # # bad # alias_method :bar, :foo # alias :bar :foo # # # good # alias bar foo # # @example EnforcedStyle: prefer_alias_method # # bad # alias :bar :foo # alias bar foo # # # good # alias_method :bar, :foo
def UNK on_lparen node on_rparen on_ignored_nl UNK on_lparen UNK on_op node on_period UNK on_rparen on_nl UNK UNK on_period UNK on_nl # In this expression, will `self` be the same as the innermost enclosing # class or module block (:lexical)? Or will it be something else # (:dynamic)? If we're in an instance_eval block, return that.
