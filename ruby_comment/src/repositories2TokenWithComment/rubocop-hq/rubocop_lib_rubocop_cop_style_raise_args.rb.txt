on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op # This cop checks the args passed to `fail` and `raise`. For exploded # style (default), it recommends passing the exception class and message # to `raise`, rather than construct an instance of the error. It will # still allow passing just a message, or the construction of an error # with more than one argument. # # The exploded style works identically, but with the addition that it # will also suggest constructing error objects when the exception is # passed multiple arguments. # # @example EnforcedStyle: exploded (default) # # bad # raise StandardError.new("message") # # # good # raise StandardError, "message" # fail "message" # raise MyCustomError.new(arg1, arg2, arg3) # raise MyKwArgError.new(key1: val1, key2: val2) # # @example EnforcedStyle: compact # # bad # raise StandardError, "message" # raise RuntimeError, arg1, arg2, arg3 # # # good # raise StandardError.new("message") # raise MyCustomError.new(arg1, arg2, arg3) # fail "message"
return UNK if UNK on_period UNK on_op UNK on_nl on_ignored_nl return UNK if UNK on_period UNK on_nl on_ignored_nl UNK on_op # Allow code like `raise Ex.new(arg1, arg2)`.
return UNK if UNK on_period UNK on_nl on_ignored_nl UNK on_op UNK on_period UNK on_nl on_ignored_nl UNK on_period UNK on_op UNK # Disallow zero arguments.
UNK on_period UNK on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen parent on_rparen on_ignored_nl parent on_period UNK # Allow code like `raise Ex.new(kw: arg)`. # Allow code like `raise Ex.new(*args)`.
