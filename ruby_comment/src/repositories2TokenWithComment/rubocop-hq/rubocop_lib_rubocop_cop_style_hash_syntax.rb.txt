on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op # This cop checks hash literal syntax. # # It can enforce either the use of the class hash rocket syntax or # the use of the newer Ruby 1.9 syntax (when applicable). # # A separate offense is registered for each problematic pair. # # The supported styles are: # # * ruby19 - forces use of the 1.9 syntax (e.g. `{a: 1}`) when hashes have # all symbols for keys # * hash_rockets - forces use of hash rockets for all hashes # * no_mixed_keys - simply checks for hashes with mixed syntaxes # * ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed # syntax hashes # # @example EnforcedStyle: ruby19 (default) # # bad # {:a => 2} # {b: 1, :c => 2} # # # good # {a: 2, b: 1} # {:c => 2, 'd' => 2} # acceptable since 'd' isn't a symbol # {d: 1, 'e' => 2} # technically not forbidden # # @example EnforcedStyle: hash_rockets # # bad # {a: 1, b: 2} # {c: 1, 'd' => 5} # # # good # {:a => 1, :b => 2} # # @example EnforcedStyle: no_mixed_keys # # bad # {:a => 1, b: 2} # {c: 1, 'd' => 2} # # # good # {:a => 1, :b => 2} # {c: 1, d: 2} # # @example EnforcedStyle: ruby19_no_mixed_keys # # bad # {:a => 1, :b => 2} # {c: 2, 'd' => 3} # should just use hash rockets # # # good # {a: 1, b: 2} # {:c => 3, 'd' => 4}
UNK UNK UNK UNK on_tstring_content UNK on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl UNK UNK if UNK on_tstring_content # Prefer { :production? => false } over { production?: false } and # similarly for other non-alnum final characters (except quotes, # to prefer { "x y": 1 } over { :"x y" => 1 }).
UNK UNK if UNK on_tstring_content UNK on_period UNK on_lparen UNK on_rparen on_nl on_ignored_nl UNK on_lparen on_tstring_beg on_tstring_content UNK UNK UNK # Most hash keys can be matched against a simple regex.
UNK on_lparen on_tstring_beg on_tstring_content UNK UNK UNK on_tstring_content on_tstring_end on_rparen on_period UNK on_nl end on_nl on_ignored_nl def check on_lparen pairs # For more complicated hash keys, let the parser validate the syntax.
