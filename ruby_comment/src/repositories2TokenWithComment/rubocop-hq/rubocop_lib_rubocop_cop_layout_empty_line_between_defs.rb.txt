on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl def UNK on_period UNK # This cop checks whether method definitions are # separated by one empty line. # # `NumberOfEmptyLines` can be an integer (default is 1) or # an array (e.g. [1, 2]) to specify a minimum and maximum # number of empty lines permitted. # # `AllowAdjacentOneLineDefs` configures whether adjacent # one-line method definitions are considered an offense. # # @example # # # bad # def a # end # def b # end # # @example # # # good # def a # end # # def b # end
def UNK on_lparen node on_rparen on_ignored_nl node on_period UNK on_period UNK on_lparen UNK on_rparen UNK on_op UNK on_comma UNK on_op # We operate on `begin` nodes, instead of using `OnMethodDef`, # so that we can walk over pairs of consecutive nodes and # efficiently access a node's predecessor; #prev_node ends up # doing a linear scan over siblings, so we don't want to call # it on each def.
UNK on_op UNK on_period loc on_period end on_period UNK on_nl UNK on_op UNK on_period loc on_period end on_period UNK on_nl # finds position of first newline
