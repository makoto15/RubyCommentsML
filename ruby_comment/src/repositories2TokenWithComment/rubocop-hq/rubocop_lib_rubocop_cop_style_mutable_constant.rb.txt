on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl def # This cop checks whether some constant value isn't a # mutable literal (e.g. array or hash). # # Strict mode can be used to freeze all constants, rather than # just literals. # Strict mode is considered an experimental feature. It has not been # updated with an exhaustive list of all methods that will produce # frozen objects so there is a decent chance of getting some false # positives. Luckily, there is no harm in freezing an already # frozen object. # # @example EnforcedStyle: literals (default) # # bad # CONST = [1, 2, 3] # # # good # CONST = [1, 2, 3].freeze # # # good # CONST = <<~TESTING.freeze # This is a heredoc # TESTING # # # good # CONST = Something.new # # # @example EnforcedStyle: strict # # bad # CONST = Something.new # # # bad # CONST = Struct.new do # def foo # puts 1 # end # end # # # good # CONST = Something.new.freeze # # # good # CONST = Struct.new do # def foo # puts 1 # end # end.freeze
UNK UNK UNK on_comma UNK on_nl on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content # Some of these patterns may not actually return an immutable object, # but we want to consider them immutable for this cop.
