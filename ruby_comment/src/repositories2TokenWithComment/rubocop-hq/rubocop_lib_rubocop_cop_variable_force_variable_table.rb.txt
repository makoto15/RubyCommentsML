on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl def UNK on_lparen UNK on_op UNK on_rparen # frozen_string_literal: true
UNK on_const on_nl def UNK on_lparen UNK on_op UNK on_rparen on_ignored_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def invoke_hook # A VariableTable manages the lifetime of all scopes and local variables # in a program. # This holds scopes as stack structure, provides a way to add local # variables to current scope, and find local variables by considering # variable visibility of the current scope.
UNK UNK variable on_nl on_ignored_nl variable on_period UNK on_lparen node on_rparen on_nl UNK on_lparen variable on_rparen on_nl end on_nl on_ignored_nl # In this code: # # foo = 1 unless foo # # (if # (lvar :foo) nil # (lvasgn :foo # (int 1))) # # Parser knows whether the foo is a variable or method invocation. # This means that if a :lvar node is shown in AST, the variable is # assumed to be already declared, even if we haven't seen any :lvasgn # or :arg node before the :lvar node. # # We don't invoke #declare_variable here otherwise # Variable#declaration_node will be :lvar node, that is actually not. # So just skip.
UNK UNK UNK scope on_period node on_period UNK on_nl end on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen # Only block scope allows referencing outer scope variables.
