on_ignored_nl UNK on_const on_nl class on_const on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period UNK on_nl on_ignored_nl def UNK on_period UNK # frozen_string_literal: true
class on_const on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period UNK on_nl on_ignored_nl def UNK on_period UNK on_lparen comment on_rparen on_ignored_nl # Parse different formats of magic comments. # # @abstract parent of three different magic comment handlers
on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period UNK on_nl on_ignored_nl def UNK on_period UNK on_lparen comment on_rparen on_ignored_nl UNK comment on_nl # @see https://git.io/vMC1C IRB's pattern for matching magic comment tokens
def UNK on_period UNK on_lparen comment on_rparen on_ignored_nl UNK comment on_nl UNK on_const on_op on_const UNK on_const on_period UNK on_lparen # Detect magic comment format and pass it to the appropriate wrapper. # # @param comment [String] # # @return [RuboCop::MagicComment]
def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK UNK UNK UNK on_period UNK # Does the magic comment enable the frozen string literal feature. # # Test whether the frozen string literal value is `true`. Cannot # just return `frozen_string_literal` since an invalid magic comment # like `# frozen_string_literal: yes` is possible and the truthy value # `'yes'` does not actually enable the feature # # @return [Boolean]
def UNK on_nl UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK on_lparen UNK on_op UNK # Was a magic comment for the frozen string literal found? # # @return [Boolean]
def UNK on_nl UNK UNK on_lparen UNK on_op UNK on_rparen on_nl on_ignored_nl UNK UNK on_nl UNK on_tstring_beg on_tstring_content on_tstring_end UNK # Expose the `frozen_string_literal` value coerced to a boolean if possible. # # @return [Boolean] if value is `true` or `false` # @return [nil] if frozen_string_literal comment isn't found # @return [String] if comment is found but isn't true or false
def UNK on_lparen UNK on_rparen on_ignored_nl UNK UNK UNK UNK UNK UNK on_nl end on_nl on_ignored_nl class on_const on_op on_const # Match the entire comment string with a pattern and take the first capture. # # @param pattern [Regexp] # # @return [String] if pattern matched # @return [nil] otherwise
class on_const on_op on_const on_nl UNK on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_regexp_beg on_tstring_content UNK UNK # Parent to Vim and Emacs magic comment handling. # # @abstract
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_regexp_beg on_tstring_content UNK UNK UNK on_tstring_content UNK UNK on_period class on_op on_const # Find a token starting with the provided keyword and extract its value. # # @param keyword [String] # # @return [String] extracted value if it is found # @return [nil] otherwise
def UNK on_nl UNK on_lparen UNK on_period class on_op on_const on_rparen on_period UNK on_lparen UNK on_period class on_op on_const on_rparen # Individual tokens composing an editor specific comment string. # # @return [Array<String>]
class on_const on_op on_const on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period UNK on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const # Wrapper for Emacs style magic comments. # # @example Emacs style comment # comment = RuboCop::MagicComment.parse( # '# -*- encoding: ASCII-8BIT -*-' # ) # # comment.encoding # => 'ascii-8bit' # # @see https://www.gnu.org/software/emacs/manual/html_node/emacs/Specify-Coding.html # @see https://git.io/vMCXh Emacs handling in Ruby's parse.y
class on_const on_op on_const on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period UNK on_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const # Wrapper for Vim style magic comments. # # @example Vim style comment # comment = RuboCop::MagicComment.parse( # '# vim: filetype=ruby, fileencoding=ascii-8bit' # ) # # comment.encoding # => 'ascii-8bit'
def UNK on_nl UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_period UNK on_op UNK on_nl end on_nl on_ignored_nl def # For some reason the fileencoding keyword only works if there # is at least one other token included in the string. For example # # # works # # vim: foo=bar, fileencoding=ascii-8bit # # # does nothing # # vim: foo=bar, fileencoding=ascii-8bit #
def UNK UNK end on_nl end on_nl on_ignored_nl class on_const on_op on_const on_nl def UNK on_nl UNK on_lparen on_regexp_beg on_tstring_content # Vim comments cannot specify frozen string literal behavior.
class on_const on_op on_const on_nl def UNK on_nl UNK on_lparen on_regexp_beg on_tstring_content UNK on_const UNK on_tstring_content on_regexp_end on_rparen on_nl end # Wrapper for regular magic comments not bound to an editor. # # Simple comments can only specify one setting per comment. # # @example frozen string literal comments # comment1 = RuboCop::MagicComment.parse('# frozen_string_literal: true') # comment1.frozen_string_literal # => true # comment1.encoding # => nil # # @example encoding comments # comment2 = RuboCop::MagicComment.parse('# encoding: utf-8') # comment2.frozen_string_literal # => nil # comment2.encoding # => 'utf-8'
def UNK on_nl UNK on_lparen on_regexp_beg on_tstring_content UNK on_const UNK on_tstring_content on_regexp_end on_rparen on_nl end on_nl on_ignored_nl UNK on_nl on_ignored_nl # Match `encoding` or `coding`
def UNK on_nl UNK on_lparen on_regexp_beg on_tstring_content UNK on_const UNK on_tstring_content on_regexp_end on_rparen on_nl end on_nl end on_nl end on_nl # Extract `frozen_string_literal`. # # The `frozen_string_literal` magic comment only works if it # is the only text in the comment. # # Case-insensitive and dashes/underscores are acceptable. # @see https://git.io/vM7Mg
