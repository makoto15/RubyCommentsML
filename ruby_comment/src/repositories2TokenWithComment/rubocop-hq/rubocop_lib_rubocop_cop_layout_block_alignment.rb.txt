on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK # This cop checks whether the end keywords are aligned properly for do # end blocks. # # Three modes are supported through the `EnforcedStyleAlignWith` # configuration parameter: # # `start_of_block` : the `end` shall be aligned with the # start of the line where the `do` appeared. # # `start_of_line` : the `end` shall be aligned with the # start of the line where the expression started. # # `either` (which is the default) : the `end` is allowed to be in either # location. The autofixer will default to `start_of_line`. # # @example EnforcedStyleAlignWith: either (default) # # bad # # foo.bar # .each do # baz # end # # # good # # variable = lambda do |i| # i # end # # @example EnforcedStyleAlignWith: start_of_block # # bad # # foo.bar # .each do # baz # end # # # good # # foo.bar # .each do # baz # end # # @example EnforcedStyleAlignWith: start_of_line # # bad # # foo.bar # .each do # baz # end # # # good # # foo.bar # .each do # baz # end
result on_op UNK on_lparen block_node on_rparen on_nl on_ignored_nl result on_comma on_op on_op result UNK result on_period UNK on_op result on_period # Which node should we align the 'end' with?
result on_comma on_op on_op result UNK result on_period UNK on_op result on_period UNK on_nl result on_nl end on_nl on_ignored_nl def # In offense message, we want to show the assignment LHS rather than # the entire assignment
on_ignored_nl UNK on_op UNK on_tstring_content UNK on_period UNK on_lparen UNK on_period UNK on_rparen on_nl UNK on_op UNK on_period UNK on_lparen # Actually it's either do or {.
UNK on_op UNK on_tstring_content UNK on_period UNK on_lparen UNK on_period UNK on_rparen on_nl UNK on_op UNK on_period UNK on_lparen UNK # We've found that "end" is not aligned with the start node (which # can be a block, a variable assignment, etc). But we also allow # the "end" to be aligned with the start of the line where the "do" # is, which is a style some people use in multi-line chains of # blocks.
