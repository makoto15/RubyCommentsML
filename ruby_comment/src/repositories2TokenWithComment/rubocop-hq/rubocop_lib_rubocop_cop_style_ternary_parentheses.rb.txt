on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_const on_op on_const # This cop checks for the presence of parentheses around ternary # conditions. It is configurable to enforce inclusion or omission of # parentheses using `EnforcedStyle`. Omission is only enforced when # removing the parentheses won't cause a different behavior. # # `AllowSafeAssignment` option for safe assignment. # By safe assignment we mean putting parentheses around # an assignment to indicate "I know I'm using an assignment # as a condition. It's not a mistake." # # @example EnforcedStyle: require_no_parentheses (default) # # bad # foo = (bar?) ? a : b # foo = (bar.baz?) ? a : b # foo = (bar && baz) ? a : b # # # good # foo = bar? ? a : b # foo = bar.baz? ? a : b # foo = bar && baz ? a : b # # @example EnforcedStyle: require_parentheses # # bad # foo = bar? ? a : b # foo = bar.baz? ? a : b # foo = bar && baz ? a : b # # # good # foo = (bar?) ? a : b # foo = (bar.baz?) ? a : b # foo = (bar && baz) ? a : b # # @example EnforcedStyle: require_parentheses_when_complex # # bad # foo = (bar?) ? a : b # foo = (bar.baz?) ? a : b # foo = bar && baz ? a : b # # # good # foo = bar? ? a : b # foo = bar.baz? ? a : b # foo = (bar && baz) ? a : b # # @example AllowSafeAssignment: true (default) # # good # foo = (bar = baz) ? a : b # # @example AllowSafeAssignment: false # # bad # foo = (bar = baz) ? a : b #
def UNK on_lparen condition on_rparen on_ignored_nl if condition on_period UNK on_nl condition on_period UNK on_period UNK UNK on_op UNK on_op # If the condition is parenthesized we recurse and check for any # complex expressions within it.
def UNK on_lparen condition on_rparen on_ignored_nl on_const on_period UNK on_lparen condition on_period UNK on_rparen on_op on_ignored_nl UNK on_lparen condition on_rparen # Anything that is not a variable, constant, or method/.method call # will be counted as a complex expression.
def UNK on_nl on_lparen UNK on_op UNK on_rparen on_op on_ignored_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen condition on_rparen # When this cop is configured to enforce parentheses and the # `RedundantParentheses` cop is enabled, it will cause an infinite loop # as they compete to add and remove the parentheses respectively.
on_lparen child on_period UNK on_op child on_period UNK on_rparen on_op on_ignored_nl on_lparen child on_period UNK on_op child on_period UNK on_rparen # Handle English "or", e.g. 'foo or bar ? a : b'
on_lparen child on_period UNK on_op child on_period UNK on_rparen on_op on_ignored_nl on_lparen child on_period UNK on_op child on_period UNK on_rparen # Handle English "and", e.g. 'foo and bar ? a : b'
on_lparen child on_period UNK on_op child on_period UNK on_rparen on_nl end on_nl on_ignored_nl UNK on_symbeg UNK on_comma UNK on_nl UNK # Handle English "not", e.g. 'not foo ? a : b'
corrector on_period UNK on_lparen condition on_period UNK on_period end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen UNK UNK on_lparen condition on_rparen on_nl # Ruby allows no space between the question mark and parentheses. # If we remove the parentheses, we need to add a space or we'll # generate invalid code.
