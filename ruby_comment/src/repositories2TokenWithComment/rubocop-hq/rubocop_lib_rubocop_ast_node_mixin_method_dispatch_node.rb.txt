on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op UNK on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content # Common functionality for nodes that are a kind of method dispatch: # `send`, `csend`, `super`, `zsuper`, `yield`, `defined?`
def UNK on_nl UNK UNK UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK UNK UNK on_nl end # The receiving node of the method dispatch. # # @return [Node, nil] the receiver of the dispatched method or `nil`
def UNK on_nl UNK UNK UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK UNK on_op on_op UNK # The name of the dispatched method as a symbol. # # @return [Symbol] the name of the dispatched method
def UNK on_nl UNK UNK UNK on_op on_op UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl parent UNK UNK # An array containing the arguments of the dispatched method. # # @return [Array<Node>] the arguments of the dispatched method
def UNK on_nl parent UNK UNK on_nl end on_nl on_ignored_nl def UNK on_nl on_op UNK on_op UNK on_nl end on_nl # The `block` node associated with this method dispatch, if any. # # @return [BlockNode, nil] the `block` node associated with this method # call or `nil`
def UNK on_nl on_op UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op UNK on_nl end on_nl # Checks whether the dispatched method is a macro method. A macro method # is defined as a method that sits in a class, module, or block body and # has an implicit receiver. # # @note This does not include DSLs that use nested blocks, like RSpec # # @return [Boolean] whether the dispatched method is a macro method
def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl # Checks whether the dispatched method is an access modifier. # # @return [Boolean] whether the dispatched method is an access modifier
def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl # Checks whether the dispatched method is a bare access modifier that # affects all methods defined after the macro. # # @return [Boolean] whether the dispatched method is a bare # access modifier
def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_const on_period UNK on_lparen UNK # Checks whether the dispatched method is a non-bare access modifier that # affects only the method it receives. # # @return [Boolean] whether the dispatched method is a non-bare # access modifier
def UNK on_nl UNK on_op on_const on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen # Checks whether the dispatched method is a bare `private` or `protected` # access modifier that affects all methods defined after the macro. # # @return [Boolean] whether the dispatched method is a bare # `private` or `protected` access modifier
def UNK on_lparen UNK on_rparen on_ignored_nl on_op UNK on_op UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # Checks whether the name of the dispatched method matches the argument # and has an implicit receiver. # # @param [Symbol, String] name the method name to check for # @return [Boolean] whether the method name matches the argument
def UNK on_nl loc on_period UNK on_lparen on_symbeg UNK on_rparen on_op loc on_period UNK on_nl end on_nl UNK UNK UNK # Checks whether the dispatched method is a setter method. # # @return [Boolean] whether the dispatched method is a setter
def UNK on_nl loc on_period UNK on_lparen on_symbeg dot on_rparen on_op loc on_period dot on_op loc on_period dot on_period UNK # Checks whether the dispatched method uses a dot to connect the # receiver and the method name. # # This is useful for comparison operators, which can be called either # with or without a dot, i.e. `foo == bar` or `foo.== bar`. # # @return [Boolean] whether the method was called with a connecting dot
def UNK on_nl loc on_period UNK on_lparen on_symbeg dot on_rparen on_op loc on_period dot on_op loc on_period dot on_period UNK # Checks whether the dispatched method uses a double colon to connect the # receiver and the method name. # # @return [Boolean] whether the method was called with a connecting dot
def UNK on_nl loc on_period UNK on_lparen on_symbeg dot on_rparen on_op loc on_period dot on_op loc on_period dot on_period UNK # Checks whether the dispatched method uses a safe navigation operator to # connect the receiver and the method name. # # @return [Boolean] whether the method was called with a connecting dot
def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl # Checks whether the *explicit* receiver of this method dispatch is # `self`. # # @return [Boolean] whether the receiver of this method dispatch is `self`
def UNK on_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lparen on_symbeg UNK on_rparen on_op on_op # Checks whether the *explicit* receiver of this method dispatch is a # `const` node. # # @return [Boolean] whether the receiver of this method dispatch # is a `const` node
def UNK on_nl UNK on_lparen on_symbeg UNK on_rparen on_op on_op loc on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl # Checks whether the method dispatch is the implicit form of `#call`, # e.g. `foo.(bar)`. # # @return [Boolean] whether the method is the implicit form of `#call`
def UNK on_nl parent on_op UNK on_op UNK on_lparen parent on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl # Whether this method dispatch has an explicit block. # # @return [Boolean] whether the dispatched method has a block
def UNK on_nl on_const on_period UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_ignored_nl UNK # Checks whether this node is an arithmetic operation # # @return [Boolean] whether the dispatched method is an arithmetic # operation
def UNK on_nl UNK on_op on_ignored_nl UNK UNK UNK on_op UNK on_lparen on_symbeg UNK on_rparen UNK on_period UNK on_lparen on_op # Checks if this node is part of a chain of `def` modifiers. # # @example # # private def foo; end # # @return [Boolean] whether the dispatched method is a `def` modifier
def UNK on_nl UNK on_op UNK on_lparen on_symbeg UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op loc # Checks whether this is a lambda. Some versions of parser parses # non-literal lambdas as a method send. # # @return [Boolean] whether this method is a lambda
def UNK on_nl UNK on_op loc on_period UNK on_op loc on_period UNK on_period UNK on_op UNK on_tstring_content on_tstring_end on_nl end # Checks whether this is a lambda literal (stabby lambda.) # # @example # # -> (foo) { bar } # # @return [Boolean] whether this method is a lambda literal
def UNK on_nl UNK UNK UNK loc on_period UNK on_nl on_ignored_nl UNK on_op loc on_period UNK on_period UNK on_op loc # Checks whether this is a unary operation. # # @example # # -foo # # @return [Boolean] whether this method is a unary operation
def UNK on_nl UNK UNK UNK loc on_period UNK on_nl on_ignored_nl UNK on_op loc on_period UNK on_period UNK on_op loc # Checks whether this is a binary operation. # # @example # # foo + bar # # @return [Bookean] whether this method is a binary operation
def UNK on_lparen parent on_rparen on_ignored_nl parent on_period UNK on_op UNK on_lparen parent on_rparen on_nl end on_nl on_ignored_nl def UNK # Check if a node's parent is a kwbegin wrapper within a macro scope # # @param parent [Node] parent of the node being checked # # @return [Boolean] true if the parent is a kwbegin in a macro scope
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_period parent on_period UNK on_nl end on_nl on_ignored_nl UNK on_symbeg UNK UNK UNK # Check if a node does not have a parent # # @param node [Node] # # @return [Boolean] if the parent is nil
