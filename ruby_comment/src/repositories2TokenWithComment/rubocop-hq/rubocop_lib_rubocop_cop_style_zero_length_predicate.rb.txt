on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_const on_op UNK on_tstring_content UNK # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op UNK on_tstring_content UNK on_nl on_const on_op UNK on_tstring_content UNK UNK on_tstring_content UNK on_nl # This cop checks for numeric comparisons that can be replaced # by a predicate method, such as receiver.length == 0, # receiver.length > 0, receiver.length != 0, # receiver.length < 1 and receiver.size == 0 that can be # replaced by receiver.empty? and !receiver.empty?. # # @example # # bad # [1, 2, 3].length == 0 # 0 == "foobar".length # array.length < 1 # {a: 1, b: 2}.length != 0 # string.length > 0 # hash.size > 0 # # # good # [1, 2, 3].empty? # "foobar".empty? # array.empty? # !{a: 1, b: 2}.empty? # !string.empty? # !hash.empty?
UNK UNK UNK on_comma UNK on_nl on_ignored_sp on_tstring_content on_ignored_sp on_tstring_content UNK end on_nl end on_nl end on_nl end on_nl EMP # Some collection like objects in the Ruby standard library # implement `#size`, but not `#empty`. We ignore those to # reduce false positives.
