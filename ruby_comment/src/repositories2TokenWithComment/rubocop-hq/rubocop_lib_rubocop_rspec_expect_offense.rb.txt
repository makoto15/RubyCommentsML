on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl def UNK on_lparen source on_comma UNK on_op UNK on_rparen on_ignored_nl # frozen_string_literal: true
UNK on_const on_nl def UNK on_lparen source on_comma UNK on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_ignored_nl on_period # Mixin for `expect_offense` and `expect_no_offenses` # # This mixin makes it easier to specify strict offense expectations # in a declarative and visual fashion. Just type out the code that # should generate a offense, annotate code by writing '^'s # underneath each character that should be highlighted, and follow # the carets with a string (separated by a space) that is the # message of the offense. You can include multiple offenses in # one code snippet. # # @example Usage # # expect_offense(<<~RUBY) # a do # b # end.c # ^^^^^ Avoid chaining a method call on a do...end block. # RUBY # # @example Equivalent assertion without `expect_offense` # # inspect_source(<<~RUBY) # a do # b # end.c # RUBY # # expect(cop.offenses.size).to be(1) # # offense = cop.offenses.first # expect(offense.line).to be(3) # expect(offense.column_range).to be(0...5) # expect(offense.message).to eql( # 'Avoid chaining a method call on a do...end block.' # ) # # Auto-correction can be tested using `expect_correction` after # `expect_offense`. # # @example `expect_offense` and `expect_correction` # # expect_offense(<<~RUBY) # x % 2 == 0 # ^^^^^^^^^^ Replace with `Integer#even?`. # RUBY # # expect_correction(<<~RUBY) # x.even? # RUBY # # If you do not want to specify an offense then use the # companion method `expect_no_offenses`. This method is a much # simpler assertion since it just inspects the source and checks # that there were no offenses. The `expect_offense` method has # to do more work by parsing out lines that contain carets. # # If the code produces an offense that could not be auto-corrected, you can # use `expect_no_corrections` after `expect_offense`. # # @example `expect_offense` and `expect_no_corrections` # # expect_offense(<<~RUBY) # a do # b # end.c # ^^^^^ Avoid chaining a method call on a do...end block. # RUBY # # expect_no_corrections
def UNK on_lparen source on_comma UNK on_op UNK on_rparen on_ignored_nl on_const on_op on_const on_op on_const on_ignored_nl on_period UNK on_op UNK # rubocop:disable Metrics/AbcSize, Metrics/MethodLength
on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end UNK on_ivar on_nl on_ignored_nl UNK on_op on_ignored_nl on_const on_op # rubocop:enable Metrics/AbcSize, Metrics/MethodLength
on_ignored_nl UNK on_op on_ignored_nl on_const on_op on_const on_op on_const on_period UNK on_lparen on_ivar on_period UNK on_comma cop on_period UNK on_rparen # In order to print a nice diff, e.g. what source got corrected to, # we need to run the actual corrections
UNK on_const on_nl on_const on_op UNK on_tstring_content UNK on_period UNK on_nl on_ignored_nl def UNK on_period UNK on_lparen UNK on_rparen on_ignored_nl # Parsed representation of code annotated with the `^^^ Message` style
def UNK on_period UNK on_lparen UNK on_rparen on_ignored_nl source on_op UNK UNK on_nl annotations on_op UNK UNK on_nl on_ignored_nl UNK # @param annotated_source [String] string passed to the matchers # # Separates annotation lines from source lines. Tracks the real # source line number that each annotation corresponds to. # # @return [AnnotatedSource]
def UNK on_lparen lines on_comma annotations on_rparen on_ignored_nl on_ivar on_op lines on_period UNK on_nl on_ivar on_op annotations on_period UNK on_period # @param lines [Array<String>] # @param annotations [Array<(Integer, String)>] # each entry is the annotated line number and the annotation text # # @note annotations are sorted so that reconstructing the annotation # text via {#to_s} is deterministic
def UNK on_nl UNK on_op lines on_period UNK on_nl on_ignored_nl annotations on_period UNK UNK on_op UNK on_comma UNK on_op on_ignored_nl # Construct annotated source string (like what we parse) # # Reconstruct a deterministic annotated source string. This is # useful for eliminating semantically irrelevant annotation # ordering differences. # # @example standardization # # source1 = AnnotatedSource.parse(<<-RUBY) # line1 # ^ Annotation 1 # ^^ Annotation 2 # RUBY # # source2 = AnnotatedSource.parse(<<-RUBY) # line1 # ^^ Annotation 2 # ^ Annotation 1 # RUBY # # source1.to_s == source2.to_s # => true # # @return [String]
def UNK on_nl lines on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_ignored_nl UNK # Return the plain source code without annotations # # @return [String]
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op on_ignored_nl UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_op on_tstring_beg # Annotate the source code with the RuboCop offenses provided # # @param offenses [Array<RuboCop::Cop::Offense>] # # @return [self]
