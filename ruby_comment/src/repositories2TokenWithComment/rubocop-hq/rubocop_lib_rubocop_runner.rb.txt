on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const UNK on_const on_op on_const on_nl UNK on_symbeg offenses # frozen_string_literal: true
UNK on_const UNK on_const on_op on_const on_nl UNK on_symbeg offenses on_nl on_ignored_nl def UNK on_lparen path on_comma offenses on_rparen on_ignored_nl # This class handles the processing of files, which includes dealing with # formatters and letting cops inspect the files.
UNK on_const on_op on_const on_nl UNK on_symbeg offenses on_nl on_ignored_nl def UNK on_lparen path on_comma offenses on_rparen on_ignored_nl UNK on_tstring_beg # rubocop:disable Metrics/ClassLength # An exception indicating that the inspection loop got stuck correcting # offenses back and forth.
def UNK on_lparen target_files on_rparen on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end if on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl on_const on_period UNK # Warms up the RuboCop cache by forking a suitable number of rubocop # instances that each inspects its allotted group of files.
on_const on_period UNK on_lparen on_ivar on_comma on_ivar on_lbracket on_symbeg UNK on_rbracket on_rparen if files on_period UNK on_op UNK on_op UNK # OPTIMIZE: Calling `ResultCache.cleanup` takes time. This optimization # mainly targets editors that integrates RuboCop. When RuboCop is run # by an editor, it should be inspecting only one file.
UNK on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_op offenses on_period UNK on_nl UNK on_ignored_nl UNK on_op UNK on_nl end on_nl # If we're running --auto-correct and the cache says there are # offenses, we need to actually inspect the file. If the cache shows no # offenses, we're good.
UNK on_comma UNK on_op UNK on_lparen file on_comma on_ignored_nl UNK on_lparen file on_rparen on_rparen on_nl UNK on_op offenses on_nl end # Do one extra inspection loop if any redundant disables were # removed. This is done in order to find rubocop:enable directives that # have now become useless.
on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_op on_ignored_nl on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl end on_nl on_ignored_nl def UNK # When running --auto-gen-config, there's some processing done in the # cops related to calculating the Max parameters for Metrics cops. We # need to do that processing and cannot use caching.
on_op on_ivar on_lbracket on_symbeg UNK on_rbracket on_nl end on_nl on_ignored_nl def UNK on_lparen cache on_comma offenses on_rparen on_ignored_nl return UNK # We can't cache results from code which is piped in to stdin
return if UNK on_period UNK on_op UNK on_period UNK on_nl on_ignored_nl cache on_period UNK on_lparen offenses on_rparen on_nl end on_nl # Caching results when a cop has crashed would prevent the crash in the # next run, since the cop would not be called then. We want crashes to # show up the same in each run.
UNK on_lparen processed_source on_comma offenses on_rparen do on_ignored_nl offenses on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl UNK on_comma UNK # When running with --auto-correct, we need to inspect the file (which # includes writing a corrected version of it) until no more corrections # are made. This is because automatic corrections can introduce new # offenses. In the normal case the loop is only executed once.
offenses on_period UNK on_lparen on_op on_symbeg UNK on_rparen on_nl UNK on_comma UNK on_op UNK on_lparen processed_source on_rparen on_nl offenses on_period # The offenses that couldn't be corrected will be found again so we # only keep the corrected ones in order to avoid duplicate reporting.
UNK UNK UNK on_nl on_ignored_nl processed_source on_op UNK on_lparen file on_rparen on_nl end on_nl on_ignored_nl on_lbracket processed_source on_comma offenses on_rbracket # We have to reprocess the source to pickup the changes. Since the # change could (theoretically) introduce parsing errors, we break the # loop if we find any.
on_ivar on_op on_lbracket on_rbracket on_nl on_ignored_nl UNK on_op UNK on_nl on_ignored_nl UNK do on_ignored_nl UNK on_lparen source on_comma offenses on_rparen # Keep track of the state of the source. If a cop modifies the source # and another cop undoes it producing identical source we have an # infinite loop.
UNK on_op UNK on_nl on_ignored_nl UNK do on_ignored_nl UNK on_lparen source on_comma offenses on_rparen on_nl on_ignored_nl if on_lparen UNK on_op # It is also possible for a cop to keep adding indefinitely to a file, # making it bigger and bigger. If the inspection loop runs for an # excessively high number of iterations, this is likely happening.
def UNK on_lparen processed_source on_comma offenses on_rparen on_ignored_nl UNK on_op processed_source on_period UNK on_nl on_ignored_nl UNK on_const on_period new on_lparen # Check whether a run created source identical to a previous run, which # means that we definitely have an infinite loop.
return UNK UNK on_lparen config on_rparen on_nl on_ignored_nl cop_classes on_period UNK on_lbrace on_op cop on_op config on_period UNK on_lparen cop # use only cops that link to a style guide if requested
return UNK if UNK on_period UNK on_nl on_ignored_nl return UNK if on_ivar on_lbracket on_symbeg UNK on_rbracket on_op on_symbeg UNK on_nl # For :autocorrect level, any offense - corrected or not - is a failure.
def UNK on_lparen config on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace on_nl on_ivar on_lbracket config on_period UNK on_rbracket on_op on_ignored_nl on_const # A Cop::Team instance is stateful and may change when inspecting. # The "standby" team for a given config is an initialized but # otherwise dormant team that can be used for config- and option- # level caching in ResultCache.
