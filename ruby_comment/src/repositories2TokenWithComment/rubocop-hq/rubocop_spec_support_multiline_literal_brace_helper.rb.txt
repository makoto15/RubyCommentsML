on_ignored_nl UNK UNK on_nl UNK UNK on_lparen UNK UNK on_op args UNK UNK on_rparen on_ignored_nl args on_op UNK UNK args # frozen_string_literal: true
UNK UNK on_lparen UNK UNK on_op args UNK UNK on_rparen on_ignored_nl args on_op UNK UNK args UNK UNK on_nl on_ignored_nl # Construct the source code for the braces. For instance, for an array # the `open` brace would be `[` and the `close` brace would be `]`, so # you could construct the following: # # braces(true, 'a', 'b', 'c', false) # # [ # line break indicated by `true` as the first argument. # a, # b, # c] # no line break indicated by `false` as the last argument. # # This method also supports multi-line arguments. For example: # # braces(true, 'a', ['{', 'foo: bar', '}'], true) # # [ # line break indicated by `true` as the first argument. # a, # { # foo: bar # } # line break indicated by `true` as the last argument. # ]
UNK UNK on_lparen on_op args on_rparen on_ignored_nl on_lparen UNK on_op UNK on_lparen on_op args on_rparen on_op on_tstring_beg UNK on_tstring_end on_op # Construct a piece of source code for brace layout testing. This farms # out most of the work to `#braces` but it also includes a prefix and suffix.
