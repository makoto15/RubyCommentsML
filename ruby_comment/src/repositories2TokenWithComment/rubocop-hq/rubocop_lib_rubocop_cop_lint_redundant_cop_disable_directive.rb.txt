on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op # The Lint/RedundantCopDisableDirective cop needs to be disabled so as # to be able to provide a (bad) example of a redundant disable. # rubocop:disable Lint/RedundantCopDisableDirective
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl def UNK on_lparen offenses # This cop detects instances of rubocop:disable comments that can be # removed without causing any offenses to be reported. It's implemented # as a cop in that it inherits from the Cop base class and calls # add_offense. The unusual part of its implementation is that it doesn't # have any on_* methods or an investigate method. This means that it # doesn't take part in the investigation phase when the other cops do # their work. Instead, it waits until it's called in a later stage of the # execution. The reason it can't be implemented as a normal cop is that # it depends on the results of all other cops to do its work. # # # @example # # bad # # rubocop:disable Layout/LineLength # x += 1 # # rubocop:enable Layout/LineLength # # # good # x += 1
on_ignored_nl range on_op if range on_period UNK on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl UNK on_lparen range on_rparen on_nl # Ranges are sorted by position.
UNK on_op range on_period UNK on_nl range on_op UNK on_lparen on_label range on_comma on_ignored_nl on_label on_symbeg UNK on_comma on_ignored_nl on_label # Eat the entire comment, the preceding space, and the preceding # newline if there is one.
on_label UNK on_period UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen range on_comma ranges on_rparen on_ignored_nl if UNK on_lparen # Special for a comment that # begins the file: remove # the newline at the end.
if UNK on_lparen ranges on_period UNK on_rparen on_op UNK on_lparen ranges on_comma range on_rparen on_nl range on_op UNK on_lparen on_label # Is there any cop between this one and the end of the line, which # is NOT being removed?
range on_op UNK on_lparen on_label range on_comma on_label on_symbeg UNK on_rparen on_nl range on_op UNK on_lparen range on_comma on_symbeg UNK # Eat the comma on the left.
UNK on_lparen on_label range on_comma on_ignored_nl on_label on_symbeg UNK on_comma on_ignored_nl on_label UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # Eat following spaces up to EOL, but not the newline itself.
UNK on_op comments on_period UNK do on_op c on_op on_ignored_nl c on_period UNK on_period line on_op range on_period UNK on_op # If a cop is disabled in a range that begins on the same line as # the end of the previous range, it means that the cop was # already disabled by an earlier comment. So it's redundant # whether there are offenses or not.
on_op UNK on_lparen c on_rparen on_nl end on_nl UNK UNK if UNK on_nl end on_nl end on_nl on_ignored_nl def UNK # Comments disabling all cops don't count since it's reasonable # to disable a few select cops first and then all cops further # down in the code.
if on_lparen UNK on_period UNK on_op on_ignored_nl line_range on_period UNK on_op UNK on_period UNK on_rparen on_op on_ignored_nl offenses on_period UNK # If there's a disable all comment followed by a comment # specifically disabling `cop`, we don't report the `all` # comment. If the disable all comment is truly redundant, we will # detect that when examining the comments of another cop, and we # get the full line range for the disable all.
