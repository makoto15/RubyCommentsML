on_ignored_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl UNK on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl UNK on_const on_nl UNK on_const on_nl on_const on_op # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_nl on_const on_op on_const on_period new on_lparen on_const on_rparen on_nl on_ignored_nl UNK on_const on_nl on_const # rubocop:disable Metrics/ClassLength, Metrics/CyclomaticComplexity
UNK on_const on_nl on_const on_op on_const on_period new on_lparen on_const on_rparen on_nl on_ignored_nl UNK on_const on_nl on_const on_op on_regexp_beg on_tstring_content # This class performs a pattern-matching operation on an AST node. # # Initialize a new `NodePattern` with `NodePattern.new(pattern_string)`, then # pass an AST node to `NodePattern#match`. Alternatively, use one of the class # macros in `NodePattern::Macros` to define your own pattern-matching method. # # If the match fails, `nil` will be returned. If the match succeeds, the # return value depends on whether a block was provided to `#match`, and # whether the pattern contained any "captures" (values which are extracted # from a matching AST.) # # - With block: #match yields the captures (if any) and passes the return # value of the block through. # - With no block, but one capture: the capture is returned. # - With no block, but multiple captures: captures are returned as an array. # - With no block and no captures: #match returns `true`. # # ## Pattern string format examples # # ':sym' # matches a literal symbol # '1' # matches a literal integer # 'nil' # matches a literal nil # 'send' # matches (send ...) # '(send)' # matches (send) # '(send ...)' # matches (send ...) # '(op-asgn)' # node types with hyphenated names also work # '{send class}' # matches (send ...) or (class ...) # '({send class})' # matches (send) or (class) # '(send const)' # matches (send (const ...)) # '(send _ :new)' # matches (send <anything> :new) # '(send $_ :new)' # as above, but whatever matches the $_ is captured # '(send $_ $_)' # you can use as many captures as you want # '(send !const ...)' # ! negates the next part of the pattern # '$(send const ...)' # arbitrary matching can be performed on a capture # '(send _recv _msg)' # wildcards can be named (for readability) # '(send ... :new)' # you can match against the last children # '(array <str sym>)' # you can match children in any order. This # # would match `['x', :y]` as well as `[:y, 'x'] # '(_ <str sym ...>)' # will match if arguments have at least a `str` and # # a `sym` node, but can have more. # '(array <$str $_>)' # captures are in the order of the pattern, # # irrespective of the actual order of the children # '(array int*)' # will match an array of 0 or more integers # '(array int ?)' # will match 0 or 1 integer. # # Note: Space needed to distinguish from int? # '(array int+)' # will match an array of 1 or more integers # '(array (int $_)+)' # as above and will capture the numbers in an array # '(send $...)' # capture all the children as an array # '(send $... int)' # capture all children but the last as an array # '(send _x :+ _x)' # unification is performed on named wildcards # # (like Prolog variables...) # # (#== is used to see if values unify) # '(int odd?)' # words which end with a ? are predicate methods, # # are are called on the target to see if it matches # # any Ruby method which the matched object supports # # can be used # # if a truthy value is returned, the match succeeds # '(int [!1 !2])' # [] contains multiple patterns, ALL of which must # # match in that position # # in other words, while {} is pattern union (logical # # OR), [] is intersection (logical AND) # '(send %1 _)' # % stands for a parameter which must be supplied to # # #match at matching time # # it will be compared to the corresponding value in # # the AST using #== # # a bare '%' is the same as '%1' # # the number of extra parameters passed to #match # # must equal the highest % value in the pattern # # for consistency, %0 is the 'root node' which is # # passed as the 1st argument to #match, where the # # matching process starts # '^^send' # each ^ ascends one level in the AST # # so this matches against the grandparent node # '`send' # descends any number of level in the AST # # so this matches against any descendant node # '#method' # we call this a 'funcall'; it calls a method in the # # context where a pattern-matching method is defined # # if that returns a truthy value, the match succeeds # 'equal?(%1)' # predicates can be given 1 or more extra args # '#method(%0, 1)' # funcalls can also be given 1 or more extra args # # You can nest arbitrarily deep: # # # matches node parsed from 'Const = Class.new' or 'Const = Module.new': # '(casgn nil? :Const (send (const nil? {:Class :Module}) :new))' # # matches a node parsed from an 'if', with a '==' comparison, # # and no 'else' branch: # '(if (send _ :== _) _ nil?)' # # Note that patterns like 'send' are implemented by calling `#send_type?` on # the node being matched, 'const' by `#const_type?`, 'int' by `#int_type?`, # and so on. Therefore, if you add methods which are named like # `#prefix_type?` to the AST node class, then 'prefix' will become usable as # a pattern. # # Also note that if you need a "guard clause" to protect against possible nils # in a certain place in the AST, you can do it like this: `[!nil <pattern>]` # # The compiler code is very simple; don't be afraid to read through it!
on_const on_op on_const on_period new on_lparen on_const on_rparen on_nl on_ignored_nl UNK on_const on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period freeze # @private
UNK on_const on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period freeze on_nl on_const on_op on_regexp_beg on_tstring_content on_regexp_end on_period freeze on_nl on_const # @private # Builds Ruby code which implements a pattern
on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_embexpr_beg on_const on_embexpr_end on_tstring_content on_tstring_end on_nl on_const on_op on_tstring_beg on_embexpr_beg on_const # Placeholders while compiling, see with_..._context methods
on_ivar on_op on_int on_ivar on_op on_lbrace on_rbrace on_ivar on_op on_int UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK # avoid name clashes between temp variables
on_ivar on_op on_lbrace on_rbrace on_ivar on_op on_int UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen # number of captures seen
on_ivar on_op on_int UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op on_const # named wildcard -> temp variable
UNK on_lparen UNK on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl on_ivar on_op on_const on_period tokens on_lparen # highest % (param) number seen
def compile_expr on_lparen token on_op tokens on_period UNK on_rparen on_ignored_nl UNK token on_nl when on_tstring_beg on_tstring_content on_tstring_end then UNK on_nl # rubocop:disable Metrics/MethodLength, Metrics/AbcSize
UNK token on_nl when on_tstring_beg on_tstring_content on_tstring_end then UNK on_nl when on_tstring_beg on_tstring_content on_tstring_end then UNK on_nl when on_tstring_beg on_tstring_content # read a single pattern-matching expression from the token stream, # return Ruby code which performs the corresponding matching operation # # the 'pattern-matching' expression may be a composite which # contains an arbitrary number of sub-expressions, but that composite # must all have precedence higher or equal to that of `&&` # # Expressions may use placeholders like: # CUR_NODE: Ruby code that evaluates to an AST node # CUR_ELEMENT: Either the node or the type if in first element of # a sequence (aka seq_head, e.g. "(seq_head first_node_arg ...")
on_ignored_nl def UNK on_lparen UNK on_comma what on_rparen on_ignored_nl return UNK UNK on_comma UNK on_comma what unless UNK on_nl on_ignored_nl # rubocop:enable Metrics/MethodLength, Metrics/AbcSize
UNK on_const on_op on_const on_nl def UNK on_lparen compiler on_comma on_op UNK on_rparen on_ignored_nl on_ivar on_comma on_ivar on_op UNK on_period # @private # Builds Ruby code for a sequence # (head *first_terms variadic_term *last_terms)
range on_op on_int on_op range on_period end if range on_period UNK on_op on_const on_nl on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content # Consider ($...) like (_ $...):
def UNK on_lparen UNK on_op nil on_rparen on_ignored_nl UNK on_op UNK on_op nil on_nl UNK on_op on_lbracket on_rbracket on_nl UNK # rubocop:disable Metrics/AbcSize # rubocop:disable Metrics/MethodLength
on_ignored_nl def UNK on_lparen enum on_comma what on_rparen on_ignored_nl return UNK UNK on_comma enum on_comma what unless UNK on_nl on_ignored_nl # rubocop:enable Metrics/MethodLength # rubocop:enable Metrics/AbcSize
def UNK on_lparen enum on_rparen on_ignored_nl on_ignored_nl return UNK UNK on_comma enum unless UNK on_nl on_ignored_nl new_unify_intersection on_op nil on_nl # rubocop:disable Metrics/MethodLength, Metrics/AbcSize
on_ignored_nl return UNK UNK on_comma enum unless UNK on_nl on_ignored_nl new_unify_intersection on_op nil on_nl UNK on_op on_lbracket on_rbracket on_nl UNK # We need to reset @unify before each branch is processed. # Moreover we need to keep track of newly encountered wildcards. # Var `new_unify_intersection` will hold those that are encountered # in all branches; these are not a problem. # Var `partial_unify` will hold those encountered in only a subset # of the branches; these can't be used outside of the union.
new_unify_intersection on_op UNK on_nl else on_ignored_nl UNK on_op new_unify_intersection on_op UNK on_nl new_unify_intersection on_op UNK on_nl UNK on_op UNK on_op # First iteration
on_ignored_nl UNK on_lparen on_op UNK on_rparen on_nl on_ignored_nl UNK on_nl end on_nl on_ignored_nl def UNK on_nl enum on_op UNK on_lparen # At this point, all members of `new_unify_intersection` can be used # for unification outside of the union, but partial_unify may not
on_ignored_nl def UNK on_nl enum on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl enum on_op UNK # rubocop:enable Metrics/MethodLength, Metrics/AbcSize
enum on_op UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen on_nl enum on_op UNK on_lparen enum on_rparen on_nl # we need to ensure that each branch of the {} contains the same # number of captures (since only one branch of the {} can actually # match, the same variables are used to hold the captures for each # branch)
on_tstring_beg on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg UNK on_lparen name on_rparen on_embexpr_end on_tstring_end on_nl else on_ignored_nl n on_op on_ivar on_lbracket name # we have already seen a wildcard with this name before # so the value it matched the first time will already be stored # in a temp. check if this value matches the one stored in the temp
on_tstring_beg on_tstring_content on_embexpr_beg n on_embexpr_end on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_content on_tstring_end on_tstring_beg on_embexpr_beg n on_embexpr_end on_tstring_content on_embexpr_beg n on_embexpr_end on_tstring_content # double assign to avoid "assigned but unused variable"
args on_op UNK on_lparen tokens on_rparen on_nl predicate on_op predicate on_lbracket on_int on_op on_op on_int on_rbracket on_tstring_beg on_embexpr_beg on_const on_embexpr_end # is there an arglist?
on_tstring_beg on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg predicate on_embexpr_end on_tstring_content on_embexpr_beg args on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_embexpr_end on_tstring_content # drop the trailing (
method on_op method on_lbracket on_int on_op on_op on_int on_rbracket if method on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen args on_op # call a method in the context which this pattern-matching # code is used in. pass target value as an argument
if method on_period UNK on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen args on_op UNK on_lparen tokens on_rparen on_nl method on_op method on_lbracket # drop the leading #
args on_op UNK on_lparen tokens on_rparen on_nl method on_op method on_lbracket on_int on_op on_op on_int on_rbracket on_tstring_beg on_embexpr_beg method on_embexpr_end # is there an arglist?
on_tstring_beg on_embexpr_beg method on_embexpr_end on_tstring_content on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg args on_period join on_lparen on_tstring_beg on_tstring_content on_tstring_end on_rparen on_embexpr_end on_tstring_content # drop the trailing (
else on_ignored_nl on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_tstring_beg on_tstring_content on_embexpr_beg UNK on_embexpr_end on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def # Circumvent https://github.com/jruby/jruby/issues/5710
end on_nl on_ignored_nl def UNK on_lparen on_op block on_rparen on_ignored_nl UNK on_op block on_period UNK on_period map on_lbrace on_op UNK # Nicer indent for debugging
on_ignored_nl def UNK on_lparen code on_comma UNK on_rparen on_ignored_nl UNK on_lparen code on_comma on_tstring_beg on_embexpr_beg on_const on_embexpr_end on_tstring_content on_embexpr_beg UNK # with_<...>_context methods are used whenever the context, # i.e the current node or the current element can be determined.
UNK on_const on_nl def UNK on_lparen method_name on_comma UNK on_rparen on_ignored_nl compiler on_op on_const on_period new on_lparen UNK on_comma on_tstring_beg # Helpers for defining methods based on a pattern string
def UNK on_lparen method_name on_comma UNK on_rparen on_ignored_nl compiler on_op on_const on_period new on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Define a method which applies a pattern to an AST node # # The new method will return nil if the node does not match # If the node matches, and a block is provided, the new method will # yield to the block (passing any captures as block arguments). # If the node matches, and no block is provided, the new method will # return the captures, or `true` if there were none.
def UNK on_lparen method_name on_comma UNK on_rparen on_ignored_nl compiler on_op on_const on_period new on_lparen UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_rparen # Define a method which recurses over the descendants of an AST node, # checking whether any of them match the provided pattern # # If the method name ends with '?', the new method will return `true` # as soon as it finds a descendant which matches. Otherwise, it will # yield all descendants which match.
UNK on_lparen pattern on_rparen on_nl UNK on_lparen on_op args on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen pattern on_rparen on_ignored_nl # If we're here, it's because the singleton method has not been defined, # either because we've been dup'ed or serialized through YAML
def UNK on_period UNK on_lparen UNK on_comma on_op block on_rparen on_ignored_nl return UNK on_lparen UNK on_comma UNK on_rparen unless UNK # Yields its argument and any descendants, depth-first. #
