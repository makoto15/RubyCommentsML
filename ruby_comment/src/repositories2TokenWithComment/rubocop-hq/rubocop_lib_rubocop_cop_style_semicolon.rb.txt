on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op UNK UNK UNK on_nl on_ignored_nl def UNK on_lparen UNK # This cop checks for multiple expressions placed on the same line. # It also checks for lines terminated with a semicolon. # # This cop has `AllowAsExpressionSeparator` configuration option. # It allows `;` to separate several expressions on the same line. # # @example # # bad # foo = 1; bar = 2; # baz = 3; # # # good # foo = 1 # bar = 2 # baz = 3 # # @example AllowAsExpressionSeparator: false (default) # # bad # foo = 1; bar = 2 # # @example AllowAsExpressionSeparator: true # # good # foo = 1; bar = 2
UNK on_op UNK on_period UNK on_lparen on_op UNK UNK on_rparen on_nl UNK on_op UNK on_period UNK on_lparen on_op UNK UNK # create a map matching lines to the number of expressions on them
UNK UNK UNK on_period UNK on_op UNK on_nl on_ignored_nl column on_op UNK UNK line on_op UNK UNK on_period UNK on_lparen # Every line with more than one expression on it is a # potential offense
column on_op UNK UNK line on_op UNK UNK on_period UNK on_lparen UNK UNK UNK on_rparen on_nl on_ignored_nl UNK UNK column # TODO: Find the correct position of the semicolon. We don't know # if the first semicolon on the line is a separator of # expressions. It's just a guess.
UNK on_lparen UNK on_op range on_op UNK on_comma UNK range on_rparen on_nl end on_nl end on_nl end on_nl end on_nl # Don't attempt to autocorrect if semicolon is separating statements # on the same line
