on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl on_const on_op UNK on_ignored_nl on_label # frozen_string_literal: true
UNK on_const on_op on_const on_nl on_const on_op UNK on_ignored_nl on_label on_symbeg UNK on_comma on_ignored_nl on_label on_symbeg UNK on_comma on_ignored_nl on_label # Checks if the code style follows the ExpectedOrder configuration: # # `Categories` allows us to map macro names into a category. # # Consider an example of code style that covers the following order: # - Module inclusion (include, prepend, extend) # - Constants # - Associations (has_one, has_many) # - Public attribute macros (attr_accessor, attr_writer, attr_reader) # - Other macros (validates, validate) # - Public class methods # - Initializer # - Public instance methods # - Protected attribute macros (attr_accessor, attr_writer, attr_reader) # - Protected instance methods # - Private attribute macros (attr_accessor, attr_writer, attr_reader) # - Private instance methods # # You can configure the following order: # # ```yaml # Layout/ClassStructure: # ExpectedOrder: # - module_inclusion # - constants # - association # - public_attribute_macros # - public_delegate # - macros # - public_class_methods # - initializer # - public_methods # - protected_attribute_macros # - protected_methods # - private_attribute_macros # - private_delegate # - private_methods # ``` # # Instead of putting all literals in the expected order, is also # possible to group categories of macros. Visibility levels are handled # automatically. # # ```yaml # Layout/ClassStructure: # Categories: # association: # - has_many # - has_one # attribute_macros: # - attr_accessor # - attr_reader # - attr_writer # macros: # - validates # - validate # module_inclusion: # - include # - prepend # - extend # ``` # # @example # # bad # # Expect extend be before constant # class Person < ApplicationRecord # has_many :orders # ANSWER = 42 # # extend SomeModule # include AnotherModule # end # # # good # class Person # # extend and include go first # extend SomeModule # include AnotherModule # # # inner classes # CustomError = Class.new(StandardError) # # # constants are next # SOME_CONSTANT = 20 # # # afterwards we have public attribute macros # attr_reader :name # # # followed by other macros (if any) # validates :name # # # then we have public delegate macros # delegate :to_s, to: :name # # # public class methods are next in line # def self.some_method # end # # # initialization goes between class methods and instance methods # def initialize # end # # # followed by other public instance methods # def some_method # end # # # protected attribute macros and methods go next # protected # # attr_reader :protected_name # # def some_protected_method # end # # # private attribute macros, delegate macros and methods # # are grouped near the end # private # # attr_reader :private_name # # delegate :some_private_delegate, to: :name # # def some_private_method # end # end # # @see https://rubystyle.guide#consistent-classes
def UNK on_lparen class_node on_rparen on_ignored_nl previous on_op on_op on_int on_nl UNK on_lparen class_node on_rparen do on_op node on_comma UNK # Validates code style on class declaration. # Add offense when find a node out of expected order.
def UNK on_lparen node on_rparen on_ignored_nl UNK on_op UNK on_lparen node on_rparen on_nl previous on_op UNK on_lparen node on_rparen on_period # Autocorrect by swapping between two nodes autocorrecting them
def UNK on_lparen node on_rparen on_ignored_nl UNK node on_period UNK UNK node on_period UNK on_lparen on_symbeg UNK on_rparen on_nl on_ignored_nl # Classifies a node to match with something in the {expected_order} # @param node to be analysed # @return String when the node type is a `:block` then # {classify} recursively with the first children # @return String when the node type is a `:send` then {find_category} # by method name # @return String otherwise trying to {humanize_node} of the current node
def UNK on_lparen node on_rparen on_ignored_nl UNK on_op node on_period UNK on_period UNK on_nl UNK on_comma on_op UNK on_period UNK # Categorize a node according to the {expected_order} # Try to match {categories} values against the node's method_name given # also its visibility. # @param node to be analysed. # @return [String] with the key category or the `method_name` as string
def UNK on_lparen node on_rparen on_ignored_nl UNK on_op on_const on_op on_lbracket UNK on_lparen node on_rparen on_rbracket on_nl UNK on_op UNK # Navigate to find the last protected method
def UNK on_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lbracket on_tstring_beg on_tstring_content # Load expected order from `ExpectedOrder` config. # Define new terms in the expected order by adding new {categories}.
def UNK on_nl UNK on_lbracket on_tstring_beg on_tstring_content on_tstring_end on_rbracket on_nl end on_nl end on_nl end on_nl end on_nl end on_nl # Setting categories hash allow you to group methods in group to match # in the {expected_order}.
