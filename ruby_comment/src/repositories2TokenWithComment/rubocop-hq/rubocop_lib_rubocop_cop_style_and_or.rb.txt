on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl def # This cop checks for uses of `and` and `or`, and suggests using `&&` and # `||` instead. It can be configured to check only in conditions or in # all contexts. # # @example EnforcedStyle: always (default) # # bad # foo.save and return # # # bad # if foo and bar # end # # # good # foo.save && return # # # good # if foo && bar # end # # @example EnforcedStyle: conditionals # # bad # if foo and bar # end # # # good # foo.save && return # # # good # foo.save and return # # # good # if foo && bar # end
def UNK on_lparen node on_comma UNK on_comma corrector on_rparen on_ignored_nl if node on_period UNK on_nl return UNK UNK on_period UNK # ! is a special case: # 'x and !obj.method arg' can be auto-corrected if we # recurse down a level and add parens to 'obj.method arg' # however, 'not x' also parses as (send x :!)
UNK on_op UNK UNK UNK on_tstring_content UNK on_period UNK on_lparen node on_period UNK on_rparen on_nl UNK on_lparen UNK on_comma UNK # Increment position of parenthesis, unless message is a predicate # method followed by a non-whitespace char (e.g. is_a?String).
