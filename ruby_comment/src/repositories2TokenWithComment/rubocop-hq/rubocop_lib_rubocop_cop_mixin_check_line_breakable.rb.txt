on_ignored_nl UNK UNK on_nl UNK UNK on_nl UNK UNK on_nl def UNK on_lparen node on_comma max on_rparen on_ignored_nl if node # frozen_string_literal: true
UNK UNK on_nl def UNK on_lparen node on_comma max on_rparen on_ignored_nl if node on_period UNK on_nl args on_op UNK on_lparen # This mixin detects collections that are safe to "break" # by inserting new lines. This is useful for breaking # up long lines. # # Let's look at hashes as an example: # # We know hash keys are safe to break across lines. We can add # linebreaks into hashes on lines longer than the specified maximum. # Then in further passes cops can clean up the multi-line hash. # For example, say the maximum line length is as indicated below: # # | # v # {foo: "0000000000", bar: "0000000000", baz: "0000000000"} # # In a LineLength autocorrection pass, a line is added before # the first key that exceeds the column limit: # # {foo: "0000000000", bar: "0000000000", # baz: "0000000000"} # # In a MultilineHashKeyLineBreaks pass, lines are inserted # before all keys: # # {foo: "0000000000", # bar: "0000000000", # baz: "0000000000"} # # Then in future passes FirstHashElementLineBreak, # MultilineHashBraceLayout, and TrailingCommaInHashLiteral will # manipulate as well until we get: # # { # foo: "0000000000", # bar: "0000000000", # baz: "0000000000", # } # # (Note: Passes may not happen exactly in this sequence.)
return true if UNK on_lparen node on_rparen on_nl on_ignored_nl return true if UNK on_lparen node on_rparen on_nl on_ignored_nl UNK on_nl # If there's a containing breakable collection on the same # line, we let that one get broken first. In a separate pass, # this one might get broken as well, but to avoid conflicting # or redundant edits, we only mark one offense at a time.
UNK on_op node on_period UNK on_period UNK on_nl on_ignored_nl UNK on_op elements on_period UNK on_op on_int on_nl on_ignored_nl UNK on_op # For simplicity we only want to insert breaks in normal # hashes wrapped in a set of curly braces like {foo: 1}. # That is, not a kwargs hash. For method calls, this ensures # the method call is made with parens.
UNK on_op elements on_period UNK on_op on_int on_nl on_ignored_nl UNK on_op UNK on_nl end on_nl on_ignored_nl def UNK on_lparen node # If the call has a second argument, we can insert a line # break before the second argument and the rest of the # argument will get auto-formatted onto separate lines # by other cops.
UNK if ancestor on_period first_line on_op node on_period first_line on_nl on_ignored_nl if ancestor on_period UNK on_op ancestor on_period UNK on_nl # Ignore ancestors on different lines.
if on_lparen UNK on_op args on_period UNK on_rparen on_nl args on_op args on_period UNK on_lparen args on_period UNK on_period children # If there is a trailing hash arg without explicit braces, like this: # # method(1, 'key1' => value1, 'key2' => value2) # # ...then each key/value pair is treated as a method 'argument' # when determining where line breaks should appear.
