on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_op on_const on_op on_const UNK on_const on_op on_const on_op # frozen_string_literal: true
UNK on_const on_op on_const on_op on_const on_op on_const UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_nl # `RuboCop::AST::Node` is a subclass of `Parser::AST::Node`. It provides # access to parent nodes and an object-oriented way to traverse an AST with # the power of `Enumerable`. # # It has predicate methods for every node type, like this: # # @example # node.send_type? # Equivalent to: `node.type == :send` # node.op_asgn_type? # Equivalent to: `node.type == :op_asgn` # # # Non-word characters (other than a-zA-Z0-9_) in type names are omitted. # node.defined_type? # Equivalent to: `node.type == :defined?` # # # Find the first lvar node under the receiver node. # lvar_node = node.each_descendant.find(&:lvar_type?) #
UNK on_const on_op on_const on_op on_const on_nl UNK on_const on_op on_const on_nl on_ignored_nl on_const on_op on_qsymbols_beg on_tstring_content on_words_sep on_tstring_content on_words_sep # rubocop:disable Metrics/ClassLength
on_const on_op on_qsymbols_beg on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_tstring_end on_period freeze on_nl # <=> isn't included here, because it doesn't return a boolean.
def UNK on_lparen type on_comma children on_op on_lbracket on_rbracket on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl on_ivar on_op on_lbrace on_rbrace # @see https://www.rubydoc.info/gems/ast/AST/Node:initialize
UNK on_nl on_ignored_nl UNK do on_op UNK on_op on_ignored_nl UNK on_period parent on_op self unless UNK on_period UNK on_nl end # ::AST::Node#initialize freezes itself.
UNK do on_op UNK on_op on_ignored_nl UNK on_period parent on_op self unless UNK on_period UNK on_nl end on_nl end on_nl # #parent= may be invoked multiple times for a node because there are # pending nodes while constructing AST and they are replaced later. # For example, `lvar` and `send` type nodes are initially created as an # `ident` type node and fixed to the appropriate type later. # So, the #parent attribute needs to be mutable.
def parent on_nl on_ivar on_lbracket on_symbeg parent on_rbracket on_nl end on_nl on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl on_ivar on_lbracket # Returns the parent node, or `nil` if the receiver is a root node. # # @return [Node, nil] the parent node or `nil`
def UNK on_lparen type on_op UNK on_comma children on_op UNK on_comma UNK on_op on_lbrace on_rbrace on_rparen on_ignored_nl UNK on_lbracket on_symbeg # Override `AST::Node#updated` so that `AST::Processor` does not try to # mutate our ASTs. Since we keep references from children to parents and # not just the other way around, we cannot update an AST and share # identical subtrees. Rather, the entire AST must be copied any time any # part of it is changed.
def UNK on_nl parent on_op children on_op UNK on_lbrace on_op UNK on_op UNK on_period UNK on_lparen self on_rparen on_rbrace on_nl # Returns the index of the receiver node in its siblings. (Sibling index # uses zero based numbering.) # # @return [Integer] the index of the receiver node in its siblings
def UNK on_nl UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op types on_comma on_op block on_rparen on_ignored_nl return UNK # Common destructuring method. This can be used to normalize # destructuring for different variations of the node. # Some node types override this with their own custom # destructuring method. # # @return [Array<Node>] the different parts of the ndde
def UNK on_lparen on_op types on_comma on_op block on_rparen on_ignored_nl return UNK on_lparen UNK on_comma on_op types on_rparen unless UNK # Calls the given block for each ancestor node from parent to root. # If no block is given, an `Enumerator` is returned. # # @overload each_ancestor # Yield all nodes. # @overload each_ancestor(type) # Yield only nodes matching the type. # @param [Symbol] type a node type # @overload each_ancestor(type_a, type_b, ...) # Yield only nodes matching any of the types. # @param [Symbol] type_a a node type # @param [Symbol] type_b a node type # @yieldparam [Node] node each ancestor node # @return [self] if a block is given # @return [Enumerator] if no block is given
def UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op types on_rparen on_ignored_nl return UNK on_lparen # Returns an array of ancestor nodes. # This is a shorthand for `node.each_ancestor.to_a`. # # @return [Array<Node>] an array of ancestor nodes
def UNK on_lparen on_op types on_rparen on_ignored_nl return UNK on_lparen UNK on_comma on_op types on_rparen unless UNK on_nl on_ignored_nl children # Calls the given block for each child node. # If no block is given, an `Enumerator` is returned. # # Note that this is different from `node.children.each { |child| ... }` # which yields all children including non-node elements. # # @overload each_child_node # Yield all nodes. # @overload each_child_node(type) # Yield only nodes matching the type. # @param [Symbol] type a node type # @overload each_child_node(type_a, type_b, ...) # Yield only nodes matching any of the types. # @param [Symbol] type_a a node type # @param [Symbol] type_b a node type # @yieldparam [Node] node each child node # @return [self] if a block is given # @return [Enumerator] if no block is given
def UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op types on_comma on_op block on_rparen on_ignored_nl # Returns an array of child nodes. # This is a shorthand for `node.each_child_node.to_a`. # # @return [Array<Node>] an array of child nodes
def UNK on_lparen on_op types on_comma on_op block on_rparen on_ignored_nl return UNK on_lparen UNK on_comma on_op types on_rparen unless UNK # Calls the given block for each descendant node with depth first order. # If no block is given, an `Enumerator` is returned. # # @overload each_descendant # Yield all nodes. # @overload each_descendant(type) # Yield only nodes matching the type. # @param [Symbol] type a node type # @overload each_descendant(type_a, type_b, ...) # Yield only nodes matching any of the types. # @param [Symbol] type_a a node type # @param [Symbol] type_b a node type # @yieldparam [Node] node each descendant node # @return [self] if a block is given # @return [Enumerator] if no block is given
def UNK on_nl UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen on_op types on_comma on_op block on_rparen on_ignored_nl # Returns an array of descendant nodes. # This is a shorthand for `node.each_descendant.to_a`. # # @return [Array<Node>] an array of descendant nodes
def UNK on_lparen on_op types on_comma on_op block on_rparen on_ignored_nl return UNK on_lparen UNK on_comma on_op types on_rparen unless UNK # Calls the given block for the receiver and each descendant node in # depth-first order. # If no block is given, an `Enumerator` is returned. # # This method would be useful when you treat the receiver node as the root # of a tree and want to iterate over all nodes in the tree. # # @overload each_node # Yield all nodes. # @overload each_node(type) # Yield only nodes matching the type. # @param [Symbol] type a node type # @overload each_node(type_a, type_b, ...) # Yield only nodes matching any of the types. # @param [Symbol] type_a a node type # @param [Symbol] type_b a node type # @yieldparam [Node] node each node # @return [self] if a block is given # @return [Enumerator] if no block is given
on_ignored_nl def_node_matcher on_symbeg receiver on_comma on_heredoc_beg on_nl on_ignored_sp on_tstring_content on_heredoc_end on_ignored_nl def_node_matcher on_symbeg UNK on_comma on_tstring_beg on_tstring_content on_tstring_end on_nl on_ignored_nl ## Destructuring
on_ignored_nl def UNK on_nl UNK on_op UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma ## Searching the AST
UNK on_op UNK on_lparen on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg block on_rparen on_nl # what class or module is this method/constant/etc definition in? # returns nil if answer cannot be determined
on_ignored_nl def UNK on_nl UNK on_op on_int on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_op on_int on_nl end on_nl ## Predicates
def_node_matcher on_symbeg UNK on_comma on_heredoc_beg on_nl on_ignored_sp on_tstring_content on_heredoc_end on_ignored_nl def UNK on_nl on_const on_period include? on_lparen type on_rparen on_nl # Some cops treat the shovel operator as a kind of assignment.
def UNK on_nl return UNK if parent on_period UNK on_nl on_ignored_nl case parent on_period type on_nl when on_symbeg UNK on_comma # Some expressions are evaluated for their value, some for their side # effects, and some for both # If we know that an expression is useful only for its side effects, that # means we can transform it in ways which preserve the side effects, but # change the return value # So, does the return value of this node matter? If we changed it to # `(...; nil)`, might that affect anything? # # rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity
return UNK if parent on_period UNK on_nl on_ignored_nl case parent on_period type on_nl when on_symbeg UNK on_comma on_symbeg UNK on_comma # Be conservative and return true if we're not sure.
on_ignored_nl def UNK on_nl case type on_nl when on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma # rubocop:enable Metrics/MethodLength, Metrics/CyclomaticComplexity
def UNK on_nl case type on_nl when on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg # Some expressions are evaluated for their value, some for their side # effects, and some for both. # If we know that expressions are useful only for their return values, # and have no side effects, that means we can reorder them, change the # number of times they are evaluated, or replace them with other # expressions which are equivalent in value. # So, is evaluation of this node free of side effects? #
case type on_nl when on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg UNK on_comma on_symbeg # Be conservative and return false if we're not sure
UNK on_op parent on_period children on_period UNK on_op on_int on_op parent on_period UNK on_op UNK on_nl end on_nl on_ignored_nl def # the last child node determines the value of the parent
UNK on_op on_int on_op parent on_period UNK on_op true on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_period UNK on_op # `for var in enum; body; end` # (for <var> <enum> <body>)
UNK on_period UNK on_op true on_op parent on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_period UNK on_nl # (case <condition> <when...>) # (if <condition> <truebranch> <falsebranch>)
UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl case node on_period type on_nl when on_symbeg # (while <condition> <body>) -> always evaluates to `nil`
node on_period UNK on_nl when on_symbeg UNK on_nl yield UNK on_lparen node on_rparen on_nl UNK UNK on_lparen node on_rparen on_lbrace # TODO: if constant name has cbase (leading ::), then we don't need # to keep traversing up through nested classes/modules
UNK on_lparen node on_rparen on_lbrace yield UNK on_rbrace on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen UNK on_rparen on_ignored_nl # block
UNK on_op UNK on_period children on_lbracket on_int on_rbracket on_nl on_ignored_nl if UNK on_period UNK on_nl on_tstring_beg on_tstring_content on_embexpr_beg UNK on_period # TODO: look for constant definition and see if it is nested # inside a class or module
return unless on_lparen receiver on_op ancestor on_period receiver on_rparen on_nl on_ignored_nl yield unless receiver on_period UNK on_nl receiver on_period UNK # `class_eval` with no receiver applies to whatever module or class # we are currently in
