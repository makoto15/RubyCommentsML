UNK UNK UNK on_nl UNK UNK on_nl UNK UNK on_nl UNK UNK on_nl UNK UNK UNK UNK UNK UNK UNK # frozen_string_literal: true
UNK UNK on_nl UNK UNK on_nl UNK UNK UNK UNK UNK UNK UNK UNK UNK UNK UNK on_nl end on_nl # Common functionality for nodes that have conditions: # `if`, `while`, `until`, `case`. # This currently doesn't include `when` nodes, because they have multiple # conditions, and need to be checked for that.
UNK UNK on_nl UNK UNK UNK UNK UNK UNK UNK UNK UNK UNK UNK on_nl end on_nl UNK UNK UNK # Checks whether the condition of the node is written on a single line. # # @return [Boolean] whether the condition is on a single line
UNK UNK on_nl UNK UNK on_nl end on_nl UNK UNK UNK on_nl UNK UNK UNK UNK on_nl end on_nl UNK # Checks whether the condition of the node is written on more than # one line. # # @return [Boolean] whether the condition is on more than one line
UNK UNK on_nl UNK UNK UNK UNK on_nl end on_nl UNK UNK UNK on_nl UNK UNK UNK UNK on_nl end # Returns the condition of the node. This works together with each node's # custom destructuring method to select the correct part of the node. # # @return [Node, nil] the condition of the node
UNK UNK on_nl UNK UNK UNK UNK on_nl end on_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP # Returns the body associated with the condition. This works together with # each node's custom destructuring method to select the correct part of # the node. # # @note For `if` nodes, this is the truthy branch. # # @return [Node, nil] the body of the node
