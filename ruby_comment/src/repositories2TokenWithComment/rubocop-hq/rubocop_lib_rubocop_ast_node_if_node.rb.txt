on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl def # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_nl keyword on_op on_tstring_beg on_tstring_content on_tstring_end # A node extension for `if` nodes. This will be used in place of a plain # node when the builder constructs the AST, making its methods available # to all `if` nodes within RuboCop.
def UNK on_nl keyword on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_nl keyword on_op on_tstring_beg on_tstring_content on_tstring_end # Checks whether this node is an `if` statement. (This is not true of # ternary operators and `unless` statements.) # # @return [Boolean] whether the node is an `if` statement
def UNK on_nl keyword on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_nl keyword on_op on_tstring_beg on_tstring_content on_tstring_end # Checks whether this node is an `unless` statement. (This is not true # of ternary operators and `if` statements.) # # @return [Boolean] whether the node is an `unless` statement
def UNK on_nl keyword on_op on_tstring_beg on_tstring_content on_tstring_end on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_period UNK on_lparen UNK # Checks whether the `if` is an `elsif`. Parser handles these by nesting # `if` nodes in the `else` branch. # # @return [Boolean] whether the node is an `elsif`
def UNK on_nl UNK on_period UNK on_lparen UNK UNK on_rparen on_op UNK on_period UNK on_nl end on_nl on_ignored_nl def UNK # Checks whether the `if` node has an `else` clause. # # @note This returns `true` for nodes containing an `elsif` clause. # This is legacy behavior, and many cops rely on it. # # @return [Boolean] whether the node has an `else` clause
def UNK on_nl UNK on_period UNK on_lparen UNK UNK on_rparen on_nl end on_nl on_ignored_nl def keyword on_nl UNK on_op on_tstring_beg # Checks whether the `if` node is a ternary operator. # # @return [Boolean] whether the `if` node is a ternary operator
def keyword on_nl UNK on_op on_tstring_beg on_tstring_end on_op UNK on_period keyword on_period UNK on_nl end on_nl on_ignored_nl def UNK on_nl # Returns the keyword of the `if` statement as a string. Returns an empty # string for ternary operators. # # @return [String] the keyword of the `if` statement
def UNK on_nl UNK keyword on_op on_tstring_beg on_tstring_content on_tstring_end on_nl on_tstring_beg on_tstring_content on_tstring_end on_nl UNK keyword on_op on_tstring_beg on_tstring_content on_tstring_end # Returns the inverse keyword of the `if` node as a string. Returns `if` # for `unless` nodes and vice versa. Returns an empty string for ternary # operators. # # @return [String] the inverse keyword of the `if` statement
def UNK on_nl on_lparen UNK on_op UNK on_rparen on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lbracket UNK # Checks whether the `if` node is in a modifier form, i.e. a condition # trailing behind an expression. Only `if` and `unless` nodes without # other branches can be modifiers. # # @return [Boolean] whether the `if` node is a modifier
def UNK on_nl UNK on_lbracket UNK on_op UNK on_rbracket on_period UNK on_period UNK UNK on_op UNK on_op on_ignored_nl UNK on_period # Chacks whether the `if` node has nested `if` nodes in any of its # branches. # # @note This performs a shallow search. # # @return [Boolean] whether the `if` node contains nested conditionals
def UNK on_nl else_branch on_op UNK on_op else_branch on_op UNK on_nl end on_nl on_ignored_nl def UNK on_nl UNK on_lbracket UNK # Checks whether the `if` node has at least one `elsif` branch. Returns # true if this `if` node itself is an `elsif`. # # @return [Boolean] whether the `if` node has at least one `elsif` branch
def UNK on_nl UNK on_lbracket UNK on_rbracket on_nl end on_nl on_ignored_nl def else_branch on_nl UNK on_lbracket UNK on_rbracket on_nl end # Returns the branch of the `if` node that gets evaluated when its # condition is truthy. # # @note This is normalized for `unless` nodes. # # @return [Node] the truthy branch node of the `if` node # @return [nil] if the truthy branch is empty
def else_branch on_nl UNK on_lbracket UNK on_rbracket on_nl end on_nl on_ignored_nl def UNK on_nl UNK UNK on_nl UNK on_comma UNK # Returns the branch of the `if` node that gets evaluated when its # condition is falsey. # # @note This is normalized for `unless` nodes. # # @return [Node] the falsey branch node of the `if` node # @return [nil] when there is no else branch
def UNK on_nl UNK UNK on_nl UNK on_comma UNK on_comma UNK on_op on_op UNK on_nl UNK on_ignored_nl UNK on_comma UNK # Custom destructuring method. This is used to normalize the branches # for `if` and `unless` nodes, to aid comparisons and conversions. # # @return [Array<Node>] the different parts of the `if` statement
def branches on_nl branches on_op on_lbracket UNK on_rbracket on_nl on_ignored_nl UNK branches UNK else_branch on_nl on_ignored_nl UNK on_op UNK UNK # Returns an array of all the branches in the conditional statement. # # @return [Array<Node>] an array of branch nodes
def UNK on_nl UNK branches on_period UNK on_lparen UNK on_rparen UNK UNK on_nl on_ignored_nl branches on_period UNK UNK on_op UNK # Calls the given block for each branch node in the conditional statement. # If no block is given, an `Enumerator` is returned. # # @return [self] if a block is given # @return [Enumerator] if no block is given
