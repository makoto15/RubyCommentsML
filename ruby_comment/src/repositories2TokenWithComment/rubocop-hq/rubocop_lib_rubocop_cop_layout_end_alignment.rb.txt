on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl def UNK on_lparen node on_rparen # This cop checks whether the end keywords are aligned properly. # # Three modes are supported through the `EnforcedStyleAlignWith` # configuration parameter: # # If it's set to `keyword` (which is the default), the `end` # shall be aligned with the start of the keyword (if, class, etc.). # # If it's set to `variable` the `end` shall be aligned with the # left-hand-side of the variable assignment, if there is one. # # If it's set to `start_of_line`, the `end` shall be aligned with the # start of the line where the matching keyword appears. # # @example EnforcedStyleAlignWith: keyword (default) # # bad # # variable = if true # end # # # good # # variable = if true # end # # variable = # if true # end # # @example EnforcedStyleAlignWith: variable # # bad # # variable = if true # end # # # good # # variable = if true # end # # variable = # if true # end # # @example EnforcedStyleAlignWith: start_of_line # # bad # # variable = if true # end # # puts(if true # end) # # # good # # variable = if true # end # # puts(if true # end) # # variable = # if true # end
UNK UNK on_lparen rhs on_op UNK on_lparen rhs on_rparen on_rparen on_nl UNK UNK rhs on_period UNK on_nl UNK if rhs # If there are method calls chained to the right hand side of the # assignment, we let rhs be the receiver of those method calls before # we check if it's an if/unless/while/until.
node on_nl end on_nl end on_nl on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl expr on_op node on_period UNK on_nl UNK # Fall back to 'keyword' style if this node is not on the RHS of an # assignment, or if it is but there's a line break between LHS and # RHS.
