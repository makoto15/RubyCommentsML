on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen # frozen_string_literal: true
UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK on_nl on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl return if UNK on_lparen # Common functionality for checking the closing brace of a literal is # either on the same line as the last contained elements or a new line.
return if UNK on_lparen node on_period children on_period UNK on_rparen on_nl on_ignored_nl UNK on_lparen node on_rparen on_nl end on_nl on_ignored_nl # If the last node is or contains a conflicting HEREDOC, we don't want # to adjust the brace layout because this will result in invalid code.
def UNK on_lparen node on_rparen on_ignored_nl UNK on_op on_ignored_nl UNK on_lparen node on_rparen on_period UNK on_nl on_ignored_nl UNK on_op on_ignored_nl # Returns true for the case # [a, # b # comment # ].some_method
def UNK on_lparen node on_rparen on_ignored_nl node on_period loc on_period UNK on_period UNK on_op children on_lparen node on_rparen on_period UNK # This method depends on the fact that we have guarded # against implicit and empty literals.
def UNK on_lparen node on_rparen on_ignored_nl node on_period loc on_period end on_period UNK on_op children on_lparen node on_rparen on_period UNK # This method depends on the fact that we have guarded # against implicit and empty literals.
def UNK on_lparen node on_comma UNK on_op UNK on_rparen on_ignored_nl UNK on_op node on_nl on_ignored_nl if node on_period UNK on_lparen # Starting with the parent node and recursively for the parent node's # children, check if the node is a HEREDOC and if the HEREDOC ends below # or on the last line of the parent node. # # Example: # # # node is `b: ...` parameter # # last_line_heredoc?(node) => false # foo(a, # b: { # a: 1, # c: <<-EOM # baz # EOM # } # ) # # # node is `b: ...` parameter # # last_line_heredoc?(node) => true # foo(a, # b: <<-EOM # baz # EOM # )
