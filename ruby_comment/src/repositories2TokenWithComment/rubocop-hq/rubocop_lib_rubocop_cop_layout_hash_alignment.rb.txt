on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl on_const on_op on_lbrace on_const on_op on_tstring_beg on_tstring_content on_tstring_end # Check that the keys, separators, and values of a multi-line hash # literal are aligned according to configuration. The configuration # options are: # # - key (left align keys, one space before hash rockets and values) # - separator (align hash rockets and colons, right align keys) # - table (left align keys, hash rockets, and values) # # The treatment of hashes passed as the last argument to a method call # can also be configured. The options are: # # - always_inspect # - always_ignore # - ignore_implicit (without curly braces) # # Alternatively you can specify multiple allowed styles. That's done by # passing a list of styles to EnforcedStyles. # # @example EnforcedHashRocketStyle: key (default) # # bad # { # :foo => bar, # :ba => baz # } # { # :foo => bar, # :ba => baz # } # # # good # { # :foo => bar, # :ba => baz # } # # @example EnforcedHashRocketStyle: separator # # bad # { # :foo => bar, # :ba => baz # } # { # :foo => bar, # :ba => baz # } # # # good # { # :foo => bar, # :ba => baz # } # # @example EnforcedHashRocketStyle: table # # bad # { # :foo => bar, # :ba => baz # } # # # good # { # :foo => bar, # :ba => baz # } # # @example EnforcedColonStyle: key (default) # # bad # { # foo: bar, # ba: baz # } # { # foo: bar, # ba: baz # } # # # good # { # foo: bar, # ba: baz # } # # @example EnforcedColonStyle: separator # # bad # { # foo: bar, # ba: baz # } # # # good # { # foo: bar, # ba: baz # } # # @example EnforcedColonStyle: table # # bad # { # foo: bar, # ba: baz # } # # # good # { # foo: bar, # ba: baz # } # # @example EnforcedLastArgumentHashStyle: always_inspect (default) # # Inspect both implicit and explicit hashes. # # # bad # do_something(foo: 1, # bar: 2) # # # bad # do_something({foo: 1, # bar: 2}) # # # good # do_something(foo: 1, # bar: 2) # # # good # do_something( # foo: 1, # bar: 2 # ) # # # good # do_something({foo: 1, # bar: 2}) # # # good # do_something({ # foo: 1, # bar: 2 # }) # # @example EnforcedLastArgumentHashStyle: always_ignore # # Ignore both implicit and explicit hashes. # # # good # do_something(foo: 1, # bar: 2) # # # good # do_something({foo: 1, # bar: 2}) # # @example EnforcedLastArgumentHashStyle: ignore_implicit # # Ignore only implicit hashes. # # # bad # do_something({foo: 1, # bar: 2}) # # # good # do_something(foo: 1, # bar: 2) # # @example EnforcedLastArgumentHashStyle: ignore_explicit # # Ignore only explicit hashes. # # # bad # do_something(foo: 1, # bar: 2) # # # good # do_something({foo: 1, # bar: 2}) #
on_ignored_nl if on_op node on_period UNK on_nl UNK on_lparen delta on_lbracket on_symbeg key on_rbracket on_op UNK on_comma node on_period UNK # We can't use the instance variable inside the lambda. That would # just give each lambda the same reference and they would all get the # last value of each. A local variable fixes the problem.
UNK on_op delta on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl UNK on_op delta on_lbracket on_symbeg UNK on_rbracket on_op UNK on_nl # We can't use the instance variable inside the lambda. That would # just give each lambda the same reference and they would all get the # last value of each. Some local variables fix the problem.
