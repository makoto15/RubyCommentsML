on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_const on_op on_symbeg UNK on_nl on_const on_op on_symbeg UNK # frozen_string_literal: true
UNK on_const on_op on_const on_const on_op on_symbeg UNK on_nl on_const on_op on_symbeg UNK on_nl on_const on_op on_ignored_nl on_lbracket on_const on_comma # This force provides a way to track local variables and scopes of Ruby. # Cops interact with this force need to override some of the hook methods. # # def before_entering_scope(scope, variable_table) # end # # def after_entering_scope(scope, variable_table) # end # # def before_leaving_scope(scope, variable_table) # end # # def after_leaving_scope(scope, variable_table) # end # # def before_declaring_variable(variable, variable_table) # end # # def after_declaring_variable(variable, variable_table) # end
on_const on_op on_symbeg UNK on_nl on_const on_op on_symbeg UNK on_nl on_const on_op on_ignored_nl on_lbracket on_const on_comma on_const on_rbracket on_period freeze # rubocop:disable Metrics/ClassLength
on_symbeg UNK on_rbracket on_period freeze on_nl on_ignored_nl on_const on_op UNK on_tstring_content on_words_sep on_tstring_content on_tstring_end on_period freeze on_nl on_const on_op on_ignored_nl # This doesn't mean block argument, it's block-pass (&block).
on_rbracket on_period freeze on_nl on_ignored_nl on_const on_op UNK on_tstring_content on_words_sep on_tstring_content on_tstring_end on_period freeze on_nl on_const on_op on_ignored_nl on_lparen on_const # This means block local variable (obj.each { |arg; this| }).
def UNK on_lparen UNK on_rparen on_ignored_nl UNK on_op UNK on_period UNK on_nl UNK unless UNK on_nl on_ignored_nl variable_table on_period UNK # Starting point.
def UNK on_lparen UNK on_rparen on_ignored_nl variable_table on_period UNK on_lparen UNK on_rparen on_nl UNK on_lparen UNK on_rparen on_nl variable_table on_period # This is called for each scope recursively.
def UNK on_lparen node on_rparen on_ignored_nl UNK node on_period UNK on_nl when on_const on_nl on_symbeg UNK on_nl when on_const on_nl # rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity
on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl UNK on_op node on_period children on_period first on_nl on_ignored_nl UNK unless UNK on_nl # rubocop:enable Metrics/MethodLength, Metrics/CyclomaticComplexity
UNK unless UNK on_nl on_ignored_nl variable_table on_period UNK on_lparen UNK on_comma node on_rparen on_nl end on_nl on_ignored_nl def UNK on_lparen # restarg and kwrestarg would have no name: # # def initialize(*) # end
UNK on_lparen node on_rparen on_nl on_ignored_nl variable_table on_period UNK on_lparen name on_comma node on_rparen on_nl on_ignored_nl skip_children! on_nl end on_nl # Need to scan rhs before assignment so that we can mark previous # assignments as referenced if rhs has referencing to the variable # itself like: # # foo = 1 # foo = foo + 1
def UNK on_lparen node on_rparen on_ignored_nl if on_const on_period UNK on_lparen node on_period UNK on_rparen on_nl asgn_node on_comma rhs_node on_op # rubocop:disable Metrics/AbcSize
on_ignored_nl variable_table on_period UNK on_lparen name on_comma node on_rparen on_nl process_node on_lparen rhs_node on_rparen on_nl variable_table on_period UNK on_lparen name # The following statements: # # foo = 1 # foo += foo = 2 # # => 3 # # are equivalent to: # # foo = 1 # foo = foo + (foo = 2) # # => 3 # # So, at operator assignment node, we need to reference the variable # before processing rhs nodes.
on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl UNK on_comma rhs_node on_op on_op node on_nl process_node on_lparen rhs_node on_rparen on_nl process_node # rubocop:enable Metrics/AbcSize
UNK on_comma UNK on_op on_op node on_nl process_node on_lparen UNK on_rparen on_nl process_node on_lparen UNK on_rparen on_nl UNK on_ignored_nl UNK # See the comment at the end of file for this behavior.
UNK on_lparen node on_rparen if UNK on_nl end on_nl on_ignored_nl def UNK on_lparen node on_rparen on_ignored_nl variable_table on_period UNK on_period # Treat begin..rescue..end with retry as a loop.
UNK on_lparen node on_rparen on_period each do on_op UNK on_op on_ignored_nl process_node on_lparen UNK on_rparen on_nl UNK on_op UNK on_nl # See the comment at the end of file for this behavior.
def UNK on_lparen node on_rparen on_ignored_nl UNK on_comma UNK on_op on_ignored_nl UNK on_lparen node on_rparen on_nl on_ignored_nl UNK on_period each # Mark all assignments which are referenced in the same loop # as referenced by ignoring AST order since they would be referenced # in next iteration.
UNK unless variable on_nl on_ignored_nl variable on_period UNK on_period each do on_op UNK on_op on_ignored_nl UNK if UNK on_period UNK # Non related references which are caught in the above scan # would be skipped here.
UNK on_period UNK do on_op node on_op on_ignored_nl reference on_op UNK on_lparen node on_rparen on_nl on_ignored_nl UNK reference if reference # #each_descendant does not consider scope, # but we don't need to care about it here.
def UNK on_lparen node on_rparen on_ignored_nl UNK on_period UNK do on_op UNK on_op on_ignored_nl UNK on_period UNK on_lparen node on_rparen # Use Node#equal? for accurate check.
UNK on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_content on_words_sep on_tstring_end on_period each do on_op UNK # Hooks invoked by VariableTable.
UNK on_lparen UNK on_comma UNK on_comma variable_table on_rparen on_nl end on_nl end on_nl on_ignored_nl on_ignored_nl end on_nl end on_nl end # Invoke hook in cops.
on_ignored_nl end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # Post condition loops # # Loop body nodes need to be scanned first. # # Ruby: # begin # foo = 1 # end while foo > 10 # puts foo # # AST: # (begin # (while-post # (send # (lvar :foo) :> # (int 10)) # (kwbegin # (lvasgn :foo # (int 1)))) # (send nil :puts # (lvar :foo)))
end on_nl end on_nl end on_nl EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP EMP # Twisted scope types # # The variable foo belongs to the top level scope, # but in AST, it's under the block node. # # Ruby: # some_method(foo = 1) do # end # puts foo # # AST: # (begin # (block # (send nil :some_method # (lvasgn :foo # (int 1))) # (args) nil) # (send nil :puts # (lvar :foo))) # # So the method argument nodes need to be processed # in current scope. # # Same thing. # # Ruby: # instance = Object.new # class << instance # foo = 1 # end # # AST: # (begin # (lvasgn :instance # (send # (const nil :Object) :new)) # (sclass # (lvar :instance) # (begin # (lvasgn :foo # (int 1))
