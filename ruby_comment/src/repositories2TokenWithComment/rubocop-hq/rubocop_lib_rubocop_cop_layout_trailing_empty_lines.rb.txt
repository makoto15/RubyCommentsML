on_ignored_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_nl UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const # frozen_string_literal: true
UNK on_const on_op on_const on_nl UNK on_const on_nl UNK on_const on_nl on_ignored_nl UNK UNK on_lparen processed_source on_rparen on_ignored_nl buffer on_op # This cop looks for trailing blank lines and a final newline in the # source code. # # @example EnforcedStyle: final_blank_line # # `final_blank_line` looks for one blank line followed by a new line # # at the end of files. # # # bad # class Foo; end # # EOF # # # bad # class Foo; end # EOF # # # good # class Foo; end # # # EOF # # @example EnforcedStyle: final_newline (default) # # `final_newline` looks for one newline at the end of files. # # # bad # class Foo; end # # # EOF # # # bad # class Foo; end # EOF # # # good # class Foo; end # # EOF #
UNK UNK UNK on_lparen processed_source on_rparen on_nl on_ignored_nl whitespace_at_end on_op buffer on_period source UNK UNK on_tstring_content UNK UNK on_nl blank_lines # The extra text that comes after the last token could be __END__ # followed by some data to read. If so, we don't check it because # there could be good reasons why it needs to end with a certain # number of newlines.
